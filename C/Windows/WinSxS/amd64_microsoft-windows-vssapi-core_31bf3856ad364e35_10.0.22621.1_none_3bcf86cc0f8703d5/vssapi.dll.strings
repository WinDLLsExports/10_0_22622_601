!This program cannot be run in DOS mode.
7Rich
.text
`.rdata
@.data
.pdata
@.didat
.rsrc
@.reloc
@USVWATAUAVAWH
D8est
d$ E3
A_A^A]A\_^[]
\$ UVWH
@8u{t
D$ E3
|$ UATAUAVAWH
9t$ptAD
D$ E3
A_A^A]A\]
|$ AVH
\$@tLH
UVWATAUAVAWH
A_A^A]A\_^]
WAVAWH
A_A^_
UVWATAUAVAWH
D8mct(H
A_A^A]A\_^]
@USVWATAUAVAWH
A_A^A]A\_^[]
UVWATAUAVAWH
A_A^A]A\_^]
WATAUAVAWH
A_A^A]A\_
UVWAVAWH
T$0E3
A_A^_^]
L$ USVWAVAWH
T$@E3
\$ E3
A_A^_^[]
L$ USVWATAVAWH
T$@E3
A_A^A\_^[]
|$ AVH
@SVWATAUAVAWH
A_A^A]A\_^[
SVWAVAWH
 A_A^_^[
@SUVWAVH
A^_^][
UVWATAUAVAWH
|$XE2
A_A^A]A\_^]
@SVWATAUAVAWH
A_A^A]A\_^[
L$ SVWH
SVWATAUAVAWH
A_A^A]A\_^[
D$ E3
L$HE3
SVWATAUAVAWH
A_A^A]A\_^[
\$ UVWATAUAVAWH
D8}ct
A_A^A]A\_^]
UATAUAVAWH
A_A^A]A\]
UVWATAUAVAWH
9]xv_L
A_A^A]A\_^]
L$ USVWATAUAVAWH
A_A^A]A\_^[]
T$(D+
L$ SUVWH
X_^][
@USVWATAUAVAWH
A_A^A]A\_^[]
UVWATAUAVAWH
D8}ct
A_A^A]A\_^]
L$ USVWATAUAVAWH
L$ E3
A_A^A]A\_^[]
UVWATAUAVAWH
D8mct
A_A^A]A\_^]
L$ UVWATAUAVAWH
A_A^A]A\_^]
s WATAUAVAWH
A_A^A]A\_
UATAUAVAWH
A_A^A]A\]
UVWATAUAVAWH
A_A^A]A\_^]
L$ UVWATAUAVAWH
D8mst
A_A^A]A\_^]
UVWATAUAVAWH
D8u#t)H
D$ E3
A_A^A]A\_^]
UVWATAUAVAWH
D$ E3
A_A^A]A\_^]
UWATAVAWH
A_A^A\_]
x UAVAWH
A_A^]
UWATAVAWH
A_A^A\_]
t$ WH
|$ AUAVAWH
A_A^A]
u)f9tC
D$(L+
t$ WH
x UAVAWH
A_A^]
t$ WATAUAVAWH
A_A^A]A\_
WAVAWH
 A_A^_
VWAVH
 A^_^
VWAVH
 A^_^
SVWATAVAWH
t$DD;t$@
A_A^A\_^[
@8y(t
UWAVH
x UATAUAVAWH
A_A^A]A\]
UWAVH
D$0fD
f9D$ 
UAVAWH
A_A^]
h UAVAWH
D8y(t
A_A^]
x UATAUAVAWH
L$PE3
A_A^A]A\]
SVWATAUAVAWH
A_A^A]A\_^[
x UATAUAVAWH
T$ E3
A_A^A]A\]
@USVWAUAVAWH
A_A^A]_^[]
UVWATAUAVAWH
A_A^A]A\_^]
UVWATAUAVAWH
A_A^A]A\_^]
VWAVH
PA^_^
UWAVH
D8uct
t$ WATAUAVAWH
A_A^A]A\_
@SVWATAUAVAWH
D$xK 
D$xZ 
D$x[ 
A_A^A]A\_^[
UVWATAUAVAWH
t$`E3
A_A^A]A\_^]
UVWATAUAVAWH
A_A^A]A\_^]
UVWATAUAVAWH
f9D$8tWH
A_A^A]A\_^]
SVWATAUAVAWH
A_A^A]A\_^[
WATAUAVAWH
A_A^A]A\_
UVWATAUAVAWH
A_A^A]A\_^]
UVWATAUAVAWH
D8}St
A_A^A]A\_^]
x UATAUAVAWH
A_A^A]A\]
UWATAVAWH
A_A^A\_]
SVWATAUAVAWH
A_A^A]A\_^[
D$`H90
` UAUAWH
A_A]]
UWATAVAWH
A_A^A\_]
` UAVAWH
A_A^]
x ATAVAWH
 A_A^A\H
|$ ATAVAWH
A_A^A\
WAVAWH
0A_A^_
L$0H3
WAVAWH
89:tFH
0A_A^_
WAVAWH
89:tFH
0A_A^_
q*Z~:
q*Z~:
q0R^G'
ATAVAWH
p0R^G'
 A_A^A\
q:_0#
VWAVH
\$ E3
D$HE3
D$HE3
SVWAVH
\$px#H+
8A^_^[
VWAVH
\$px I+
@A^_^
WAVAWH
\$ A;
0A_A^_
LcA<E3
HcQ<H
\$ UH
 H3E H3E
oD$ f
oL$0f
oT$@f
o\$PH
oD$ f
oL$0f
oT$@f
o\$PH
oD$ f
oL$0f
oT$@f
o\$PH
oD$ f
oL$0f
oT$@f
o\$PH
oD$ f
oL$0f
oT$@f
o\$PH
oD$ f
oL$0f
oT$@f
o\$PH
oD$ f
oL$0f
oT$@f
o\$PH
oD$ f
oL$0f
oT$@f
o\$PH
oD$ f
oL$0f
oT$@f
o\$PH
oD$ f
oL$0f
oT$@f
o\$PH
oD$ f
oL$0f
oT$@f
o\$PH
oD$ f
oL$0f
oT$@f
o\$PH
oD$ f
oL$0f
oT$@f
o\$PH
oD$ f
oL$0f
oT$@f
o\$PH
oD$ f
oL$0f
oT$@f
o\$PH
oD$ f
oL$0f
oT$@f
o\$PH
oD$ f
oL$0f
oT$@f
o\$PH
oD$ f
oL$0f
oT$@f
o\$PH
oD$ f
oL$0f
oT$@f
o\$PH
x AVH
D$@E3
x AVH
x AVH
D$(~ 
D$(~ 
D$ ~ 
D$(~ 
E(=csm
E8=csm
EH=csm
EX=csm
Eh=csm
Ex=csm
D9d$`
pcPZt
@8t$@
\$ E3
p3TpY
u|D8e
D9t$P
D$XI9]
D$xP 
D$xU 
pY\Xv
D$xl 
D$HH93t
t$HE3
D$ E3
D9|$P
D9l$P
D9|$p
D9|$P
D9l$p
D9|$P
D$pt>
D9l$P
D9l$`
L$PE3
D9l$`
L$PE3
D$0]H
D$(<B
D$ qJ
D$0]H
D$(<B
D$ qJ
pcPZt
pcPZt
UATAUAVAWH
;GDw>B
f9WXt
A_A^A]A\]
t1HcK
x ATAVAWH
 A_A^A\
t.f92t
@UATAUAVAWH
fD9<_u
H;E t
fE9,Gu
ePA_A^A]A\]
UWAVH
L$ UVWATAUAVAWH
|$(9MgH
A_A^A]A\_^]
8w1t*
@SVWATAUAVAWH
pRRx3
|$@8\$Bu=E
A_A^A]A\_^[
8\$BulE
pSPTZ
8\$BulE
x AVH
t$ WH
f9,Zu
@SVWATAUAVAWH
H9>uvH
fC9<tu
f9<Ju
f9<Au
@8|$@t
A_A^A]A\_^[
\$ UVWH
WAVAWH
fD;9u
 A_A^_
fD;0t
\$ UVWATAUAVAWH
fD9$Ou
fD9$Bu
A_A^A]A\_^]
\$ UVWATAUAVAWH
fD9<^u
A_A^A]A\_^]
UVWAVAWH
fD94Bu
fD98u
A_A^_^]
WATAUAVAWH
>fE;/tGL
0A_A^A]A\_
@UATAUAVAWH
A8<4te
A8<6u
e A_A^A]A\]
@USVWATAUAVAWH
?=u!@
?{uCD
|$ E3
A_A^A]A\_^[]
?=u;H
t$ WAVAWH
\$@9^
 A_A^_
x AVH
L$ SVWAVH
(A^_^[
x AVH
UWATAVAWH
A_A^A\_]
fE9$Hu
fD9$Wu
fD9$_u
SVWAVH
(A^_^[
@SVWATAUAVAWH
A_A^A]A\_^[
@SVWATAUAVAWH
IL$PH
|$ E3
A_A^A]A\_^[
VWATAVAWH
fD9$Cu
A_A^A\_^
t$ UWATAVAWH
D9d$(|
D$,D8%
t(D8%_Q
D$pE3
t<fA9(t6I
q*Z~:
|$ UH
p0Zt}
x AVH
VWATAVAWH
fD9 t
D$0fD9 t
A_A^A\_^
t$ WH
WAVAWH
 A_A^_
qYT:]
\$ UVWAVAWH
t,D8=C;
L9{Hu
A_A^_^]
WATAUAVAWH
0A_A^A]A\_
D$8E3
@SUVWH
D$0L;
H9=$%
p0\:#7
D$@E3
qx_8O
USVWATAVAWH
p!PZa
d$ E3
@A_A^A\_^[]
UVWATAUAVAWH
@8= %
ty@8=
t"@8=
fA9>u
@8=e$
@A_A^A]A\_^]
L$ SWH
L$XH+
|$ AVH
WAVAWH
89:u=9z
pcPZt
0A_A^_
WAVAWH
89:u69z
pcPZt
0A_A^_
WATAUAVAWH
H9/sDH
 A_A^A]A\_
x AVH
H9;s!
x AVH
uPH9i
L$ SVWH
x UAVAWH
fD98t
D$@fD98t
HcD$$HcL$ H
A_A^]
@SVWATAUAVAWH
A_A^A]A\_^[
WAVAWH
A_A^_
SVWATAUAVAWH
A_A^A]A\_^[
WATAUAVAWH
A_A^A]A\_
qYT:]
UWAVH
@SVWATAUAVAWH
A_A^A]A\_^[
qy]</
q0TTo6
\$ WH
L$`H3
@SUVWAVH
fD9t$@t
A^_^][
\$ WH
L$`H3
x ATAVAWH
fE9<pu
 A_A^A\
\$ UVWATAUAVAWH
A_A^A]A\_^]
USVWAVH
A^_^[]
L$ USVWAVH
A^_^[]
L$ USVWATAVAWH
D$XE3
A_A^A\_^[]
x UATAUAVAWH
fD94Yu
fD94Gu
A_A^A]A\]
f9,Nu
f9,^u
|$ AUAVAWH
A_A^A]
UATAUAVAWH
A_A^A]A\]
UATAUAVAWH
A_A^A]A\]
@SVWATAUAVAW
B848u
|$0fD
A_A^A]A\_^[
H USVWH
H USVWH
L$ USVWAVAWH
D$8E3
A_A^_^[]
L$ USVWAVAWH
xA_A^_^[]
L$ SVWH
p AWH
x AVH
USVWAVH
USVWAVAWH
A_A^_^[]
H USVWAVAWH
UWAVH
USVWAVH
USVWAVAWH
USVWATAUAVAWH
H USVWAVH
H USVWAVAWH
A_A^_^[]
UWATAVAWH
A_A^A\_]
x AVH
SVWATAUAVAWH
D9|$`tSL
A_A^A]A\_^[
WATAUAVAWH
D9d$ptYL
fE9$Fu
A_A^A]A\_
SVWATAUAVAWH
D$HM+
fE94Du
fD94Au
A_A^A]A\_^[
UATAUAVAWH
IL$`H
D9l$ptAD
A_A^A]A\]
UATAUAVAWH
IL$`H
D9l$ptAD
A_A^A]A\]
qjS6b
WATAUAVAWH
D9l$`tSL
A_A^A]A\_
WATAUAVAWH
D9l$`tSL
A_A^A]A\_
UATAUAVAWH
IL$`H
D9l$ptAD
A_A^A]A\]
WATAUAVAWH
D9l$`tSL
A_A^A]A\_
@SVWATAUAVAWH
L$Hf9
A_A^A]A\_^[
@SVWATAUAVAWH
A_A^A]A\_^[
t$ WH
f9,Zu
VWATAVAWH
A_A^A\_^
|$ UAVAWH
D9|$PtFD
D8}ct*H
A_A^]
|$ UAVAWH
D9|$PtFD
D8}ct*H
A_A^]
SVWATAUAVAWH
A_A^A]A\_^[
s WATAUAVAWH
IL$`H
A_A^A]A\_
|$ UATAUAVAWH
A_A^A]A\]
x ATAVAWH
A_A^A\
x ATAVAWH
A_A^A\
x ATAVAWH
A_A^A\
x ATAVAWH
A_A^A\
SVWAUAVAWH
9t$ptYH
A_A^A]_^[
@SVWATAUAVAWH
IL$XH
A_A^A]A\_^[
WATAUAVAWH
H9_xt
A_A^A]A\_
WATAUAVAWH
A_A^A]A\_
qRRx3
SVWATAUAVAWH
9|$`tSH
D$ E3
A_A^A]A\_^[
qRRx3
s WATAUAVAWH
IL$`H
9|$ptYH
D$ E3
A_A^A]A\_
UWATAVAWH
D9d$PtFD
D8ect*H
A_A^A\_]
UWATAVAWH
D9d$PtFD
D8ect*H
A_A^A\_]
qSPTZ
UWATAVAWH
D9d$PtFD
D8ect*H
A_A^A\_]
qSPTZ
UWATAVAWH
D9d$PtFD
D8ect*H
A_A^A\_]
SVWATAUAVAWH
A_A^A]A\_^[
WATAUAVAWH
A_A^A]A\_
x ATAVAWH
A_A^A\
x ATAVAWH
A_A^A\
UWATAVAWH
D9d$PtFD
D8ect*H
A_A^A\_]
UWATAVAWH
D9d$PtFD
D8ect*H
A_A^A\_]
x UATAUAVAWH
A_A^A]A\]
` UAVAWH
A_A^]
UWATAVAWH
D9d$PtFD
D8ect*H
A_A^A\_]
UWATAVAWH
D9d$PtFD
D8ect*H
A_A^A\_]
UWATAVAWH
D9d$PtFD
D8ect*H
A_A^A\_]
UWATAVAWH
D9d$PtFD
D8ect*H
A_A^A\_]
SVWATAUAVAWH
IL$XH
D9d$ptYL
A_A^A]A\_^[
SVWATAUAVAWH
IL$PH
9t$`tWH
A_A^A]A\_^[
VWATAUAVH
A^A]A\_^
WATAUAVAWH
A_A^A]A\_
|$ UAVAWH
D9|$PtFD
D8}ct*H
A_A^]
|$ UAVAWH
D9|$PtFD
D8}ct*H
A_A^]
SVWATAUAVAWH
A_A^A]A\_^[
SVWATAUAVAWH
IL$PH
A_A^A]A\_^[
c AUAVAWH
IL$PH
D9l$`tSL
A_A^A]
c AUAVAWH
IL$PH
D9l$`tSL
A_A^A]
UWATAVAWH
D9d$PtFD
D8ect*H
A_A^A\_]
9t$PtFD
@8uct*H
|$ UAVAWH
D9|$PtFD
D8}ct*H
A_A^]
|$ UAVAWH
D9|$PtFD
D8}ct*H
A_A^]
|$ UAVAWH
D9|$PtFD
D8}ct*H
A_A^]
|$ UAVAWH
D9|$PtFD
D8}ct*H
A_A^]
q"ZV3'
SVWATAUAVAWH
IL$XH
D9d$ptYL
A_A^A]A\_^[
q"ZV3'
SVWATAUAVAWH
IL$XH
A_A^A]A\_^[
\r^7$
WATAUAVAWH
A_A^A]A\_
\r^7$
WATAUAVAWH
A_A^A]A\_
AUAVAWH
A_A^A]
t$ UWATAVAWH
t$@E3
A_A^A\_]
VWAUAVAWH
9\$PtJH
A_A^A]_^
VWAUAVAWH
9\$PtJH
A_A^A]_^
D$0E3
D$0E3
D$0E3
VWAUAVAWH
D9|$PtJL
A_A^A]_^
VWAUAVAWH
D9|$PtJL
A_A^A]_^
WATAUAVAWH
IL$PH
D9d$ptYL
A_A^A]A\_
ATAVAWH
A_A^A\
[ VWATAVAWH
A_A^A\_^
WAVAWH
A_A^_
WATAUAVAWH
A_A^A]A\_
x ATAVAWH
A_A^A\
ATAVAWH
A_A^A\
[ VWATAVAWH
A_A^A\_^
ATAVAWH
A_A^A\
[ VWATAVAWH
A_A^A\_^
UATAUH
UATAUH
@SUVWH
L$HH3
X_^][
UVWATAUAVAWH
A_A^A]A\_^]
@USVWATAUAVAWH
A_A^A]A\_^[]
@SUVWH
L$HH3
X_^][
x UAVAWH
A_A^]
UWATAUAVH
A^A]A\_]
@USVWAUAVAWH
D$8f90@
A_A^A]_^[]
\$ WH
L$@H3
c AUAVAWH
A_A^A]
{ AVH
WATAUAVAWH
A_A^A]A\_
UVWATAUAVAWH
A_A^A]A\_^]
x ATAVAWH
A_A^A\
x ATAVAWH
A_A^A\
WATAUAVAWH
A_A^A]A\_
WATAUAVAWH
\$ E3
t$ E3
A_A^A]A\_
SVWATAUAVAWH
D$ E3
A_A^A]A\_^[
SVWATAUAVAWH
A_A^A]A\_^[
WATAUAVAWH
A_A^A]A\_
WATAUAVAWH
A_A^A]A\_
WATAUAVAWH
A_A^A]A\_
VWATAVAWH
A_A^A\_^
x ATAVAWH
A_A^A\
t$ WATAUAVAWH
A_A^A]A\_
SVWATAUAVAWH
A_A^A]A\_^[
x ATAVAWH
A_A^A\
WATAUAVAWH
A_A^A]A\_
UVWATAUAVAWH
I+Flu
I+FtH
A_A^A]A\_^]
x ATAVAWH
A_A^A\
x ATAVAWH
A_A^A\
x ATAVAWH
A_A^A\
q1Z\i
{ AVH
{ AVH
ATAVAWH
A_A^A\
x ATAVAWH
A_A^A\
x ATAVAWH
A_A^A\
x ATAVAWH
A_A^A\
WATAUAVAWH
A_A^A]A\_
x ATAVAWH
A_A^A\
x ATAVAWH
A_A^A\
x ATAVAWH
A_A^A\
UWATAVAWH
A_A^A\_]
UWATAVAWH
A_A^A\_]
@USWH
f9<Bu
f9<Ju
L$PE3
@USWH
f9<Bu
f9<Ju
L$PE3
@USVWAVH
f9<Au
f9<Au
f9<Au
f9<Au
f9<Qu
A^_^[]
@USVWAVH
f9<Au
f9<Au
f9<Au
f9<Au
f9<Qu
A^_^[]
@USVWAVH
f9<Au
f9<Au
f9<Au
f9<Au
f9<Qu
A^_^[]
@USVWAVH
f9<Au
f9<Au
f9<Au
f9<Au
f9<Qu
A^_^[]
\$ UVWAVAWH
f94Bu
fA94@u
fA94@u
A_A^_^]
@USVWATAVAWH
f94Bu
f94Bu
f94Bu
fA94@u
fA94@u
A_A^A\_^[]
\$ UVWH
f9<Bu
f9<Ju
\$ UVWAVAWH
f94Bu
fA94@u
fA94@u
A_A^_^]
\$ UVWATAVH
f94Bu
f94Bu
f94Bu
A^A\_^]
L$PH3
UWATAVAWH
A_A^A\_]
x AVH
x AVH
t6HcK
VWAVH
 A^_^
t8HcK
x AVH
t9HcK
AUAVAWH
D$ E3
A_A^A]
SVWATAUAVAWH
tX9\$ptR
A_A^A]A\_^[
x UAVAWH
D8yytmH
L9ypumH
D9}oL
A_A^]
q)_|t
WAVAWH
A_A^_
WAVAWH
A_A^_
|$ ATAUAWH
A_A]A\
@SVWATAUAVAWH
D$hh$
D$h}$
l$ E3
A_A^A]A\_^[
UWATAVAWH
D$8b%
D$8e%
D$8k%
D$8r%
A_A^A\_]
t$ WATAUAVAWH
8\$IH
D$p8%
D$p;%
8\$IL
D$pH%
D$p %
D$pU%
D$pX%
A_A^A]A\_
D$(L%
D$(L%
D$ L%
D$(L%
AUAVAWH
D$ E3
A_A^A]
WATAUAVAWH
A_A^A]A\_
|$ UATAUAVAWH
A_A^A]A\]
AUAVAWH
D$ E3
A_A^A]
SVWATAUAVAWH
p9]2_
A_A^A]A\_^[
D$(E!
D$(E!
D$ E!
D$(E!
@SVWATAUAVAWH
A_A^A]A\_^[
x UATAUAVAWH
D$8-(
D$8A(
A_A^A]A\]
@SVWATAUAVAWH
t$ E3
p"ZV3'
\r^7$
p"ZV3'
D$h%$
t$ E3
D$hI$
D$hR$
A_A^A]A\_^[
D$([$
D$([$
D$ [$
D$([$
SVWATAUAVAWH
A_A^A]A\_^[
@SVWATAUAVAWH
|$ E3
A_A^A]A\_^[
VWAVH
0A^_^
fD94~u
fD94Bu
x ATAVAWH
 A_A^A\
x ATAVAWH
 A_A^A\
SVWATAUAVAWH
A_A^A]A\_^[
t$ WATAUAVAWH
L$pD8
A_A^A]A\_
@SVWATAUAVAWH
D$XD8
A_A^A]A\_^[
USVWATAUAVAWH
pRRx3
A_A^A]A\_^[]
WAVAWH
fD9<Fu
fD9<^u
A_A^_
UVWATAUAVAWH
A_A^A]A\_^]
d$ E3
D$X,+
D$X4+
D$XE+
D$XG+
D$XM+
D$X"+
WATAUAVAWH
A_A^A]A\_
@SVWATAUAVAWH
A_A^A]A\_^[
x ATAVAWH
A_A^A\
@SVWATAUAVAWH
A_A^A]A\_^[
@SVWATAUAVAWH
A_A^A]A\_^[
@SVWATAUAVAWH
D$`! 
D$`" 
A_A^A]A\_^[
D$(2 
D$(2 
D$ 2 
D$(2 
WATAUAVAWH
D$Xr(
D$Xy(
D$X|(
D$X~(
A_A^A]A\_
WATAUAVAWH
A_A^A]A\_
SVWATAUAVAWH
\$PMc
D$ E3
A_A^A]A\_^[
s WATAUAVAWH
pyRRC
D$ E3
A_A^A]A\_
WATAUAVAWH
A_A^A]A\_
x UATAUAVAWH
A_A^A]A\]
@SVWATAUAVAWH
A_A^A]A\_^[
@SVWATAUAVAWH
A_A^A]A\_^[
D$()*
D$()*
D$ )*
D$()*
@SVWATAUAVAWH
D$Pu,
D$X!&
D$X"&
D$X#&
A_A^A]A\_^[
D$(4&
D$(4&
D$ 4&
D$(4&
@SVWATAUAVAWH
D$XD8
A_A^A]A\_^[
UVWATAUAVAWH
A_A^A]A\_^]
UVWATAUAVAWH
t$ E3
A_A^A]A\_^]
UVWATAUAVAWH
A_A^A]A\_^]
UATAUAVAWH
D$(M+
A_A^A]A\]
UWAVH
UVWATAVH
CHH+E
CPH+E
0A^A\_^]
{ AVH
SVWATAUAVAWH
D$xH"
D$xO"
D$xW"
D$xZ"
D$x]"
D$xb"
t$XE3
A_A^A]A\_^[
D$(q"
D$(q"
D$ q"
D$(q"
x ATAVAWH
A_A^A\
c AUAVAWH
A_A^A]
@USVWATAUAVH
A^A]A\_^[]
VWATAUAVH
D9t$PtJL
A^A]A\_^
WATAUAVAWH
A_A^A]A\_
q3XpZ.x
VWATAUAVH
D9t$PtJL
A^A]A\_^
q3XpZ.x
VWATAVAWH
A_A^A\_^
x ATAVAWH
A_A^A\
@SVWATAUAVAWH
A_A^A]A\_^[
SVWATAUAVAWH
A_A^A]A\_^[
SVWATAUAVAWH
A_A^A]A\_^[
SVWATAUAVAWH
t$ E3
A_A^A]A\_^[
x ATAVAWH
A_A^A\
WATAUAVAWH
A_A^A]A\_
WATAUAVAWH
A_A^A]A\_
WATAUAVAWH
A_A^A]A\_
q(T:H
VWATAVAWH
A_A^A\_^
WATAUAVAWH
A_A^A]A\_
WATAUAVAWH
A_A^A]A\_
VWATAUAVH
L$ E3
A^A]A\_^
VWATAVAWH
A_A^A\_^
SVWATAUAVAWH
A_A^A]A\_^[
D$(2"
D$(2"
D$ 2"
D$(2"
UVWATAUAVAWH
A_A^A]A\_^]
WATAUAVAWH
A_A^A]A\_
t$ WATAUAVAWH
D$X]'
D$Xc'
D$Xi'
D$Xl'
A_A^A]A\_
@SVWATAUAVAWH
l$ E3
A_A^A]A\_^[
VWATAVAWH
D9d$PtJL
A_A^A\_^
WATAUAVAWH
A_A^A]A\_
UAVAWH
D$HM&
D$@E3
A_A^]
s WATAUAVAWH
D9|$PtJL
A_A^A]A\_
WATAUAVAWH
A_A^A]A\_
UAVAWH
D$`E3
A_A^]
x ATAVAWH
A_A^A\
WATAUAVAWH
A_A^A]A\_
s WATAUAVAWH
A_A^A]A\_
WATAUAVAWH
A_A^A]A\_
SVWATAUAVAWH
A_A^A]A\_^[
T$0H!D$ E3
SVWATAUAVAWH
t$ E3
D$pH93t
H91tc
D$pH93t
t$pE3
D$ E3
A_A^A]A\_^[
SVWATAUAVAWH
IL$`H
L$ E3
D$ E3
@8|$P
A_A^A]A\_^[
SVWATAUAVAWH
|$hE3
D$PH9;t
|$P@8
D$ E3
A_A^A]A\_^[
SVWATAUAVAWH
|$pE3
D$ E3
A_A^A]A\_^[
SVWATAUAVAWH
|$pE3
IL$PH
D$`H9;t
D$ E3
A_A^A]A\_^[
SVWATAUAVAWH
D$XH9;t
D$XH9;t
IL$pH
D$ E3
@8|$P
A_A^A]A\_^[
WAVAWH
A_A^_
x ATAVAWH
A_A^A\
SVWATAUAVAWH
A_A^A]A\_^[
D$("(
D$("(
D$ "(
D$("(
D$H,)
UVWATAUAVAWH
d$@E3
A_A^A]A\_^]
x UATAUAVAWH
A_A^A]A\]
SVWATAUAVAWH
A_A^A]A\_^[
D$($,
D$($,
D$ $,
D$($,
D$(A,
D$(A,
D$ A,
D$(A,
@USWH
@USVWATAUAVAWH
D$PE3
t$ E3
A_A^A]A\_^[]
UATAUAVAWH
A_A^A]A\]
WAVAWH
D$ E3
\$x@8
A_A^_
WATAUAVAWH
D$p0#
D$p4#
D$pM#
D$pe#
A_A^A]A\_
D$(o#
D$(o#
D$ o#
D$(o#
@USVWAUAVAWH
A_A^A]_^[]
WATAUAVAWH
D$h@8
A_A^A]A\_
WATAUAVAWH
A_A^A]A\_
WATAUAVAWH
9|$h@
A_A^A]A\_
WATAUAVAWH
A_A^A]A\_
@SVWATAUAVAWH
D$XD8
A_A^A]A\_^[
t$ WATAUAVAWH
A_A^A]A\_
WATAUAVAWH
A_A^A]A\_
@USVWATAUAVAWH
d$ E3
A_A^A]A\_^[]
SVWATAUAVAWH
9\$`tSH
A_A^A]A\_^[
D$([!
D$([!
D$ [!
D$([!
D$0E3
WATAUAVAWH
A_A^A]A\_
UVWATAUAVAWH
A_A^A]A\_^]
p(_><
@USVWATAVAWH
p(_><
A_A^A\_^[]
@USVWATAUAVAWH
]xI9vp
p(_><
A_A^A]A\_^[]
@SVWATAUAVAWH
D$pw!
D$p|!
D$hu4
A_A^A]A\_^[
x AVH
L$0H3
9.~&H
SVWATAUAVAWH
A_A^A]A\_^[
D$(~*
D$(~*
D$ ~*
D$(~*
x ATAVAWH
A_A^A\
q#YP76|
WAVAWH
A_A^_
q#YP76|
x ATAVAWH
A_A^A\
c AUAVAWH
D$ E3
A_A^A]
qs]8r
c AUAVAWH
D$ E3
A_A^A]
c AUAVAWH
D$ E3
A_A^A]
x ATAVAWH
A_A^A\
WATAUAVAWH
A_A^A]A\_
@SVWATAUAVAWH
A_A^A]A\_^[
UVWATAUAVAWH
A_A^A]A\_^]
@SVWATAUAVAWH
|$ E3
A_A^A]A\_^[
qrV~9
WATAUAVAWH
A_A^A]A\_
c AUAVAWH
D$ E3
A_A^A]
WATAUAVAWH
A_A^A]A\_
x ATAVAWH
A_A^A\
x ATAVAWH
A_A^A\
x ATAVAWH
A_A^A\
x ATAVAWH
A_A^A\
c AUAVAWH
D$ E3
A_A^A]
c AUAVAWH
D$ E3
A_A^A]
c AUAVAWH
D$ E3
A_A^A]
c AUAVAWH
D$ E3
A_A^A]
x ATAVAWH
A_A^A\
WATAUAVAWH
A_A^A]A\_
AUAVAWH
D$ E3
A_A^A]
SVWATAUAVAWH
D$ E3
8\$Puj8
L$XH+
GPH+A
L$XH+
GPH+A
9_0u!
8\$Qt!
A_A^A]A\_^[
VWATAVAWH
A_A^A\_^
UWATAVAWH
D$@D9c
d$ E3
A_A^A\_]
t$ WATAUAVAWH
A_A^A]A\_
WATAUAVAWH
D;d$h
\$ E3
\8\$AtOH
D$ E3
\$ E3
A_A^A]A\_
t$ WATAUAVAWH
D$`3*
D$`8*
D$`;*
D$`>*
D$`A*
D$`F*
D$`G*
A_A^A]A\_
D$(S*
D$(S*
D$ S*
D$(S*
UVWATAUAVAWH
A_A^A]A\_^]
x UATAUAVAWH
A_A^A]A\]
UVWATAUAVAWH
A_A^A]A\_^]
\$ UVWATAUAVAWH
A_A^A]A\_^]
\$ UVWAVAWH
A_A^_^]
UVWATAUAVAWH
A_A^A]A\_^]
UVWATAUAVAWH
A_A^A]A\_^]
UATAUAVAWH
A_A^A]A\]
UAVAWH
A_A^]
\$ UVWATAUAVAWH
A_A^A]A\_^]
UVWATAUAVAWH
f9D$8u
A_A^A]A\_^]
K8@8y(t
WATAUAVAWH
A_A^A]A\_
t$ WH
SVWATAUAVAWH
t$@A8
A_A^A]A\_^[
x ATAVAWH
A_A^A\
UWATAVAWH
A_A^A\_]
UVWATAUAVAWH
D8}St*H
A_A^A]A\_^]
@SVWAVAWH
A_A^_^[
SVWATAUAVAWH
A_A^A]A\_^[
` UAUAWH
A_A]]
WAVAWH
89:u69z
pcPZt
0A_A^_
SVWATAUAVAWH
A_A^A]A\_^[
UWATAVAWH
A_A^A\_]
x UATAUAVAWH
A_A^A]A\]
x UATAUAVAWH
A_A^A]A\]
t @8{
VWATAUAWH
A_A]A\_^
t@L;H
WATAUAVAWH
D$(E3
A_A^A]A\_
|$ ATAVAWH
H;8u/H
0A_A^A\
E H+E
H;_ t)H
l$ VWAVH
t$HfD
\$ UVWATAUAVAWH
A_A^A]A\_^]
\$ UVWATAUAVAWH
A_A^A]A\_^]
UVWATAUAVAWH
A_A^A]A\_^]
UVWATAUAVAWH
A_A^A]A\_^]
UAVAWH
D$ E3
H;B u{H
A_A^]
UVWATAUAVAWH
l$@E3
l$ E3
L9k0u
A_A^A]A\_^]
\$ UVWAVAWH
H;^ t
A_A^_^]
|$ AVH
t$ AWH
WAVAWH
 A_A^_
@8{du
@8{et
@8y(t
{ AVH
D8wet2L
D8wdt
UVWATAUAVAWH
f94Ku
f94Bu
f94Bu
A_A^A]A\_^]
t$ WH
C8H!C@H
@SVWATAUAVAWH
&D8gdt{H
D8get{H
fE9$Gu
A_A^A]A\_^[
D$ E3
UVWATAUAVAWH
A_A^A]A\_^]
s WATAUAVAWH
|$PD8~dtpL
D8~etpL
A_A^A]A\_
WAVAWH
89:u69z
pcPZt
0A_A^_
q1Y^T?
x UATAUAVAWH
A_A^A]A\]
UATAUAVAWH
fE9$_u
fE9$Fu
A_A^A]A\]
UATAUAVAWH
A_A^A]A\]
@SVWATAUAVAWH
D8sdueD8seu_L
p1Y^T?
A_A^A]A\_^[
UATAUAVAWH
f94Ku
A_A^A]A\]
t$ WATAUAVAWH
A_A^A]A\_
UVWATAUAVAWH
A_A^A]A\_^]
H+E'u
H+E/H
H+E7u
H+E?H
|$ UATAUAVAWH
D$PE3
A_A^A]A\]
x AVH
` UAUAWH
@8q(t
A_A]]
t$ WATAUAVAWH
A_A^A]A\_
t6HcK
t7HcK
USVWATAUAVAWH
A_A^A]A\_^[]
q0Zt}
WAVAWH
0A_A^_
SVWATAUAVAWH
H9_htqH
I9}hI
\$ E3
A_A^A]A\_^[
s WATAUAVAWH
H9_htsL
I9}hI
D$ E3
A_A^A]A\_
|$ UH
x UAVAWH
fD9<Fu
fD9<^u
A_A^]
UVWATAUAVAWH
pRRx3
fB9<Fu
ux@8}
uqD8u
pSPTZ
uuD8}
A_A^A]A\_^]
UVWATAUAVAWH
9t$8tbL
pRRx3
p3XpZ.x
A_A^A]A\_^]
@USVWATAUAVAWH
A_A^A]A\_^[]
UWATAVAWH
A_A^A\_]
UWAUAVAWH
@v#Hc
A_A^A]_]
UATAUAVAWH
A_A^A]A\]
SVWATAUAVAWH
H9{htqH
I9}hI
t$ E3
A_A^A]A\_^[
\$ UVWATAUAVAWH
A_A^A]A\_^]
UWATAVAWH
A_A^A\_]
WAVAWH
0A_A^_
SVWATAUAVAWH
H9_htoL
I9}hI
|$ E3
|$ E3
|$ E3
|$ E3
A_A^A]A\_^[
K SVWATAUAVAWH
t$ E3
t$ E3
t$ E3
t$ E3
t$ E3
t$ E3
A_A^A]A\_^[
x UATAUAVAWH
|$ E3
|$ E3
|$ E3
A_A^A]A\]
` UAVAWH
A_A^]
UVWATAUAVAWH
A_A^A]A\_^]
D9G@v
D;O@r
9K@v0L
SVWATAUAVAWH
A_A^A]A\_^[
USVWATAUAVAWH
t$ E3
t$ E3
t$ E3
t$ E3
t$ E3
t$ E3
t$ E3
t$ E3
t$ E3
A_A^A]A\_^[]
t$ E3
UVWATAUAVAWH
t$ E3
t$ E3
t$ E3
t$ E3
A_A^A]A\_^]
t$ E3
UVWATAUAVAWH
A_A^A]A\_^]
UVWAVAWH
A_A^_^]
x UAVAWH
A_A^]
UVWATAUAVAWH
A_A^A]A\_^]
UATAUAVAWH
A_A^A]A\]
|$ UAUAVH
A^A]]
pH]:S
WAVAWH
0A_A^_
SVWATAUAVAWH
H9_htsL
I9}hI
|$ E3
D$ E3
D$ E3
A_A^A]A\_^[
ATAVAWH
0A_A^A\
SVWATAUAVAWH
H9_htqH
I9}hI
\$ E3
\$ E3
A_A^A]A\_^[
WAVAWH
0A_A^_
SVWATAUAVAWH
H9_htsL
I9}hI
t$ E3
D$ E3
D$ E3
A_A^A]A\_^[
WAVAWH
0A_A^_
SVWATAUAVAWH
H9_htqH
I9}hI
\$ E3
t$ E3
\$ E3
A_A^A]A\_^[
ATAVAWH
0A_A^A\
SVWATAUAVAWH
H9_htqH
I9}hI
\$ E3
d$ E3
\$ E3
\$ E3
A_A^A]A\_^[
UWATAVAWH
fD9 t
D9#umH
d$ E3
fD9$_u
fD9 t
A_A^A\_]
VWATAVAWH
@A_A^A\_^
s WATAUAVAWH
H9_htqH
I9}hI
t$ E3
t$ E3
A_A^A]A\_
UWATAVAWH
p#YP76|
d$ E3
d$ E3
A_A^A\_]
UVWATAUAVAWH
A_A^A]A\_^]
x AVH
9W@v Hc
|$ UATAUAVAWH
A_A^A]A\]
UATAUAVAWH
A_A^A]A\]
VWATAVAWH
|$ E3
A_A^A\_^
UVWATAUAVAWH
A_A^A]A\_^]
s WATAUAVAWH
H9_htqH
I9}hI
\$ E3
\$ E3
A_A^A]A\_
x UATAUAVAWH
H9{htIH
I9}hI
A_A^A]A\]
UATAUAVAWH
A_A^A]A\]
SVWATAUAVAWH
t$`E3
A_A^A]A\_^[
UWAVH
D9w@v=Hc
UVWAVAWH
H+EPu
H+EXH
A_A^_^]
s WATAUAVAWH
IL$XH
W L9"
A_A^A]A\_
l$ VWAVH
l$ E3
L$@H3
UVWATAUAVAWH
D$ E3
A_A^A]A\_^]
t$ WH
9\$8vLL
;\$8r
L$HH3
UWATAVAWH
A_A^A\_]
USVWATAUAWH
D$ E3
A_A]A\_^[]
{ ATAVAWH
A_A^A\
\$ UVWATAUAVAWH
D$ E3
A_A^A]A\_^]
UVWATAUAVAWH
A_A^A]A\_^]
SVWATAUAVAWH
A_A^A]A\_^[
D$ E3
|$ UATAUAVAWH
A_A^A]A\]
|$ UATAUAVAWH
D$ E3
A_A^A]A\]
WAVAWH
K D8s0tgI
fE94Au
fD94Nu
fG94Au
 A_A^_
UATAUAVAWH
A_A^A]A\]
UVWATAUAVAWH
4CfE;
tJfA;
tDfE;&u
Cf;)t
 A_A^A]A\_^]
D$0E3
\$(E3
D$ E3
WATAUAVAWH
A_A^A]A\_
WAVAWH
A_A^_
UWAVH
fD90t
UVWATAUAVAWH
L$0E3
fD9,ju
fE9,$
fE9,~t
D$"fA
~fD9)u
fE9,~u
fE9,l
fE9,N
A_A^A]A\_^]
WATAUAVAWH
H9{(tKH
py]</
A_A^A]A\_
s WATAUAVAWH
A_A^A]A\_
qH]:S
WATAUAVAWH
A_A^A]A\_
s WATAUAVAWH
A_A^A]A\_
s WATAUAVAWH
A_A^A]A\_
s WATAUAVAWH
A_A^A]A\_
s WATAUAVAWH
A_A^A]A\_
s WATAUAVAWH
p0TTo6
A_A^A]A\_
WATAUAVAWH
A_A^A]A\_
WATAUAVAWH
A_A^A]A\_
tKH9{
@USVWATAVAWH
`A_A^A\_^[]
pjS6b
UVWATAUAVAWH
D$ E3
D$ E3
D$ E3
A_A^A]A\_^]
USVWATAUAVAWH
A_A^A]A\_^[]
@SVWAVAWH
A_A^_^[
q;]:P
c AUAVAWH
T$ E3
A_A^A]
x UATAUAVAWH
A_A^A]A\]
x UATAUAVAWH
A_A^A]A\]
|$ UAVAWH
9V v(
A_A^]
UVWAVAWH
fD94zu
0A_A^_^]
@SVWH
L$(H3
t$ WH
\$ WH
D$ L+
L$(H3
\$ WH
L$(H3
H!|$HH!|$@H
UVWATAUAVAWH
fA9\E
fA9\E
fA9LE
uyfA9
fA9LD
fA9\E
D$xfC
0A_A^A]A\_^]
VWATH
H9_ uAD
H9_0u0A
H9_(u3A
0A\_^
UVWAVAWH
A_A^_^]
WAVAWH
89:u69z
pcPZt
0A_A^_
qH9^8t*
t$ WH
t$ WATAUAVAWH
\$`H9] u:D
H9]0u<A
H9](u<A
0A_A^A]A\_
UVWATAUAVAWH
A_A^A]A\_^]
L$ WH
fC9<Au
L$ VWAVH
fA9,Ju
fA9,Iu
|$ UATAUAVAWH
T$0E3
A_A^A]A\]
UVWATAUAVAWH
d$ E3
A_A^A]A\_^]
t$ UWATAVAWH
)L$PH
A_A^A\_]
UVWATAUAVAWH
A_A^A]A\_^]
\$ UVWATAUAVAWH
A_A^A]A\_^]
\$ UVWATAUAVAWH
A_A^A]A\_^]
L$PH3
l$ VWATAVAWH
fD9dG
A_A^A\_^
x UAVAWH
fD9<Yu
|$HE3
|$@E3
A_A^]
t$ WATAUAVAWH
fD9<Fu
fD9<Fu
fD9<Nu
M9>uoL
A_A^A]A\_
WATAUAVAWH
D9{(u^L
A_A^A]A\_
WATAUAVAWH
D9{(u^L
fD9<Fu
A_A^A]A\_
G.fD;
L$8H3
f9<Au
x UATAUAVAWH
D9~(uZH
A_A^A]A\]
\$ UVWH
UVWATAUAVAWH
f9<Cu
A_A^A]A\_^]
|$ UATAUAVAWH
fD9$Gu
E9f(tZL
fD9$wu
fD9$Wu
fD9$_u
A_A^A]A\]
UATAUAVAWH
A_A^A]A\]
pjS6b
UATAUAVAWH
A_A^A]A\]
UATAUAVAWH
A_A^A]A\]
qPSrq'A
` UAVAWH
A_A^]
UATAUAVAWH
A_A^A]A\]
VWATAVAWH
A_A^A\_^
t$ WATAUAVAWH
A_A^A]A\_
UVWATAUAVAWH
fD9$Au
fE9$Gu
fE9$Fu
fF9$@u
fG9$Gu
fE9$^u
A_A^A]A\_^]
t$ WATAUAVAWH
A_A^A]A\_
UVWATAUAVAWH
H9T$0u<A
fG94Du
fE94_u
A_A^A]A\_^]
UVWATAUAVAWH
|$(E3
H!\$(H
D$ E3
D9@@t"H
@A_A^A]A\_^]
x UATAUAVAWH
D$4A9\$
L$Xt9B
D$8H9
D"PH+
D"XH+
T$PA9}
`K+D"`u
hK+D"hH
uK9\$0
D$4A;D$
A_A^A]A\]
UVWATAUAVAWH
fD9$Au
uV9L$`uPH
A_A^A]A\_^]
UVWATAUAVAWH
T9}Hu3H
@A_A^A]A\_^]
L$ WH
fC9<Au
L$ WH
fC9<Au
fA9<Cu
fC9<Qu
UWAVH
H!\$(L
!\$ L
VWATAVAWH
F,f;G&u'f;G0u!f;G:u
f;GDu
F|f;G^u
\$(E3
D$@H+
D$`L+
A_A^A\_^
WAVAWH
D$8fD
A_A^_
\$ UVWATAUAVAWH
A_A^A]A\_^]
VWAVH
t$ WAVAWH
A_A^_
x UATAUAVAWH
D$ E3
L$ E3
L$@E3
D$XfH
D$`H+
A_A^A]A\]
t$ WAVAWH
9\$`u
0A_A^_
|$ UATAUAVAWH
8XAtT
A_A^A]A\]
t$ WAVAWH
D$08XA
L$XH3
A_A^_
UVWAUAWH
GJH!}
A_A]_^]
t$ UATAUAVAWH
l$(E3
T$XHi
D$XH+
D$`H+
E94$vPA
T$XLi
D$XH+
D$`H+
E;<$r
T$XLi
D$XH+
D$`H+
D9t$@
A_A^A]A\]
l$ VWAUAVAWH
9\$0u
H9^8t.9^Tu)9^Pt$
9\$0t
L$HH3
A_A^A]_^
VWATAVAWH
oh@8}Iu
E;wdr
0A_A^A\_^
x AVH
D9I@t
WAVAWH
0A_A^_
UVWATAUAVAWH
D$4A9\$d
|$hA8_I
D$`H+
D$hH+
l$88\$ttGA
D$4A;D$d
A_A^A]A\_^]
WAVAWH
0A_A^_
t$ UWATAUAWH
9L$DvHA
;\$Dr
D$PE3
D$PHi
A_A]A\_]
\$ UVWATAUAVAWH
A96v1
A_A^A]A\_^]
x AVH
UVWATAUAVAWH
D9npv9H
@A_A^A]A\_^]
f9<Au
@SUVWAVH
L$@H3
PA^_^][
SUVWATAUAVAWH
hh8]I
t$09>
PI+E u
XI+E(H
HA_A^A]A\_^][
WAVAWH
0A_A^_
@USVWATAVAWH
A_A^A\_^[]
@USVWATAUAVAWH
uTA8^
uNA8^
uHA8^
A_A^A]A\_^[]
UVWATAUAVAWH
D$@D;
A_A^A]A\_^]
@SUWATAUAVAWH
|$0E3
D!ytH
L$xH3
A_A^A]A\_][
SVWATAUAVAWH
L$@I+
T$0E;
T$HH;
PA_A^A]A\_^[
UVWATAUAVAWH
D$0B9\
D$0B;D
L$4;M$sCL
PA_A^A]A\_^]
\$ UVWAVAWH
L$XH3
`A_A^_^]
\$ UVWATAUAVAWH
A_A^A]A\_^]
l$ VWAUAVAWH
A_A^A]_^
t$ WATAUAVAWH
t$4A9w
D$4D;@
A_A^A]A\_
@SUVWATAVAWH
L$XH3
`A_A^A\_^][
UVWAVAWH
A_A^_^]
x AVH
t$ WAVAWH
A_A^_
UVWATAUAVAWH
0A_A^A]A\_^]
UVWATAUAVAWH
D$@D;
A_A^A]A\_^]
UVWATAUAVAWH
E;}Pt5H
@A_A^A]A\_^]
UVWATAUAVAWH
0A_A^A]A\_^]
UVWATAUAVAWH
A_A^A]A\_^]
UVWATAUAVAWH
T$0D9m8v6H
@A_A^A]A\_^]
@SUVWAVAWH
L$XH3
hA_A^_^][
t$ UWAVH
x ATAVAWH
A9F@t7M
F8D;`@
0A_A^A\
VWAVH
!|$@H
H!|$0E3
H!|$8H
D$0E3
\$Pt/H
L$XH3
UVWATAUAVAWH
PA_A^A]A\_^]
t$ WH
H!|$`H
T$`H!|$`H
VWAVH
u#f;w&u
f;w0u
f;w:u
f;wDu
f;G^t
0A^_^
UVWAVAWH
0A_A^_^]
x AVH
D9p@tXH
9h@t:H
WATAUAVAWH
A_A^A]A\_
l$ VWAUAVAWH
0A_A^A]_^
t$ WH
WAVAWH
9F@t>
0A_A^_
VWATAVAWH
fD;g&
fD;g0
fD;g:
fD;gD
A_A^A\_^
x AVH
T$ E3
L$@H3
t$ WH
l$ VWAVH
0A^_^
@USVWATAVAWH
]PD;}H
`A_A^A\_^[]
UATAUAVAWH
D;u0r
A_A^A]A\]
USVWATAUAWH
A_A]A\_^[]
t$ UWATAVAWH
!t$D!t$@!t$HM
!t$@H
D;|$D
A_A^A\_]
UVWATAUAVAWH
A_A^A]A\_^]
t$ UATAUAVAWH
D!8D!~h
D$@9D$L
D$@;D$L
A_A^A]A\]
UVWATAUAVAWH
A_A^A]A\_^]
UVWATAWH
L9d$8
L9d$@
L9d$H
fD9$Au
fF9$zu
A_A\_^]
t$ WH
H!|$hH
WH9|$hu?3
T$hH!|$hH
t$ UWAVH
UVWATAUAVAWH
9]@vFH
D;u@r
pA_A^A]A\_^]
@USVWAVH
E89E0r
E@9EHsU
@A^_^[]
UWATAUAVH
A^A]A\_]
x UATAUAVAWH
d$ E3
L$8E3
A_A^A]A\]
UATAUAVAWH
I9_pt
A_A^A]A\]
WAVAWH
A_A^_
WATAUAVAWH
0A_A^A]A\_
L$ SH
L$ VWAVH
fA9,Au
fA9,Cu
fA9,Bu
f9,Su
H9_8uxH;
9_Lt[A
t$ WAVAWH
H9~(tAH
0A_A^_
\$ UVWATAUAVAWH
t$(E3
D$ E3
D$D9r
D$D;B
A_A^A]A\_^]
x ATAVAWH
0A_A^A\
@SUVWATAUAVAWH
A_A^A]A\_^][
UVWAVAWH
9]Pu:D
9\$4u:H
A_A^_^]
\$ UVWATAUAVAWH
H!\$0A
H!\$8H
D$0E3
!\$(E3
H!\$ 
D$(E3
H!\$ I
@A_A^A]A\_^]
H!]8L
M(H!]0L
E0H!](H
U8H!]
uB9_LuUH
t$ WATAUAVAWH
9ohv0A
|$0E3
Pt{I;
|$(E3
E94$u
y Bt%
0A9,$u*H
A_A^A]A\_
l$ VWAVH
F0H+A
F8H+A
F(H+A
0A^_^
p AWH
WATAUAVAWH
0A_A^A]A\_
l$ VWAVH
0A^_^
WAVAWH
@A_A^_
x ATAVAWH
0A_A^A\
\$ UVWATAUAVAWH
G H9x
t$pA9t$
D$pE;D$
0A_A^A]A\_^]
UVWAVAWH
9\$ht-H
9\$pt
0A_A^_^]
t$ WH
x ATAVAWH
u 9PDu
0A_A^A\
WAVAWH
Cd9Fdu
0A_A^_
VWAVH
H9]8tVD
H9^8u%
0A^_^
t$ WAVAWH
I9^8t:D
D9|$Pt
H9_8tS
0A_A^_
WAVAWH
0A_A^_
UVWAVAWH
@A_A^_^]
VWAVH
9\$Pu;H
0A^_^
x AVH
UVWATAUAVAWH
to9_TujI
H9_8t 9_Tu
t.9\$pH
9\$pu
0A_A^A]A\_^]
VWAVH
H!l$0E3
H!l$(L
D$@H!l$ A
!l$DH
9t$hu/
9t$0tM
UVWAVAWH
9\$ht)H
9\$pt5H9_8ux9_Lu;H
0A_A^_^]
9_hu3
_hD;[ht
C H;H
C H9H
9Chv4H
VWATAVAWH
9\$`u/
0A_A^A\_^
D9ALu
9}hv<A
VWAVH
L$XfA
0A^_^
UVWATAUAVAWH
H!|$(H
D$(E3
D$(E3
D$(E3
H!|$(H
H!|$(H
A_A^A]A\_^]
\$ UVWATAUAVAWH
D$ E3
A_A^A]A\_^]
L$ E3
L$Hf9
\$0E3
\$(E3
D$ E3
\$dA9_
D9\$ht
t$XD;t$\
D;t$\u
D$0E3
\$(E3
t$XD;t$\u
D$`C9D
L$dA;O
WAVAWH
9_TtHH
0A_A^_
x UATAUAVAWH
D$ E3
L$8E3
D$0E3
fB9Lh
L$HE3
A_A^A]A\]
l$ VWATAVAWH
H!|$0
wcH!|$(H
D$PE3
D$ E3
A_A^A\_^
VWAVH
H!\$hM
!\$(H
H!\$(H
D$hE3
D$ E3
@A^_^
L$HH3
UATAUAVAWH
9]XvIL
A9_Xt+H
A_A^A]A\]
x AVH
O@E;N
x ATAVAWH
 A_A^A\
l$ VWAVH
9\$`t
0A^_^
VWAVH
9\$`t5H
@A^_^
UVWATAUAVAWH
pA_A^A]A\_^]
VWAVH
H!\$xH
!\$pH
D$pE3
D$xE3
H!\$0H
PA^_^
VWATAVAWH
L9|$xtXH
0A_A^A\_^
UWAVH
H!|$`L
l$PD;
0A^_]
UVAVH
H!t$pL
@A^^]
l$ VWAVH
fD94Au
UVWATAUAVAWH
A_A^A]A\_^]
l$ VWAVH
l$(E3
|$ E3
0A^_^
t$ UWAVH
H!]0I
H!\$0
!\$ H
H!|$0
!|$ H
\$ UVWATAUAVAWH
0A_A^A]A\_^]
WAVAWH
0A_A^_
f9,Yu
x ATAVAWH
A_A^A\
x ATAVAWH
A_A^A\
t$ WAVAWH
9.tVA
D$Pf9
0A_A^_
x AVH
fB9,Au
f9,Bu
L$ SUVWATAUAVAWH
HA_A^A]A\_^][
KHf;H
K(f;H
L$HE3
L$ SUVWAVH
D$8E3
A^_^][
UVWAVAWH
A_A^_^]
H!X !X
D$pE3
D$8H!\$0
!\$ H
D$xH!\$xH
VWATAVAWH
D$xE3
A_A^A\_^
{9|$Xt2A
D$ E3
H!\$ 
UVWATAUAVAWH
A_A^A]A\_^]
WAVAWH
0A_A^_
\$(E3
@SUVWATAVAWH
\$(E3
D$@E3
D$(E3
A_A^A\_^][
VWAVH
9)t5A
VWAVH
\$(E3
t$ WAVAWH
0A_A^_
t$ WATAUAVAWH
D97u!H;
D9t/0
D9d/0
D/PH+
D/XH+
D/PH+
D/XH+
D/PH+
D/XH+
D/PH+
D/XH+
D/PH+
D/XH+
D/PH+
D/XH+
A_A^A]A\_
WATAUAVAWH
D9t$@w
A_A^A]A\_
UVWAVAWH
pA_A^_^]
UVWATAUAVAWH
A_A^A]A\_^]
t$ WATAUAVAWH
l$HD;
f9<Fu
A_A^A]A\_
VWATAVAWH
`A_A^A\_^
L$ SH
t$ WATAUAVAWH
0A_A^A]A\_
VWAVH
D$0E3
@A^_^
\$(E3
D$0E3
|$(E3
WATAUAVAWH
0A_A^A]A\_
t$ WH
\$0E3
UVWATAUAVAWH
@A_A^A]A\_^]
WATAUAVAWH
fE9<~u
H!\$ E
A_A^A]A\_
t$ WAVAWH
0A_A^_
t$ WATAUAVAWH
0A_A^A]A\_
L$HE3
VWAVH
0A^_^
UVWATAUAVAWH
9\$Dt
L$pH3
A_A^A]A\_^]
WATAUAVAWH
D9t$@w
A_A^A]A\_
SUVWATAVAWH
f94Hu
@A_A^A\_^][
t$ UWATAUAWH
H!\$(L
H!\$@H
D$8E3
H!\$ 
A_A]A\_]
VWAVH
t?D95t
0A^_^
UVWATAUAVAWH
fD94Fu
<F\tFH
fA94lu
@A_A^A]A\_^]
q"[pF
ATAVAWH
t.D9e
 A_A^A\
UVWATAUAVAWH
L$0E3
t$(E3
D$ E3
D$`E3
D$(E3
A_A^A]A\_^]
|$ UAVAWH
A_A^]
Set m_pSidAdmin
SYSTEM\CurrentControlSet\Services\VSS\Settings
CVssWriterState::Initialize
ActiveWriterStateTimeout
wait returned for coordinator thread: %#x, wait<%d> error<%#x>
waiting INFINITE for coordinator thread: %#x
Returning dc = %s, ad = %s, dsrm = %s
CVssRegistryValueIterator::Attach
SYSTEM\Setup
UpgradeInProgress
SystemSetupInProgress
CVssMachineInformation::IsDuringSetup
EventClassID == 
VssapiPublisher
CreateVssBackupComponentsInternal
SYSTEM\ControlSet001\Control\MiniNT
CVssMachineInformation::IsDuringWinPE
CreateWriterEx
CVssDiag::FlushQueue
CVssMachineInformation::IsDuringDsrmSafeMode
SYSTEM\CurrentControlSet\Control\Safeboot\Option
CVssMachineInformation::IsDCwithAD
VSSCHEMA
BuildComponentDocumentFromString
base\stor\vss\modules\backupext\vsxml\vs_schema.cxx
SYSTEM\CurrentControlSet\Control\ProductOptions
base\stor\vss\modules\vssapi\modulekeeper.cxx
Product type is not LanManNt - It is not a DC
CVssBackupComponents::~CVssBackupComponents
CVssBackupComponents::SetContextInternal
CVssModuleKeeper::~CVssModuleKeeper
CVssModuleKeeper::CVssModuleKeeper
x-schema:#VssComponentMetadata
CXMLDocument::FindElement
SYSTEM\CurrentControlSet\Services\VSS\Settings
<root>
</root>
MaxXmlDocumentSizeMB
CVssRequestorActivity
CXMLNode::InsertNode
IVssCoordinatorEx2
BACKUP_COMPONENTS
MDULKPRC
VssModuleKeeper
Initialized
Requestor
LanManNt
version
MSXML30
xmlns
CVssBackupComponents::CVssBackupComponents
CVssMachineInformation::IsDomainController
CVssBackupComponents::InitializeForBackup
CVssMachineInformation::IsDCwithADinDSRM
CVssBackupComponents::FreeWriterStatus
CXMLDocument::LoadFromXML
CXMLDocument::CreateNode
CXMLNode::InsertChild
CXMLDocument::Next
base\stor\vss\modules\vssapi\vssapi.cpp
VSSAPICP
VssFreeSnapshotPropertiesInternal
VssAPI::VssFreeSnapshotProperties
BUEXMLC
CXMLNode::SetAttribute
BUECXMLC
CVssBackupComponents::AbortBackup
base\stor\vss\modules\backupext\vsxml\vs_cmxml.cxx
CVssBackupComponents::StartCoordKeeperThread
base\stor\vss\modules\backupext\vsxml\vs_xml.cxx
CXMLDocument::Initialize
CXMLDocument::IsNodeMatch
CVssBackupComponents::Query
CVssBackupComponents::SetContext
SubscribeCallback
WSHVWRTC
CreateWriter
base\stor\vss\modules\vssapi\vswriter.cpp
InstanceId for Writer %s is {%.8x-%.4x-%.4x-%.2x%.2x-%.2x%.2x%.2x%.2x%.2x%.2x}
WriterId              = {%.8x-%.4x-%.4x-%.2x%.2x-%.2x%.2x%.2x%.2x%.2x%.2x}
CVssSidCollection::IsSidAllowedToFire
**** Subscribe succeeded for [%p]
EventSystem.EventClassCollection
EventSystem.EventSubscription
CVssWriterImpl::CreateWriter
*** Constructing object %p
wszWriterInstanceName = %s
WriterName            = %s
CEventSubscription
WriterInstanceId
CEventSystem
WriterId
(NULL)
WRTWRTIC
CVssWriterImpl::SubscribeInternal
base\stor\vss\modules\vswriter\vswrtimp.cpp
CVssWriterImpl::CVssWriterImpl
{%.8x-%.4x-%.4x-%.2x%.2x-%.2x%.2x%.2x%.2x%.2x%.2x}
CONTEXT
Adding context: '%s' = '%s' (%d)
Adding context: '%s' (%d)
CVssRegistryValueIterator::ReadCurrentValueDetails
FALSE
RETURN
Time spent: %02ld:%02ld:%02ld-%04ld; total: %#x; HRESULT: %#x
REGREGSC
base\stor\vss\modules\registry\registry.cxx
SECSECRC
CVssSidCollection::AddSid
CVssSidCollection::AddWellKnownSid
base\stor\vss\modules\sec\security.cxx
Returning BOOL: %s
ExpandForVerification()
CVssSidCollection::ExpandForVerification
CVssRegistryKey::Open
CVssRegistryKey::Close
CVssDiag::Initialize
SYSTEM\CurrentControlSet\Services\VSS\Diag
INCTYPEH
CVssSafeCriticalSection::Init
base\stor\vss\inc\vs_types.hxx
%s\%s
CAutoSid::CreateBasicSid
CVssRegistryKey::GetValue
GetCurrentAccessToken
Parameters %s
CVssRegistryKey::Create
Diagnose enabled for (%s)
CVssSidCollection::AddUser
CVssRegistryValueIterator::GetCurrentValueContent
GetClientTokenUser
AcquireSemaphore
CVssSafeComPtr<struct IVssCoordinatorEx2>::Initialize
CVssSafeComPtr<struct IVssCoordinatorEx2>::GetInterface
HasPrivilege
CVssSafeComPtr<struct IVssCoordinatorEx2>::Reset
GlobalInterfaceTable
vssapi.dll
TRCTRCC
base\stor\vss\modules\trace\fntracer.cpp
CVssFunctionTracer::LogVssStartupAttempt
VSS information: Service starting at request of process '%s'. [0x%08x]
RtlDisownModuleHeapAllocation
ntdll.dll
bad allocation
permission denied
file exists
no such device
filename too long
device or resource busy
io error
directory not empty
invalid argument
no space on device
no such file or directory
function not supported
no lock available
not enough memory
resource unavailable try again
cross device link
operation canceled
too many files open
permission_denied
address_in_use
address_not_available
address_family_not_supported
connection_already_in_progress
bad_file_descriptor
connection_aborted
connection_refused
connection_reset
destination_address_required
bad_address
host_unreachable
operation_in_progress
interrupted
invalid_argument
already_connected
too_many_files_open
message_size
filename_too_long
network_down
network_reset
network_unreachable
no_buffer_space
no_protocol_option
not_connected
not_a_socket
operation_not_supported
protocol_not_supported
wrong_protocol_type
timed_out
operation_would_block
address family not supported
address in use
address not available
already connected
argument list too long
argument out of domain
bad address
bad file descriptor
bad message
broken pipe
connection aborted
connection already in progress
connection refused
connection reset
destination address required
executable format error
file too large
host unreachable
identifier removed
illegal byte sequence
inappropriate io control operation
invalid seek
is a directory
message size
network down
network reset
network unreachable
no buffer space
no child process
no link
no message available
no message
no protocol option
no stream resources
no such device or address
no such process
not a directory
not a socket
not a stream
not connected
not supported
operation in progress
operation not permitted
operation not supported
operation would block
owner dead
protocol error
protocol not supported
read only file system
resource deadlock would occur
result out of range
state not recoverable
stream timeout
text file busy
timed out
too many files open in system
too many links
too many symbolic link levels
value too large
wrong protocol type
OLEAUT32.dll
api-ms-win-core-com-l1-1-0.dll
api-ms-win-service-management-l1-1-0.dll
api-ms-win-service-winsvc-l1-1-0.dll
api-ms-win-security-lsalookup-l1-1-0.dll
api-ms-win-eventlog-legacy-l1-1-0.dll
api-ms-win-security-sddl-l1-1-0.dll
MPR.dll
RPCRT4.dll
XmlLite.dll
samcli.dll
netutils.dll
DSROLE.dll
ESENT.dll
WS2_32.dll
\^F&{
!api-ms-win-devices-config-l1-1-1.dll
VirtDisk.dll
SETUPAPI.dll
bcd.dll
Memory allocation error
VssSafeDuplicateStr
INCSTRH
base\stor\vss\inc\vs_str.hxx
StringCchCopy(%s, %d, %s) failed
INCICHLH
base\stor\vss\inc\ichannel.hxx
Channel not open
CVssIOCTLChannel::Call
previous IOCTL hasn't yet completed
CreateEvent(NULL, TRUE, FALSE, NULL)
Could not extend the output buffer
IOCTL sent: %lx on device %s
 Input buffer size: %ld, Output buffer size: %ld
IOCTL %lx failed on device %s - 0x%08lx. Error code = 0x%08lx
IOCTL %lx succeeded on device %s - 0x%08lx. 
 Output buffer: size received = %ld
VssAPI: DllMain got unexpected reason code (%d), lpReserved: %sNULL
CoCreateInstance
Exception
ReturnNt
ReturnHr
LogNt
LogHr
FailFast
%hs(%u)\%hs!%p: 
%hs!%p: 
(caller: %p) 
%hs(%d) tid(%x) %08X %ws
Msg:[%ws] 
CallContext:[%hs] 
[%hs(%hs)]
[%hs]
kernelbase.dll
onecore\internal\sdk\inc\wil\opensource\wil\resource.h
WilError_03
WilFailureNotifyWatchers
CVssJetWriter::InitializeThreadFunc
WSHJTWRC
base\stor\vss\modules\vssapi\jetwriter.cpp
CoInitializeEx failed 0x%08lx
CvssIJetWriter::Initialize failed
CvssIJetWriter::Initialize failed [0x%08lx]
Error loading VSS.DLL [0x%08lx]
VssLoadString
CVssResource::LoadStringW
Error loading VSS.DLL resource with ID = 0x%08lx [0x%08lx]
ENTER
Unknown
vsstrace.dll
Calling Initialize during safe mode
ResetEvent(cancelEvent)
CoInitializeEx
CVssBackupComponents::PostGatherWriterStatus
::WaitForSingleObject(cancelEvent, INFINITE) 
Registry writer failed to respond, severe error
CoCreateGuid
System
UNDEFINED
CoCreateInstance-GIT
IXMLDOMNode::insertBefore
IXMLDOMNode::setAttribute
IXMLDOMNode::createNode
IXMLDOMNode::get_firstChild
IXMLDOMNode::get_NodeType
IXMLDOMNode::get_NodeName
IXMLDOMNode::loadXML
CVssWorkerThread::FinalReleaseWorkerThreadObject
INCWORKH
base\stor\vss\inc\worker.hxx
Bad state %d
Returning HRESULT: 0x%08lx
BootableSystemState
SystemService
UserData
Other
TransactionDb
NonTransactionDb
No alternate writer
BackEnd
FrontEnd
SystemRM
Automatic
CVssWriterImpl::SetupEvent
Failure to create event object due to error %d.
CVssWriterImpl::Initialize
You cannot initialize the writer twice
alternate writer not supported
invalid usage type
invalid source typ
Called CVssWriterImpl::Initialize() with:
UsageType             = %s
SourceType            = %s
AppLevel              = %s
FreezeTimeout         = %d (ms)
AlternateWriterState  = %s
IOThrottlingOnly      = %s
Calling Initialize during setup
Writer is not privileged
NULL writer name
Invalid app level %d
Cannot allocate writer instance name
Cannot allocate writer name
InstanceId for Writer %s is{%.8x-%.4x-%.4x-%.2x%.2x-%.2x%.2x%.2x%.2x%.2x%.2x}
Failure to create mutex object due to error %d.
CVssWriterImpl::DoAbort
Entering operation Abort
Abort skipped in state %d
OnAbort failed. hr = 0x%08lx
CVssWriterImpl::Subscribe
Writer is inactive during setup or safe mode
Event System is not present. Writer support is disabled. Error 0x%08lx
You must initialize the writer before other operations
bad event flags
The writer has already called the Subscribe function.
about to enter context callback
IEventSubscription::put_SubscriptionName
IEventSubscription::put_EventClassID
IEventSubscription::put_InterfaceID
IEventSubscription::put_SubscriberInterface
IEventSubscription::put_PerUser
IEventSubscription::PutSubscriberProperty
IEventSystem::Store
IEventSubscription::get_SubscriptionID
CVssWriterState::MarkStateCompleted
TornComponentsMax
CVssSidCollection::Initialize
m_SDWriters.Initialize() failed
m_SDRequestors.Initialize() failed
m_SDBoth.Initialize() failed
SetOwner
SetGroup
CVssSidCollection::IsProcessValidWriter
SYSTEM\CurrentControlSet\Services\VSS\VssAccessControl
Error on closing key with name %s. lRes == 0x%08lx
CVssRegistryValueIterator::GetCurrentValueName
CVssRegistryValueIterator::GetCurrentValueNameLen
CVssRegistryValueIterator::GetCurrentValueType
CVssMachineInformation::IsDuringSafeMode
SafeBoot option 0x%08lx
Unrecognized safe mode option %ud
ProductType
OptionValue
JTWIJTWC
base\stor\vss\modules\jetwriter\ijetwriter.cpp
ESENT ERROR {%.8x-%.4x-%.4x-%.2x%.2x-%.2x%.2x%.2x%.2x%.2x%.2x} %s: %ld
Function
EERROR_BAD_FORMAT
GetLastError( )
SOFTWARE\MICROSOFT\WINDOWS NT\CurrentVersion\ASR\RestoreSession
E_FAIL
\\?\GLOBALROOT%s
\Device\VolMgrControl
hDisk
InstanceCount
GetDriveTypeByHandle
::NtQueryVolumeInformationFile( hDisk, &IoStatusBlock, &DeviceInfo,sizeof(DeviceInfo), FileFsDeviceInformation)
puiDriveTypeOut
?Tf^a
*ppwszAttributeData
hError
ActivityStoppedAutomatically
VSS_BackupComponents_OpResult
CVssBackupComponents
State
SessionId
SnapshotSetId
StateFlags
Context
HrCoordInit
CVssFunctionTracer
FunctionName
FileAlias
FileName
LineNumber
CurrentContexts
HResult
ExtraParam1
VSS_BackupComponents_OpResult
CVssBackupComponents
State
SessionId
SnapshotSetId
StateFlags
Context
HrCoordInit
CVssFunctionTracer
FunctionName
FileAlias
FileName
LineNumber
CurrentContexts
HResult
ExtraParam1
VSS_BackupComponents_OpResult
CVssBackupComponents
State
SessionId
SnapshotSetId
StateFlags
Context
HrCoordInit
CVssFunctionTracer
FunctionName
FileAlias
FileName
LineNumber
CurrentContexts
HResult
ExtraParam1
ExtraParam2
ExtraParam3
ActivityError
PartA_PrivTags
wilActivity
hresult
fileName
lineNumber
module
failureType
message
threadId
callContext
originatingContextId
originatingContextName
originatingContextMessage
currentContextId
currentContextName
currentContextMessage
failureId
failureCount
function
ActivityError
PartA_PrivTags
wilActivity
hresult
fileName
lineNumber
module
failureType
message
threadId
callContext
originatingContextId
originatingContextName
originatingContextMessage
currentContextId
currentContextName
currentContextMessage
CVssRequestorActivity
PartA_PrivTags
wilActivity
hresult
threadId
phase
CVssBackupComponents
State
SessionId
SnapshotSetId
StateFlags
Context
HrCoordInit
CVssRequestorActivity
PartA_PrivTags
PartA_PrivTags
wilActivity
hresult
fileName
lineNumber
module
failureType
message
threadId
callContext
originatingContextId
originatingContextName
originatingContextMessage
currentContextId
currentContextName
currentContextMessage
phase
CVssBackupComponents
State
SessionId
SnapshotSetId
StateFlags
Context
HrCoordInit
WriterMetadata
IdInstance
IdWriter
InstanceName
WriterName
BackupSchema
ExpressWriter
WriterHasRestorePlan
Usage
Source
RestoreMethod
WriterRestore
Reboot
MajorVersion
MinorVersion
TotalComponents
State
HrWriterFailure
HrApplication
WriterMetadata
IdInstance
IdWriter
InstanceName
WriterName
BackupSchema
ExpressWriter
WriterHasRestorePlan
Usage
Source
RestoreMethod
WriterRestore
Reboot
MajorVersion
MinorVersion
TotalComponents
State
HrWriterFailure
HrApplication
ComponentTypes
HComponentsPerType
VSS_BackupComponents_OpResult
CVssBackupComponents
State
SessionId
SnapshotSetId
StateFlags
Context
HrCoordInit
CVssFunctionTracer
FunctionName
FileAlias
FileName
LineNumber
CurrentContexts
HResult
CVssRequestorActivity
PartA_PrivTags
wilActivity
threadId
CVssRequestorActivity
PartA_PrivTags
wilActivity
hresult
threadId
CVssRequestorActivity
PartA_PrivTags
PartA_PrivTags
wilActivity
hresult
fileName
lineNumber
module
failureType
message
threadId
callContext
originatingContextId
originatingContextName
originatingContextMessage
currentContextId
currentContextName
currentContextMessage
FallbackError
PartA_PrivTags
wilResult
hresult
fileName
lineNumber
module
failureType
message
threadId
callContext
originatingContextId
originatingContextName
originatingContextMessage
currentContextId
currentContextName
currentContextMessage
failureId
failureCount
function
FallbackError
PartA_PrivTags
wilResult
hresult
fileName
lineNumber
module
failureType
message
threadId
callContext
originatingContextId
originatingContextName
originatingContextMessage
currentContextId
currentContextName
currentContextMessage
Microsoft.Windows.Storage.VSSTraceLogProvider
API-MS-Win-Core-LocalRegistry-L1-1-0.dll
RegDeleteKeyExW
advapi32.dll
RegDeleteKeyW
CLSID
ForceRemove
NoRemove
Delete
TYPELIB
HKEY_CLASSES_ROOT
HKEY_CURRENT_USER
HKEY_LOCAL_MACHINE
HKEY_USERS
HKEY_PERFORMANCE_DATA
HKEY_DYN_DATA
HKEY_CURRENT_CONFIG
Module
LocalServer32
REGISTRY
generic
unknown error
iostream
iostream stream error
system
Arithmetic overflow.  wAlignmentOffset = %hu was larger than m_wAlignmentBytes = %hu
CVssIOCTLChannel::ApplyAlignment
Arithmetic overflow. m_wAlignmentBytes = %hu too large
Opening a handle to %s (access = 0x%08lx, share = 0x%08lx)
CVssIOCTLChannel::Open
Error: the buffer is too small to fit %s (%d < %d)
Error: the object name %s does terminate with a backslash
StringCchCopyN
Could not open the object '%s'. [0x%08lx]
The object '%s'. was opened under the device handle 0x%08lx
GetVolumeNameForVolumeMountPoint(%s,...) failed with error code 0x%08lx
\\?\UNC\
VssAPI::IsVolumeSnapshotted
IsVolumeSnapshottedInternal
FAILED as insufficient privileges to call shim
FAILED as invalid parameters
OpenSCManager(NULL,NULL,SC_MANAGER_CONNECT)
 OpenService (shSCManager, '%s', SERVICE_QUERY_STATUS)
QueryServiceStatus (shSCService, &sSStat)
Coordinator
CoCreateInstance(CLSID_VSSCoordinator)
RegOpenKeyExW(%ld,%s\%s,...) = ERROR_FILE_NOT_FOUND
Encountering a non-fixed volume (%s) - %ud
Volume (%s) not supported for snapshots 0x%08lx
GetProviderMgmtInterfaceInternal
this function can only be called by an admin
Software Provider
GetProviderMgmtInterface
ShouldBlockRevertInternal
method not implemented in client SKU
Invalid name for key under WritersBlockingRevert
CreateVssBackupComponents
InitializeForBackup
DisableWriterClasses
GatherWriterMetadata
QueryStatus
QueryStatus OUT param
Application %s has registered to block volumes.
Invalid type for value under ApplicationsBlockingRevert
Application %s has successfully blocked volume %s from revert using value %s.
Value %s identified as volume name or mount point, but does not match the queried volume.
Key value element %s does not match the volume name and is not a mount point.
CheckFilesOnVolume
GetWriterMetadataCount
GetWriterMetadata
GetIdentity
GetFileCounts
GetComponent
GetComponentInfo
GetFile
GetPath
GetVolumePathName
Volume reported for this component is invalid. We assume that component is not torn.
StringCchCopy
GetDatabaseFile
GetDatabaseLogFile
GetVolumeNameForVolumeMountPoint
GetVolumeName
NormalizeUNCPath
pwszOriginalUNCPath=%s bNormalizeToFQDN=%d
Server name %s normalization failed
\\%s\%s\
StringCchPrintf(%p, %d, %s, %s) failed
GetRootAndLogicalPrefixPathsInternal
NULL required input parameter.
GetVolumePathName is fail on the path %s, winerror 0x%08lx.
Expand mapped drive letter of share failed
GetVolumeNameForVolumeMountPoint is now failing on the volume, winerror 0x%08lx. 
Memory allocation failed.
ResolveDfsTargets
GetVolumePathName fail on DfsTarget: %s, winerror 0x%08lx.
NormalizeUNCPath for DFS RootPath
Invalid uLogicalPrefixPathSize length
CoTaskMemAlloc for uLogicalPrefixPathSize
NormalizeUNCPath for non-DFS RootPath
invalid string position
string too long
CVssIOCTLChannel::Unpack
Output buffer overflow. Trying to read non-existent arguments. m_pbOutputBuffer = %p, m_dwOutputCurrentOffset = %lu, dwSize = %lu, m_dwOutputCurrentOffset = %lu
IOCTL Unpack overflow
Output buffer overflow. Reading bad arguments. dwSize = %lu
Arithmetic overflow. m_dwOutputCurrentOffset = %lu or dwSize = %lu too large.
Providers
SYSTEM\CurrentControlSet\Services\VSS\Settings
SYSTEM\CurrentControlSet\Services\VSS\Settings\WritersBlockingRevert
SYSTEM\CurrentControlSet\Services\VSS
SYSTEM\CurrentControlSet\Services\VSS\Settings\ApplicationsBlockingRevert
TornComponentsBlockRevert
InitializeCriticalSectionAndSpinCount(&m_cs, 0x80000400)
Initialization failed
Unexpected error
RaiseFailFastException
RtlDllShutdownInProgress
SNAPSHOT_SET_DESCRIPTION
snapshotSetId
context
NULL output pointer
The client process is not running under an administrator account or does not have backup privilege enabled
CreateVssExamineWriterMetadataInternal
Cannot allocate CVssExamineWriterMetadataLite
XML passed to CreateVssExamineWriterMetadata was invalid
Cannot allocate CVssExamineWriterMetadata
CreateVssSnapshotSetDescription
NULL output parameter.
Missing root element
Can't allocate snapshot set description.
LoadVssSnapshotSetDescription
Cannot allocate snapshot set description.
CreateVssExpressWriterInternal
IVssExpressWriter
{00000000-0000-0000-0000-00000000-0000}
Caller has insufficient privileges for creating express writer
Local\SM0:%lu:%lu:%hs
NP6:+
CVssJetWriter::Initialize
CreateThread failed with error %d
CVssJetWriter::OnIdentify
CVssJetWriter::OnPrepareBackupBegin
CVssJetWriter::OnPrepareBackupEnd
CVssJetWriter::OnPrepareSnapshotBegin
CVssJetWriter::OnPrepareSnapshotEnd
CVssJetWriter::OnFreezeBegin
CVssJetWriter::OnFreezeEnd
CVssJetWriter::OnThawBegin
CVssJetWriter::OnThawEnd
CVssJetWriter::OnPostSnapshot
CVssJetWriter::OnAbortBegin
CVssJetWriter::OnAbortEnd
CVssJetWriter::OnBackupCompleteBegin
CVssJetWriter::OnBackupCompleteEnd
CVssJetWriter::OnPreRestoreBegin
CVssJetWriter::OnPreRestoreEnd
CVssJetWriter::OnPostRestoreBegin
CVssJetWriter::OnPostRestoreEnd
CVssJetWriter::GetCurrentVolumeArray
CVssJetWriter::GetCurrentVolumeCount
CVssJetWriter::GetSnapshotDeviceName
CVssJetWriter::GetCurrentSnapshotSetId
CVssJetWriter::GetContext
CVssJetWriter::GetCurrentLevel
CVssJetWriter::IsPathAffected
CVssJetWriter::IsBootableSystemStateBackedUp
CVssJetWriter::AreComponentsSelected
CVssJetWriter::GetBackupType
CVssJetWriter::GetRestoreType
CVssJetWriter::IsPartialFileSupportEnabled
CVssJetWriter::SetWriterFailure
VssReallocString
CVssAutoCoString::Reallocate
CVssAutoCoString::Append
StringCchCatW(m_pwsz, cchNewLength + 1, pwsz)
COM Call %S failed [0x%08lx]
0x%08lx, %s
0x%08lx
Tracing started or updated. PID=%d, CommandLine=[%s], UserName=[%s]. SQN=[%d -> %d]
TRACING_STARTED
CVssFunctionTracer::UpdateLocalIsTracingEnabledFlag
StaticTrace failed due to out of memory condition
STATIC
DebugTrace failed due to out of memory condition
TraceInternalWithFormat failed due to out of memory condition
internal tracing buffer - out of memory
CVssFunctionTracer::GetCurrentContexts
Name: %s\%s, SID:%s
TRACE
TRACE_BINARY
THROW
re-throwing %#x
HRESULT 0x%08lx rethrown by %s
CVssFunctionTracer::ReThrow
Out of memory detected in function %s
ERROR_DISK_FULL detected in function %s
VSS_E_SNAPSHOT_SET_IN_PROGRESS detected in function %s
Unexpected error in routine %s.  hr = 0x%08lx
Out of memory detected in function %s - %s
ERROR_DISK_FULL detected in function %s - %s
Unexpected error in routine %s - %s. hr = 0x%08lx
Unexpected error in routine %s. hr = 0x%08lx
Out of memory detected. %s. Provider ID = {%.8x-%.4x-%.4x-%.2x%.2x-%.2x%.2x%.2x%.2x%.2x%.2x}
Invalid argument detected. %s. Provider ID = {%.8x-%.4x-%.4x-%.2x%.2x-%.2x%.2x%.2x%.2x%.2x%.2x}
Provider veto detected. %s. Provider ID = {%.8x-%.4x-%.4x-%.2x%.2x-%.2x%.2x%.2x%.2x%.2x%.2x}
Volume not supported. %s. Provider ID = {%.8x-%.4x-%.4x-%.2x%.2x-%.2x%.2x%.2x%.2x%.2x%.2x}
Bad state. %s. Provider ID = {%.8x-%.4x-%.4x-%.2x%.2x-%.2x%.2x%.2x%.2x%.2x%.2x}
Snapshot id not found. %s. Provider ID = {%.8x-%.4x-%.4x-%.2x%.2x-%.2x%.2x%.2x%.2x%.2x%.2x}
Volume not supported by provider. %s. Provider ID = {%.8x-%.4x-%.4x-%.2x%.2x-%.2x%.2x%.2x%.2x%.2x%.2x}
Cannot revert DiskID. %s. Provider ID = {%.8x-%.4x-%.4x-%.2x%.2x-%.2x%.2x%.2x%.2x%.2x%.2x}
Insufficient storage. %s. Provider ID = {%.8x-%.4x-%.4x-%.2x%.2x-%.2x%.2x%.2x%.2x%.2x%.2x}
Snapshot set creation is already in progress. %s. Provider ID = {%.8x-%.4x-%.4x-%.2x%.2x-%.2x%.2x%.2x%.2x%.2x%.2x}
Unexpected error calling a provider routine: %s  [hr = 0x%08lx] Provider ID = {%.8x-%.4x-%.4x-%.2x%.2x-%.2x%.2x%.2x%.2x%.2x%.2x}
ERROR_DISK_FULL detected. %s
Out of memory detected. %s.
Invalid device when calling a provider routine: %s
Timeout error calling a provider routine: %s.
Unexpected error calling a provider routine: %s  [hr = 0x%08lx] 
%s event failed at one writer. hr = 0x%08lx
CVssFunctionTracer::TranslateWriterReturnCode
WARNING: %s [hr = 0x%08lx]
RegisterEventSource failed, %#x
CVssFunctionTracer::SafeLogEvent
Too many substitution strings, %d
ReportEvent failed, %#x
CVssFunctionTracer::LogError
- Code: %8ls%08lu- Call: %8ls%08lu- PID:  %08lu- TID:  %08lu- CMD:  %-*ls- User: %-*ls
Current context: '%s'
Error on RegisterEventSourceW 0x%08lx
Error on ReportEventW 0x%08lx
Error on DeregisterEventSource 0x%08lx
INFO: %s [hr = 0x%08lx]
%s, 0x%08lx, %s
%s, 0x%08lx
HRESULT exception caught: hr: 0x%x
Unexpected COM exception caught: hr: 0x%x
COM error caught: hr: 0x%x
bad_alloc STL exception caught: hr: 0x%x
Unexpected STL exception caught: %s
WRITER_METADATA
x-schema:#VssWriterMetadataInfo
IDENTIFICATION
writerId
instanceId
instanceName
friendlyName
usage
dataSource
majorVersion
minorVersion
BACKUP_LOCATIONS
INCLUDE_FILES
EXCLUDE_FILES
EXCLUDE_FILES_FROM_SNAPSHOT
DATABASE
FILE_GROUP
RESTORE_METHOD
method
service
userProcedure
writerRestore
rebootRequired
ALTERNATE_LOCATION_MAPPING
logicalPath
componentName
caption
restoreMetadata
notifyOnBackupComplete
selectable
selectableForRestore
DATABASE_FILES
DATABASE_LOGFILES
FILE_LIST
DEPENDENCY
componentFlags
filespecBackupType
onWriterId
onLogicalPath
onComponentName
filespec
recursive
alternatePath
backupSchema
CVssExamineWriterMetadata::LoadDocument
BUEWXMLC
base\stor\vss\modules\backupext\vsxml\vs_wmxml.cxx
CVssExamineWriterMetadata::Initialize
CVssExamineWriterMetadata::GetIdentity
CVssExamineWriterMetadata::GetFileCounts
IXMLDOMNode::get_nodeType
IXMLDOMNode::get_nodeName
CVssExamineWriterMetadata::GetFileType
BACKUP_LOCATIONS element was not found.
%s element was not found
Can't create CVssWMFiledesc due to allocation failure.
CVssExamineWriterMetadata::GetIncludeFile
CVssExamineWriterMetadata::GetExcludeFile
CVssExamineWriterMetadata::GetComponent
BACKUP_LOCATIONS element was not found
Component was not found
Component %d was not found
Cannot allocate CVssWMComponent due to allocation failure.
CVssExamineWriterMetadata::GetRestoreMethod
CVssExamineWriterMetadata::GetAlternateLocationMapping
NULL output parameter
Cannot find RESTORE_METHOD element
Cannot find ALTERNATE_LOCATION_MAPPING element
Cannot create CVssAlternateLocationMapping due to allocation failure.
CVssExamineWriterMetadata::GetBackupSchema
NULL out parameter
CVssExamineWriterMetadata::GetVersion
CVssExamineWriterMetadata::GetExcludeFromSnapshotCount
CVssExamineWriterMetadata::GetExcludeFromSnapshotFile
CVssExamineWriterMetadata::GetDocument
CVssExamineWriterMetadata::SaveAsXML
CVssExamineWriterMetadata::LoadFromXML
Required input parameter is NULL.
CVssExamineWriterMetadata::QueryInterface
CVssExamineWriterMetadata::GetIdentityEx
CVssExamineWriterMetadata failed. 0x%08lx
CVssWMComponent::GetComponentInfo
Failed to create VSS_COMPONENTINFO
CVssWMComponent::FreeComponentInfo
CVssWMComponent::GetFile
CVssWMComponent::GetDatabaseFile
CVssWMComponent::GetDatabaseLogFile
CVssWMComponent::GetDependency
Cannot find %s element
Cannot find element %s.
Cannot create CVssWMDependency due to allocation failure.
CVssWMComponent::GetComponentFile
Cannot create CVssWMFiledesc due to allocation failure.
CVssWMFiledesc::GetPath
CVssWMFiledesc::GetFilespec
CVssWMFiledesc::GetRecursive
CVssWMFiledesc::GetAlternateLocation
CVssWMFiledesc::GetBackupTypeMask
CVssWMDependency::GetWriterId
CVssWMDependency::GetLogicalPath
CVssWMDependency::GetComponentName
CVssCreateWriterMetadata::Initialize
NULL string input parameter
CVssCreateWriterMetadata::AddIncludeFiles
CVssCreateWriterMetadata::AddExcludeFiles
CVssCreateWriterMetadata::AddExcludeFilesFromSnapshot
CVssCreateWriterMetadata::AddComponent
Component %s already exists
CVssCreateWriterMetadata::AddDatabaseFiles
CVssCreateWriterMetadata::CreateComponentFiles
Invalid element type
BackupLocations element is missing
Component %s::%s was not created
CVssCreateWriterMetadata::AddDatabaseLogFiles
CVssCreateWriterMetadata::AddFilesToFileGroup
CVssCreateWriterMetadata::SetRestoreMethod
CVssCreateWriterMetadata::AddAlternateLocationMapping
RESTORE_METHOD element is not defined.
CVssCreateWriterMetadata::AddComponentDependency
Document contains no components
Component %s\%s was not found
CVssCreateWriterMetadata::SetBackupSchema
CVssCreateWriterMetadata::GetDocument
CVssCreateWriterMetadata::SaveAsXML
CVssCreateWriterMetadata::ConvertMappedNetworkDrivesToUNC
empty document
RANK: new path is %s
RANK: new alt path is %s
CVssCreateWriterMetadata::ConvertMappedDrive
NULL required output parameter.
Input path is not a drive letter
StringCchPrintf
Cannot alloc path
Cannot realloc path
The input path has local drive in it - nothing to convert
Could no map drive %s. WNetGetUniversalName returned %lu
Cannot alloc output
CVssCreateWriterMetadata::QueryInterface
CVssExamineWriterMetadataLite::LoadDocument
CVssExamineWriterMetadataLite::Initialize
CVssExamineWriterMetadataLite::GetIdentity
CVssExamineWriterMetadataLite::GetFileCounts
CVssExamineWriterMetadataLite::GetFileType
CVssExamineWriterMetadataLite::GetIncludeFile
CVssExamineWriterMetadataLite::GetExcludeFile
CVssExamineWriterMetadataLite::GetComponent
CVssExamineWriterMetadataLite::GetRestoreMethod
CVssExamineWriterMetadataLite::GetAlternateLocationMapping
CVssExamineWriterMetadataLite::GetBackupSchema
CVssExamineWriterMetadataLite::GetVersion
CVssExamineWriterMetadataLite::GetExcludeFromSnapshotCount
CVssExamineWriterMetadataLite::GetExcludeFromSnapshotFile
CVssExamineWriterMetadataLite::GetDocument
CVssExamineWriterMetadataLite::SaveAsXML
CVssExamineWriterMetadataLite::LoadFromXML
CVssExamineWriterMetadataLite::QueryInterface
CVssExamineWriterMetadataLite::GetIdentityEx
CVssWMComponentLite::GetComponentInfo
CVssWMComponentLite::FreeComponentInfo
CVssWMComponentLite::GetFile
CVssWMComponentLite::GetDatabaseFile
CVssWMComponentLite::GetDatabaseLogFile
CVssWMComponentLite::GetDependency
CVssWMComponentLite::GetComponentFile
CVssWMFiledescLite::GetPath
CVssWMFiledesc::GetFilespecLite
CVssWMFiledescLite::GetFilespec
CVssWMFiledescLite::GetRecursive
CVssWMFiledescLite::GetAlternateLocation
CVssWMFiledescLite::GetBackupTypeMask
CVssWMDependencyLite::GetWriterId
CVssWMDependencyLite::GetLogicalPath
CVssWMDependencyLite::GetComponentName
BOOTABLE_SYSTEM_STATE
SYSTEM_SERVICE
USER_DATA
OTHER
TRANSACTION_DB
NONTRANSACTIONAL_DB
database
filegroup
never
always
ifReplaceFails
RESTORE_IF_NONE_THERE
RESTORE_IF_CAN_BE_REPLACED
STOP_RESTART_SERVICE
RESTORE_TO_ALTERNATE_LOCATION
REPLACE_AT_REBOOT
REPLACE_AT_REBOOT_IF_CANNOT_REPLACE
RESTORE_STOP_START_SERVICE
CUSTOM
differential
incremental
other
byCopy
import
failed
original
alternate
directed
originalLocation
Atapi
Fibre
iScsi
Virtual
FileBackedVirtual
Spaces
FCPH3
partial
Value %s is neither yes nor no.
CVssMetadataHelper::ConvertToBoolean
BUEHELPC
base\stor\vss\modules\backupext\vsxml\helper.cxx
Value %s is not a valid guid.
CVssMetadataHelper::ConvertToVSS_ID
Invalid usage type
CVssMetadataHelper::WszFromUsageType
The string %s is not a valid usage type
CVssMetadataHelper::ConvertToUsageType
Invalid data source type
CVssMetadataHelper::WszFromSourceType
The string %s is not a valid source type.
CVssMetadataHelper::ConvertToSourceType
Invalid component type
CVssMetadataHelper::WszFromComponentType
The string %s is not a valid component type
CVssMetadataHelper::ConvertToComponentType
Invalid method type %d
CVssMetadataHelper::WszFromRestoreMethod
The string %s is not a valid restore method.
CVssMetadataHelper::ConvertToRestoreMethod
Invalid writerRestore type %d
CVssMetadataHelper::WszFromWriterRestore
CVssMetadataHelper::ConvertToWriterRestore
Invalid backupType %d
CVssMetadataHelper::WszFromBackupType
The string %s is not a valid backup type.
CVssMetadataHelper::ConvertToBackupType
Invalid restore type %d
CVssMetadataHelper::WszFromRestoreType
The string %s is not a valid restore type
CVssMetadataHelper::ConvertToRestoreType
Invalid restoreTarget %d
CVssMetadataHelper::WszFromRestoreTarget
The string %s is not a valid restoreTarget.
CVssMetadataHelper::ConvertToRestoreTarget
CVssMetadataHelper::WszFromFileRestoreStatus
The string %s is not a valid file restore status.
CVssMetadataHelper::ConvertToFileRestoreStatus
Invalid bus type %d
CVssMetadataHelper::WszFromBusType
The string %s is not a valid storage bus type.
CVssMetadataHelper::ConvertToStorageBusType
Invalid interconnect address type %d
CVssMetadataHelper::WszFromInterconnectAddressType
The string %s is not a valid interconnect address type.
CVssMetadataHelper::ConvertToInterconnectAddressType
Invalid rollforward type %d
CVssMetadataHelper::WszFromRollforwardType
The string %s is not a valid rollforward type.
CVssMetadataHelper::ConvertToRollforwardType
CVssMetadataHelper::GetStringAttributeValue
CVssMetadataHelper::GetByteArrayAttributeValue
CVssMetadataHelper::GetVSS_IDAttributeValue
CVssMetadataHelper::GetBooleanAttributeValue
LCMapStringA
CVssMetadataHelper::get_ansi_stringValue
Cannot allocate ANSI string
Failed to allocate byte array.
CVssMetadataHelper::get_byteArrayValue
An empty string is not a valid number
CVssMetadataHelper::get_dwordValue
String %s is not a valid number
CVssMetadataHelper::MissingElement
The %s element is missing.
CVssMetadataHelper::MissingAttribute
The %s attribute is missing.
CVssMetadataHelper::GetElementCount
CVssMetadataHelperLite::GetStringAttributeValue
CVssMetadataHelperLite::GetVSS_IDAttributeValue
CVssMetadataHelperLite::GetBooleanAttributeValue
CVssMetadataHelperLite::get_ansi_stringValue
CVssMetadataHelperLite::get_dwordValue
CVssMetadataHelperLite::GetElementCount
SNAPSHOT_DESCRIPTION
LUN_MAPPING
LUN_INFORMATION
SOURCE_LUN
DESTINATION_LUN
INTERCONNECT_DESCRIPTION
DISK_EXTENT
originalCount
description
metadata
snapshotId
providerId
snapshotAttributes
originatingMachine
isDynamicVolume
serviceMachine
originalVolumeName
timestamp
deviceName
exposedPath
exposedName
startingOffset
extentLength
deviceType
deviceTypeModifier
commandQueueing
busType
vendorId
productId
productRevision
serialNumber
diskSignature
lunID
interconnectAddressType
interconnectAddress
deviceIdentification
sourceDevice
mappedSnapshotId
mappedVolumeName
mappedPathFromRoot
CVssSnapshotSetDescription::LoadFromXML
BUESNAPC
base\stor\vss\modules\backupext\vsxml\snapshot.cxx
Load of snapshot set description document failed
CVssSnapshotDescription::GetProviderId
The provider doesn't exist in the set
CVssSnapshotSetDescription::SaveAsXML
CVssSnapshotSetDescription::GetToplevelNode
CVssSnapshotSetDescription::GetSnapshotSetId
CVssSnapshotSetDescription::GetDescription
CVssSnapshotSetDescription::SetDescription
CVssSnapshotSetDescription::GetMetadata
CVssSnapshotSetDescription::SetMetadata
CVssSnapshotSetDescription::GetContext
CVssSnapshotSetDescription::SetOriginalSnapshotCount
CVssSnapshotSetDescription::GetOriginalSnapshotCount
CVssSnapshotSetDescription::GetSnapshotCount
GetElementCount
CVssSnapshotSetDescription::GetSnapshotDescription
NULL output paramter.
Cannot find the %d snapshot description.
Cannot find the %d snaphot description.
Cannot allocate snapshot description.
CVssSnapshotSetDescription::DeleteSnapshotDescription
CVssSnapshotSetDescription::FindSnapshotHelper
Cannot find the snaphot description for snapshot{%.8x-%.4x-%.4x-%.2x%.2x-%.2x%.2x%.2x%.2x%.2x%.2x}.
CVssSnapshotSetDescription::FindSnapshotDescription
CVssSnapshotSetDescription::AddSnapshotDescription
CVssSnapshotDescription::GetSnapshotId
CVssSnapshotDescription::SetProviderId
CVssSnapshotDescription::GetTimestamp
CVssSnapshotDescription::SetTimestamp
CVssSnapshotDescription::GetAttributes
CVssSnapshotDescription::SetAttributes
CVssSnapshotDescription::GetOrigin
CVssSnapshotDescription::SetOrigin
CVssSnapshotDescription::IsDynamicVolume
CVssSnapshotDescription::SetIsDynamicVolume
CVssSnapshotDescription::GetServiceMachine
CVssSnapshotDescription::SetServiceMachine
CVssSnapshotDescription::GetDeviceName
CVssSnapshotDescription::SetDeviceName
CVssSnapshotDescription::GetExposure
CVssSnapshotDescription::SetExposure
CVssSnapshotDescription::GetMappedSnapshotId
CVssSnapshotDescription::SetMappedSnapshotId
CVssSnapshotDescription::GetMappedOrigin
CVssSnapshotDescription::SetMappedOrigin
CVssSnapshotDescription::GetMappedOriginPath
CVssSnapshotDescription::SetMappedOriginPath
CVssSnapshotDescription::GetLunCount
CVssSnapshotDescription::AddLunMapping
CVssSnapshotDescription::GetLunMapping
Cannot find the %d lun mapping.
Cannot allocate lun mapping.
CVssLunMapping::AddDiskExtent
CVssLunMapping::GetDiskExtentCount
CVssLunMapping::GetDiskExtent
Cannot find the %d disk extent.
CVssLunMapping::GetLunInformation
Cannot find the %s.
Cannot allocate lun information.
CVssLunMapping::GetSourceDevice
CVssLunMapping::SetSourceDevice
CVssLunMapping::GetSourceLun
CVssLunMapping::GetDestinationLun
CVssLunMapping::GetLunId
CVssLunMapping::SetLunId
CVssLunInformation::SetLunBasicType
CVssLunInformation::GetLunBasicType
Bad Device type.
Bad Device type modifier.
CVssLunInformation::GetDiskSignature
CVssLunInformation::SetDiskSignature
CVssLunInformation::AddInterconnectAddress
NULL Required input parameter.
CVssLunInformation::GetInterconnectAddressCount
CVssLunInformation::GetInterconnectAddress
Cannot find the %d interconnect address.
CVssLunInformation::SetStorageDeviceIdDescriptor
NULL required input parameter
CVssLunInformation::GetStorageDeviceIdDescriptor
BuildDocumentFromString
XML document is too long
First StringCchCat failed
Second StringCchCat failed
Third StringCchCat failed
BuildWriterDocumentFromString
BuildExpressWriterDocumentFromString
Error on initializing the Id 0x%08lx
CVssID::Initialize
::WaitForSingleObject(semaphore, INFINITE)
::WaitForSingleObject(semaphore, INFINITE) [0x%08lx]
onecore\internal\sdk\inc\wil\opensource\wil\result.h
CInternalWriterData::CComponentIdentifier::CComponentIdentifier
INCCXMLH
base\stor\vss\inc\vs_cmxml.hxx
out of memory
CInternalWriterData::FindRestoreComponent
CInternalWriterData::RemoveRestoreComponent
CInternalWriterData::AddRestoreComponent
component already selected for restore!
could not allocate space for metadata
couldn't allocate space for instance id
WRITER_COMPONENTS
BACKUP_METADATA
RESTORE_METADATA
PARTIAL_FILE
DIRECTED_TARGET
RESTORE_TARGET
RESTORE_SUBCOMPONENT
COMPONENT
DIFFERENCED_FILE
bootableSystemStateBackup
componentType
backupSucceeded
ranges
selectComponents
backupType
restoreType
partialFileSupport
backupOptions
restoreOptions
backupStamp
previousBackupStamp
selectedForRestore
additionalRestores
restoreTarget
preRestoreFailureMsg
postRestoreFailureMsg
filesRestored
repair
targetPath
targetFilespec
sourceRanges
targetRanges
lastModifyTimeLow
lastModifyTimeHigh
lastModifyLSN
restoreInstanceId
authRestore
rollForwardType
rollForwardPoint
restoreName
prepareForBackupFailureMsg
PostSnapshotFailureMsg
FailureMsg
ErrorCode
ApplicationErrorCode
CInternalWriterData::SetComponents
ran out of memory
XML data from writer is not valid:{%.8x-%.4x-%.4x-%.2x%.2x-%.2x%.2x%.2x%.2x%.2x%.2x}
CVssComponent::GetLogicalPath
CVssComponent::GetComponentType
CVssComponent::GetComponentName
CVssComponent::GetBackupSucceeded
CVssComponent::GetAlternateLocationMappingCount
CVssComponent::GetPartialFileCount
CVssComponent::GetNewTargetCount
CVssComponent::GetDirectedTargetCount
CVssComponent::GetRestoreSubcomponentCount
CVssComponent::GetFiledescElement
Cannot find %s element.
Couldn't create CVssWMFiledesc due to allocation failure.
CVssComponent::GetAlternateLocationMapping
CVssComponent::GetNewTarget
CVssComponent::GetPartialFile
Cannot find PARTIAL_FILE element.
CVssComponent::GetDirectedTarget
Cannot find DIRECTED_TARGET element.
CVssComponent::GetRestoreSubcomponent
Cannot find RESTORE_SUBCOMPONENT element.
CVssComponent::SetMetadata
Required input paramter is NULL.
Components document is not writeable
CVssComponent::SetBackupMetadata
CVssComponent::SetRestoreMetadata
CVssComponent::GetMetadata
CVssComponent::GetBackupMetadata
CVssComponent::GetRestoreMetadata
CVssComponent::GetPreRestoreFailureMsg
CVssComponent::GetPostRestoreFailureMsg
CVssComponent::GetBackupOptions
CVssComponent::GetRestoreOptions
CVssComponent::GetBackupStamp
CVssComponent::GetPreviousBackupStamp
CVssComponent::IsSelectedForRestore
CVssComponent::GetAdditionalRestores
CVssComponent::AddPartialFile
Cannot be called during restore
Must be called by writer
CVssComponent::AddDirectedTarget
Must be called by writer.
IVssComponent::GetRestoreTarget
Restore target must be Directed.
CVssComponent::SetRestoreTarget
Can only call this function from the writer
Can only be called during restore
CVssComponent::GetRestoreTarget
Must be called during restore.
CVssComponent::SetPreRestoreFailureMsg
Cannot call this function in the requestor.
CVssComponent::SetPostRestoreFailureMsg
CVssComponent::SetBackupStamp
Can only call this function from the writer.
Can only be called during backup.
CVssComponent::GetFileRestoreStatus
CVssComponent::AddDifferencedFilesByLastModifyTime
CVssComponent::AddDifferencedFilesByLastModifyLSN
CVssComponent::GetDifferencedFilesCount
CVssComponent::GetDifferencedFile
Cannot find DIFFERENCED_FILE element.
Invalid parameter specified
CVssComponent::AddDifferencedFiles
CVssComponent::SetPrepareForBackupFailureMsg
Cannot be called during restore.
CVssComponent::SetPostSnapshotFailureMsg
Must be called during backup.
CVssComponent::GetPrepareForBackupFailureMsg
CVssComponent::GetPostSnapshotFailureMsg
CVssComponent::GetAuthoritativeRestore
CVssComponent::GetRollForward
CVssComponent::GetRestoreName
CVssComponent::SetFailure
CVssComponent::SetFailure(%d,%d,%s,%d)
CVssComponent::GetFailure
CVssComponent::GetFailure(%d,%d,%s,%d)
Invalid input parameters.
CVssComponent::GetFailure could not find "%s" attribute.
CVssComponent::QueryInterface
CVssWriterComponents::Initialize
CVssWriterComponents::GetWriterInfo
CVssWriterComponents::GetComponentCount
CVssWriterComponents::GetComponent
Cannot find %d COMPONENT.
Cannot create CVssComponent due to allocation failure
CVssWriterComponents::IsChanged
CVssWriterComponents::SaveAsXML
CVssNULLWriterComponents::GetWriterInfo
CVssNULLWriterComponents::GetComponentCount
CVssNULLWriterComponents::GetComponent
CVssNULLWriterComponents::IsChanged
CVssNULLWriterComponents::SaveAsXML
CVssBackupComponents already initialized
CVssBackupComponents::BasicInit
CreateSemaphore(NULL, 1, 1,NULL)
CVssBackupComponents::GetSessionId
CLSIDFromString failed
Initialization function was not called
CVssBackupComponents::ValidateInitialized
Access denied
This Domain Controller has the Active Directory service stopped or is running in Directory Service Restore Mode
GetVSS_IDAttributeValue
ran out of memory allocating snapshot set id!
CVssBackupComponents::SetBackupState
Cannot call this in WinPE
Cannot call this in Safe Mode
CVssBackupComponents::SetRestoreState
CVssBackupComponents::InitializeForRestore
This Domain Controller has the Active Directory service stopped.
CVssAsrWriterRestore::InitializeForRestore
CVssBackupComponents::LoadComponentsDocument
failed to load the following XML document
Load of Backup components document failed
CVssBackupComponents::AddComponent
CVssBackupComponents::AddComponent called at the wrong time
CVssBackupComponents::GetBackupState
Invalid account called function
CVssBackupComponents::GetRestoreState
CVssBackupComponents::CoordGetBackupState
not called from coordinator
CVssBackupComponents::CoordGetRestoreState
Start-from index %u is specified (none zero), but instance-id is %p and bCreateIfNotThere is %u
CVssBackupComponents::PositionOnWriterComponents
WRITER_COMPONENTS element was not found.
Attempt to create a duplicate component.
CVssBackupComponents::FindComponent
Component was not found. %s\%s
CVssBackupComponents::GetCallbackInterface
Error querying for the IDispatch interface.  hr = 0x%08x
VSSEvent
CVssBackupComponents::SetupWriter
CVssBackupComponents::PrepareForBackup
Cannot use this method for restore
Cannot use this method if no writers are involved
Unexpected call to PrepareForBackup in state %d.
CVssBackupComponents::InternalPrepareForBackup
SetEvent(cancelEvent
CVssBackupComponents::SaveAsXML
CVssBackupComponents::InternalPrepareForBackup1
IVssWriter::PrepareForBackup (%s)
PostPrepareForBackup failed with hr = 0x%08lx
CVssBackupComponents::PostPrepareForBackup
WaitForSingleObject(cancelEvent, INFINITE) 
CVssBackupComponents::CacheAutoRecoveryInfo
Filling in ComponentFlags Cache info in ProcessAutoRecoverComponent for writer with instance id: {%.8x-%.4x-%.4x-%.2x%.2x-%.2x%.2x%.2x%.2x%.2x%.2x}.
::CreateVssExamineWriterMetadata
IVssExamineWriterMetadata::GetFileCounts
IVssExamineWriterMetadata::GetComponent
IVssWMComponent::GetComponentInfo
Component path= %s ComponentFlag = %u
Memory allocation error while adding to map
Finished Filling in ComponentFlags cache info in ProcessAutoRecoverComponent with %d elements
CVssBackupComponents::ProcessAutoRecoverComponent
CVssBackupComponents::CalculateComponentPath
Component not found!
Found component flag in ProcessAutoRecoverComponent dwComponentFlag = %d elements
Adding VSS_VOLSNAP_ATTR_AUTORECOVER to internal context
IVssBackupComponents::SetContextInternal
CVssBackupComponents::RebuildComponentData
IXMLDOMNode:cloneNode
Cloned node has no children
IXMLDOMNode::replaceChild
CVssBackupComponents::RebuildComponentDataBackup
WRITER_COMPONENTS element didn't contain any components
CVssBackupComponents::RebuildComponentDataRestore
did not find expected component %s\%s under section for writer with instance {%.8x-%.4x-%.4x-%.2x%.2x-%.2x%.2x%.2x%.2x%.2x%.2x}
The Coordinator Thread failed to start. No WaitForSingleObject in this case.
SetEvent(m_hTerminateEvent) failed with %u
Setting impersonation token
SetThreadToken
SetEvent(m_hReadyEvent) failed with %u
WaitForSingleObject(m_hTerminateEvent, INFINITE) failed with %u
CVssBackupComponents::GatherWriterStatus
CVssBackupComponents::InternalGatherWriterStatus
SetEvent(cancelEvent)
Unable to allocate writer property array
CVssBackupComponents::InternalGatherWriterStatus1
IVssWriter::RequestWriterInfo, Request Writer Status
PostGatherWriterStatus failed with hr = 0x%08lx
CVssBackupComponents::GetWriterStatusCount
NULL output pointer.
GatherWriterStatusAsync was not called or is not complete.
CVssBackupComponents::GetWriterStatus
CVssBackupComponents::GetWriterStatusEx
Invalid writer selection
CVssBackupComponents::SetBackupSucceeded
Required input string parameter is NULL.
CVssBackupComponents::SetBackupOptions
CVssBackupComponents::SetSelectedForRestoreEx
Didn't find a running writer with a matching instance id.
Didn't find a running writer that matched the selected component.
cannot restore a component to a different writer class id
The component was previously selected for restore under a different instance
CVssBackupComponents::SetRestoreOptions
CVssAsrWriterRestore::SetRestoreOptions
The ASR object is not created
CVssBackupComponents::SetFileRestoreStatus
CVssBackupComponents::SetAuthoritativeRestore
Can only be called during restore.
CVssBackupComponents::SetRollForward
missing roll-forward point
CVssBackupComponents::SetRestoreName
CVssBackupComponents::AddNewTarget
CVssBackupComponents::SetRangesFilePath
CVssBackupComponents::SetAdditionalRestores
CVssBackupComponents::SetPreviousBackupStamp
CVssBackupComponents::InternalBackupComplete
Invalid state %d for call to BackupComplete.
Can't call BackupComplete without first gathering writer metadata.
A critical piece of information is missing.  Possibly, the backup document was created with an earlier version of the infrastructure.
IVssAsync::Wait
IVssAsync::QueryStatus
DisableWriterInstances
IVssWriter::InternalBackupComplete1
IVssWriter::BackupComplete(%s)
CVssBackupComponents::PostBackupComplete
WaitForSingleObject(cancelEvent, INFINITE)
CVssBackupComponents::BackupComplete
GetWriterComponentsCount
BackupComplete called with no components selected.
CVssBackupComponents::AddAlternativeLocationMapping
CVssBackupComponents::AddRestoreSubcomponent
CVssBackupComponents::InternalPreRestore
Invalid state %d for call to PreRestore.
CVssBackupComponents::InternalPreRestore1
IVssWriter::PreRestore
CVssAsrWriterRestore::PreRestore
CVssBackupComponents::PostPreRestore
CVssBackupComponents::InternalPostRestore
Invalid state %d for call to PostRestore.
CVssBackupComponents::InternalPostRestore1
IVssWriter::InternalPostRestore
CVssAsrWriterRestore::PostRestore
CVssBackupComponents::PostPostRestore
CVssBackupComponents::PreRestore
Cannot use this method for backup
CVssBackupComponents::PostRestore
CVssBackupComponents::FindAndValidateWriterData
Instance id and instance name was not discovered in Identify pass{%.8x-%.4x-%.4x-%.2x%.2x-%.2x%.2x%.2x%.2x%.2x%.2x} %s
WriterSid: %s, TokenOwnerSid: %s
SID for instance id and instance name does not match{%.8x-%.4x-%.4x-%.2x%.2x-%.2x%.2x%.2x%.2x%.2x%.2x} %s
CVssBackupComponents::FindAndValidateWriterDataWithSid
Instance id was not discovered in Identify pass{%.8x-%.4x-%.4x-%.2x%.2x-%.2x%.2x%.2x%.2x%.2x%.2x}
SID for instance id does not match{%.8x-%.4x-%.4x-%.2x%.2x-%.2x%.2x%.2x%.2x%.2x%.2x}
CVssBackupComponents::GetContent
Improper account attempted to call function
Invalid state %d to request BACKUP_COMPONENTS content
CVssBackupComponents::CoordGetContent
not a valid sid
CVssBackupComponents::DoGetContent
A writer that isn't selected for restore is active!
Error querying IXMLDOMElement to the node. 0x%08lx
Failed calling setAttribute on filesRestored with %s
Could not get node interface
CVssBackupComponents::SetContent
CVssBackupComponents::CoordSetContent
Not called from the coordinator
sid is invalid
CVssBackupComponents::GetWriterContent
unexpected NULL pointer
CVssBackupComponents::CoordGetWriterContent
CVssBackupComponents::ExposeCurrentState
     InstanceId for Writer %s is
     wszWriterInstanceName = %s
     exposed state: %d
     exposed failure: 0x%08lx
Invalid Writer state
expose current state called after FreeWriterStatus
The server does not support transportable shadows
Invalid context 0x%08lx
Unexpected call to SetContext in state %d.
Cleared VSS_VOLSNAP_ATTR_TXF_RECOVERY from internal context due to VSS_VOLSNAP_ATTR_NO_AUTORECOVERY presence
IVssSnapshotProvider::SetContext
CVssBackupComponents::StartSnapshotSet
Unexpected call to StartSnapshotSet in state %d.
Failed to allocate BSTR.
CVssBackupComponents::GetSoftwareProviderInterface
QueryInterface(IVssProviderNotifications)
IVssProviderNotifications::OnLoad
CreateEvent(NULL, FALSE, FALSE, NULL)
CVssBackupComponents::GetCoordinatorInterface
passing impersonation token to Coord Keeper Thread
::RevertToSelf()
DuplicateToken(hToken, SecurityImpersonation, m_hInitializeToken)
CreateThread(...)
SetThreadToken(NULL, hToken) failed: %#x
SetThreadToken(NULL, hToken)
rethrowing
::WaitForSingleObject(m_hReadyEvent, INFINITE) 
Failed to create and initialize coordinator proxy
CVssBackupComponents::AddToSnapshotSet
Output parameter is NULL
Cannot call AddToSnapshotSet at this point
CVssBackupComponents::DoSnapshotSet
NULL Output parameter.
Cannot call DoSnapshotSet at this point.
CVssBackupComponents::PostDoSnapshotSet
CVssBackupComponents::DeleteSnapshots
Null output parameter
NULL SourceObjectId
Error calling Query(). [0x%08lx]
CVssBackupComponents::BreakSnapshotSet
CVssBackupComponents::BreakSnapshotSetEx
CVssBackupComponents::PreFastRecovery
CVssBackupComponents::FastRecovery
CVssBackupComponents::AddSnapshotToRecoverySet
Input snapshot ID is GUID_NULL
Input destination volume is given, but empty string
Must call InitializeForRestore for Resync operation
The client process is not running under an administrator account or does not have restore privilege enabled
Method not implemented on client SKU
Requestor inputs snapID: {%.8x-%.4x-%.4x-%.2x%.2x-%.2x%.2x%.2x%.2x%.2x%.2x}Destination: %s
CVssBackupComponents::ProcessBCD
The SNAPSHOT_SET_DESCRIPTION element is missing. In this case it is possible that the BCD is not that of a transportable snapshot.
IXMLDOMNode::get_xml
CComBSTR::Append
VssCoordinator::InitializeRecoverSet
CVssBackupComponents::RecoverSet
No address given for the ppAsync
CVssBackupComponents::ImportSnapshots
Null output parameter.
CVssBackupComponents::GetSnapshotProperties
GetSnapshot({%.8x-%.4x-%.4x-%.2x%.2x-%.2x%.2x%.2x%.2x%.2x%.2x},%p)
CVssBackupComponents::GatherWriterMetadata
Can't call this function while PrepareForBackup is in progress
Can't call this function twice on the same instance
CVssBackupComponents::GetWriterMetadataCount
Gather writer metadata is not complete
CVssBackupComponents::InternalGatherWriterMetadata
Error querying the IDispatch interface.  hr = 0x%08lx
CVssBackupComponents::InternalGatherWriterMetadata1
IVssWriter::RequestWriterInfo, GatherWriterMetadata
AddExpressWriters failed with 0x%08x
CVssBackupComponents::PostGatherWriterMetadata
Can't allocate writer instance array
Registry Writer did not respond, severe error
CVssBackupComponents::AddWriterData
Two writers with identical instance ids. %s
CreateVssExamineWriterMetadata
IVssExamineWriterMetadata::QueryInterface
IVssExamineWriterMetadata::GetIdentityEx
XML doesn't match parameters to ExposeWriterMetadata
IVssExamineWriterMetadata::GetRestoreMethod
GetBackupSchema
multiple writer with no restore plan
colliding instance names
Cannot create CInternalWriterMetadata because of allocation failure
Didn't find writer with instance id. %s
SID didn't match initialization sid
CVssBackupComponents::AddExpressWriter
StringCchPrintfW to create file name failed with 0x%08x
CreateFile(%s) failed
Application
CreateFile
ReadFile(%s) failed
Non-unicode file found (%s)
Failed AddWriterData
CVssBackupComponents::AddExpressWriters
*.xml
GetWindowsDirectory failed
%s\Vss\Writers\%s\
StringCchPrintfW to create directory failed with 0x%08x
StringCchPrintfW to create mask failed with 0x%08x
FindFirstFile(%s)
FindFirstFile(%s) returned no results
AddExpressWriter failed
Failed FindNextFile with %d
CreateFile("75DFB225-E2E4-4d39-9AC9-FFAFF65DDF06.xml")
AddExpressWriters for System subdirectory failed with 0x%08x
AddExpressWriters for Application subdirectory failed with 0x%08x
wszXMLDocument parameter is NULL
pbIsMetadateStore parameter is NULL
Class or instance IDs are not valid GUIDs
CVssBackupComponents::AddWriterDataWithSid
CVssBackupComponents::ExposeWriterMetadata
    WriterId             = 
    WriterName           = %s
CVssBackupComponents::GetWriterMetadata
CVssBackupComponents::GetWriterMetadataEx
iWriter %d > # of writers(%d)
Cannot create CVssExamineWriterMetadata due to allocation failure.
Metadata supplied by writer {%.8x-%.4x-%.4x-%.2x%.2x-%.2x%.2x%.2x%.2x%.2x%.2x} is invalid.
CVssBackupComponents::FreeWriterMetadata
CVssBackupComponents::FreeWriterComponents
CVssBackupComponents::GetWriterComponentsCount
CVssBackupComponents::GetWriterComponents
Couldn't find %d WRITER_COMPONENT.
Cannot create CVssWriterComponents due to allocation failure.
CVssBackupComponents::IsVolumeSupported
CVssBackupComponents::AddWriterClass
Can't allocate writer class array
CVssBackupComponents::DisableWriterClasses
An invalid combination of arguments was specified
CVssBackupComponents::EnableWriterClasses
Cannot allocate writer class array
CVssBackupComponents::DisableWriterInstances
CVssBackupComponents::IsWriterClassDisabled
CVssBackupComponents::IsWriterInstanceDisabled
CVssBackupComponents::TrimWriters
Couldn't allocate memory for Max Writer Instances
Couldn't allocate memory for Max Writer Instances + 1
Internal error in writer trimming algorithm: iWriterD %d iWriterS %d cWriterInstances %d m_cWriterInstances %d
Internal error in adding deleting writer to trimmed writer array: iWriterD %d iWriterS %d cWriterInstances %d m_cWriterInstances %d
CVssBackupComponents::SetSnapshotSetDescription
Only Volume snapshot service can set snapshot set description.
Rethrow
CVssBackupComponents::ExposeSnapshot
CVssBackupComponents::UnexposeSnapshot
CVssBackupComponents::RevertToSnapshot
RevertToSnapshot({%.8x-%.4x-%.4x-%.2x%.2x-%.2x%.2x%.2x%.2x%.2x%.2x},%s
CVssBackupComponents::QueryRevertStatus
QueryRevertStatus(%s)
CVssBackupComponents::EnableWritersForRestore
CVssBackupComponents::CheckForDeletingWriter
invalid argument
GetVolumePathName is now failing on the volume, winerror 0x%08lx. Autorecovery bit will NOT be set, Deleting writer will NOT do its work even if it should.
GetVolumeNameForVolumeMountPoint is now failing on the volume, winerror 0x%08lx. Autorecovery bit will NOT be set, Deleting writer will NOT do its work even if it should.
IVssExamineWriterMetadata::QueryInterface(IID_IVssExamineWriterMetadataEx)
IVssExamineWriterMetadataEx::GetExcludeFromSnapshotCount
IVssExamineWriterMetadataEx::GetExcludeFromSnapshotFile
GetVolumePathName fails for exclude file path %s
GetVolumeNameForVolumeMountPoint fails for exclude file path %s
Omitted VSS_VOLSNAP_ATTR_AUTORECOVER for internal context due to VSS_VOLSNAP_ATTR_NO_AUTORECOVERY presence
SnapshotSetCreated
PrepareForBackup
PrepareForBackupSucceeded
PrepareForBackupFailed
DoSnapshotSet
DoSnapshotSetSucceeded
DoSnapshotSetFailed
BackupComplete
BackupCompleteSucceeded
BackupCompleteFailed
Aborting
Aborted
PreRestore
PreRestoreSucceeded
PreRestoreFailed
PostRestore
PostRestoreSucceeded
PostRestoreFailed
GatheringWriterMetadata
GatheringWriterStatus
CVssBackupComponents::DisconnectWriterCallback
CVssBackupComponents::GetRootAndLogicalPrefixPaths
CVssBackupComponents::LogWriterMetadataAsTelemetry
CVssBackupComponents::LogWritersMetadataAsTelemetry
Error: getting a NULL interface
GetInterfaceFromGlobal({%.8x-%.4x-%.4x-%.2x%.2x-%.2x%.2x%.2x%.2x%.2x%.2x}, %lu)
RevokeInterfaceFromGlobal(%lu) [%0x08lx]
RegisterInterfaceInGlobal({%.8x-%.4x-%.4x-%.2x%.2x-%.2x%.2x%.2x%.2x%.2x%.2x}, %lu)
DisableAutoRecovery
SYSTEM\CurrentControlSet\Services\VSS\Settings
%I64d
NULL node
CXMLNode::RemoveChild
IXMLDOMNode::removeChild
NULL input argument
IXMLDOMNode::SafeQI
Error querying IXMLDOMNode to IXMLDOMElement. 0x%08lx
Error querying from IXMLDOMNode to IXMLDOMElement. hr = 0x%08lx
Error querying IXMLDOMElement from the IXMLDOMNode. hr = 0x%08lx
Cannot allocate string
NULL document
IXMLDOMNode::get_nextSibling
IXMLDOMNode::get_parentNode
CXMLDocument::FindAttribute
NULL argument.
IXMLDOMNode::get_attributes
IXMLDOMNamedNodeMap::getNamedItem
IXMLDOMNode::get_text
CXMLDocument::ResetToDocument
CXMLDocument::ResetToParent
CXMLDocument::FindElementOneOf
CXMLNode::SaveAsXML
NULL document.
IXMLDOMDocument::get_parseError
IXMLDOMParseError::get_errorCode
IXMLDOMParseError::get_reason
IXMLDOMParseError::get_srcText
IXMLDOMParseError::get_line
IXMLDOMParseError::get_linepos
XML parse fails, error code 0x%08lx, line %d char %d, reason: %s
(null)
XML parse fails, Problem text: %s
CVssWorkerThread::PrepareJob
_beginthreadex failed. errno = 0x%08lx
CVssWorkerThread::StartJob
ResumeThread(%p) = -1, GetLastError() == 0x%08lx, m_eThreadState == %d
ResumeThread failed. Error: 0x%08lx. State: %d
CVssWorkerThread::ThreadFunction
CVssWorkerThread::Terminate
WaitForSingleObject(%p,INFINITE) == WAIT_FAILED, GetLastError() == 0x%08lx, m_eThreadState == %d
WaitForSingleObject failed. Error: 0x%08lx. State: %d
CVssAsyncBackup::CVssAsyncBackup
BUEASYNC
base\stor\vss\modules\backupext\vsxml\async.cxx
CVssAsyncBackup::~CVssAsyncBackup
CVssAsyncBackup::CreateInstanceAndStartJob
OpenThreadToken( GetCurrentThread(), TOKEN_IMPERSONATE | TOKEN_DUPLICATE | TOKEN_QUERY, TRUE, hToken)
OpenThreadToken succeeded
DuplicateToken(hToken, SecurityImpersonation, hDuplicateToken)
Error creating the CVssAsync instance. hr = 0x%08lx
Error initializing critical section
Error querying the IVssAsync interface. hr = 0x%08lx
CVssAsyncBackup::PrepareJob failed.  hr = 0x%08lx.
Error starting the job. hr = 0x%08lx
Rethrowing after restoring user privilege
CVssAsyncBackup::OnInit
CVssAsyncBackup::OnRun
BackupComponents object is NULL.
Internal PrepareBackup failed. 0x%08lx
Internal BackupComplete failed. 0x%08lx
Internal GatherWriterMetadata failed. 0x%08lx
Internal GatherWriterStatus failed. 0x%08lx
IVssAsync::Wait failed. 0x%08lx
IVssAsync::QueryStatus failed. 0x%08lx
CVssAsyncBackup::OnFinish
CVssAsyncBackup::OnTerminate
CVssAsyncBackup::Cancel
BackupComponents object is NULL
CVssAsyncBackup::Wait
invalid hThread
CVssAsyncBackup::QueryStatus
Output parameter is NULL.
Returning *pHrResult: 0x%08x
GatherWriterStatus
CVssSafeComPtr<struct IVssAsync>::GetInterface
CVssSafeComPtr<struct IVssAsync>::Initialize
CVssSafeComPtr<struct IVssAsync>::Reset
level %d node %s
CVssXMLLiteElement::Trace
INCXLTH
base\stor\vss\inc\vs_xmllite.hxx
XMLLTC
base\stor\vss\modules\xmllite\xmllite.cxx
CreateStreamOnHGlobal
CVssXMLLiteDocument::LoadFromXML
CVssXMLLiteDocument::ResetToDocument
CVssXMLLiteDocument::FindElement
CVssXMLLiteDocument::Next
CVssXMLLiteDocument::FindAttribute
CVssXMLLiteDocument::Parse
CreateXmlReader
UTF-16
CreateXmlReaderInputWithEncodingName
SetInput
GetQualifiedName
MoveToFirstAttribute
GetValue
MoveToElement
vector<T> too long
invalid map/set<T> iterator
map/set<T> too long
CVssExpressWriter::CVssExpressWriter
WRTXWIMP
base\stor\vss\modules\vswriter\vsxwimp.cpp
CVssExpressWriter::~CVssExpressWriter
CVssExpressWriter::CreateMetadata
Already created Express Writer, waiting for save
Already loaded Express Writer, waiting for save
No writer name provided
Writer with this ID or of this type cannot be created
CoCreateGuid failed with 0x%08x
CVssCreateExpressWriterMetadata::CreateInstance failed
First QueryInterface failed
Second QueryInterface failed
Reference count on CVssCreateExpressWriterMetadata is %lu
CVssCreateExpressWriterMetadata::Initialize call failed
CVssExpressWriter::LoadMetadata
Writer identity could not be extracted
CVssExpressWriter::Register
Can't save if not created or loaded beforehand
WriterExists failed with 0x%08x
WriterExists returned 0x%08x - writer already exists
RecreateDirectories returned 0x%08x - directories could not be recreated
CreateFilePath failed with 0x%08x
SaveAsXML call on IVssCreateWriterMetadataEx failed with 0x%08x
CVssExpressWriter::Unregister
Cannot delete, waiting for save
Cannot delete well known writer
WriterExists returned 0x%08x - writer does not exists
DeleteFile for "%s" failed with %d
DeleteFile(%s)
CVssExpressWriter::Cleanup
CVssExpressWriter::CreateFilePath
\Vss\Writers\Application\
\Vss\Writers\System\
GetWindowsDirectoryW failed with %d
%s%s%.8x-%.4x-%.4x-%.2x%.2x-%.2x%.2x%.2x%.2x%.2x%.2x.xml
StringCchPrintfW failed to create file name with 0x%08x
CVssExpressWriter::GetWriterIdentity
CreateVssExamineWriterMetadata failed with 0x%08x
GetIdentity failed with 0x%08x
CVssExpressWriter::SaveData
CreateFile for "%s" failed with %d
CreateFile(%s))
WriteFile for "%s" failed with %d
WriteFile(%s)
CVssExpressWriter::ValidWriterIdentity
Writer ID cannot be GUID_NULL
Using well known writer ID is forbidden
Unsupported usage type provided
CVssExpressWriter::WriterExists
CVssExpressWriter::RecreateDirectories
\Vss\Writers
\Vss\Writers\System
\Vss\Writers\Application
GetWindowsDirectoryW failed with %d.
CVssExpressWriter::RecreateDirectory
StringCchPrintfW failed with %d
D:(A;OICI;FA;;;BO)(A;OICI;FA;;;LS)(A;OICI;FA;;;NS)(A;ID;FA;;;S-1-5-80-956008885-3418522649-1831038044-1853292631-2271478464)(A;CIIOID;GA;;;S-1-5-80-956008885-3418522649-1831038044-1853292631-2271478464)(A;ID;FA;;;SY)(A;OICIIOID;GA;;;SY)(A;ID;FA;;;BA)(A;OICIIOID;GA;;;BA)(A;ID;0x1200a9;;;BU)(A;OICIIOID;GXGR;;;BU)(A;OICIIOID;GA;;;CO)
ConvertStringSecurityDescriptorToSecurityDescriptorW() failed with %d
CreateDirectoryW() failed with %d
GetFileAttributesW() failed with %d
Could not recreate directory, file in place (%08x)
Writer
CVssWriterImpl::Lock
INCWRMPH
base\stor\vss\inc\vswrtimp.h
Lock called when it wasn't initialized
CVssWriterImpl::Unlock
UnsubscribeCallback
CVssWriterImpl::~CVssWriterImpl
*** Destructing object %p
CVssWriterImpl::GetSnapshotDeviceName
A required parameter is NULL
Invalid operation on transportable snapshots with legacy writer involved
GetSnapshotDeviceName must only be called from OnPostSnapshot
Volume %s was not found in the list of snapshot volumes
CVssWriterImpl::BeginSequence
CVssWriterImpl::ResetSequence
CVssWriterImpl::GetSessionId
GetStateForCurrentEvent called from unknown thread
CVssWriterImpl::GetContext
unchanged
auto-recovery masked
Returning context %ld (%s)
CVssWriterImpl::SetWriterFailure
CVssWriterImpl::SetWriterFailureEx
restore
backup
Setting the %s failure status, hr=%#x
The calling thread is not the same thread that originally serviced the event; setting failure state, hr=%#x
CVssWriterImpl::IsPathAffected
IsPathAffected called with path %s
empty volume count
IsPathAffected: Compare m_ppwszVolumeArray[%d]=%s wszVolumeRoot=%s
no matching volume found
CVssWriterImpl::GetCallback
Error querying for IVssWriterCallback interface.  hr = 0x%08lx
Call to CoSetProxyBlanket failed.  hr = 0x%08lx
CVssWriterImpl::CreateBasicWriterMetadata
Cannot create CVssCreateWriterMetadata due to allocation failure.
CVssCreateWriterMetadata::Initialize failed. hr = 0x%08lx
CVssWriterImpl::InternalGetWriterComponents
Cannot allocate instance Id string or instance name string
IVssWriterCallback::GetBackupState failed.  hr = 0x%08lx
IVssWriterCallback::GetRestoreState failed.  hr = 0x%08lx
Cannot get WRITER_COMPONENTS document.  hr = 0x%08lx
Can't allocate CVssWriterComponents object
Internally transferred WRITER_COMPONENTS document is invalid
Failed to initialize WRITER_COMPONENTS document.  hr = 0x%08lx
Internally transferred WRITER_METADATA document is invalid
CVssWriterImpl::InitializeDelayedPostSnapshotCache
Writer is now in Delayed Post Snapshot mode
Error caught. Re-throwing ... hr = 0x%08lx
CVssWriterImpl::InternalGetWriterComponentsCached
CVssWriterImpl::EnterState
Writer state is not a beginning state at the start of snapshot sequence. Previous sequence must have been interupted
Attempt to start snapshot sequence with a duplicate snapshot set id: {%.8x-%.4x-%.4x-%.2x%.2x-%.2x%.2x%.2x%.2x%.2x%.2x}
Sequence for snapshot set {%.8x-%.4x-%.4x-%.2x%.2x-%.2x%.2x%.2x%.2x%.2x%.2x} was aborted.
Current sequence was aborted. Current writer state (%d) does not match the state expected for the state transition (%d)
*** Warning ***: Writer %s with ID {%.8x-%.4x-%.4x-%.2x%.2x-%.2x%.2x%.2x%.2x%.2x%.2x}attempts to reset the previous sequence with Snapshot Set ID {%.8x-%.4x-%.4x-%.2x%.2x-%.2x%.2x%.2x%.2x%.2x%.2x}. Current state = %d
CVssWriterImpl::LeaveState
CVssWriterImpl::StartTimerThreadInternal
SetEvent failed with error %d
CVssWriterImpl::TimerFunc
WaitForSingleObject failed with error %d
Starting Timer Thread
Wait in timer thread failed due to reason %d.
Aborting due to timeout
CVssWriterImpl::RequestWriterInfoInternal
Incorrect flags
Backup Operator privileges are not set
the writer is shutting down
Entering operation RequestWriterInfo(bWriterMetadata == true)
Wait failed due to reason %d.
Writer's OnIdentify method threw and exception.
Writer's OnIdentify method returned false.
ConvertMappedNetworkDrivesToUNC failed with hr = 0x%08lx. Error is ignored
Couldn't allocate memory for ids or name
Cannot save XML document as string. hr = 0x%08lx
Entering operation RequestWriterInfo(bWriterMetadata == false)
Writer %s (%s) has dropped the session status for snapshot set %s
Writer %s exposing state<%d> failure<%#x>
CVssWriterImpl::PrepareForBackupInternal
Entering operation PrepareForBackup
SnapshotSetID         = %s
Couldn't properly begin sequence
Writer's OnPrepareBackup method threw an exception
Writer rejected the preparebackup
CVssWriterImpl::SaveChangedComponents
Couldn't allocate instance id string
Saving WRITER_COMPONENTS document as XML failed.  hr = 0x%08lx
IVssWriterCallback::SetContent failed.  hr = 0x%08lx
CVssWriterImpl::ProcessObjectList
No local volumes in the snapshot set - this is expected only in case of a remote snapshots set
CVssWriterImpl::PrepareForSnapshotInternal
ADMIN privileges are not set
A required in parameter is NULL.
Received Event: PrepareForSnapshot
VolumeNamesList       = %s
improper state transition
a component was torn
Writer's OnPrepareSnapshot method threw an execption
Writer rejected the prepare snapshot
CVssWriterImpl::FreezeInternal
A required parameter is NULL.
Received Event: Freeze
Level                 = %d
Improper entry into state
ResetEvent failed with error %d
Writer's OnFreeze Method threw and exception
Writer rejected the freeze
Cannot create timer args due to allocation failure
Failure to create thread due to error %d.
CVssWriterImpl::ThawInternal
Received Event: Thaw
Writer rejected the thaw
Writer's OnThaw method threw an exception
CVssWriterImpl::PostSnapshotInternal
Received Event: PostSnapshot - Parameters:
SnapshotSetID         = <%s>
SnapshotDevicesList   = <%s>
Writer's OnPostSnapshot method threw an exception
Writer rejected the post Snapshot
CVssWriterImpl::BackupCompleteInternal
Received Event: OnBackupComplete
Empty snapshot set scenario failed to ResetSequence
Writer's OnBackupComplete method threw an exception.
Writer rejected the backup complete
CVssWriterImpl::BackupShutdownInternal
Can only be called from the coordinator
Received Event: OnBackupShutdown
SnapshotSetID = %s
WriterId             = {%.8x-%.4x-%.4x-%.2x%.2x-%.2x%.2x%.2x%.2x%.2x%.2x}
WriterName           = %s
Writer's OnBackupShutdown  method threw an exception.
Writer rejected the backup shutdown
CVssWriterImpl::AbortInternal
Backup privileges are not set
Received Event: Abort
CVssWriterImpl::PreRestoreInternal
Received Event: PreRestore
Restore Operator privileges are not set
backup schema: %#x
The pre-restore event will be serialized
The pre-restore event is not serialized
Writer's OnPreRestore method threw an exception
Writer rejected the prerestore
CVssWriterImpl::PostRestoreInternal
Received Event: PostRestore
The post-restore event will be serialized
The post-restore event is not serialized
Writer's OnPostRestore method threw an exception
Writer rejected the postrestore
CVssWriterImpl::CalculateComponentPath
CVssWriterImpl::CheckTornComponents
skipping torn-component checking due to registry key
caching component data in CheckTornComponents
cIncludes = %u, cExcludes = %u, cComponents = %u
wszWriterQualifiedName = %s
ComponentIndex cache is releasd due to insufficient memory
ComponentIndex cache has %u elements
caching component data finished in CheckTornComponents
IVssComponent::GetComponent
IVssComponent::GetLogicalPath
IVssComponent::GetComponentName
component %s is selected for backup
component %s is found
ComponentIndex cache is released after finding a torn component
warning:  component %s is not found
ComponentIndex cache is released at the end of CheckTornComponents
CVssWriterImpl::CheckTornComponent
checking whether component %s is torn
skipping torn check for the final %d filespecs for performance reasons.  Only the first %d filespecs were checked
CVssWriterImpl::CheckTornFile
path %s in not on any snapshot
Cannot allocate BSTR.
WriterInstanceName
Rethrowing exception
CVssWriterImpl::TerminateTimerThread
CVssWriterImpl::Unsubscribe
Writer infrastructure is in unstable condition due to an unhandled exception.
CVssWriterImpl::UnsubscribeInternal
SubscriptionID == 
allocation of BSTR failed
IEventSystem::Remove
**** Unsubscribe succeeded for [%p] (%u subscriptions removed)
CVssWriterImpl::DisconnectContext
Continuing CoDisconnectContext wait for %d seconds
CoDisconnectContext timed out after %d seconds, but writer unsubscribe will continue
Failed to create CVssWriterImpl.  hr = 0x%08lx
CVssWriterImpl::GetBackupSchemaFromWriterComponents
Unable to generate writer ID string; out of resources
IVssWriterCallback::GetContent
Unable to load the writer components document
Unable to find root element
Unable to find WRITER_COMPONENTS element
CVssWriterImpl::CheckWriterIntegrity
CVssWriterImpl::LogWriterEventRejectedEvent
%#010x
CVssWriterState::CreateNewState
Out of memory error creating writer state object
Out of memory error adding writer state to the list
Old snapshot set
CVssWriterState::LogStateAging
Old operation
Old state
Old failure
Old extended failure hr
Old extended failure message
An older writer session state is being removed. 
CVssWriterState::AgeStates
Removing completed state {%.8x-%.4x-%.4x-%.2x%.2x-%.2x%.2x%.2x%.2x%.2x%.2x}
Removing aborted state {%.8x-%.4x-%.4x-%.2x%.2x-%.2x%.2x%.2x%.2x%.2x%.2x}
Removing zombie state {%.8x-%.4x-%.4x-%.2x%.2x-%.2x%.2x%.2x%.2x%.2x%.2x}
CVssWriterState::FinishBackupComplete
Couldn't call BackupComplete without OnThaw as a previous state [%d]
CVssWriterState::SetBackupCompleteStatus
Can't set backup complete on session id (%#x){%.8x-%.4x-%.4x-%.2x%.2x-%.2x%.2x%.2x%.2x%.2x%.2x}
CVssWriterState::UpdateThreadIdForSession
CVssWriterState::UpdateSessionIdOnBeginSequence
CVssWriterState::GetStateForSession
CVssWriterState::SetNoResponseFailure
Writer sequence no longer in operation, retry
SnapshotTornComponents
EnableRemoteSnapshots
be000cbe-11fe-4426-9c58-531aa6355fc4
ASR Writer
WRTASRWC
base\stor\vss\modules\vswriter\asrwriterrest.cpp
CVssAsrAPIRestore::CreateObject
Asr writer not found
Asr component not found
Exception caught!
CoImpersonateClient
OpenProcessToken
CoRevertToSelf
OpenThreadToken
IsInGroup
AllocateAndInitializeSid
CheckTokenMembership
PrivilegeCheck
ERROR_INSUFFICIENT_BUFFER expected error . [0x%08lx]
GetTokenInformation
Unexpected error. Final buffer size = %lu, original size was %lu
GetClientTokenOwner
CreateWellKnownSidType
CAutoSid::CreateFromString
ConvertStringSidToSid(%s)
CreateWellKnownSid(type, NULL, NULL, &dwSid)
CreateWellKnownSid(type, NULL, pSid, [%ld])
Invalid user name argument
LookupAccountName fails to give SID size for %s, fReturn %d, winerror %d, dwSid %d, dwDomain %d. This key value is ignored.
User %s specified under VssAccessControl key doesn't exist. This key value is ignored.
LookupAccountName fails for %s, winerror %d. This key value in VssAccessControl is ignored.
LookupAccountName fails unexpectedly for %s, winerror %d. Account ignored.
Invalid SID passed to AddSid
Adding SID %s ...
m_SDRequestors.Deny(...)
m_SDWriters.Deny(...)
m_SDBoth.Deny(...)
m_SDRequestors.Allow(...)
m_SDWriters.Allow(...)
m_SDBoth.Allow(...)
allowed
denied
explicitely
implicitely
WriterSid: %s was %s %s to fire
LookupAccountSid returned with winerror %d, bRes %s.
LookupAccountSid fails unexpectedly, winerror %d.
NetLocalGroupGetMemebers(%s)
NetLocalGroupGetMembers() failed for "%s" with %d
CVssSidCollection::AddSidToRegistry
StringCchVPrintfW()
RegCreateKeyExW(%ld,%s,...)
Key %s already exists
RegCreateKeyExW(%ld,%s,...,[%lu])
RegOpenKeyExW(%ld,%s,...)
CVssRegistryKey::SetValue
RegSetValueExW(0x%08lx,%s,0,REG_DWORD,%ld)
CVssRegistryKey::SetBinaryValue
RegSetValueExW(0x%08lx,%s,0,REG_BINARY,%p.%lu)
RegQueryValueExW(0x%08lx(%s),%s,0,[%lx],0,[%lu])
Unexpected type %lu for a string value 0x%08lx(%s),%s
Expected REG_DWORD type for registry key %s value name %s. The present value has been ignored
Unexpected size %lu for a DWORD value 0x%08lx(%s),%s
Unexpected error: noninitialized iterator
Unexpected error: dwIndex out of scope %lu %lu
CVssRegistryKeyIterator::Attach
RegQueryInfoKeyW(%p, ...)
Unexpected error: attempting to read a value of the wrong type
Unexpected error: current value type changed in the meantime %lu %lu
RegEnumValue(%p,%lu,%p,%lu ...)
Unexpected error: unexpected DWORD size [%ld, %ld]
 NULL or empty parameter
CVssDiag::RecordWriterEvent
CVssDiag::RecordGenericEvent
Parameters %ld, %ld, %ld, 0x%08lx, {%.8x-%.4x-%.4x-%.2x%.2x-%.2x%.2x%.2x%.2x%.2x%.2x}
Event name: %s
VSS_IN_IDENTIFY (Enter)
VSS_IN_IDENTIFY (Leave)
VSS_IN_PREPAREBACKUP (Enter)
VSS_IN_PREPAREBACKUP (Leave)
VSS_IN_PREPARESNAPSHOT (Enter)
VSS_IN_PREPARESNAPSHOT (Leave)
VSS_IN_FREEZE (Enter)
VSS_IN_FREEZE (Leave)
VSS_IN_FREEZE_FRONT (Enter)
VSS_IN_FREEZE_FRONT (Leave)
VSS_IN_FREEZE_BACK (Enter)
VSS_IN_FREEZE_BACK (Leave)
VSS_IN_FREEZE_SYSTEM (Enter)
VSS_IN_FREEZE_SYSTEM (Leave)
VSS_IN_FREEZE_RM (Enter)
VSS_IN_FREEZE_RM (Leave)
VSS_IN_FREEZE_KTM (Enter)
VSS_IN_FREEZE_KTM (Leave)
VSS_IN_FREEZE_DTC (Enter)
VSS_IN_FREEZE_DTC (Leave)
VSS_IN_THAW (Enter)
VSS_IN_THAW (Leave)
VSS_IN_THAW_KTM (Enter)
VSS_IN_THAW_KTM (Leave)
VSS_IN_THAW_DTC (Enter)
VSS_IN_THAW_DTC (Leave)
VSS_IN_POSTSNAPSHOT (Enter)
VSS_IN_POSTSNAPSHOT (Leave)
VSS_IN_BACKUPCOMPLETE (Enter)
VSS_IN_BACKUPCOMPLETE (Leave)
VSS_IN_PRERESTORE (Enter)
VSS_IN_PRERESTORE (Leave)
VSS_IN_POSTRESTORE (Enter)
VSS_IN_POSTRESTORE (Leave)
VSS_IN_GETSTATE (Enter)
VSS_IN_GETSTATE (Leave)
VSS_IN_ABORT (Enter)
VSS_IN_ABORT (Leave)
VSS_IN_BACKUPSHUTDOWN (Enter)
VSS_IN_BACKUPSHUTDOWN (Leave)
VSS_IN_BKGND_FREEZE_THREAD (Enter)
VSS_IN_BKGND_FREEZE_THREAD (Leave)
VSS_IN_PROVIDER_BEGINPREPARE (Enter)
VSS_IN_PROVIDER_BEGINPREPARE (Leave)
VSS_IN_PROVIDER_ENDPREPARE (Enter)
VSS_IN_PROVIDER_ENDPREPARE (Leave)
VSS_IN_PROVIDER_PRECOMMIT (Enter)
VSS_IN_PROVIDER_PRECOMMIT (Leave)
VSS_IN_PROVIDER_COMMIT (Enter)
VSS_IN_PROVIDER_COMMIT (Leave)
VSS_IN_PROVIDER_POSTCOMMIT (Enter)
VSS_IN_PROVIDER_POSTCOMMIT (Leave)
VSS_IN_PROVIDER_PREFINALCOMMIT (Enter)
VSS_IN_PROVIDER_PREFINALCOMMIT (Leave)
VSS_IN_PROVIDER_POSTFINALCOMMIT (Enter)
VSS_IN_PROVIDER_POSTFINALCOMMIT (Leave)
VSS_IN_PROVIDER_POSTSNAPSHOT (Enter)
VSS_IN_PROVIDER_POSTSNAPSHOT (Leave)
VSS_IN_PROVIDER_ABORTSNAPSHOTS (Enter)
VSS_IN_PROVIDER_ABORTSNAPSHOTS (Leave)
VSS_IN_DOSNAPSHOT (Enter)
VSS_IN_DOSNAPSHOT (Leave)
VSS_IN_OPEN_VOLUME_HANDLE (Enter)
VSS_IN_OPEN_VOLUME_HANDLE (Leave)
VSS_IN_IOCTL_FLUSH_AND_HOLD (Enter)
VSS_IN_IOCTL_FLUSH_AND_HOLD (Leave)
VSS_IN_IOCTL_RELEASE (Enter)
VSS_IN_IOCTL_RELEASE (Leave)
VSS_IN_IOCTL_NOTIFY_FLUSH_COMPLETE (Enter)
VSS_IN_IOCTL_NOTIFY_FLUSH_COMPLETE (Leave)
VSS_WS_UNKNOWN (SetCurrentState)
VSS_WS_STABLE (SetCurrentState)
VSS_WS_WAITING_FOR_FREEZE (SetCurrentState)
VSS_WS_WAITING_FOR_THAW (SetCurrentState)
VSS_WS_WAITING_FOR_POST_SNAPSHOT (SetCurrentState)
VSS_WS_WAITING_FOR_BACKUP_COMPLETE (SetCurrentState)
VSS_WS_FAILED_AT_IDENTIFY (SetCurrentState)
VSS_WS_FAILED_AT_PREPARE_BACKUP (SetCurrentState)
VSS_WS_FAILED_AT_PREPARE_SNAPSHOT (SetCurrentState)
VSS_WS_FAILED_AT_FREEZE (SetCurrentState)
VSS_WS_FAILED_AT_THAW (SetCurrentState)
VSS_WS_FAILED_AT_POST_SNAPSHOT (SetCurrentState)
VSS_WS_FAILED_AT_BACKUP_COMPLETE (SetCurrentState)
VSS_WS_FAILED_AT_PRE_RESTORE (SetCurrentState)
VSS_WS_FAILED_AT_POST_RESTORE (SetCurrentState)
VSS_WS_FAILED_AT_BACKUPSHUTDOWN (SetCurrentState)
VSS_S_OK (SetCurrentFailure)
((HRESULT)0x800423F0L) (SetCurrentFailure)
((HRESULT)0x800423F1L) (SetCurrentFailure)
((HRESULT)0x800423F2L) (SetCurrentFailure)
((HRESULT)0x800423F3L) (SetCurrentFailure)
((HRESULT)0x800423F4L) (SetCurrentFailure)
((HRESULT)0x800423F5L) (SetCurrentFailure)
((HRESULT)0x80042319L) (SetCurrentFailure)
(Enter)
(Leave)
UNKNOWN_EVENT[0x%08lx] %s
DSREPAIR
Not DSREPAIR
SafeBoot option 0x%08lx, %s
Fail to find safeboot registry key
Fail to find Product Options registry key
Product type is LanManNt - It is a DC
Cannot determine whether machine is DC
Failure to use DsRoleGetPrimaryDomainInformation for DC
DsRoleGetPrimaryDomainInformation succeeded but DSROLE_PRIMARY_DOMAIN_INFO_BASIC buffer is NULL
Re-throwing after cleanup
Disabled
CVssIJetWriter::ProcessJetInstance
JetGetSystemParameter(JET_paramLogFilePath)
Succeeded
FAILED
CVssIJetWriter::ProcessJetInstance - %s calling JetGetSystemParameter() with instance Log file path '%s' (from ESE) or '%s' full name
JetGetSystemParameter(JET_paramSystemPath)
CVssIJetWriter::ProcessJetInstance - %s calling JetGetSystemParameter() with JET_paramSystemPath / checkpoint file path '%s' (from ESE) or '%s' full name
JetGetSystemParameter(JET_paramBaseName)
JetGetSystemParameter(JET_paramLegacyFileNames)
CVssIJetWriter::ProcessJetInstance - %s calling JetGetSystemParameter() for base name '%s' (from ESE) to form LogFileName '%s' and CheckpointFileName '%s'
CVssIJetWriter::ProcessJetInstance - %s adding component '%s\%s' for jet instance '%s' database '%s' with display name '%s'
CVssIJetWriter::ProcessJetInstance - %s adding database files for instance '%s', database '%s', database file '%s\%s'
CVssIJetWriter::ProcessJetInstance - %s adding log file for instance '%s', database '%s', log file '%s\%s'
CVssIJetWriter::ProcessJetInstance - %s adding checkpoint file for instance '%s', database '%s', checkpoint file '%s\%s'
CVssIJetWriter::OnIdentify
Jet Writer
JetGetInstanceInfo
CVssIJetWriter::OnPrepareBackup
CVssIJetWriter::OnBackupComplete
CVssIJetWriter::OnPrepareSnapshot
CVssIJetWriter::OnFreeze
CVssIJetWriter::OnThaw
CVssIJetWriter::OnPostSnapshot
CVssIJetWriter::OnAbort
CVssIJetWriter::OnPreRestore
CVssIJetWriter::OnPostRestore
CVssIJetWriter::Initialize
Bad FilesToInclude list.
Bad FilesToExclude list.
FAILED creating CVssIJetWriter object due to allocation failure.
FAILED during internal initialisation of CVssIJetWriter object
CVssIJetWriter::Uninitialize
FLTRC
CVssWriterPublisherFilter::SetupIdArrays
Cannot allocate writer class id array
base\stor\vss\modules\filter\filter.cxx
CVssWriterPublisherFilter::SetupGenericSids
Cannot allocate instance id include array
IMultiInterfaceEventControl::GetSubscriptions
CVssWriterPublisherFilter::PrepareToFire
IEnumEventObject::Next
IEventObjectCollection::get_NewEnum
IEventSubscription::get_OwnerSID
IUnknown::QueryInterface
Firing subscriber SID (%s) for method (%s)
Subscriber with SID (%s) is not allowed to fire
Subscriber with SID (%s) for method (%s) was not fired.
FireSubscription
Error querying for IMultiInterfaceEventControl interface.  hr = 0x%08lx
SetupPublisherFilter
IMultiInterfaceEventControl::put_FireInParallel
IMultiInterfaceEventControl::SetMultiInterfacePublisherFilter
ClearPublisherFilter
ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/
GetRestoreOptionDataValuePair
ppwszDataStringOut
pwszOptionString
ppwszEndOfPairOut
ppwszValueStringOut
ERROR_NO_MORE_ITEMS
pwszValueString
pwszDataString
pwszBackupDoc
TraceBackupDocument
StringCchCopyN( wszTraceBuffer, ARRAYSIZE(wszTraceBuffer), pwszStart, CHAR_PER_LINE )
CComObject<CVssAsrAPIRestore>::CreateInstance( &pVssAsrApi )
ppVssAsrRestore
CVssAsrAPIRestore::_ParseRestoreOption
spUnk->QueryInterface( riid, (VOID**)ppVssAsrRestore )
pcExcludeDisks
ppdwExcludeDisks
pcIncludeDisks
ppdwIncludeDisks
pdwRestoreFlags
pcIncludeAllCritical
pwszBootVolumeName
pwszSystemVolumeName
BootVolumeName
SystemVolumeName
*pwszBootVolumeName
SkipDiskRecreation
*pwszSystemVolumeName
ExcludeDisk
CheckAllCritical
pListCur
IncludeDisk
InjectDrivers
SkipRecreateVHD
pdwIncludeArray
pdwExcludeArray
m_pAsrSys
CVssAsrAPIRestore::PreRestore
m_pAsrLdm
m_pAsrFmt
_AsrPerformPreRestore((WCHAR *)pwszMetadata, pdwIncludeDisks, cIncludeDisks, pdwExcludeDisks, cExcludeDisks, dwRestoreFlags, wszSystemVolumeName, wszBootVolumeName )
_ParseRestoreOption( &pdwIncludeDisks, &cIncludeDisks, &pdwExcludeDisks, &cExcludeDisks, &cIncludeAllCritical, &dwRestoreFlags, &wszSystemVolumeName, &wszBootVolumeName )
m_pAsrSys != NULL
CVssAsrAPIRestore::PostRestore
m_pAsrFmt != NULL
m_pAsrLdm != NULL
m_pAsrLdm->PerformPostRestore(m_pAsrSys)
m_pAsrSys->PerformPostRestore()
m_pAsrSys->GetRestoredOfflinedHivePath( L"SOFTWARE", &pwszOfflineSoftwareHiveFilePath )
SOFTWARE
pwszRestoreOptions
CVssAsrAPIRestore::SetRestoreOptions
ERROR_ALREADY_ASSIGNED
pwszXmlBuffer
CVssAsrAPIRestore::_AsrPerformPreRestore
m_pAsrSys->InitializeForRestore((WCHAR *) pwszXmlBuffer, dwRestoreFlags)
GetLastError()
m_pAsrLdm->InitializeForRestore((WCHAR *) pwszXmlBuffer)
m_pAsrFmt->InitializeForRestore((WCHAR *) pwszXmlBuffer)
m_pAsrSys->PerformPreRestore( m_pAsrLdm, pdwIncludeDisks, cIncludeDisks, pdwExcludeDisks, cExcludeDisks )
m_pAsrLdm->InitializePhysicalPackListForRestore()
m_pAsrSys->MarkActiveBitOnSystemPartition()
m_pAsrLdm->PerformPreRestore(m_pAsrSys)
wszSystemVolumeName
m_pAsrFmt->PerformPreRestore(m_pAsrSys)
m_pAsrSys->SetBootAndSystemVolumeName( wszSystemVolumeName, wszBootVolumeName )
wszBootVolumeName
CVssXmlRwDocument::CVssXmlRwDocument
base\stor\vss\modules\xmlrw\xmlrw.cpp
XMLRWC
XML size is %ld
CVssXmlRwDocument::InitializeFromString
CreateXmlReader( __uuidof(IXmlReader), (LPVOID*) &m_pReader, NULL)
CreateStreamOnHGlobal(m_ptrBuffer.GetHGLOBAL(), FALSE, &pStream)
m_pReader->SetInput(pReaderInput)
CreateXmlReaderInputWithEncodingName(pStream, NULL, L"UTF-16", FALSE, NULL, &pReaderInput)
Current level %d
CVssXmlRwDocument::SelectElementIfExists
Target level if found = %d
Selecting element %s on level %d
m_pReader->Read(&xmlNodeType)
Target level if not found = %d
m_pReader->Read(&xmlNodeType)
- ERROR: Call %S not succeeded. 
  Error Code = 0x%08lx. Error description = %s
m_pReader->GetQualifiedName(qualifiedName.GetBufferAddr(), qualifiedName.GetLengthAddr())
m_pReader->GetQualifiedName(XML_STR_PARAM(qualifiedName))
m_pReader->GetNamespaceUri(namespaceUri.GetBufferAddr(), namespaceUri.GetLengthAddr())
m_pReader->GetNamespaceUri(XML_STR_PARAM(namespaceUri))
m_pReader->GetLocalName(localName.GetBufferAddr(), localName.GetLengthAddr())
m_pReader->GetLocalName(XML_STR_PARAM(localName))
* END = %s
* ELEMENT = %s [ns:%s, local:%s], level = %d
Selecting attribute %s
CVssXmlRwDocument::SelectAttributeIfExists
m_pReader->MoveToNextAttribute()
m_pReader->MoveToNextAttribute()
CVssXmlRwDocument::SelectElement
*    ATTRIBUTE = %s [ns:%s, local:%s]
CVssXmlRwDocument::SelectAttribute
Element '%s' not found
CVssXmlRwDocument::GetAttributeValue
Attribute '%s' not found
m_pReader->GetValue(attributeValue.GetBufferAddr(), attributeValue.GetLengthAddr())
m_pReader->GetValue(XML_STR_PARAM(attributeValue))
MX_E_INPUTEND - unexpected end of input
*       VALUE = '%s'
MX_E_ENCODINGSWITCH - unable to switch the encoding
MX_E_ENCODING - unrecognized encoding
WC_E_WHITESPACE - whitespace expected
MX_E_ENCODINGSIGNATURE - unrecognized input signature
WC_E_GREATERTHAN - '>' expected
WC_E_SEMICOLON - semicolon expected
WC_E_EQUAL - equal expected
WC_E_QUOTE - quote expected
WC_E_HEXDIGIT - hexadecimal digit expected
WC_E_LESSTHAN - wfc: no '<' in attribute value
WC_E_LEFTBRACKET - '[' expected
WC_E_DIGIT - decimal digit expected
WC_E_XMLCHARACTER - illegal xml character
WC_E_LEFTPAREN - '(' expected
WC_E_SYNTAX - incorrect document syntax
WC_E_NAMECHARACTER - illegal name character
WC_E_COMMENT - incorrect comment syntax
WC_E_CDSECT - incorrect CDATA section syntax
WC_E_DECLATTLIST - incorrect ATTLIST declaration syntax
WC_E_CONDSECT - incorrect conditional section syntax
WC_E_DECLELEMENT - incorrect ELEMENT declaration syntax
WC_E_DECLDOCTYPE - incorrect DOCTYPE declaration syntax
WC_E_DECLNOTATION - incorrect NOTATION declaration syntax
WC_E_DECLENTITY - incorrect ENTITY declaration syntax
WC_E_PUBLIC - PUBLIC expected
WC_E_NDATA - NDATA expected
WC_E_NAME - name expected
WC_E_SYSTEM - SYSTEM expected
WC_E_ELEMENTMATCH - wfc: element type match
WC_E_ROOTELEMENT - one root element 
WC_E_TEXTXMLDECL - text/xmldecl not at the beginning of input
WC_E_UNIQUEATTRIBUTE - wfc: unique attribute spec
WC_E_TEXTDECL - incorrect text declaration syntax
WC_E_LEADINGXML - leading "xml"
WC_E_ENCNAME - incorrect encoding name syntax
WC_E_XMLDECL - incorrect xml declaration syntax
WC_E_PESINTERNALSUBSET - wfc: pes in internal subset
WC_E_PUBLICID - incorrect public identifier syntax
WC_E_NORECURSION - wfc: no recursion
WC_E_PESBETWEENDECLS - wfc: pes between declarations
WC_E_UNDECLAREDENTITY - wfc: undeclared entity 
WC_E_ENTITYCONTENT - entity content not well formed
WC_E_NOEXTERNALENTITYREF - wfc: no external entity references
WC_E_PARSEDENTITY - wfc: parsed entity
WC_E_SYSTEMID - incorrect system identifier syntax
WC_E_PI - incorrect processing instruction syntax
WC_E_CDSECTEND - no ']]>' in element content
WC_E_QUESTIONMARK - '?' expected
NC_E_QNAMECHARACTER - illegal qualified name character
WC_E_MOREDATA - not all chunks of value have been read
NC_E_NAMECOLON - colon in name
NC_E_QNAMECOLON - multiple colons in qualified name
NC_E_UNDECLAREDPREFIX - undeclared prefix
NC_E_DECLAREDPREFIX - declared prefix
NC_E_XMLPREFIXRESERVED 'xml' prefix is reserved and must have the http://www.w3.org/XML/1998/namespace URI
NC_E_EMPTYURI - non default namespace with empty uri
NC_E_XMLURIRESERVED xml namespace URI (http://www.w3.org/XML/1998/namespace) must be assigned only to prefix 'xml'
NC_E_XMLNSPREFIXRESERVED 'xmlns' prefix is reserved for use by XML
NC_E_XMLNSURIRESERVED xmlns namespace URI (http://www.w3.org/2000/xmlns/) is reserved and must not be used
\Device\DfsClient
CVssUNCPath::SetUNCPath
base\stor\vss\modules\remotevss\util\share\sharemgt.cxx
FSSSHRMC
Don't support SetUNCPath more than once
pwszUNCPath is NULL
UNC path not initialized
UNC Path starts with invalid prefix
Output ppwszScopeName is NULL
CVssUNCPath::GetScopeName
Cannot allocate share scope name
UNC Path has no share scope name component in it
Cannot allocate share name
UNC Path has no share name component in it
CVssUNCPath::GetShareName
UNC Path has no scope name component in it
Output ppwszShareName is NULL
CVssUNCPath::IsUNCPrefixInternal
Unable to translate server name in IP address format to host name. Please make sure your DNS servers have IPv4 and IPv6 reverse lookup zones (ip6.arpa and ip.arpa) configured.
ReverseDnsLookup
Invalid pwszMappedPath=%s
ExpandMappedSharePathToUNC
Input path is not a locally mapped share
Input path does not start with a drive letter
.ipv6-literal.net
CVssCreateExpressWriterMetadata::Initialize
base\stor\vss\modules\backupext\vsxml\vs_xwmxml.cxx
BUEXWXML
Failed creating CVssCreateWriterMetadata
Requested usage type is not supported
CVssCreateExpressWriterMetadata::AddComponent
CVssCreateExpressWriterMetadata::AddExcludeFiles
AddComponent called on Express Writer with component flags %08x
AddComponent called on Express Writer with notify on backup complete request
AddFilesToFileGroup called on Express Writer metadata with %08x
CVssCreateExpressWriterMetadata::AddFilesToFileGroup
CVssCreateExpressWriterMetadata::SetRestoreMethod
AddFilesToFileGroup called on Express Writer with alternate location
SetRestoreMethod called on Express Writer with method %d
SetRestoreMethod called on Express Writer with incorrect writer restore
CVssCreateExpressWriterMetadata::SetBackupSchema
CVssCreateExpressWriterMetadata::AddComponentDependency
CVssCreateExpressWriterMetadata::SaveAsXML
SetBackupSchema called on Express Writer metadata with %08x
pwszFsName
pFsType
FAT32
exFAT
StringCchCopy( pwszFsName, cchFsName, L"NTFS" )
StringCchCopy( pwszFsName, cchFsName, L"FAT" )
StringCchCopy( pwszFsName, cchFsName, L"FAT32" )
StringCchCopy( pwszFsName, cchFsName, L"ReFS" )
StringCchCopy( pwszFsName, cchFsName, L"UDF" )
StringCchCopy( pwszFsName, cchFsName, L"CDFS" )
StringCchCopy( pwszFsName, cchFsName, L"exFAT" )
AsrFmt::InitializeForRestore
pwszXmlDoc
E_OUTOFMEMORY
FixedVolumes
pStateInfo
RemovableMedia
ERROR_INVALID_NAME
pXmlDoc
AsrFmt::_ExtractFixedVolumesFromXml
NumVolumeNames
pNextVolume
ppVolume
VolumeName
AsrFmt::_ExtractRemovableMediaFromXml
NumRemMedia
pNextRemMedia
ppRemMedia
Media
VolumeGuid
pVolume
FsName
DosPath
ClusterSize
Label
pwszGuid
AsrFmt::_ExtractVolumeFromXml
pwszLabel
pwszDosPath
ERROR_INSUFFICIENT_BUFFER
DevicePath
pRemMedia
AsrFmt::_ExtractMediaFromXml
AsrFmt::_IsVolumeOnIncludedDisks
ERROR_INVALID_PARAMETER
pwszVolumeName
pAsrSys
hVolume
pfIsOnIncludedDisksOut
::GetLastError()
FormatInitialise()
AsrFmt::_RestoreVolumeInformation
::StringCchCat(ARRAY_COUNT_PARAM(wszVolumeRootPath), L"\\")
::StringCchCopy(ARRAY_COUNT_PARAM(wszVolumeRootPath), pVolume->szGuid)
::StringCchCopy( ARRAY_COUNT_PARAM(FormatVolInfo.wszVolumePath), pVolume->szGuid )
::StringCchCopy( ARRAY_COUNT_PARAM(FormatVolInfo.wszLabel), pVolume->szLabel)
::StringCchCopy( ARRAY_COUNT_PARAM(FormatVolInfo.wszFsName), pVolume->szFsName)
GetPartitionInfo( pVolume->szGuid, &PartInfo )
IsDynamicVolume( pVolume->szGuid, &fDynamicVolume )
_RestoreVolumeInformation( pVolume, pfnFveEraseDrive, pfnFveOpenVolume, pfnFveCloseVolume )
SetMBRPartitionInfo( pVolume->szGuid, &PartInfo )
ERROR_NOT_FOUND
AsrFmt::_RestoreEspVolumeInformation
GetFileSytemName( pCurSifDisk->PartitionInfoTable[iSifPartition].FileSystemType, ARRAY_COUNT_PARAM(FormatVolInfo.wszFsName))
DiskGetDriveLayout( pCurSifDisk->AssignedTo->DeviceNumber, &pPhyDriveLayoutEx, &cbDrivelayout )
AsrFmt::PerformPreRestore
DiskBuildDevicePartitionPath( pCurSifDisk->AssignedTo->DeviceNumber, dwPhyPartNumber, TRUE, ARRAY_COUNT_PARAM(FormatVolInfo.wszVolumePath) )
_RestoreEspVolumeInformation(pAsrSys)
\??\Volume{
hMountMgr
\\.\MountPointManager
FormatInitialise
g_hIfsDll
fmifs.dll
FormatRoutineEx2 != NULL
FormatEx2
FormatVolume
g_dwFormatTlsIndex != TLS_OUT_OF_INDEXES
s_FormatVolumeThread
hThread
Quick
pFormatContext
fResult
IsVolumeIntact
%ws\*
pwszLabelName
pwszVolumeRootPath
pfIsIntactOut
AsrLdm::IsSifDiskDynamic
pSifDisk
pbIsDynamic
AsrLdm::OfflineAllPacks
pCurPack->IsDiskInPack( pSifDisk->DeviceNumber, &fInPack )
DoVdsIoctlCall(hVdsDriver, IOCTL_VOLMGR_QUERY_PACK_INFO, &QueryPackInBuffer, sizeof(QueryPackInBuffer), (void **)&pQueryPackOutBuffer)
pPackIdNotToOffline
AsrLdm::OnlinePack
DoVdsIoctlCall(hVdsDriver, IOCTL_VOLMGR_EXPORT_PACK, &ExportPackInBuffer, sizeof(ExportPackInBuffer), NULL)
DoVdsIoctlCall(hVdsDriver, IOCTL_VOLMGR_IMPORT_PACK, &ImportPackInBuffer, sizeof(ImportPackInBuffer), NULL)
pPackId
DevicePathToWin32Path(DD_VOLMGR_CONTROL_DEVICE_NAME, ARRAY_COUNT_PARAM(wszVolMgmtCtlPath))
pPackList
DoVdsIoctlCall(hVdsDriver, IOCTL_VOLMGR_ENUM_PACKS, NULL, 0, (void **)&pOutBuffer)
AsrLdm::InitializeForRestore
AsrLdm::InitializePhysicalPackListForRestore
NumPacks
AsrLdm::InitializeFromXMLDoc
m_pPackList
AsrLdm
DynPack
AsrLdm::PropagateDiskNotIntactByPack
pSifPack->GetPackId( &guidPackId )
pSifDiskList
AsrLdm::CheckPackIntactByDisk
pSifPack->IsDiskInPack( pCurSifDisk->DeviceNumber, &fInPack )
pfBasicDisks
pPhyDisk
pCurPack->IsDiskInPack( pPhyDisk->DeviceNumber, &fInPack )
pfIntact
pPhyPack->GetPackId( &guidPackId )
IsBasicDiskEmpty(pSifDisk, &fDiskEmpty)
pSifPack->IsPackIntact( pSifDiskList, pPhyPack, pfIntact )
pPhyPack->CheckPackDiskIntact( pSifDiskList, pfIntact )
pAsrSystem
AsrLdm::PerformPreRestore
pCurSifPack->GetRestoredPackId(&guidRestoredPackId)
hVdsDriver != INVALID_HANDLE_VALUE
AsrLdm::OnlinePack( hVdsDriver, &guidRestoredPackId)
AsrLdm::OfflineAllPacks( hVdsDriver, &guidRestoredPackId )
pCurSifPack->SetVolumeGuids( hVdsDriver )
pCurSifPack->ClearBootSectorForCriticalVolumes(hVdsDriver, &guidRestoredPackId)
AsrLdm::PerformPostRestore
pCurSifPack->AreAllSifDisksAssigned( pAsrSystem, &fAssigned )
::UuidCreate( &guidOfflineHive ) == RPC_S_OK
pAsrSystem->GetRestoredOfflinedHivePath(L"System", &pwszOfflineSystemHiveFilePath)
::RegLoadKey(HKEY_LOCAL_MACHINE, wszOfflineHive, pwszOfflineSystemHiveFilePath)
SafeStrConvertGuidString(&guidOfflineHive, ARRAY_COUNT_PARAM(wszOfflineHive))
AsrRegpGetDefaultCurrentControlSet(hkeyOfflineSystemHive, &hkeyOfflineDefaultCCS)
AsrRegpOpenHandle(wszOfflineHive, TRUE, &hkeyOfflineSystemHive)
m_pPackList[0].PerformPostRestore(hkeyOfflineDefaultCCS)
pInPackId
pDynDiskList
pDynVolList
DoVdsIoctlCall(hVdsDriver, IOCTL_VOLMGR_QUERY_PACK_INFO, &PackInBuffer, sizeof(PackInBuffer), (void **)&pPackOutBuffer)
DynPack::InitializePhysicalPackForRestore
pDynDiskList[ulDiskIndex].Initialize(hVdsDriver, pInPackId, &pDiskInfoOutBuffer->DiskIds[ulDiskIndex])
DoVdsIoctlCall(hVdsDriver, IOCTL_VOLMGR_ENUM_DISKS, &DiskInfoInBuffer, sizeof(DiskInfoInBuffer), (void **)&pDiskInfoOutBuffer)
pDynVolList[ulVolumeIndex].InitializePhysicalVolForRestore(hVdsDriver, pInPackId, &pVolInfoOutBuffer->VolumeIds[ulVolumeIndex])
DoVdsIoctlCall(hVdsDriver, IOCTL_VOLMGR_ENUM_VOLUMES, &VolInfoInBuffer, sizeof(VolInfoInBuffer), (void **)&pVolInfoOutBuffer)
PackId
DynPack::InitializeFromXMLDoc
IsOnline
PackName
NumDynVols
NumDynDisks
pDiskList
IsCritical
pVolumeList
DynDisk
DynVolume
DynPack::AreAllSifDisksAssigned
DynPack::CreateDisks
pfAssigned
SafeStrConvertGuidString(&guidCreatedPack, ARRAY_COUNT_PARAM(wszGuidString))
::StringCchCopy(ARRAY_COUNT_PARAM(CreateDiskInputBuffer.NewPackName), m_PackInfo.Name)
SafeStrConvertGuidString(&pCreateDiskOutputBuffer->DiskId, ARRAY_COUNT_PARAM(wszGuidString))
SafeStrConvertGuidString(&pCurrentSifDynDisk->m_DiskId, ARRAY_COUNT_PARAM(wszGuidString))
DynPack::CreateVolumes
SafeStrConvertGuidString(&m_PackId, ARRAY_COUNT_PARAM(wszGuidString))
DynPack::RestoreBootVolumePartitionId
pNewPackId
DiskGetDriveLayout( pSifDisk->AssignedTo->DeviceNumber, &pPhyDrivelayoutEx, &cbDrivelayout )
pAsrSys->GetSifDiskBySifDevNum( pCurrentSifDynDisk->GetDeviceNumber(), &pSifDisk )
DynPack::PerformPreRestore
DiskSetDriveLayout(pSifDisk->AssignedTo->DeviceNumber, pPhyDrivelayoutEx, cbDrivelayout)
CreateVolumes(hVdsDriver, &guidNewPackId)
CreateDisks( hVdsDriver, pAsrSys, &guidNewPackId )
DynPack::PerformPostRestore
RestoreBootVolumePartitionId( pAsrSys )
PrimaryPackId
SafeStrConvertGuidToStringWithBraces(&m_RestoredPackId, ARRAY_COUNT_PARAM(wszGuidString))
DynPack::IsDiskInPack
Services\VolMgrx
DynPack::IsPackIntact
pfInPack
pfPackIntact
pPhyPack
DynPack::SetVolumeGuids
pCurSifVolume->IsVolumeIntact( pSifDiskList, pCurPhyVolume, &fVolIntact )
DynPack::GetRestoredPackId
pSifDynVol->SetVolumeGuidName( hVdsDriver, &m_RestoredPackId )
DynPack::GetPackId
pguidRestoredPackId
DynPack::ClearBootSectorForCriticalVolumes
pguidPackId
DynPack::CheckPackDiskIntact
pSifDynVol->ClearCriticalVolumeBootSector( hVdsDriver, pguidRestoredPackId )
TraceVmVolumeLayout
SafeStrConvertGuidString(&pNextExtentLayout->DiskId, ARRAY_COUNT_PARAM(wszGuidString))
pVolumeLayout
pCreateVolumeInputBuffer
TraceCreateVolumeInputBuffer
SafeStrConvertGuidString(pOrigVolGuid, ARRAY_COUNT_PARAM(wszGuidString))
pOrigVolGuid
SafeStrConvertGuidString(&pCreateVolumeInputBuffer->VolumeId, ARRAY_COUNT_PARAM(wszGuidString))
SafeStrConvertGuidString(&pCreateVolumeInputBuffer->PackId, ARRAY_COUNT_PARAM(wszGuidString))
pQueryVolumeInfoBuffer
TraceQueryVolumeInfoBuffer
SafeStrConvertGuidString(pVolGuid, ARRAY_COUNT_PARAM(wszGuidString))
pVolGuid
pVolId
pDynPlexList
pDynPlexList[ulPlexIndex].Initialize(hVdsDriver, pPackId, pNextPlexLayout)
DynVolume::InitializePhysicalVolForRestore
pDynPhyVol
DynVolume::IsVolumeIntact
pCurSifPlex->IsPlexIntact( pSifDiskList, pCurPhyPlex, &fPlexIntact )
pfVolIntact
NumPlexes
DynVolume::InitializeFromXMLDoc
HasPartitions
IsSystem
IsBoot
VolumeLength
NumSymbolicNames
DynPlex
pPlexList
DynVolume::PackVolmgmtCreateVolumeBuffer
pSifDynDisks
pcbVolumeInputBuffer
ERROR_DEVICE_NOT_CONNECTED
pCreateVolInputBuffer
ERROR_INVALID_DATA
DynVolume::CreateVolume
DynVolume::SetVolumeGuidName
SetVolumeGuidName(hVdsDriver, pNewPackId)
AsrSystem::RestoreVolumeGuids( pwszDeviceName, m_pmwszVolumeNames )
DoVdsIoctlCall(hVdsDriver, IOCTL_VOLMGR_QUERY_VOLUME_INFO, &VolInfoInBuffer, sizeof(VolInfoInBuffer), (void **)&pVolInfoOutBuffer)
::StringCchPrintf(wszDevicePath, ARRAYSIZE(wszDevicePath), L"\\\\?\\GLOBALROOT%s", pwszDeviceName )
DynVolume::ClearCriticalVolumeBootSector
AsrpClearVolumeBootSector( wszDevicePath )
DynDisk::Initialize
DynDisk::PutRestoredDiskInfo
IsMissing
DynDisk::InitializeFromXMLDoc
PublicLength
PublicOffset
DeviceNumber
pQueryDiskInfoBuffer
DynDisk::TraceQueryDiskInfoBuffer
SafeStrConvertGuidString(&pQueryDiskInfoBuffer->GptDiskId, ARRAY_COUNT_PARAM(wszGuidString))
;&fMt
DynPlex::Initialize
pDynMemberList
pPlexLayout
pPhyPlex
DynPlex::IsPlexIntact
pCurSifMember->IsMemberIntact( pSifDiskList, pCurPhyMember, &fMemberIntact )
pfPlexIntact
NumMembers
DynPlex::InitializeFromXMLDoc
InterleaveLength
Percentage
Status
IsCurrentSystem
IsCurrentBoot
DynMember
pDynMember
pMemberLayout
DynMember::Initialize
DynMember::IsMemberIntact
pDynExtentList
pfMemberIntact
pPhyMember
DynMember::InitializeFromXMLDoc
pCurSifExtent->IsExtentIntact( pSifDiskList, pCurPhyExtent, &fExtentIntact )
NumExtents
DynExtent
pExtentList
7pExtentLayout
DynExtent::Initialize
DiskId
DynExtent::InitializeFromXMLDoc
Length
Offset
DynExtent::IsExtentIntact
pfExtentIntact
pPhyDiskExtent
-[ppwszVolumeGuidNameOut
AsrSystem::GetBootVolumeName
pwszVolumeGuidName
*ppwszVolumeGuidNameOut
DiskListMarkOfflineDisks
TracePhysicalDiskInfo
DeviceIoControl( hDisk, IOCTL_DISK_GET_DISK_ATTRIBUTES, NULL, 0, &DiskAttributes, sizeof(DiskAttributes), &dwBytesReturned, NULL)
dwRestoreFlags < ASR_ROF_INVALID
AsrSystem::InitializeForRestore
DiskBuses
Version
AsrVhd
Disks
_JoinLists( &pVirtualDiskList, m_pDiskListHead )
_TransferNodesFromList( &m_pDiskListHead, &AsrSystem::_IsVirtual, &pVirtualDiskList )
AsrSystem::_ExtractVersionFromXml
AsrVersion
%d.%d
Platform
MachineName
OSVersion
FirmwareType
BootSysDirectory
BootWinDirectory
AutoExtend
AsrSystem::_ExtractSystemFromXml
BusType
AsrSystem::_ExtractDiskBusesFromXml
NumBusType
pdwSifBusType
NumGptDisks
NumMbrDisks
MbrDisk
AsrSystem::_ExtractDisksFromXml
GptDisk
NumPartitions
pCurrentDisk
BusKey
PartitionTableSize
BytesPerSector
MbrSignature
TracksPerCylinder
SectorsPerTrack
MediaType
NumCylinders
IsExcluded
DiskSize
AsrSystem::_ExtractMbrDiskFromXml
IsShared
pTempDiskInfo
ppCurrentDisk
pTempDiskInfo->pDriveLayoutEx
GetDriveLayoutExSize( cEntriesInPartitionTable, &dwCurDriveLayoutExSize )
pTempDiskInfo->pPartition0Ex
pTempDiskInfo->pDiskGeometry
pTempDiskInfo->PartitionInfoTable
::DWordMult(sizeof(ASR_PTN_INFO), cEntriesInPartitionTable, &cbAsrPartitionInfoTable)
MbrPartition
GptGuid
AsrSystem::_ExtractGptDiskFromXml
MaxPartition
GetDriveLayoutExSize( cPartitions, &cbDriveLayoutEx )
tempDiskInfo
tempDiskInfo->pDiskGeometry
tempDiskInfo->pDriveLayoutEx
tempDiskInfo->PartitionInfoTable
tempDiskInfo->pPartition0Ex
GptPartition
PartitionFlag
PartitionIndex
PartitionType
BootFlag
PartitionOffset
FileSystemType
AsrSystem::_ExtractMbrPartitionFromXml
PartitionLength
pAsrExPartInfo
pPartInfo
pulPartitionIndex
GptAttributes
PartitionID
GptName
RelativeFilePath
VhdFileInfo
Flags
BlockSize
VirtualDisk
Sequence
NumFiles
NumDisks
pVhdFileInfo
AsrSystem::_ExtractVhdFileInfoFromXml
ppVirtualDiskInfo
AsrSystem::_ExtractVirtualDiskFromXml
rgVhdFileInfo
pVirtualDiskInfo
GetSifDiskBySifDevNum( pVirtualDiskInfo->m_dwDeviceNumber, &pDiskInfo )
AsrSystem::_ExtractAsrVhdFromXml
AsrSystem::_ExtractGptPartitionFromXml
VSS_E_INVALID_XML_DOCUMENT
(DWORD) VSS_E_ASRERROR_NO_PHYSICAL_DISK_AVAILABLE
AsrSystem::_RestoreDisks
DiskListMarkOfflineDisks( pPhysicalDiskList )
DiskListFreeNonFixedMedia(&pPhysicalDiskList)
(DWORD) VSS_E_ASRERROR_FIXED_PHYSICAL_DISK_AVAILABLE_AFTER_DISK_EXCLUSION
_TransferNodesFromList( &pPhysicalDiskList, &AsrSystem::_IsVirtual, &pVirtualDiskList )
AsrpCheckDiskIntact( pAsrLdm, pPhysicalSifDiskList)
AsrpDisksAssignment(pPhysicalSifDiskList, pPhysicalDiskList, pAsrLdm )
AsrSystem::_RecoverBcdStore
(DWORD) VSS_E_ASRERROR_DISK_RECREATION_FAILED
::StringCchCopy( ARRAY_COUNT_PARAM(wszGlobalPathOfBcdToRestore), m_wszSystemVolumeName )
!( m_dwRestoreFlags & ASR_ROF_SKIP_DISK_RECREATION ) || ( ( wcslen( m_wszSystemVolumeName ) > ::wcslen(L"\\\\?\\") ) && ( _wcsnicmp( m_wszSystemVolumeName, L"\\\\?\\", wcslen(L"\\\\?\\" ) ) == 0 ) )
pSystemDisk->AssignedTo
GetSystemPlex( m_pDiskListHead, TRUE, &pSystemDisk, &dwSifSystemPartitionIndex )
pSystemDisk->pDriveLayoutEx->PartitionStyle == PARTITION_STYLE_GPT
pSystemDisk->pDriveLayoutEx
DiskBuildDevicePartitionPath(dwPhySysDiskNumber, dwPhySystemPartNumber, TRUE, ARRAY_COUNT_PARAM(wszGlobalPathOfBcdToRestore))
FindPhysicalPartition( &pSystemDisk->pDriveLayoutEx->PartitionEntry[dwSifSystemPartitionIndex], pSystemDisk->AssignedTo, &dwPhySystemPartNumber )
::StringCchCat(ARRAY_COUNT_PARAM(wszGlobalPathOfBcdToRestore), BCD_STORE_FILEPATH)
\efi\microsoft\Boot\BCD
SafeStrConvertGuidString(&guidBcdkBkp, ARRAY_COUNT_PARAM(wszBcdTemp))
::CoCreateGuid( &guidBcdkBkp )
::StringCchCat( ARRAY_COUNT_PARAM(wszGlobalPathOfBcdTemp), wszBcdTemp )
::StringCchCopy( ARRAY_COUNT_PARAM(wszGlobalPathOfBcdTemp), wszGlobalPathOfBcdToRestore )
::StringCchCopy( ARRAY_COUNT_PARAM(wszNtSystemPartition), m_wszSystemVolumeName )
::CopyFileEx( wszGlobalPathOfBcdToRestore, wszGlobalPathOfBcdTemp, NULL, NULL, NULL, 0 )
ntStatus
DiskBuildDevicePartitionPath(dwPhySysDiskNumber, dwPhySystemPartNumber, FALSE, ARRAY_COUNT_PARAM(wszNtSystemPartition))
AsrSystem::_ClearSystemBootBits
AsrSystem::_UpdateRestoredRegistryMap
BootStat.dat
m_SystemInfo.BootWinDirectory
AsrSystem::_IsSupportedVersion
AsrSystem::_JoinLists
ERROR_OLD_WIN_VERSION
AsrSystem::_TransferNodesFromList
ppDiskListA
ppTransferList
ppDiskList
AsrSystem::_MarkActiveBitOnSystemPartitionHelper
!*ppTransferList
pSifSystemDisk->pDriveLayoutEx
pSifSystemDisk
pSifSystemDisk->pDriveLayoutEx->PartitionCount > dwSifSystemPartIndex
pSifSystemDisk->pDriveLayoutEx->PartitionStyle == PARTITION_STYLE_MBR || pSifSystemDisk->pDriveLayoutEx->PartitionStyle == PARTITION_STYLE_GPT
pSifSystemDisk->pDriveLayoutEx->PartitionStyle == pPhySystemDiskDriveLayout->PartitionStyle
DiskGetDriveLayout( dwPhySystemDiskNumber, &pPhySystemDiskDriveLayout, &cbPhySystemDiskDriveLayout)
DiskSetDriveLayout( dwPhySystemDiskNumber, pPhySystemDiskDriveLayout, cbPhySystemDiskDriveLayout )
ppwszOutVolumeName
AsrSystem::ExtractAllVolumeNames
VolumeMountPoint
pmwszAllVolumeNames
pbTempBufferVolNames
SymbolicName
AsrSystem::GetSifDiskAssignTo
AsrSystem::ExtractVolumeSymbolicNameXmlNode
AsrSystem::GetSifDiskBySifDevNum
pulAssignedToPhyDisk
ppSifDisk
AsrSystem::RestoreVolumeGuids
pmwszVolumeNames
pwszDeviceName
AsrSystem::PerformPreRestore
_RestoreDisks( pAsrLdm, pdwIncludeDisks, cIncludeDisks, pdwExcludeDisks, cExcludeDisks )
ERROR_UNSUPPORTED_TYPE
_RecoverBcdStore()
AsrSystem::PerformPostRestore
GetSystemPlex(m_pDiskListHead, TRUE, &pSifSystemDisk, &dwSifSystemPartIndex)
AsrSystem::MarkActiveBitOnSystemPartition
_MarkActiveBitOnSystemPartitionHelper( pSifSystemDisk, dwSifSystemPartIndex, pPhySystemDisk->DeviceNumber )
AsrSystem::GetRestoredOfflinedHivePath
ppwszHivePathnameOut
pwszHiveFilename
ERROR_FILE_NOT_FOUND
\config\
AsrSystem::SetBootAndSystemVolumeName
)ppSystemDiskOut
GetSystemPlex
GetBootPartition
pdwPartitionTableIndex
pSifDisk->AssignedTo
AsrpAssignPartitionsForDisk
pAssignedTo->pDriveLayoutEx
GetDriveLayoutExSize( pSifDisk->pDriveLayoutEx->PartitionCount, &cbNewDriveLayoutEx )
AsrpAssignPartitionsForDisk( pSifDisk )
AsrpAssignPartitions
pPhysicalDisk
AsrpAssignVolumeGuids
ERROR_BAD_DEVICE
DiskBuildDevicePartitionPath( pPhysicalDisk->DeviceNumber, pDriveLayoutEx_Physical->PartitionEntry[dwIndex].PartitionNumber, FALSE, ARRAY_COUNT_PARAM(wszDeviceName) )
ulBytesPerSector != 0
PutBootCodeOnDisk
pbIoBuffer
hPhyDisk
AsrpEraseBitlockedVolume
dwSetFileErrorCode
AsrpClearBootSector
EraseBitlockedDrive( wszVolumeName, pfnFveEraseDrive, pfnOpenVolume, pfnCloseVolume )
AsrpClearAllBootSectors
pbSectorBuffer
FindPhysicalPartition
pDriveLayoutEx
pdwPartitionNum
pSifPartInfo
pSifPartInfo->PartitionStyle == PARTITION_STYLE_MBR
DiskGetDriveLayout( pPhyDisk->DeviceNumber, &pPhyDriveLayoutEx, &cbDriveLayout)
AsrpClearBootSectorsCriticalVolumeOnly
pSifPartInfo->PartitionStyle == PARTITION_STYLE_GPT
FindPhysicalPartition( pPartionInfoEx, pSifDisk->AssignedTo, &dwPhysicalPartitionNum )
pSifDisk->IsIntact
IsDynamicVolume( wszPartitionDevicePath, &fDynamicVolume )
DiskBuildDevicePartitionPath(dwDeviceNumber, dwPhysicalPartitionNum, TRUE, ARRAY_COUNT_PARAM(wszPartitionDevicePath))
AsrpClearVolumeBootSector
AsrpClearVolumeBootSector(wszPartitionDevicePath)
hVolume != INVALID_HANDLE_VALUE
pwszVolume
DoDiskIoctlCall( hVolume, IOCTL_DISK_GET_DRIVE_GEOMETRY, NULL, 0, (void **)&pDiskGeometry, &cbDiskGeometry)
DeviceIoControl( hVolume, FSCTL_DISMOUNT_VOLUME, NULL, 0, NULL, 0, &dwBytesReturned, NULL )
::WriteFile( hVolume, pbSectorBuffer, pDiskGeometry->BytesPerSector, &dwBytesReturned, NULL )
::SetFilePointerEx( hVolume, liPositionToSeekTo, NULL, FILE_BEGIN )
pSifDisk != NULL
AsrpRecreateSifDisk
AsrpClearBootSectorsCriticalVolumeOnly(pSifDisk, pAssignTo->DeviceNumber)
pSifDisk->Style==PARTITION_STYLE_MBR || pSifDisk->Style==PARTITION_STYLE_GPT
GetDriveLayoutExSize( pAssignTo->pDriveLayoutEx->PartitionCount, &cbDriveLayoutEx )
AsrpClearAllBootSectors( hDisk, pAssignTo->pDriveLayoutEx, pAssignTo->pDiskGeometry->BytesPerSector, pAssignTo->DeviceNumber)
AsrpRecreateDisks
AsrpAssignVolumeGuids( pAssignTo, hDisk, pSifDisk )
\J/IPl(s*
AsrVhd::GetDeviceDependencyInformation
wszDevicepath
hDevice != INVALID_HANDLE_VALUE
ppDependencyInfo
pVhdInfo
dwError
AsrVhd::TraceVirtualDiskInfo
\\.\PhysicalDrive%lu
IsBasicDiskEmpty
pfDiskEmpty
pDisk
AsrpExcludeEmptyBasicSifDisks
pDisk->Style == PARTITION_STYLE_MBR || pDisk->Style == PARTITION_STYLE_GPT
IsBasicDiskEmpty( pSifDisk, &bEmpty )
pAsrLdm->IsSifDiskDynamic( pSifDisk, &bDynamicDisk )
!pSifDisk->IsCritical
!pSifDisk->AssignedTo
pAsrLdm
AsrpCheckDiskIntact
pAsrLdm->PropagateDiskNotIntactByPack( pSifDiskList, pCurSifDisk )
pAsrLdm->PropagateDiskNotIntactByPack ( pSifDiskList, pCurSifDisk )
pAsrLdm->CheckPackIntactByDisk( pSifDiskList, pCurSifDisk, pCurPhyDisk, &fBothBasic, &fIntact )
pPhysicalDiskList
AsrpAssignDiskToRdisk
VSS_E_ASRERROR_RDISK0_TOOSMALL
VSS_E_ASRERROR_DATADISK_RDISK0
AsrpAssignDiskToAnyRDisk
ERROR_NO_MATCH
AsrpAssignBootDisk
AsrpAssignSystemDisk
AsrpAssignBySignature
pSifBootDisk
AsrpConvertRawDisks
AsrpBasicDiskAssignmentPass
AsrpFindLastUsedPartition
pfConverted
AsrpAdjustDiskSizeToUsedPartitionSize
ppLastUsedPartition
AsrpFindLastUsedPartition(pSifDisk, &pLastUsedPartition )
pbIsDiskResized
pbAreDisksResized
AsrpAdjustDiskSizes
AsrpPerformDisksAssignment
AsrpAdjustDiskSizeToUsedPartitionSize( pSifDisk, &bDiskResized )
AsrpAssignSifDisksToPhysicalDisks( pSifDiskList, pPhysicalDiskList, pbCriticalDiskNoARC )
pbCriticalDiskNoARC
VSS_E_ASRERROR_NO_ARCPATH
AsrpDisksAssignment
pfCriticalDiskNoARC
AsrpAssignSifDisksToPhysicalDisks
VSS_E_ASRERROR_RDISK_FOR_SYSTEM_DISK_NOT_FOUND
GetSystemPlex( pSifDiskList, TRUE, &pSifSystemDisk, &dwSifSystemParIndex )
VSS_E_ASRERROR_CRITICAL_DISKS_TOO_SMALL
GetRdisk0DeviceNumber
SYSTEM\CurrentControlSet\Control\MiniNT
\\?\GLOBALROOT\arcname\multi(0)disk(0)rdisk(0)
pdwDeviceNumber
AsrGetSystemVolumeGlobalRootPath
DoStorageIoctlCall(hDisk, IOCTL_STORAGE_GET_DEVICE_NUMBER, NULL, 0, (void **)&pStorageDeviceNumber)
AsrGetSystemVolumeDevPath(wszDevicePath, ARRAYSIZE(wszDevicePath) )
AsrGetSystemVolumeDevPath
StringCchPrintf( pwszVolume, cchVolume, L"\\\\?\\GLOBALROOT%s", wszDevicePath )
pSysInfo
::StringCchCopyN( pwszVolume, cchVolume, pSysInfo->SystemPartition.Buffer, (pSysInfo->SystemPartition.Length)/sizeof(WCHAR) )
NtQuerySystemInformation( SystemSystemPartitionInformation, pSysInfo, cbRequiredSize, &cbRequiredSize)
ppPartitionTable
AsrpGetMorePartitionInfo
AsrGetSystemVolumeGlobalRootPath( wszSysVolPath, ARRAYSIZE(wszSysVolPath) )
GetRdisk0DeviceNumber(&dwRDisk0DevNumber)
DoVolumeIoctlCall(hSystemVolume, IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS, NULL, 0, (void **)&pSystemVolExtents, NULL)
hSystemVolume
hBootVolume
GetBootVolumeGuidName(&pwszBootVolGuidName)
pPartitionTable
DoVolumeIoctlCall(hBootVolume, IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS, NULL, 0, (void **)&pBootVolExtents, NULL)
\\?\GLOBALROOT
DiskBuildDevicePartitionPath( dwDeviceNumber, pCurPtnEx->PartitionNumber, FALSE, ARRAY_COUNT_PARAM(wszDevicePath) )
::StringCchPrintf( wszDevicePath, ARRAYSIZE(wszDevicePath), L"%s\\Device\\Harddisk%d\\Partition%d\\", L"\\\\?\\GLOBALROOT", dwDeviceNumber, pCurPtnEx->PartitionNumber )
%s\Device\Harddisk%d\Partition%d\
AsrpGetDiskLayout
GetFileSytemType( wszFsName, &pPartitionTable[dwIndex].FileSystemType )
AsrpGetMorePartitionInfo( pStorageDeviceNumber->DeviceNumber, pDriveLayoutEx, &pPartitionTable )
ERROR_BAD_ENVIRONMENT
DiskListPopulateLayoutInfo
::StringCchPrintf(ARRAY_COUNT_PARAM(wszErrorCodeString), L"0x%x", dwError)
DiskListInitialize
::StringCchPrintf(ARRAY_COUNT_PARAM(wszDeviceNumber), L"%d", pStorageDeviceNumber->DeviceNumber)
ERROR_IO_DEVICE
hdevInfo
pNewDisk
pDiDetail
::StringCchCopy(pNewDisk->DevicePath, cchDevicePath, pDiDetail->DevicePath)
pNewDisk->DevicePath
DiskListFreeExcludedDisks
MapExcludedDisks
MarkDisksToExcludeFromBitmap
UpdateExcludedSifDisksAsIncluded
pExcludeDisksBmp
UpdateExcludedSifDisksAsIncluded(pPhysicalDiskList, pSifDiskList, pdwRestoreOptIncludeDisks, cRestoreOptIncludeDisks)
AsrpMarkExclusionDisksForRestore
bmpPhysicalDisksToExclude.Set(dwSystemDiskDeviceNumber)
bmpPhysicalDisksToExclude.Initialize(dwPhysicalDeviceNumber+1)
MapExcludedDisks(pSifDiskList, pPhysicalDiskList)
MarkDisksToExcludeFromBitmap(pPhysicalDiskList, &bmpPhysicalDisksToExclude)
MapExcludedDisks(pPhysicalDiskList, pSifDiskList)
MarkUnaccessableDisksAsExcluded( pPhysicalDiskList )
(DWORD)VSS_E_ASRERROR_CRITICAL_DISK_CANNOT_BE_EXCLUDED
ReadReservationKeys
DeviceIoControl(hDisk, IOCTL_STORAGE_PERSISTENT_RESERVE_IN, &Param, Param.Size, pList, sizeof(PRI_RESERVATION_LIST), &cbReturned, NULL)
pfHasPRKeys
DeviceIoControl( hDisk, IOCTL_STORAGE_PERSISTENT_RESERVE_IN, &Param, Param.Size, pList, ulLen, &cbReturned, NULL)
pList
pBuffer
CheckDiskWritable
::ReadFile( hDisk, pBuffer, ulBytesPerSector, &cbRead, NULL )
::SetFilePointerEx( hDisk, liOffset, NULL, FILE_BEGIN )
::WriteFile( hDisk, pBuffer, ulBytesPerSector, &cbWritten, NULL )
ERROR_READ_FAULT
MarkUnaccessableDisksAsExcluded
ERROR_WRITE_FAULT
AsrRegGetDword
pdwOutRestoreInstanceCount
pwszValueName
pfOutValue
AsrRegGetBool
QuickFormat
SOFTWARE\MICROSOFT\WINDOWS NT\CurrentVersion\ASR\BackupSession
AsrRegSetRestoreInstanceCount
AsrRegIncrRestoreInstanceCount
AsrRegSetRestoreMapForDeviceNumber
SOFTWARE\MICROSOFT\WINDOWS NT\CurrentVersion\ASR\RestoreSession\RestorationMap
DeviceNumber{%d}
AsrRegClearExitCode
PostRestoreExitCode
PreRestoreExitCode
AsrRegSetExitCode
lDeleteValueResult
hkeyRestoreSession
AsrRegAddLastInstanceGuid
%d/%02d/%02d-%02d:%02d:%02d
SafeStrConvertGuidString(&guidAsrInstanceGuid, ARRAY_COUNT_PARAM(wszAsrInstanceString))
LastInstance
::StringCchPrintf( ARRAY_COUNT_PARAM(wszAsrInstanceString), L"%d/%02d/%02d-%02d:%02d:%02d", SystemTime.wYear, SystemTime.wMonth, SystemTime.wDay, SystemTime.wHour, SystemTime.wMinute, SystemTime.wSecond )
pwszOfflineHiveFilePaths
AsrRegUpdateOfflineSoftwareHive
AsrRegDeleteLastAliveStamp
::RegLoadKey(HKEY_LOCAL_MACHINE, wszOfflineHive, pwszOfflineHiveFilePaths)
Microsoft\Windows\CurrentVersion\Reliability
hkeyOfflineSoftwareHive
LastAliveStamp
lResult
pVolList
GetMultiStringFromVolumeList
ppbMultiStr
pbMultiStr
::StringCchCopy( pwszListCurrentStart, cFreeBuffer, pCurrentVol->szGuid )
pwszMultiVolumeList
hkeyOfflineRestoreSession
AsrRegUpdateReformattedVolume
RestoredVolumes
GetMultiStringFromVolumeList( pVolList, &cbMultiStr, &pbMultiStr )
AsrRegUpdateRestoreSession
::RegSetValueEx( hkeyOfflineRestoreSession, ASR_REG_RESTORED_VOLUME, 0, REG_MULTI_SZ, pbMultiStr, cbMultiStr )
RegCreateKeyEx( hkeyOfflineSoftwareHive, ASR_REG_PATH_OFFLINE_SOFTWARE_RESTORE_SESSION, 0, NULL, NULL, KEY_ALL_ACCESS, NULL, &hkeyOfflineAsrRestoreSession, &dwDisposition)
MICROSOFT\WINDOWS NT\CurrentVersion\ASR\RestoreSession
AsrRegUpdateReformattedVolume( hkeyOfflineAsrRestoreSession, pVolList )
AsrRegAddLastInstanceGuid( hkeyOfflineAsrRestoreSession )
pwszNewString
SafeStrJoinN
pguidToConvert && pwszGuidStringOut
::StringCchCat(pwszNewString, cchNewString, pwszCurString)
%.8x-%.4x-%.4x-%.2x%.2x-%.2x%.2x%.2x%.2x%.2x%.2x
SafeStrExtractVersionNumber
pdwMajorVersion
pwszVersionString
::DWordAdd((cElements/8), 1, &cbNeeded)
pdwMinorVersion
pbBitmap
LogEvent
EnablePrivilege
pValue
ERROR_DATATYPE_MISMATCH
hSystemKey
AsrRegpGetDefaultCurrentControlSet
Current
phDefaultCCSKey
ControlSet%03d
Select
::StringCchPrintf( ARRAY_COUNT_PARAM(wszDefaultCCSKeyName), L"ControlSet%03d", dwDefaultCCSId )
/~OphOutDiskHandle
DiskOpen
dwLastError
pIoctlOutputBuffer
ppOutDriveLayout
DiskGetDriveLayout
pDriveLayout
DiskSetDriveLayout
SafeStrConvertGuidString(&pDriveLayoutEx->Gpt.DiskId, ARRAY_COUNT_PARAM(wszGuidString))
DiskTraceDriveLayout
SafeStrConvertGuidString(&pPartitionInfo->Gpt.PartitionId, ARRAY_COUNT_PARAM(wszGuidString))
multi(0)disk(0)rdisk(
pdwRdiskNumberOut
pwszDevicePathOut
DiskBuildDevicePartitionPath
DiskForceDriversSync
%s\Device\Harddisk%d\Partition%d
pwszlpcszArcName
\Arcname\
ppwszNtPath
pwszNTName
pwszFullArcPath
ppwszArcPathOut
pwszNtPath
pbDirInfo
\Arcname
pwszArcPath
SYMBOLICLINK
::DWordSub( cPartition, 1, &cbDriveLayoutEx)
pcbDriveLayoutEx
::DWordAdd(cbDriveLayoutEx, sizeof(DRIVE_LAYOUT_INFORMATION_EX), &cbDriveLayoutEx)
::DWordMult(cbDriveLayoutEx, sizeof(PARTITION_INFORMATION_EX), &cbDriveLayoutEx)
ppwszVolumeGuidOut
wszVolumeName
FveOpenVolumeW
FveCloseVolume
FveApi.dll
FveEraseDrive
DeviceIoControl( hVolume, IOCTL_VOLUME_IS_DYNAMIC, NULL, 0, &fDynamic, sizeof(fDynamic), &dwBytesReturned, NULL )
GetPartitionInfo
IsDynamicVolume
pfDynamicVolume
SetMBRPartitionInfo
pPartInfo->PartitionStyle == PARTITION_STYLE_MBR
pwszVolumePath
EraseBitlockedDrive
hrFve
pwszNameToQuery
pQueryPointInput
ppOutQueryPointOutput
dwIoctlLastError
pQueryPointOutput
MtMgrDeletePoint
pwszNameToDelete
pCreatePointInput
symbolic link
pDeletePointInput
device name
MtMgrGetSymbolicNames
ppmwszOutSymbolicNames
pwszSymbolicName
pwszNametoGetMtPointsOn
ppMountPointsOut
pmwszSymbolicNames
MtMgrGetMountPoints
hMountMgrOut != NULL
MtMgrCreateMountPoint
pwszFormattedName
MtMgrOpen
pwszDevicePath
ERROR_TIMEOUT
COfflineDriverInjection::InitializeOfflineDriverInject
amd64
%PROCESSOR_ARCHITECTURE%
_GetExtensionProcAddress<PDRIVERSTOREOFFLINEADDDRIVERPACKAGE> ( ASR_OFFLINE_DRIVER_INJECTION_EXTENSION_NAME, &hDrvStoreDll, &pfnDriverStoreOfflineAddDriverPackage )
COfflineDriverInjection::MountAndSetWinDirPathForOfflineOSVolume
COfflineDriverInjection::InjectDriversInOfflineOS
OfflineDriverInjectionExtension
s_pwszWindowsDirectoryPathForOfflineOS
INBOX
wszMountPoint
COfflineDriverInjection::InjectDriverPackageInOfflineOS
wszLocalInfName
3rd Party
COfflineDriverInjection::EnumerateAndInjectFromDriverStore
AsrRegpOpenHandle(ASR_KEY_PATH, FALSE, &hkeyOpenKey)
AsrRegpQueryValueSz(hkeyOpenKey, wszExtensionName, &wszExtensionValue)
COfflineDriverInjection::_GetExtensionProcAddress
SOFTWARE\Microsoft\Windows NT\CurrentVersion\ASR
szFunctionName
pFnLocal != NULL
dwByteCount > 0
BootIsSystemStartFromFixedDisk
SYSTEM\CurrentControlSet\Control
AsrRegpOpenHandle(BOOT_REGPATH_SYSTEM_START_OPTION, FALSE, &hkeyOpenKey)
pdwDeviceNumberOut
pfIsSystemDiskFixed
RDPATH=
\\?\GLOBALROOT\Arcname\%s
SystemStartOptions
AsrRegpQueryValueSz(hkeyOpenKey, BOOT_REGVALUE_SYSTEM_START_OPTION, &pwszSystemStartOption)
SetLastShutdownGood
pwszBootStatusPathname
::StringCchPrintf(ARRAY_COUNT_PARAM(wszWin32VolumeName), L"\\\\?\\GLOBALROOT\\Arcname\\%s", pwszArcNameStart)
hSystemPartition
::RtlGetSetBootStatusData( hBootStatusData, TRUE, RtlBsdPowerTransition, &bsdPowerTransition, sizeof(bsdPowerTransition),NULL)
::RtlGetSetBootStatusData( hBootStatusData, FALSE, RtlBsdPowerTransition, &bsdPowerTransition, sizeof(bsdPowerTransition),NULL)
hBootStatusData
::RtlGetSetBootStatusData( hBootStatusData, FALSE, RtlBsdItemBootShutdown, &fLastShutdownGood, sizeof(fLastShutdownGood),NULL)
RSDSh3
vssapi.pdb
.text$di
.text$lp01vssapi.dll!20_pri7
.text$lp03vssapi.dll!30_clientonly
.text$mn
.text$mn$00
.text$np
.text$x
.text$yd
.text$zs
.text$zy
.text$zz
.rdata$brc
.rdata$zz$brc
.idata$5
.00cfg
.CRT$XCA
.CRT$XCU
.CRT$XCZ
.CRT$XIA
.CRT$XIAA
.CRT$XIZ
.gehcont
.gfids
.giats
.rdata
.rdata$00
.rdata$01
.rdata$03
.rdata$voltmd
.rdata$zETW0
.rdata$zETW1
.rdata$zETW2
.rdata$zETW9
.rdata$zz
.rdata$zzzdbg
.xdata
.xdata$x
.didat$2
.didat$3
.didat$4
.didat$6
.didat$7
.edata
.idata$2
.idata$3
.idata$4
.idata$6
.data$brc
.data$00$brc
.data$dk00$brc
.data$r$brc
.data$zz$brc
.data
.data$00
.data$dk00
.data$dk01
.data$zz
.bss$00
.bss$03
.bss$dk00
.bss$dk01
.bss$pr00
.bss$pr03
.bss$zz
.pdata
.didat$5
.rsrc$01
.rsrc$02
$>":$
(8":(
(8@JL
CoTaskMemAlloc
OpenServiceW
CoCreateInstance
CoTaskMemFree
CoTaskMemRealloc
OpenSCManagerW
CloseServiceHandle
CLSIDFromString
QueryServiceStatus
CoUninitialize
CoInitializeEx
LookupAccountSidLocalW
ReportEventW
RegisterEventSourceW
ConvertSidToStringSidW
DeregisterEventSource
CoGetClassObject
WNetGetUniversalNameW
UuidFromStringW
StringFromCLSID
CoCreateGuid
CoDisconnectObject
UuidToStringW
RpcStringFreeW
CoWaitForMultipleHandles
CreateStreamOnHGlobal
CreateXmlReader
CreateXmlReaderInputWithEncodingName
ConvertStringSecurityDescriptorToSecurityDescriptorW
CoSetProxyBlanket
CoDisconnectContext
CoImpersonateClient
CoRevertToSelf
ConvertStringSidToSidW
LookupAccountNameLocalW
NetLocalGroupGetMembers
NetApiBufferFree
DsRoleGetPrimaryDomainInformation
DsRoleFreeMemory
JetGetSystemParameterW
JetGetInstanceInfoW
JetFreeBuffer
JetOSSnapshotPrepare
JetOSSnapshotFreezeW
JetOSSnapshotThaw
JetOSSnapshotAbort
InetPtonW
GetNameInfoW
UuidCreate
CM_Get_Parent
GetStorageDependencyInformation
SetupDiDestroyDeviceInfoList
SetupDiEnumDeviceInterfaces
SetupDiGetClassDevsW
SetupDiGetDeviceInterfaceDetailW
SetupEnumPublishedInfW
SetupGetInfDriverStoreLocationW
pSetupGetFileTitle
BcdSetSystemStoreDevice
BcdImportStoreWithFlags
 !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNO
VSSAPI.DLL
??0CVssJetWriter@@QEAA@XZ
??0CVssWriter@@QEAA@XZ
??1CVssJetWriter@@UEAA@XZ
??1CVssWriter@@UEAA@XZ
?AreComponentsSelected@CVssJetWriter@@IEBA_NXZ
?AreComponentsSelected@CVssWriter@@IEBA_NXZ
?CreateVssBackupComponents@@YAJPEAPEAVIVssBackupComponents@@@Z
?CreateVssExamineWriterMetadata@@YAJPEAGPEAPEAVIVssExamineWriterMetadata@@@Z
?GetBackupType@CVssJetWriter@@IEBA?AW4_VSS_BACKUP_TYPE@@XZ
?GetBackupType@CVssWriter@@IEBA?AW4_VSS_BACKUP_TYPE@@XZ
?GetContext@CVssJetWriter@@IEBAJXZ
?GetContext@CVssWriter@@IEBAJXZ
?GetCurrentLevel@CVssJetWriter@@IEBA?AW4_VSS_APPLICATION_LEVEL@@XZ
?GetCurrentLevel@CVssWriter@@IEBA?AW4_VSS_APPLICATION_LEVEL@@XZ
?GetCurrentSnapshotSetId@CVssJetWriter@@IEBA?AU_GUID@@XZ
?GetCurrentSnapshotSetId@CVssWriter@@IEBA?AU_GUID@@XZ
?GetCurrentVolumeArray@CVssJetWriter@@IEBAPEAPEBGXZ
?GetCurrentVolumeArray@CVssWriter@@IEBAPEAPEBGXZ
?GetCurrentVolumeCount@CVssJetWriter@@IEBAIXZ
?GetCurrentVolumeCount@CVssWriter@@IEBAIXZ
?GetRestoreType@CVssJetWriter@@IEBA?AW4_VSS_RESTORE_TYPE@@XZ
?GetRestoreType@CVssWriter@@IEBA?AW4_VSS_RESTORE_TYPE@@XZ
?GetSnapshotDeviceName@CVssJetWriter@@IEBAJPEBGPEAPEBG@Z
?GetSnapshotDeviceName@CVssWriter@@IEBAJPEBGPEAPEBG@Z
?Initialize@CVssJetWriter@@QEAAJU_GUID@@PEBG_N211K@Z
?Initialize@CVssWriter@@QEAAJU_GUID@@PEBGW4VSS_USAGE_TYPE@@W4VSS_SOURCE_TYPE@@W4_VSS_APPLICATION_LEVEL@@KW4VSS_ALTERNATE_WRITER_STATE@@_N1@Z
?InstallAlternateWriter@CVssWriter@@QEAAJU_GUID@@0@Z
?IsBootableSystemStateBackedUp@CVssJetWriter@@IEBA_NXZ
?IsBootableSystemStateBackedUp@CVssWriter@@IEBA_NXZ
?IsPartialFileSupportEnabled@CVssJetWriter@@IEBA_NXZ
?IsPartialFileSupportEnabled@CVssWriter@@IEBA_NXZ
?IsPathAffected@CVssJetWriter@@IEBA_NPEBG@Z
?IsPathAffected@CVssWriter@@IEBA_NPEBG@Z
?OnAbortBegin@CVssJetWriter@@UEAAXXZ
?OnAbortEnd@CVssJetWriter@@UEAAXXZ
?OnBackOffIOOnVolume@CVssWriter@@UEAA_NPEAGU_GUID@@1@Z
?OnBackupComplete@CVssWriter@@UEAA_NPEAVIVssWriterComponents@@@Z
?OnBackupCompleteBegin@CVssJetWriter@@UEAA_NPEAVIVssWriterComponents@@@Z
?OnBackupCompleteEnd@CVssJetWriter@@UEAA_NPEAVIVssWriterComponents@@_N@Z
?OnBackupShutdown@CVssWriter@@UEAA_NU_GUID@@@Z
?OnContinueIOOnVolume@CVssWriter@@UEAA_NPEAGU_GUID@@1@Z
?OnFreezeBegin@CVssJetWriter@@UEAA_NXZ
?OnFreezeEnd@CVssJetWriter@@UEAA_N_N@Z
?OnIdentify@CVssJetWriter@@UEAA_NPEAVIVssCreateWriterMetadata@@@Z
?OnIdentify@CVssWriter@@UEAA_NPEAVIVssCreateWriterMetadata@@@Z
?OnPostRestore@CVssWriter@@UEAA_NPEAVIVssWriterComponents@@@Z
?OnPostRestoreBegin@CVssJetWriter@@UEAA_NPEAVIVssWriterComponents@@@Z
?OnPostRestoreEnd@CVssJetWriter@@UEAA_NPEAVIVssWriterComponents@@_N@Z
?OnPostSnapshot@CVssJetWriter@@UEAA_NPEAVIVssWriterComponents@@@Z
?OnPostSnapshot@CVssWriter@@UEAA_NPEAVIVssWriterComponents@@@Z
?OnPreRestore@CVssWriter@@UEAA_NPEAVIVssWriterComponents@@@Z
?OnPreRestoreBegin@CVssJetWriter@@UEAA_NPEAVIVssWriterComponents@@@Z
?OnPreRestoreEnd@CVssJetWriter@@UEAA_NPEAVIVssWriterComponents@@_N@Z
?OnPrepareBackup@CVssWriter@@UEAA_NPEAVIVssWriterComponents@@@Z
?OnPrepareBackupBegin@CVssJetWriter@@UEAA_NPEAVIVssWriterComponents@@@Z
?OnPrepareBackupEnd@CVssJetWriter@@UEAA_NPEAVIVssWriterComponents@@_N@Z
?OnPrepareSnapshotBegin@CVssJetWriter@@UEAA_NXZ
?OnPrepareSnapshotEnd@CVssJetWriter@@UEAA_N_N@Z
?OnThawBegin@CVssJetWriter@@UEAA_NXZ
?OnThawEnd@CVssJetWriter@@UEAA_N_N@Z
?OnVSSApplicationStartup@CVssWriter@@UEAA_NXZ
?OnVSSShutdown@CVssWriter@@UEAA_NXZ
?SetWriterFailure@CVssJetWriter@@IEAAJJ@Z
?SetWriterFailure@CVssWriter@@IEAAJJ@Z
?Subscribe@CVssWriter@@QEAAJK@Z
?Uninitialize@CVssJetWriter@@QEAAXXZ
?Unsubscribe@CVssWriter@@QEAAJXZ
CreateVssBackupComponentsInternal
CreateVssExamineWriterMetadataInternal
CreateVssExpressWriterInternal
CreateVssSnapshotSetDescription
CreateWriter
CreateWriterEx
DllCanUnloadNow
DllGetClassObject
GetProviderMgmtInterface
GetProviderMgmtInterfaceInternal
IsVolumeSnapshotted
IsVolumeSnapshottedInternal
LoadVssSnapshotSetDescription
ShouldBlockRevert
ShouldBlockRevertInternal
VssFreeSnapshotProperties
VssFreeSnapshotPropertiesInternal
__CxxFrameHandler4
__C_specific_handler
_vsnwprintf
_wcsicmp
realloc
wcscat_s
_purecall
_wcsnicmp
towupper
malloc
memcpy_s
??1exception@@UEAA@XZ
??0exception@@QEAA@XZ
??0exception@@QEAA@AEBV0@@Z
_vsnprintf_s
_callnewh
??0exception@@QEAA@AEBQEBDH@Z
?what@exception@@UEBAPEBDXZ
_CxxThrowException
__CxxFrameHandler3
??0exception@@QEAA@AEBQEBD@Z
memcpy
memmove
_XcptFilter
_amsg_exit
_initterm
msvcrt.dll
?terminate@@YAXXZ
_lock
_unlock
__dllonexit
_onexit
??1type_info@@UEAA@XZ
EtwRegisterTraceGuidsW
EtwGetTraceEnableLevel
SizeofResource
VirtualProtect
RegEnumValueW
EnterCriticalSection
EtwGetTraceLoggerHandle
lstrcpynW
RegDeleteValueW
DeviceIoControl
VirtualAlloc
GetModuleFileNameW
RegOpenKeyExW
LeaveCriticalSection
InitializeCriticalSection
GetVolumePathNameW
CreateFileW
CharNextW
RegSetValueExW
RegEnumKeyExW
EtwGetTraceEnableFlags
GetVolumeNameForVolumeMountPointW
CreateEventW
MultiByteToWideChar
GetLastError
RegCreateKeyExW
CharPrevW
CloseHandle
EtwUnregisterTraceGuids
GetSystemInfo
FindResourceExW
ResetEvent
LoadResource
HeapDestroy
GetProcAddress
LocalFree
DeleteCriticalSection
GetModuleHandleW
FreeLibrary
RegQueryInfoKeyW
RegCloseKey
lstrcmpiW
VirtualQuery
GetDriveTypeW
LoadLibraryExW
GetModuleFileNameA
CreateSemaphoreExW
HeapFree
SetLastError
ReleaseSemaphore
GetModuleHandleExW
InitializeCriticalSectionAndSpinCount
WaitForSingleObject
GetCurrentThreadId
ReleaseMutex
Sleep
FormatMessageW
OutputDebugStringW
WaitForSingleObjectEx
OpenSemaphoreW
HeapAlloc
CreateMutexExW
GetCurrentProcessId
GetProcessHeap
DebugBreak
IsDebuggerPresent
CreateThread
RtlCaptureContext
RtlLookupFunctionEntry
RtlVirtualUnwind
UnhandledExceptionFilter
SetUnhandledExceptionFilter
GetCurrentProcess
TerminateProcess
QueryPerformanceCounter
GetSystemTimeAsFileTime
GetTickCount
ntdll.dll
api-ms-win-core-libraryloader-l1-2-0.dll
api-ms-win-core-memory-l1-1-0.dll
api-ms-win-core-registry-l1-1-0.dll
api-ms-win-core-synch-l1-1-0.dll
api-ms-win-core-string-obsolete-l1-1-0.dll
api-ms-win-core-io-l1-1-0.dll
api-ms-win-core-file-l1-1-0.dll
api-ms-win-core-string-l2-1-0.dll
api-ms-win-core-file-l1-2-0.dll
api-ms-win-core-string-l1-1-0.dll
api-ms-win-core-errorhandling-l1-1-0.dll
api-ms-win-core-handle-l1-1-0.dll
api-ms-win-core-sysinfo-l1-1-0.dll
api-ms-win-core-heap-l1-1-0.dll
api-ms-win-core-heap-l2-1-0.dll
api-ms-win-core-processthreads-l1-1-0.dll
api-ms-win-core-synch-l1-2-0.dll
api-ms-win-core-localization-l1-2-0.dll
api-ms-win-core-debug-l1-1-0.dll
api-ms-win-core-rtlsupport-l1-1-0.dll
api-ms-win-core-profile-l1-1-0.dll
VssTrace.DLL
_vsnprintf
iswdigit
wcstoul
_wtoi
_wtoi64
towlower
_errno
_beginthreadex
wcschr
_wcsdup
wcsncmp
wcsrchr
wcspbrk
tolower
wcstok
GetTokenInformation
GetCommandLineW
OpenThreadToken
OpenProcessToken
GetCurrentThread
LoadStringW
GetVersionExW
LocalAlloc
WideCharToMultiByte
LockResource
FreeResource
EventUnregister
EventRegister
EventSetInformation
EventWriteTransfer
SetEvent
AcquireSRWLockExclusive
EventActivityIdControl
SetThreadToken
EqualSid
IsValidSid
RevertToSelf
DuplicateToken
ReadFile
GetWindowsDirectoryW
FindFirstFileW
FindNextFileW
RaiseException
InitOnceBeginInitialize
InitOnceComplete
FindClose
ReleaseSRWLockExclusive
ResumeThread
GlobalAlloc
GlobalLock
GlobalFree
GlobalUnlock
DeleteFileW
GetSystemWindowsDirectoryW
WriteFile
GetFileAttributesW
CreateDirectoryW
CreateMutexW
GetTickCount64
AllocateAndInitializeSid
CheckTokenMembership
FreeSid
PrivilegeCheck
CreateWellKnownSid
InitializeSecurityDescriptor
SetSecurityDescriptorOwner
GetLengthSid
CopySid
SetSecurityDescriptorGroup
SetSecurityDescriptorDacl
GetAclInformation
GetAce
AddAce
InitializeAcl
AddAccessDeniedAceEx
AddAccessAllowedAceEx
GetSidSubAuthorityCount
EqualDomainSid
RegQueryValueExW
GetFullPathNameW
ExpandEnvironmentStringsW
EtwTraceMessage
RtlInitUnicodeString
NtClose
NtFsControlFile
NtQueryInformationFile
RtlNtStatusToDosError
NtCreateFile
NtQueryVolumeInformationFile
GetComputerNameExW
RtlIpv6StringToAddressW
RtlIpv4StringToAddressW
ResolveDelayLoadedAPI
DelayLoadFailureHook
api-ms-win-security-base-l1-1-0.dll
api-ms-win-core-processenvironment-l1-1-0.dll
api-ms-win-eventing-provider-l1-1-0.dll
api-ms-win-core-heap-obsolete-l1-1-0.dll
api-ms-win-core-file-l2-1-0.dll
api-ms-win-core-kernel32-legacy-l1-1-1.dll
api-ms-win-core-delayload-l1-1-1.dll
api-ms-win-core-delayload-l1-1-0.dll
swscanf
qsort
wcsstr
GetVolumeInformationW
SetErrorMode
TlsSetValue
EncodePointer
TlsAlloc
DecodePointer
TlsGetValue
RegLoadKeyW
RegUnLoadKeyW
NtQuerySystemInformation
CopyFileExW
SetFilePointer
SetFilePointerEx
GetSystemTime
RtlAdjustPrivilege
NtOpenSymbolicLinkObject
NtQuerySymbolicLinkObject
NtOpenDirectoryObject
NtQueryDirectoryObject
GetLogicalDrives
SetVolumeMountPointW
GetVolumePathNamesForVolumeNameW
RtlUnlockBootStatusData
RtlGetSetBootStatusData
api-ms-win-core-util-l1-1-0.dll
memcmp
memset
wcscmp
.?AVlogic_error@std@@
.?AVlength_error@std@@
.?AVout_of_range@std@@
.?AVbad_alloc@std@@
.?AVexception@@
.?AV_com_error@@
.?AVResultException@wil@@
TCPAu2
fSfSfUfh
Invalid partition table
Error loading operating system
Missing operating system
VS_VERSION_INFO
StringFileInfo
040904B0
CompanyName
Microsoft Corporation
FileDescription
Microsoft
 Volume Shadow Copy Requestor/Writer Services API DLL
FileVersion
10.0.22621.1 (WinBuild.160101.0800)
InternalName
VSSAPI.DLL
LegalCopyright
 Microsoft Corporation. All rights reserved.
OriginalFilename
VSSAPI.DLL
ProductName
Microsoft
 Windows
 Operating System
ProductVersion
10.0.22621.1
VarFileInfo
Translation
<Schema name="VssComponentMetadata"
        xmlns="urn:schemas-microsoft-com:xml-data"
        xmlns:dt="urn:schemas-microsoft-com:datatypes">
<AttributeType name="filespec" dt:type="string" required="yes">
   <description>
   File specification.  Can include wildcard characters ? and *
   </description>
</AttributeType>
<AttributeType name="path" dt:type="string" required="yes">
   <description>
   Path to a file.  The path can include environment variables or
   values extracted from registry keys.
   </description>
</AttributeType>
<AttributeType name="recursive" dt:type="enumeration"
               dt:values="yes no" default="no">
   <description>
   Is path specified recursive or limited to the directory that is specified.
   </description>
</AttributeType>
<AttributeType name="alternatePath" dt:type="string" required="no">
   <description>
   Alternate path in which to find the file.  Files in a file group may
   have been copied to an alternative location by the writer.  Backup should
   pick up the files from the alternative location instead of the original
   location but should restore the files to their original location
   </description>
</AttributeType>
<AttributeType name="logicalPath" dt:type="string" required="no">
   <description>
   Logical path for a database or file group.  This logical name uses backslash
   as separators to form a logical namespace hierarchy
   </description>
</AttributeType>
<AttributeType name="componentName" dt:type="string" required="yes">
   <description>
   Name used to identify a database or file group.  May be qualified by a
   logical path.
   </description>
</AttributeType>
<AttributeType name="version" dt:type="enumeration" dt:values="1.0 1.1 1.2 1.3" required="yes">
   <description>
   Version of a specific document
   </description>
</AttributeType>
<AttributeType name="writerId" dt:type="uuid" required="yes">
   <description>
   Unique id to identify the writer.  Note that this identifies the
   writer class rather than a specific instance of the writer.
   </description>
</AttributeType>
<AttributeType name="instanceId" dt:type="uuid" required="no">
   <description>
   Unique id identifying the instance of a writer during backup.  It
   has no meaning during restore.
   </description>
</AttributeType>
<AttributeType name="instanceName" dt:type="string" required="no">
   <description>
   Unique generated by the writer that identifies the instance of a writer
   both during backup and restore.  This id is used to map writers at backup
   time to writers at restore time.
   </description>
</AttributeType>
<AttributeType name="backupSchema" dt:type="number" required="no">
   <description>
Describes the writer capabilities and how different types of backup are performed.
   </description>
</AttributeType>
<ElementType name="BACKUP_COMPONENTS" content="eltOnly" model="closed" order="many">
   <description>
   Components that are backed up or restored.
   Used to communicate between the writer and the backup application during
   backup and restore.
   </description>
   <AttributeType name="selectComponents" dt:type="enumeration"
                       dt:values="yes no" default="no">
      <description>
      Does the backup application select individual components or
      does it backup entire volumes
      </description>
   </AttributeType>
   <AttributeType name="bootableSystemStateBackup" dt:type="enumeration"
                  dt:values = "yes no" default="no" >
      <description>
      Is backup saving the bootable state of the system.
      </description>
   </AttributeType>
   <AttributeType name="backupType" dt:type="enumeration"
                  dt:values="full differential incremental log copy other"
                  default="full">
      <description>
      Type of backup being performed.
      </description>
   </AttributeType>
   <AttributeType name="restoreType" dt:type="enumeration"
dt:values="byCopy import other"
default="byCopy">
   <description>
   Type of restore being performed.
   </description>
   </AttributeType>
   <AttributeType name="partialFileSupport" dt:type="enumeration"
                  dt:values= "yes no" default="no" >
       <description>
       Indicates whether the requestor is capable of backing up and restoring
       portions of files.  If no, then the writer should never generate
       PARTIAL_FILE or DIRECTED_RESTORE elements.
       Only entire files can be backed up or restored.
       </description>
   </AttributeType>
   <AttributeType name="snapshotSetId" dt:type="uuid" required="no">
       <description>
       this is the unique identifier for the snapshot set
       </description>
   </AttributeType>
   <attribute type="version" />
   <attribute type="selectComponents" />
   <attribute type="bootableSystemStateBackup" />
   <attribute type="backupType" />
   <attribute type="restoreType" />
   <attribute type="partialFileSupport" />
   <attribute type="snapshotSetId" />
   <element type= "WRITER_COMPONENTS" />
   <element type= "SNAPSHOT_SET_DESCRIPTION" minOccurs="0" maxOccurs="*" />
</ElementType>
<ElementType name="WRITER_COMPONENTS" content="eltOnly" model="closed"
             order="many">
   <description>
   Components that are backed up and restored that are associated with a
   specific writer instance
   </description>
   <attribute type="writerId" />
   <attribute type="instanceId" />
   <attribute type="instanceName" />
   <attribute type="backupSchema" />
   <element type="COMPONENT" />
</ElementType>
<ElementType name="COMPONENT" content="eltOnly" model="open" order="many">
   <AttributeType name="backupSucceeded" dt:type="enumeration"
                  dt:values="yes no" default="no">
      <description>
      Indication of whether the component was backed up successfully
      or not.  This should be set during the BackupComplete notification
      </description>
   </AttributeType>
   <AttributeType name="componentType" dt:type="enumeration"
                  dt:values="database filegroup">
       <description>
       Indication of whether component is database or file group
       </description>
   </AttributeType>
   <AttributeType name="backupStamp" dt:type="string" required="no">
       <description>
       This string attribute contains the identifier assigned to the
       backup by the writer.  The attribute is set by the writer either
       during the PrepareBackup or PostSnapshot event.
       </description>
    </AttributeType>
   <AttributeType name="previousBackupStamp" dt:type="string" required="no">
       <description>
       In the case of an incremental or differential backup, this identifies
       the backup from which differences are compouted.  This attribute is
       set by the requestor prior to the PrepareBackup event.
       </description>
   </AttributeType>
   <AttributeType name="selectedForRestore" dt:type="enumeration"
                  dt:values="yes no"  default="no" >
       <description>
       This yes/no attribute is set by the request prior to calling
       PreRestore and indicates whether the component is being restored
       or not.
       </description>
   </AttributeType>
   <AttributeType name="additionalRestores" dt:type="enumeration"
                  dt:values="yes no" default="no" >
       <description>
       This yes/no attribute is set by the requestor prior to calling
       PreRestore and indicates whether additional restores of the
       component will follow (i.e., ull restore followed by log restores
       </description>
   </AttributeType>
   <AttributeType name="restoreTarget" dt:type="enumeration"
                  dt:values="original alternate directed originalLocation"
                  default="original" >
       <description>
       This enumerated attribute is set by the writer during PreRestore
       and indicates whether the files for the component should be restored
       to their original location, alternate location (as expressed by
       ALTERNATE_LOCATION_MAPPING elements in the metadata), new location
       (as expressed by RESTORE_TARGET elements created by the writer) or
       should be partially restored (as expressed by the DIRECTED_TARGET
       element created by the writer.
       </description>
   </AttributeType>
   <AttributeType name="preRestoreFailureMsg" dt:type="string" required="no">
       <description>
       This attirbute is set by the writer during the PreRestore event if
       the preRestore operation failed for some reason.  It gives a textual
       description of why the preRestore failed.
       </description>
   </AttributeType>
   <AttributeType name="filesRestored" dt:type="enumeration"
                  dt:values= "none all failed" default="all" >
       <description>
       This attribute is set by the requestor after restoring files
       for the component (i.e., between the PreRestore and PostRestore
       events).  Yes indicates that the files were restored successfully;
       no indicates that the files were not restored and the original files
       are intact; failed indicates that the original files were partially
       overwritten and are therefore corrupt.  Note that the failed status
       can only occur in the situation of a restore of a file where only
       part of the data is restored (DIRECTED_RESTORE) or where only part
       of a file is backed up and restored (e.g., as part of a differential
       backup).  In these cases a failed restore occurs if some of the data
       to be restored is written to the file but not all.  In this case,
       the original copy of the file no long exists and the copy on tape is
       not complete and therefore cannot be used to create a consistent
       copy.  The only option is to use a previous full backup to restore
       the data.  Note that the "failed" indication can be used to indicate
       that some, but no all of the files of a component were restored.  The
       requestore is required to either restore all the files of a component
       or none of the files.  However, there are situations where this is
       not possible, and the restoration of a component has failed, but
       cannot be completely undone.
       </description>
   </AttributeType>
   <AttributeType name="postRestoreFailureMsg" dt:type="string" required="no">
       <description>
       This string attribute is set by the writer during the PostRestore
       event.  It is a text message indicating why the restore failed.
       </description>
   </AttributeType>
   <AttributeType name="backupOptions" dt:type="string" required="no">
       <description>
       This is a private string passed between the requestor and the writer
       to control the backup of the component.  It should be set by the
       requestor prior to the PrepareBackup event.
       </description>
   </AttributeType>
   <AttributeType name="restoreOptions" dt:type="string" required = "no">
       <description>
       This is a private string passsed between to requestor and the writer
       to control the restore of a component.  It should be set by the
       requestor prior to the PreRestore event.
       </description>
   </AttributeType>
   <AttributeType name="restoreInstanceId" dt:type="uuid" required = "no">
       <description>
       This is an attribute that allows a writers component to be restored by a specific
       instance of the writer at restore time.  
       </description>
   </AttributeType>
    <AttributeType name="authRestore" dt:type="enumeration"
               dt:values="yes no" default="no">
      <description>
        This attributes determines whether restore of this component should be authoritative
        or not.
      </description>
    </AttributeType>
    <AttributeType name="rollForwardType" dt:type="enumeration" required = "no"
               dt:values="none all partial">
      <description>
        This attributes determines how far a writer should roll forward restored data
        or not.
      </description>
    </AttributeType>
    <AttributeType name="rollForwardPoint" dt:type="string" required = "no">
      <description>
        This attributes determines how far a writer should roll forward restored data
        or not.
      </description>
    </AttributeType>
    <AttributeType name="restoreName" dt:type="string" required = "no">
      <description>
      This attribute allows a requestor to rename a component at restore time.
      </description>
    </AttributeType>
   <AttributeType name="prepareForBackupFailureMsg" dt:type="string" required="no">
       <description>
       This attirbute is set by the writer during the PrepareForBackup event if
       the PrepareForBackup operation failed for some reason.  It gives a textual
       description of why the PrepareForBackup failed.
       </description>
   </AttributeType>
   <AttributeType name="PostSnapshotFailureMsg" dt:type="string" required="no">
       <description>
       This attirbute is set by the writer during the PostSnapshotFailureMsg event if
       the PostSnapshotFailureMsg operation failed for some reason.  It gives a textual
       description of why the PostSnapshotFailureMsg failed.
       </description>
   </AttributeType>
   <AttributeType name="FailureMsg" dt:type="string" required="no">
       <description>
       This attribute allows writer to set event-independent, per-component error message
       in case of a partial failure.
       </description>
   </AttributeType>
   <AttributeType name="ErrorCode" dt:type="number" required="no">
       <description>
       This attribute allows writer to set basic HRESULT error code on the component
       in case of a partial failure.
       </description>
   </AttributeType>
   <AttributeType name="ApplicationErrorCode" dt:type="number" required="no">
       <description>
       This attribute allows writer to set extended error code information on the component
       in case of a partial failure.
       </description>
   </AttributeType>
   <attribute type="componentType" />
   <attribute type="logicalPath" />
   <attribute type="componentName" />
   <attribute type="restoreInstanceId" />
   <attribute type="backupSucceeded" />
   <attribute type="backupOptions" />
   <attribute type="restoreOptions" />
   <attribute type="backupStamp" />
   <attribute type="previousBackupStamp" />
   <attribute type="selectedForRestore" />
   <attribute type="additionalRestores" />
   <attribute type="restoreTarget" />
   <attribute type="preRestoreFailureMsg" />
   <attribute type="filesRestored" />
   <attribute type="postRestoreFailureMsg" />
   <attribute type="authRestore" />
   <attribute type="rollForwardType" />
   <attribute type="rollForwardPoint" />
   <attribute type="restoreName" />
   <attribute type="prepareForBackupFailureMsg" />
   <attribute type="PostSnapshotFailureMsg" />
   <attribute type="FailureMsg" />
   <attribute type="ErrorCode" />
   <attribute type="ApplicationErrorCode" />
   <element type="ALTERNATE_LOCATION_MAPPING" minOccurs="0" maxOccurs="*" />
   <element type="BACKUP_METADATA" minOccurs="0" maxOccurs="1" />
   <element type="RESTORE_METADATA" minOccurs="0" maxOccurs="1" />
   <element type="RESTORE_TARGET" minOccurs="0" maxOccurs="*" />
   <element type="DIRECTED_TARGET" minOccurs="0" maxOccurs="*" />
   <element type="PARTIAL_FILE" minOccurs="0" maxOccurs="*" />
   <element type="RESTORE_SUBCOMPONENT" minOccurs="0" maxOccurs="*" />
   <element type="DIFFERENCED_FILE" minOccurs="0" maxOccurs="*" />
</ElementType>
<ElementType name="ALTERNATE_LOCATION_MAPPING" content="empty" model="closed">
  <description>
     Mapping from a location that was backed up to a location to restore to.
  </description>
   <attribute type="path" />
   <attribute type="filespec" />
   <attribute type="recursive" />
   <attribute type="alternatePath" />
</ElementType>
<ElementType name="BACKUP_METADATA" content="empty" model="closed">
   <description>
   Default metadata element for backup.  Content is a binary hex string.
   Note that the writer can store whatever he wants in the component.  This
   is just a simple default mechanism.
   </description>
   <AttributeType name="metadata" dt:type="string" required="yes">
      <description>
      Metadata to be passed on restore
      </description>
   </AttributeType>
   <attribute type="metadata" />
</ElementType>
<ElementType name="RESTORE_METADATA" content="empty" model="closed">
   <description>
   Default metadata element for passing information from the writer's
   PreRestore event to the writer's PostRestore event.  The data is
   opaque to the requestor.
   </description>
   <AttributeType name="metadata" dt:type="string" required="yes">
      <description>
      Metadata to be passed from PreRestore to PostRestore.
      </description>
   </AttributeType>
   <attribute type="metadata" />
</ElementType>
<ElementType name="RESTORE_TARGET" content="empty" model="closed">
   <description>
   This element in a COMPONENT should be supplied if the value of the
   restoreTarget attribute of the COMPONENT is "new".  It supplies a
   mapping from a the original location of the file to the location where
   the file should be restored.  There may be multiple RESTORE_TARGET
   elements within a component.
   </description>
   <attribute type="path" />
   <attribute type="filespec" />
   <attribute type="recursive" />
   <attribute type="alternatePath" />
</ElementType>
<ElementType name="DIRECTED_TARGET" content="empty" model="closed">
   <description>
   This element in a COMPONENT should be should be supplied if the value
   of the restoreTarget attribute of the COMPONENT is "directed".  It
   is intended to support partial restoration of files or potentially
   how files should be reorganized upon restore.  There may be multiple
   DIRECTED_TARGET elements within a component.
   </description>
   <AttributeType name="targetPath" dt:type="string" required="no">
       <description>
       This is the target location of the file that is to be written
       by the requestor.  If this attribute is not specified then
       the targetPath is assumed to be the same as the original path.
       </description>
   </AttributeType>
   <AttributeType name="targetFilespec" dt:type="string" required="no">
       <description>
       This is the name of the file that is to be written
       by the requestor.  If this is not specified then the target filename
       is assumed to be the same as the original file name.  Note that if
       both the targetPath and targetFilespec are not specified then the
       original file is overwritten.
       </description>
   </AttributeType>
   <AttributeType name="sourceRanges" dt:type="string" required ="yes">
       <description>
       This is a string of the form (offset:cb ...) where each offset
       is the byte offset to start reading data and cb is the length
       of the data to be read (each is a 64 bit integer).  The ranges
       may not overlap and must be monotonically increasing.
       </description>
   </AttributeType>
   <AttributeType name="targetRanges" dt:type="string" required="yes">
       <description>
       This is a string of the form (offset:cb ...) where each offset
       is the byte offset to start wrting data and cb is the length of
       the data to be written (each is a 64 bit integer).  The ranges
       may not overlap and must be monotonically increasing.
       </description>
   </AttributeType>
   <attribute type="path" />
   <attribute type="filespec" />
   <attribute type="targetPath" />
   <attribute type="targetFilespec" />
   <attribute type="sourceRanges" />
   <attribute type="targetRanges" />
</ElementType>
<ElementType name="PARTIAL_FILE" content="empty" model="closed">
   <description>
   This element in a COMPONENT is supplied by the writer during the
   PostRestore event.  It indicates that only a portion of the file
   should be backed up.  There may be multiple PARTIAL_FILE elements
   within a single COMPONENT.
   </description>
   <AttributeType name="ranges" dt:type="string" required="no">
       <description>
       This range list has the form (offset:length ...) where offset is
       the byte offset in the file to be backed up and length is the length
       of the data to be backed up.  Both are 64 bit integers.  The ranges
       must be monotonically increasing and must not overlap.  If the
       rangelist is not specified then the entire file should be backed up.
       </description>
   </AttributeType>
   <AttributeType name="metadata" dt:type="string" required="no">
       <description>
       This is metadata used by the writer for restoring the partial
       backup.  It might for example, include the total size of the
       file to be restored.
       </description>
   </AttributeType>
   <attribute type="path" />
   <attribute type="filespec" />
   <attribute type="ranges" />
   <attribute type="metadata" />
</ElementType>
<ElementType name="RESTORE_SUBCOMPONENT" content="empty" model="closed">
   <description>
   This element in a COMPONENT is added by the requestore prior to the
   PreRestore event.  It allows a subcomponent of a backed up component to
   be restored.
   </description>
   <AttributeType name="repair" dt:type="enumeration"
                  dt:values="yes no" default="no">
       <description>
       This indicates that the purpose of the restore is to repair one or more files
       of the component.  The writer is responsible for identifying what
       is to be restored using a DIRECTED_TARGET element.
       </description>
   </AttributeType>
   <attribute type="logicalPath" />
   <attribute type="componentName" />
   <attribute type="repair" />
</ElementType>
<ElementType name="SNAPSHOT_SET_DESCRIPTION" content="eltOnly" model="closed">
   <description>
   This describes a snapshot, including the snapshot set id as well as
   the volume information for the snapshotted volumes
   </description>
   <AttributeType name="snapshotSetId" dt:type="uuid" required="yes">
       <description>
       this is the unique identifier for the snapshot
       </description>
   </AttributeType>
   <AttributeType name="context" dt:type="ui4" required="yes">
       <description>
       this is the context used to create the snapshot
       </description>
   </AttributeType>
   <AttributeType name="metadata" dt:type="string" required="no">
       <description>
       this is private metadata about the snapshot set
       </description>
   </AttributeType>
   <AttributeType name="description" dt:type="string" required="no">
       <description>
       this is a user description of the snapshot
       </description>
   </AttributeType>
   <AttributeType name="originalCount" dt:type="ui4" required="yes">
       <description>
       this is the original count of snapshots in the snapshot set
       </description>
   </AttributeType>
   <attribute type="snapshotSetId" />
   <attribute type="context" />
   <attribute type="description" />
   <attribute type="metadata" />
   <attribute type="originalCount" />
   <element type="SNAPSHOT_DESCRIPTION" minOccurs="0" maxOccurs="*" />
</ElementType>
<ElementType name="SNAPSHOT_DESCRIPTION" content="eltOnly" model="closed">
   <description>
   This is the description of a snapshotted volume
   </description>
   <AttributeType name="snapshotId" dt:type="uuid" required="yes" >
       <description>
       This is the unique id of the snapshotted volume
       </description>
   </AttributeType>
   <AttributeType name="originatingMachine" dt:type="string" required="yes" >
       <description>
       This is the machine where the original volume was snapshotted
       </description>
   </AttributeType>
   <AttributeType name="serviceMachine" dt:type="string" required="yes" >
       <description>
       This is the Application Server machine (i.e. where the writers were notified)
       </description>
   </AttributeType>
   <AttributeType name="originalVolumeName" dt:type="string" required ="yes">
       <description>
       This is the original name of the volume.
       </description>
   </AttributeType>
   <AttributeType name="snapshotAttributes" dt:type="ui4" required="yes">
       <description>
       this describes the actual snapshot attributes (as defined in
       VSS_VOLUME_SNAPSHOT_ATTRIBUTES)
       </description>
   </AttributeType>
   <AttributeType name="deviceName" dt:type="string" required="no" >
        <description>
        This is the internal device name for the snapshotted volume.  This
        can be used if the snapshot is not exposed.
        </description>
   </AttributeType>
   <AttributeType name="exposedName" dt:type="string" required="no" >
       <description>
       This is the exposed name of the snapshot volume
       </description>
   </AttributeType>
   <AttributeType name="exposedPath" dt:type="string" required="no">
       <description>
       If only a subdirectory is exposed, this is the path to that
       subdirectory.
       </description>
   </AttributeType>
   <AttributeType name="providerId" dt:type="uuid" required="yes">
       <description>
       This is the provider that surfaced the snapshot
       </description>
   </AttributeType>
   <AttributeType name="timestamp" dt:type="ui8" required="yes">
       <description>
       this is when the snapshot set was created.
       </description>
   </AttributeType>
    <AttributeType name="isDynamicVolume" dt:type="enumeration"
                   dt:values="yes no" required="yes" >
        <description>
        Is the original volume for the snapshot dynamic or basic
        </description>
    </AttributeType>
   <AttributeType name="mappedSnapshotId" dt:type="uuid" required="no">
       <description>
       This is the id of the mapped local snapshot in case that this 
        object stands for a remote virtual snapshot
       </description>
   </AttributeType>
   <AttributeType name="mappedVolumeName" dt:type="string" required ="no">
       <description>
       This is the name of the volume that maps to the original share 
        in case that this object stands for a remote snapshot
       </description>
   </AttributeType>
   <AttributeType name="mappedPathFromRoot" dt:type="string" required ="no">
       <description>
       This is the path of the original share from the volume root. 
        Relevant only if that this object stands for a remote snapshot
       </description>
   </AttributeType>
   <attribute type="snapshotId" />
   <attribute type="providerId" />
   <attribute type="snapshotAttributes" />
   <attribute type="originatingMachine" />
   <attribute type="serviceMachine" />
   <attribute type="originalVolumeName" />
   <attribute type="timestamp" />
   <attribute type="deviceName" />
   <attribute type="exposedPath" />
   <attribute type="exposedName" />
   <attribute type="isDynamicVolume" />
   <attribute type="mappedSnapshotId" />
   <attribute type="mappedVolumeName" />
   <attribute type="mappedPathFromRoot" />
   <element type="LUN_MAPPING" minOccurs="0" maxOccurs="*"/>
</ElementType>
<ElementType name="LUN_MAPPING" content="eltOnly" model="closed">
    <description>
    Actual mapping of source lun to a destination lun
    </description>
    <AttributeType name="sourceDevice" dt:type="string" required="yes" >
        <description>
        This is the device name of the source device on the originating
        machine.  Note that this is only used during snapshot creation
        </description>
    </AttributeType>
    <AttributeType name="lunID" dt:type="uuid" required="no" >
        <description>
        Longhorn Server.
        This GUID is written on all source LUNs at creation time.
        It is needed to match LUNs at import time.
        </description>
    </AttributeType>
    <element type="SOURCE_LUN" minOccurs="1" maxOccurs="1" />
    <element type="DESTINATION_LUN" minOccurs="1" maxOccurs="1" />
    <element type="DISK_EXTENT" minOccurs="1" maxOccurs="*" />
    <attribute type="sourceDevice" />
    <attribute type="lunID" />
</ElementType>
<ElementType name="DISK_EXTENT" content="empty" model="closed">
    <description>
    A particular disk extent on a LUN
    </description>
    <AttributeType name="startingOffset" dt:type="ui8" required="yes">
        <description>
        starting offset of the extent in sectors
        </description>
    </AttributeType>
    <AttributeType name="extentLength" dt:type="ui8" required="yes">
        <description>
        length of the extent in sectors
        </description>
    </AttributeType>
    <attribute type="startingOffset" />
    <attribute type="extentLength" />
</ElementType>
<ElementType name="SOURCE_LUN" content="eltOnly" model="closed">
   <description>
   The information for the lun on the originating volume
   </description>
   <element type="LUN_INFORMATION" />
</ElementType>
<ElementType name="DESTINATION_LUN" content="eltOnly" model="closed">
   <description>
   The information for the lun on the snapshotted volume
   </description>
   <element type="LUN_INFORMATION" />
</ElementType>
<ElementType name="INTERCONNECT_DESCRIPTION" content="empty" model="closed">
   <description>
   An interconnect address including the address type
   </description>
   <AttributeType name="interconnectAddressType" dt:type="enumeration"
                  dt:values="FCFS FCPH FCPH3 MAC Scsi" required="yes" >
       <description>
       interconnect address type.  Describes type of the interconnect
       address stored in the interconnectAddress attribute
       </description>
   </AttributeType>
   <AttributeType name="port" dt:type="string" required="no">
      <description>
      Port through which the interconnect address is referred to.  Note
      that the same device may have different interconnect addresses through
      different ports.
      </description>
   </AttributeType>
   <AttributeType name="interconnectAddress" dt:type="string" required="yes">
       <description>
       World Wide name or other interconnect address of the device
       </description>
   </AttributeType>
   <attribute type="interconnectAddressType" />
   <attribute type="port" />
   <attribute type="interconnectAddress" />
</ElementType>
<ElementType name="LUN_INFORMATION" content="eltOnly" model="closed">
    <description>
    enough of the location and name of the lun to transport it. TBD
    </description>
   <AttributeType name="busType" dt:type="enumeration"
              dt:values="Scsi Atapi Ata 1394 Ssa Fibre Usb RAID iScsi Sas Sata"
              required="yes" >
       <description>
       Type of bus that the LUN is attached to
       </description>
   </AttributeType>
   <AttributeType name="deviceType" dt:type="ui1" required="yes" >
       <description>
       SCSI-2 device type
       </description>
   </AttributeType>
   <AttributeType name="deviceTypeModifier" dt:type="ui1" required="yes">
       <description>
       SCSI-2 device type modifier (if any) - this may be 0
       </description>
   </AttributeType>
   <AttributeType name="commandQueueing" dt:type="enumeration"
                  dt:values="yes no" default="no" >
       <description>
       Flag indicating whether the device can support mulitple outstanding
       commands.  The actual synchronization in this case is the
       responsibility of the port driver.
       </description>
   </AttributeType>
   <AttributeType name="vendorId" dt:type="string" required="no" >
       <description>
       Optional string identifying the vendor
       </description>
   </AttributeType>
   <AttributeType name="productId" dt:type="string" required="no" >
       <description>
       Optional string identifying the product
       </description>
   </AttributeType>
   <AttributeType name="productRevision" dt:type="string" required="no" >
       <description>
       Optional product revision information
       </description>
   </AttributeType>
   <AttributeType name="serialNumber" dt:type="string" required="no" >
       <description>
       Optional serial number of the device
       </description>
   </AttributeType>
   <AttributeType name="diskSignature" dt:type="uuid" required="yes">
       <description>
       Disk signature or GUID.  If a signature than all but the lower
       32 bits of the GUID are 0.
       </description>
   </AttributeType>
   <AttributeType name="deviceIdentification" dt:type="string" required="yes" >
       <description>
       UUENCODED binary for the device identification page as
       defined by the STORAGE_DEVICE_ID_DESCRIPTOR structure.  This contains
       the vendor id, EUI-64 id, FC-PH name, and vendor specific data.
       </description>
   </AttributeType>
   <element type="INTERCONNECT_DESCRIPTION" minOccurs="0" maxOccurs="*"/>
   <attribute type="deviceType" />
   <attribute type="deviceTypeModifier" />
   <attribute type="commandQueueing" />
   <attribute type="busType" />
   <attribute type="vendorId" />
   <attribute type="productId" />
   <attribute type="productRevision" />
   <attribute type="serialNumber" />
   <attribute type="diskSignature" />
   <attribute type="deviceIdentification" />
</ElementType>
<ElementType name="DIFFERENCED_FILE" content="empty" model="closed">
<description>
The writer used these elements to indicate differenced files.
</description>
<AttributeType name="lastModifyLSN" dt:type="string" required="no" >
<description>
The LSN that indicates the point of the last backup.
</description>
</AttributeType>
<AttributeType name="lastModifyTimeLow" dt:type="number" default="0" >
<description>
The time that indicates the point of the last backup.
</description>
</AttributeType>
<AttributeType name="lastModifyTimeHigh" dt:type="number" default="0" >
<description>
The time that indicates the point of the last backup.
</description>
</AttributeType>
<attribute type="path" />
<attribute type="filespec"  />
<attribute type="recursive" />
<attribute type="lastModifyLSN" />
<attribute type="lastModifyTimeLow" />
<attribute type="lastModifyTimeHigh" />
</ElementType>
</Schema>
<Schema name="VssWriterMetadataInfo"
        xmlns="urn:schemas-microsoft-com:xml-data"
    xmlns:dt="urn:schemas-microsoft-com:datatypes">
<AttributeType name="filespec" dt:type="string" required="yes">
   <description>
   File specification.  Can include wildcard characters ? and *
   </description>
</AttributeType>
<AttributeType name="path" dt:type="string" required="yes">
   <description>
   Path to a file.  The path can include environment variables or
   values extracted from registry keys.
   </description>
</AttributeType>
<AttributeType name="recursive" dt:type="enumeration"
               dt:values="yes no" default="no">
   <description>
   Is path specified recursive or limited to the directory that is specified.
   </description>
</AttributeType>
<AttributeType name="alternatePath" dt:type="string" required="no">
   <description>
   Alternate path in which to find the file.  Files in a file group may
   have been copied to an alternative location by the writer.  Backup should
   pick up the files from the alternative location instead of the original
   location but should restore the files to their original location
   </description>
</AttributeType>
<AttributeType name="logicalPath" dt:type="string" required="no">
   <description>
   Logical path for a database or file group.  This logical name uses backslash
   as separators to form a logical namespace hierarchy
   </description>
</AttributeType>
<AttributeType name="componentName" dt:type="string" required="yes">
   <description>
   Name used to identify a database or file group.  May be qualified by a
   logical path.
   </description>
</AttributeType>
<AttributeType name="restoreMetadata" dt:type="enumeration"
               dt:values="yes no" default="no">
   <description>
   Restore metadata exists for this database or file group.  Backup
   application should capture the restore metadata and pass it to the
   writer on restore.
   </description>
</AttributeType>
<AttributeType name="notifyOnBackupComplete" dt:type="enumeration"
               dt:values="yes no" default="no">
   <description>
   Writer should be notified when backup is complete whether this
   database or file group was successfully backed up or not.
   </description>
</AttributeType>
<AttributeType name="caption" dt:type="string" required="no">
   <description>
   Textual Description of database or file group
   </description>
</AttributeType>
<AttributeType name="icon" dt:type="string" required="no">
   <description>
   Icon associated with database or file group
   </description>
</AttributeType>
<AttributeType name="selectable" dt:type="enumeration"
               dt:values="yes no" default="yes">
   <description>
   Is this component selectable for backup or is it always backed up.
   If no, then the component is always backed up if any other components of
   the application/service are backed up.  If yes, then the
   component may be selectively backed up.
   </description>
</AttributeType>
<AttributeType name="selectableForRestore" dt:type="enumeration"
               dt:values="yes no" default="no">
   <description>
   Is this component selectable for restore
   </description>
</AttributeType>
<AttributeType name="version" dt:type="enumeration" dt:values="1.0 1.1 1.2 1.3" required="yes">
   <description>
   Version of a specific document
   </description>
</AttributeType>
<AttributeType name="writerId" dt:type="uuid" required="yes">
   <description>
   Unique id to identify the writer.  Note that this identifies the
   writer class rather than a specific instance of the writer.
   </description>
</AttributeType>
<AttributeType name="instanceId" dt:type="uuid" required="no">
   <description>
   Unique id identifying the instance of a writer during backup.  It
   has no meaning during restore.
   </description>
</AttributeType>
<AttributeType name="instanceName" dt:type="string" required="no">
   <description>
   Unique id generated by the writer that identifies the instance of a writer
   both during backup and restore.  This id is used to map writers at backup
   time to writers at restore time.
   </description>
</AttributeType>
<AttributeType name="componentFlags" dt:type="number" default="0">
   <description>
   Contains extra flags that describe the component being backed up.   
   </description>
</AttributeType>
<AttributeType name="backupSchema" dt:type="number" default="0">
<description>
Describes the writer capabilities and how different types of backup are performed.
</description>
</AttributeType>
<AttributeType name="filespecBackupType" dt:type="number" default="0">
<description>
Describes how backup should be performed on a specific filespec.
</description>
</AttributeType>
<ElementType name="WRITER_METADATA" content="eltOnly" model="open" order="one">
   <description>
      Information used by Backup application to backup/restore data
   </description>
   <attribute type="version" />
   <attribute type="backupSchema" />
   <element type="IDENTIFICATION" />
   <element type="BACKUP_LOCATIONS" minOccurs="0" />
   <element type="RESTORE_METHOD" minOccurs="0" />
</ElementType>
<ElementType name="IDENTIFICATION" content="empty" model="closed">
   <description>
      Identification of a service/application backing up data
   </description>
   <AttributeType name="friendlyName" dt:type="string" required="yes">
      <description>
      Friendly name used to describe the service or application.
      </description>
   </AttributeType>
   <AttributeType name="usage" dt:type="enumeration"
           dt:values="USER_DATA BOOTABLE_SYSTEM_STATE SYSTEM_SERVICE OTHER"
           default="OTHER">
      <description>
      How the data associated with the writer is used.  For now we
      distinguish user data and system state.
      </description>
   </AttributeType>
   <AttributeType name="dataSource" dt:type="enumeration"
               dt:values="TRANSACTION_DB NONTRANSACTIONAL_DB OTHER"
           default="OTHER">
      <description>
      Description of the nature of the data manager.  Currently only
      databases are identified
      </description>
   </AttributeType>
   <AttributeType name="majorVersion" dt:type="number" default="1">
     <description>
       Major version number of the writer.
     </description>
   </AttributeType>
   <AttributeType name="minorVersion" dt:type="number" default="0">
     <description>
       Minor version number of the writer.
     </description>
   </AttributeType>
   <attribute type="instanceId" required="yes" />
   <attribute type="instanceName" />
   <attribute type="writerId" />
   <attribute type="friendlyName" />
   <attribute type="usage" />
   <attribute type="dataSource" />
   <attribute type="majorVersion" />
   <attribute type="minorVersion" />
</ElementType>
<ElementType name="BACKUP_LOCATIONS" content="eltOnly" model="closed" order="many">
   <description>
      Files to include and exclude from the backup
   </description>
   <element type="INCLUDE_FILES" minOccurs="0" />
   <element type="EXCLUDE_FILES" minOccurs="0" />
   <element type="EXCLUDE_FILES_FROM_SNAPSHOT" minOccurs="0" />   
   <element type="DATABASE" minOccurs="0"/>
   <element type="FILE_GROUP" minOccurs="0" />
</ElementType>
<ElementType name="INCLUDE_FILES" content="empty">
   <description>
      Files to include in the backup, essentially files to backup if you want
      to backup this application/service
   </description>
   <attribute type="path" />
   <attribute type="filespec" />
   <attribute type="recursive" />
   <attribute type="alternatePath" />
</ElementType>
<ElementType name="EXCLUDE_FILES" content="empty">
   <description>
      Files that should always be excluded from the backup
   </description>
   <attribute type="path" />
   <attribute type="filespec" />
   <attribute type="recursive" />
</ElementType>
<ElementType name="EXCLUDE_FILES_FROM_SNAPSHOT" content="empty">
   <description>
      Files that should always be excluded from the backup
   </description>
   <attribute type="path" />
   <attribute type="filespec" />
   <attribute type="recursive" />
</ElementType>
<ElementType name="DATABASE" content="eltOnly" model="closed" order="many">
   <description>
      List of databases of interest.  This is used to allow selective
      backup and restore of specific databases.
   </description>
   <attribute type= "logicalPath" />
   <attribute type="componentName" />
   <attribute type="caption" />
   <attribute type="icon" />
   <attribute type="restoreMetadata" />
   <attribute type="notifyOnBackupComplete" />
   <attribute type="selectable" />
   <attribute type="selectableForRestore" />
   <attribute type="componentFlags" />
   <element type="DATABASE_FILES" minOccurs="1" />
   <element type="DATABASE_LOGFILES" />
   <element type="DEPENDENCY" minOccurs="0" />
</ElementType>
<ElementType name="DATABASE_FILES" content="empty" model="closed">
   <description>
      Location of a set of database files.  Filespec can include wildcards
   </description>
   <attribute type="path" />
   <attribute type="filespec" />
   <attribute type="filespecBackupType" />
</ElementType>
<ElementType name="DATABASE_LOGFILES" content="empty" model="closed">
   <description>
      Location of a set of database log files.  Filespec can include
      wildcards.  Indication of whether database log files are truncated.
   </description>
   <attribute type="path" />
   <attribute type="filespec" />
   <attribute type="filespecBackupType" />
</ElementType>
<ElementType name="FILE_GROUP" content="eltOnly" model="closed" order="many">
   <description>
      A named group of files.  Used to group sets of files into a group
      that are backed up together
   </description>
   <attribute type="logicalPath" />
   <attribute type="componentName" />
   <attribute type="caption" />
   <attribute type="icon" />
   <attribute type="restoreMetadata" />
   <attribute type="notifyOnBackupComplete" />
   <attribute type="selectable" />
   <attribute type="selectableForRestore" />
   <attribute type="componentFlags" />
   <element type="FILE_LIST" />
   <element type="DEPENDENCY" minOccurs="0" />
</ElementType>
<ElementType name="FILE_LIST" content="empty" model="closed">
   <description>
      Location of a set of files in a FILE_GROUP.  Filespec can include
      wildcards.
   </description>
   <attribute type="path" />
   <attribute type="filespec" />
   <attribute type="recursive" />
   <attribute type="alternatePath" />
   <attribute type="filespecBackupType" />
</ElementType>
<ElementType name="DEPENDENCY" content="empty" model="closed">
    <description>
    A dependency from one component to another component in another writer.
    </description>
  <AttributeType name="onWriterId" dt:type="uuid" required="yes">
    <description>
    Id of writer that this component is dependent on.
    </description>
  </AttributeType>
  <AttributeType name="onLogicalPath" dt:type="string" required="no">
    <description>
    Logical path of component that this component is dependent on.
    </description>
  </AttributeType>
  <AttributeType name="onComponentName" dt:type="string" required="yes">
    <description>
    Name of component that this component is dependent on.
    </description>
  </AttributeType>
  <attribute type="onWriterId" />
  <attribute type="onLogicalPath" />
  <attribute type="onComponentName" />
</ElementType>
<ElementType name="RESTORE_METHOD" content="eltOnly" model="open" order="many">
  <description>
  How restore should be performed.  Includes specification of how files
  should be restored as well as special steps that should occur in order
  to complete the restore.
  </description>
  <AttributeType name="method" dt:type="enumeration"
             required="yes"
             dt:values="RESTORE_IF_NONE_THERE
                        RESTORE_IF_CAN_BE_REPLACED
                        STOP_RESTART_SERVICE
                        REPLACE_AT_REBOOT
                        REPLACE_AT_REBOOT_IF_CANNOT_REPLACE
                        RESTORE_TO_ALTERNATE_LOCATION
                        CUSTOM
                        RESTORE_STOP_START_SERVICE">
      <description>
       RESTORE_IF_NONE_THERE: i.e., can restore data if it is not at the
       location where it was backed up from.  This essentially allows
       data to be restored to a clean system
       RESTORE_IF_CAN_BE_REPLACED: Restore data if all of the files can
       be replaced in the orgiginal backup location.  Fails if any of
       the files are open.  If an alternate location is provided, files
       will be placed there if they cannot be restored to their original
       location.
       STOP_RESTART_SERVICE: stop service (service attribute must be
       specified). Restore files to original backup location.
       Restart service.  Fails if any of the files are open after the
       service is stopped.
       REPLACE_AT_REBOOT: Restore files to a temporary location.  Use
       MoveFileEx to replace the files at reboot.
       REPLACE_AT_REBOOT_IF_CANNOT_REPLACE:  Similiar to REPLACE_AT_REBOOT
       however files may be restored in place in they are not busy.  All files
       within a component must be either completely replaced in place or
       completely replaced at reboot, so if one component file is busy, all files
       in that component must be replaced at reboot.       
       RESTORE_TO_ALTERNATIVE_LOCATION: Restore files to an alternate
       location.  Typically writerRestore will indicate that the writer
       will participate in the restore process
       CUSTOM: restore process cannot be expressed using this specification
       RESTORE_STOP_START_SERVICE: Restore files to original location,
       then restart the specified service.
       </description>
   </AttributeType>
   <AttributeType name="service" dt:type="string" required="no">
      <description>
      Must be specified if method="STOP_RESTART_SERVICE" or method="RESTORE_STOP_START_SERVICE".
      </description>
   </AttributeType>
   <AttributeType name="writerRestore" dt:type="enumeration"
                  dt:values="always never ifReplaceFails" default="never">
      <description>
      Whether writer should be invoked after files are restored to
      disk.  Options are always, never, and ifReplaceFails.  The latter means
      that the files will be restored to their original location.  If one
      or more of the files cannot be replaced, then the files will be
      restored to an alternate location (must be specified via
      ALTERNATE_LOCATION_MAPPING.  After the files are restored, the writer
      is invoked.
      </description>
   </AttributeType>
  <AttributeType name="userProcedure" dt:type="uri" required="no">
     <description>
     Description of actions that the user should perform to restore the files.
     The format of this string has yet to be determined.
     </description>
  </AttributeType>
  <AttributeType name="rebootRequired" dt:type="enumeration"
                 dt:values="yes no" default="no" >
     <description>
     Should a reboot be performed after restoring the data for this
     writer
     </description>
  </AttributeType>
  <attribute type="method" />
  <attribute type="service" />
  <attribute type="writerRestore" />
  <attribute type="userProcedure" />
  <attribute type="rebootRequired" />
  <element type="ALTERNATE_LOCATION_MAPPING" minOccurs="0" maxOccurs="*" />
</ElementType>
<ElementType name="ALTERNATE_LOCATION_MAPPING" content="empty" model="closed">
  <description>
     Mapping from a location that was backed up to a location to restore to.
  </description>
   <attribute type="path" />
   <attribute type="filespec" />
   <attribute type="recursive" />
   <attribute type="alternatePath" />
</ElementType>
</Schema>
<Schema name="VssWriterMetadataInfo"
        xmlns="urn:schemas-microsoft-com:xml-data"
    xmlns:dt="urn:schemas-microsoft-com:datatypes">
<AttributeType name="filespec" dt:type="string" required="yes">
   <description>
   File specification.  Can include wildcard characters ? and *
   </description>
</AttributeType>
<AttributeType name="path" dt:type="string" required="yes">
   <description>
   Path to a file.  The path can include environment variables or
   values extracted from registry keys.
   </description>
</AttributeType>
<AttributeType name="recursive" dt:type="enumeration"
               dt:values="yes no" default="no">
   <description>
   Is path specified recursive or limited to the directory that is specified.
   </description>
</AttributeType>
<AttributeType name="alternatePath" dt:type="string" required="no">
   <description>
   Alternate path in which to find the file.  Files in a file group may
   have been copied to an alternative location by the writer.  Backup should
   pick up the files from the alternative location instead of the original
   location but should restore the files to their original location
   </description>
</AttributeType>
<AttributeType name="logicalPath" dt:type="string" required="no">
   <description>
   Logical path for a database or file group.  This logical name uses backslash
   as separators to form a logical namespace hierarchy
   </description>
</AttributeType>
<AttributeType name="componentName" dt:type="string" required="yes">
   <description>
   Name used to identify a database or file group.  May be qualified by a
   logical path.
   </description>
</AttributeType>
<AttributeType name="restoreMetadata" dt:type="enumeration"
               dt:values="yes no" default="no">
   <description>
   Restore metadata exists for this database or file group.  Backup
   application should capture the restore metadata and pass it to the
   writer on restore.
   </description>
</AttributeType>
<AttributeType name="notifyOnBackupComplete" dt:type="enumeration"
               dt:values="yes no" default="no">
   <description>
   Writer should be notified when backup is complete whether this
   database or file group was successfully backed up or not.
   </description>
</AttributeType>
<AttributeType name="caption" dt:type="string" required="no">
   <description>
   Textual Description of database or file group
   </description>
</AttributeType>
<AttributeType name="icon" dt:type="string" required="no">
   <description>
   Icon associated with database or file group
   </description>
</AttributeType>
<AttributeType name="selectable" dt:type="enumeration"
               dt:values="yes no" default="yes">
   <description>
   Is this component selectable for backup or is it always backed up.
   If no, then the component is always backed up if any other components of
   the application/service are backed up.  If yes, then the
   component may be selectively backed up.
   </description>
</AttributeType>
<AttributeType name="selectableForRestore" dt:type="enumeration"
               dt:values="yes no" default="no">
   <description>
   Is this component selectable for restore
   </description>
</AttributeType>
<AttributeType name="version" dt:type="enumeration" dt:values="1.0 1.1 1.2 1.3" required="yes">
   <description>
   Version of a specific document
   </description>
</AttributeType>
<AttributeType name="writerId" dt:type="uuid" required="yes">
   <description>
   Unique id to identify the writer.  Note that this identifies the
   writer class rather than a specific instance of the writer.
   </description>
</AttributeType>
<AttributeType name="instanceId" dt:type="uuid" required="no">
   <description>
   Unique id identifying the instance of a writer during backup.  It
   has no meaning during restore.
   </description>
</AttributeType>
<AttributeType name="instanceName" dt:type="string" required="no">
   <description>
   Unique id generated by the writer that identifies the instance of a writer
   both during backup and restore.  This id is used to map writers at backup
   time to writers at restore time.
   </description>
</AttributeType>
<AttributeType name="componentFlags" dt:type="number" default="0">
   <description>
   Contains extra flags that describe the component being backed up.   
   </description>
</AttributeType>
<AttributeType name="backupSchema" dt:type="number" default="0">
<description>
Describes the writer capabilities and how different types of backup are performed.
</description>
</AttributeType>
<AttributeType name="filespecBackupType" dt:type="number" default="0">
<description>
Describes how backup should be performed on a specific filespec.
</description>
</AttributeType>
<ElementType name="WRITER_METADATA" content="eltOnly" model="open" order="one">
   <description>
      Information used by Backup application to backup/restore data
   </description>
   <attribute type="version" />
   <attribute type="backupSchema" />
   <element type="IDENTIFICATION" />
   <element type="BACKUP_LOCATIONS" minOccurs="0" />
   <element type="RESTORE_METHOD" minOccurs="0" />
</ElementType>
<ElementType name="IDENTIFICATION" content="empty" model="closed">
   <description>
      Identification of a service/application backing up data
   </description>
   <AttributeType name="friendlyName" dt:type="string" required="yes">
      <description>
      Friendly name used to describe the service or application.
      </description>
   </AttributeType>
   <AttributeType name="usage" dt:type="enumeration"
           dt:values="USER_DATA BOOTABLE_SYSTEM_STATE SYSTEM_SERVICE OTHER"
           default="OTHER">
      <description>
      How the data associated with the writer is used.  For now we
      distinguish user data and system state.
      </description>
   </AttributeType>
   <AttributeType name="dataSource" dt:type="enumeration"
               dt:values="TRANSACTION_DB NONTRANSACTIONAL_DB OTHER"
           default="OTHER">
      <description>
      Description of the nature of the data manager.  Currently only
      databases are identified
      </description>
   </AttributeType>
   <AttributeType name="majorVersion" dt:type="number" default="1">
     <description>
       Major version number of the writer.
     </description>
   </AttributeType>
   <AttributeType name="minorVersion" dt:type="number" default="0">
     <description>
       Minor version number of the writer.
     </description>
   </AttributeType>
   <attribute type="instanceId" required="yes" />
   <attribute type="instanceName" />
   <attribute type="writerId" />
   <attribute type="friendlyName" />
   <attribute type="usage" />
   <attribute type="dataSource" />
   <attribute type="majorVersion" />
   <attribute type="minorVersion" />
</ElementType>
<ElementType name="BACKUP_LOCATIONS" content="eltOnly" model="closed" order="many">
   <description>
      Files to include and exclude from the backup
   </description>
   <element type="INCLUDE_FILES" minOccurs="0" />
   <element type="EXCLUDE_FILES" minOccurs="0" />
   <element type="EXCLUDE_FILES_FROM_SNAPSHOT" minOccurs="0" />   
   <element type="DATABASE" minOccurs="0"/>
   <element type="FILE_GROUP" minOccurs="0" />
</ElementType>
<ElementType name="INCLUDE_FILES" content="empty">
   <description>
      Files to include in the backup, essentially files to backup if you want
      to backup this application/service
   </description>
   <attribute type="path" />
   <attribute type="filespec" />
   <attribute type="recursive" />
   <attribute type="alternatePath" />
</ElementType>
<ElementType name="EXCLUDE_FILES" content="empty">
   <description>
      Files that should always be excluded from the backup
   </description>
   <attribute type="path" />
   <attribute type="filespec" />
   <attribute type="recursive" />
</ElementType>
<ElementType name="EXCLUDE_FILES_FROM_SNAPSHOT" content="empty">
   <description>
      Files that should always be excluded from the backup
   </description>
   <attribute type="path" />
   <attribute type="filespec" />
   <attribute type="recursive" />
</ElementType>
<ElementType name="DATABASE" content="eltOnly" model="closed" order="many">
   <description>
      List of databases of interest.  This is used to allow selective
      backup and restore of specific databases.
   </description>
   <attribute type= "logicalPath" />
   <attribute type="componentName" />
   <attribute type="caption" />
   <attribute type="icon" />
   <attribute type="restoreMetadata" />
   <attribute type="notifyOnBackupComplete" />
   <attribute type="selectable" />
   <attribute type="selectableForRestore" />
   <attribute type="componentFlags" />
   <element type="DATABASE_FILES" minOccurs="1" />
   <element type="DATABASE_LOGFILES" />
   <element type="DEPENDENCY" minOccurs="0" />
</ElementType>
<ElementType name="DATABASE_FILES" content="empty" model="closed">
   <description>
      Location of a set of database files.  Filespec can include wildcards
   </description>
   <attribute type="path" />
   <attribute type="filespec" />
   <attribute type="filespecBackupType" />
</ElementType>
<ElementType name="DATABASE_LOGFILES" content="empty" model="closed">
   <description>
      Location of a set of database log files.  Filespec can include
      wildcards.  Indication of whether database log files are truncated.
   </description>
   <attribute type="path" />
   <attribute type="filespec" />
   <attribute type="filespecBackupType" />
</ElementType>
<ElementType name="FILE_GROUP" content="eltOnly" model="closed" order="many">
   <description>
      A named group of files.  Used to group sets of files into a group
      that are backed up together
   </description>
   <attribute type="logicalPath" />
   <attribute type="componentName" />
   <attribute type="caption" />
   <attribute type="icon" />
   <attribute type="restoreMetadata" />
   <attribute type="notifyOnBackupComplete" />
   <attribute type="selectable" />
   <attribute type="selectableForRestore" />
   <attribute type="componentFlags" />
   <element type="FILE_LIST" />
   <element type="DEPENDENCY" minOccurs="0" />
</ElementType>
<ElementType name="FILE_LIST" content="empty" model="closed">
   <description>
      Location of a set of files in a FILE_GROUP.  Filespec can include
      wildcards.
   </description>
   <attribute type="path" />
   <attribute type="filespec" />
   <attribute type="recursive" />
   <attribute type="alternatePath" />
   <attribute type="filespecBackupType" />
</ElementType>
<ElementType name="DEPENDENCY" content="empty" model="closed">
    <description>
    A dependency from one component to another component in another writer.
    </description>
  <AttributeType name="onWriterId" dt:type="uuid" required="yes">
    <description>
    Id of writer that this component is dependent on.
    </description>
  </AttributeType>
  <AttributeType name="onLogicalPath" dt:type="string" required="no">
    <description>
    Logical path of component that this component is dependent on.
    </description>
  </AttributeType>
  <AttributeType name="onComponentName" dt:type="string" required="yes">
    <description>
    Name of component that this component is dependent on.
    </description>
  </AttributeType>
  <attribute type="onWriterId" />
  <attribute type="onLogicalPath" />
  <attribute type="onComponentName" />
</ElementType>
<ElementType name="RESTORE_METHOD" content="eltOnly" model="open" order="many">
  <description>
  How restore should be performed.  Includes specification of how files
  should be restored as well as special steps that should occur in order
  to complete the restore.
  </description>
  <AttributeType name="method" dt:type="enumeration"
             required="yes"
             dt:values="RESTORE_IF_NONE_THERE
                        RESTORE_IF_CAN_BE_REPLACED
                        STOP_RESTART_SERVICE
                        REPLACE_AT_REBOOT
                        REPLACE_AT_REBOOT_IF_CANNOT_REPLACE
                        RESTORE_TO_ALTERNATE_LOCATION
                        CUSTOM
                        RESTORE_STOP_START_SERVICE">
      <description>
       RESTORE_IF_NONE_THERE: i.e., can restore data if it is not at the
       location where it was backed up from.  This essentially allows
       data to be restored to a clean system
       RESTORE_IF_CAN_BE_REPLACED: Restore data if all of the files can
       be replaced in the orgiginal backup location.  Fails if any of
       the files are open.  If an alternate location is provided, files
       will be placed there if they cannot be restored to their original
       location.
       STOP_RESTART_SERVICE: stop service (service attribute must be
       specified). Restore files to original backup location.
       Restart service.  Fails if any of the files are open after the
       service is stopped.
       REPLACE_AT_REBOOT: Restore files to a temporary location.  Use
       MoveFileEx to replace the files at reboot.
       REPLACE_AT_REBOOT_IF_CANNOT_REPLACE:  Similiar to REPLACE_AT_REBOOT
       however files may be restored in place in they are not busy.  All files
       within a component must be either completely replaced in place or
       completely replaced at reboot, so if one component file is busy, all files
       in that component must be replaced at reboot.       
       RESTORE_TO_ALTERNATIVE_LOCATION: Restore files to an alternate
       location.  Typically writerRestore will indicate that the writer
       will participate in the restore process
       CUSTOM: restore process cannot be expressed using this specification
       RESTORE_STOP_START_SERVICE: Restore files to original location,
       then restart the specified service.
       </description>
   </AttributeType>
   <AttributeType name="service" dt:type="string" required="no">
      <description>
      Must be specified if method="STOP_RESTART_SERVICE" or method="RESTORE_STOP_START_SERVICE".
      </description>
   </AttributeType>
   <AttributeType name="writerRestore" dt:type="enumeration"
                  dt:values="always never ifReplaceFails" default="never">
      <description>
      Whether writer should be invoked after files are restored to
      disk.  Options are always, never, and ifReplaceFails.  The latter means
      that the files will be restored to their original location.  If one
      or more of the files cannot be replaced, then the files will be
      restored to an alternate location (must be specified via
      ALTERNATE_LOCATION_MAPPING.  After the files are restored, the writer
      is invoked.
      </description>
   </AttributeType>
  <AttributeType name="userProcedure" dt:type="uri" required="no">
     <description>
     Description of actions that the user should perform to restore the files.
     The format of this string has yet to be determined.
     </description>
  </AttributeType>
  <AttributeType name="rebootRequired" dt:type="enumeration"
                 dt:values="yes no" default="no" >
     <description>
     Should a reboot be performed after restoring the data for this
     writer
     </description>
  </AttributeType>
  <attribute type="method" />
  <attribute type="service" />
  <attribute type="writerRestore" />
  <attribute type="userProcedure" />
  <attribute type="rebootRequired" />
  <element type="ALTERNATE_LOCATION_MAPPING" minOccurs="0" maxOccurs="*" />
</ElementType>
<ElementType name="ALTERNATE_LOCATION_MAPPING" content="empty" model="closed">
  <description>
     Mapping from a location that was backed up to a location to restore to.
  </description>
   <attribute type="path" />
   <attribute type="filespec" />
   <attribute type="recursive" />
   <attribute type="alternatePath" />
</ElementType>
</Schema>
