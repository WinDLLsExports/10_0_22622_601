!This program cannot be run in DOS mode.
.text
`.rsrc
@.reloc
j[i(g
&*.sS
v4.0.30319
#Strings
#GUID
#Blob
__StaticArrayInitTypeSize=20
<>c__DisplayClass100_0
<>c__DisplayClass110_0
<>9__10_0
<ProcessRecord>b__10_0
<>c__DisplayClass120_0
<>c__DisplayClass130_0
<>c__DisplayClass140_0
<>c__DisplayClass40_0
<>c__DisplayClass150_0
<>c__DisplayClass50_0
<>c__DisplayClass160_0
<>c__DisplayClass60_0
<>9__170_0
<GetIMultiPointStationProxy>b__170_0
<>c__DisplayClass80_0
<>c__DisplayClass90_0
<>c__DisplayClass101_0
<>c__DisplayClass111_0
<>c__DisplayClass11_0
<>c__DisplayClass121_0
<>c__DisplayClass131_0
<>c__DisplayClass141_0
<>c__DisplayClass41_0
<>c__DisplayClass151_0
<>c__DisplayClass61_0
<>9__171_0
<GetIMultiPointServerProxy>b__171_0
<>c__DisplayClass71_0
<>c__DisplayClass81_0
<>c__DisplayClass91_0
<>c__DisplayClass102_0
<>c__DisplayClass112_0
<>c__DisplayClass12_0
<>c__DisplayClass122_0
<>c__DisplayClass132_0
<>c__DisplayClass142_0
<>c__DisplayClass42_0
<>c__DisplayClass152_0
<>c__DisplayClass52_0
<>c__DisplayClass62_0
<>9__172_0
<GetIMultiPointUserManagerProxy>b__172_0
<>c__DisplayClass72_0
<>c__DisplayClass82_0
<>c__DisplayClass103_0
<>c__DisplayClass113_0
<>9__13_0
<ProcessRecord>b__13_0
<>c__DisplayClass123_0
<OnGroupUpdated>b__133_0
<>c__DisplayClass143_0
<>c__DisplayClass43_0
<>c__DisplayClass153_0
<>c__DisplayClass53_0
<>c__DisplayClass63_0
<>9__173_0
<GetIMultiPointSessionProxy>b__173_0
<>c__DisplayClass73_0
<>c__DisplayClass93_0
<>9__3_0
<GetConnectionState>b__3_0
<>c__DisplayClass104_0
<>c__DisplayClass114_0
<>c__DisplayClass124_0
<>c__DisplayClass144_0
<>c__DisplayClass154_0
<>c__DisplayClass54_0
<>c__DisplayClass164_0
<>9__174_0
<GetIMultiPointDiskProtectionProxy>b__174_0
<>c__DisplayClass74_0
<>c__DisplayClass94_0
<>9__4_0
<QuerySessionInformationForString>b__4_0
<>c__DisplayClass105_0
<>c__DisplayClass115_0
<>c__DisplayClass125_0
<>c__DisplayClass145_0
<>c__DisplayClass155_0
<>c__DisplayClass55_0
<>c__DisplayClass165_0
<>c__DisplayClass75_0
<>c__DisplayClass85_0
<>c__DisplayClass95_0
<>9__5_0
<QuerySessionInformationForStruct>b__5_0
<>c__DisplayClass106_0
<>c__DisplayClass116_0
<>c__DisplayClass126_0
<>c__DisplayClass146_0
<>c__DisplayClass156_0
<>c__DisplayClass56_0
<>c__DisplayClass66_0
<>c__DisplayClass107_0
<>c__DisplayClass117_0
<>9__17_0
<ProcessRecord>b__17_0
<>c__DisplayClass127_0
<>c__DisplayClass37_0
<>c__DisplayClass147_0
<>9__47_0
<ImportModules>b__47_0
<>c__DisplayClass47_0
<>c__DisplayClass157_0
<>c__DisplayClass167_0
<>c__DisplayClass67_0
<>c__DisplayClass87_0
<>c__DisplayClass97_0
<>c__DisplayClass108_0
<>c__DisplayClass118_0
<>c__DisplayClass128_0
<>c__DisplayClass38_0
<>c__DisplayClass148_0
<>c__DisplayClass48_0
<>c__DisplayClass158_0
<>9__168_0
<GetIMultiPointCertificateRequestProxy>b__168_0
<>c__DisplayClass68_0
<>c__DisplayClass78_0
<>c__DisplayClass88_0
<>c__DisplayClass98_0
<>c__DisplayClass109_0
<>c__DisplayClass119_0
<ShutdownNotification>b__129_0
<>c__DisplayClass139_0
<>c__DisplayClass39_0
<>c__DisplayClass149_0
<>c__DisplayClass49_0
<>c__DisplayClass159_0
<>9__169_0
<GetIMultiPointChatProxy>b__169_0
<>c__DisplayClass79_0
<>c__DisplayClass89_0
<>c__DisplayClass99_0
<>9__9_0
<ProcessRecord>b__9_0
<>9__0
<SendIM>b__0
<ConnectIM>b__0
<DisconnectIM>b__0
<GetDiskProtectionNeededSpaceInGb>b__0
<OnDeviceAdded>b__0
<OnStationAdded>b__0
<OnPeerServerAdded>b__0
<OnScheduledUpdateSettingsChanged>b__0
<IsUsbStorageDeviceBlocked>b__0
<OnSessionBlocked>b__0
<OnSessionUnblocked>b__0
<IsVirtualIpPerSessionEnabled>b__0
<OnPeerServerDiscovered>b__0
<OnUserUpdated>b__0
<OnUserCreated>b__0
<OnSessionDisconnected>b__0
<OnUserDeleted>b__0
<OnDeviceRemoved>b__0
<OnStationRemoved>b__0
<OnPeerServerRemoved>b__0
<InstallDiskProtectionService>b__0
<UnInstallDiskProtectionService>b__0
<SetDiskProtectionServiceInDiscardMode>b__0
<SetBootToConsoleMode>b__0
<SetDiskProtectionServiceInPassiveMode>b__0
<GetSystemMode>b__0
<SetAdminOrchestrationMode>b__0
<GetDiskProtectionMode>b__0
<SetBlockAllMessage>b__0
<OnBootToConsoleModeChange>b__0
<OnSystemModeChange>b__0
<OnProjectionStateChange>b__0
<OnDesktopMonitoringChange>b__0
<OnServiceControlSessionChange>b__0
<GetUpdateSchedule>b__0
<SetUpdateSchedule>b__0
<SetStationName>b__0
<GetStationServerName>b__0
<OnManagedServerOffline>b__0
<OnVirtualDesktopOnline>b__0
<OnManagedServerOnline>b__0
<GetManagedSystemsType>b__0
<GetScreenState>b__0
<SetDesktopMonitoring>b__0
<ConfigureWebLimiting>b__0
<SendMsg>b__0
<DoWorkInParallel>b__0
<EnableWebLimitingAll>b__0
<ConfigureWebLimitingAll>b__0
<EnableProjectAll>b__0
<IdentifyAll>b__0
<OnEnterSplitScreen>b__0
<OnExitSplitScreen>b__0
<SetStationAutologon>b__0
<GetMultiPointProtocolVersion>b__0
<GetServerVersion>b__0
<GetClientVersion>b__0
<RunFileSession>b__0
<LogOffConsoleSession>b__0
<LogOffSession>b__0
<StopLockingSession>b__0
<StopIdentifyingSession>b__0
<LockSession>b__0
<ConfigureVirtualIpPerSession>b__0
<DisconnectSession>b__0
<IdentifySession>b__0
<OnVirtualDesktopNotification>b__0
<SetSuppressPrivacyNotification>b__0
<CloseSessionApplication>b__0
<GetScheduledUpdateConfiguration>b__0
<OnConfigureStation>b__0
<StopIdentifyingStation>b__0
<RefreshStation>b__0
<OnAssociateSessionWithStation>b__0
<GetStation>b__0
<SplitStation>b__0
<UnsplitStation>b__0
<IdentifyStation>b__0
<GetDisplayOrientation>b__0
<SetDisplayOrientation>b__0
<SetStationRemoteConnection>b__0
<LoadWindowsEdition>b__0
<Shutdown>b__0
<SetUserInfo>b__0
<ShareDesktop>b__0
<StopShareDesktop>b__0
<OnboardVirtualDesktop>b__0
<ViewDesktop>b__0
<IdentifySessionWrapper>b__0
<AddUser>b__0
<SetCurrentDashboardUser>b__0
<RemoveUser>b__0
<SetSingleSessionPerUser>b__0
<AddRemoteManagedComputer>b__0
<RemoveRemoteManagedComputer>b__0
<SendError>b__0
<EnumerateStationIDs>b__0
<BlockUsbStorageDevices>b__0
<UnblockUsbStorageDevices>b__0
<GetSessionFlags>b__0
<AddRemoteManagedComputerUsingSuppliedCredentials>b__0
<StopIdentifySessions>b__0
<BlockUsbStorageDevicesAllStations>b__0
<UnblockUsbStorageDevicesAllStations>b__0
<RemapStations>b__0
<StopIdentifyStations>b__0
<GetRunningApps>b__0
<EnumerateUsers>b__0
<GetThumbnailBits>b__0
<GetNetJoinStatus>b__0
<ConfigureChat>b__0
<GetLicenseCount>b__0
<Reboot>b__0
<OnSystemAlert>b__0
<OnStationAlert>b__0
<GetPeerWmsServerList>b__0
<GetPeerWmsConnectorList>b__0
<SetUseHardwareGpu>b__0
<OnSessionAgentReady>b__0
<GetCurrentActivity>b__0
<QueryRemoteManagementProperty>b__0
<>9__170_1
<GetIMultiPointStationProxy>b__170_1
<>c__DisplayClass90_1
<>9__171_1
<GetIMultiPointServerProxy>b__171_1
<>c__DisplayClass91_1
<>c__DisplayClass52_1
<>9__172_1
<GetIMultiPointUserManagerProxy>b__172_1
<>9__173_1
<GetIMultiPointSessionProxy>b__173_1
<>c__DisplayClass93_1
<>9__174_1
<GetIMultiPointDiskProtectionProxy>b__174_1
<>c__DisplayClass66_1
<>9__169_1
<GetIMultiPointChatProxy>b__169_1
<>9__1
<SetBootToConsoleMode>b__1
<SetStationAutologon>b__1
<GetStation>b__1
<EnumerateStationIDs>b__1
<ImportModules>b__1
<>c__5`1
Nullable`1
IEnumerable`1
ClientBase`1
ConcurrentQueue`1
ProcessSessionCallback`1
Action`1
PSDataCollection`1
ReadOnlyCollection`1
EventHandler`1
IEnumerator`1
DelegatedConstructor`1
DelegatedCredentials`1
IExtensibleObject`1
List`1
notUsed1
CS$<>8__locals1
multipoint1
HRESULT_FROM_WIN32
kernel32
Microsoft.Win32
user32
ToUInt32
ReadInt32
USER_MODALS_INFO_2
<SetStationAutologon>b__2
<GetStation>b__2
Func`2
Dictionary`2
X509Certificate2
UserModalsInfo2
<GetStation>b__3
UInt64
ToInt64
blockList64
allowList64
<GetStation>b__4
<GetStation>b__5
UInt16
DB41E63FA067F94F21A9D34D2038F987F0C480530A3672047FD4F67C62990136
<Module>
<PrivateImplementationDetails>
DATAID_WMS_TASK_HOME_WEB
CRED_TYPE_GENERIC
CREDUIWIN_GENERIC
SYSPREP_SPECIALIZE_SUCCEEDED
SYSPREP_GENERALIZE_SUCCEEDED
HRESULT_ERROR_ACCESS_DENIED
WS_E_ENDPOINT_ACCESS_DENIED
SYSPREP_SPECIALIZE_FAILED
SYSPREP_GENERALIZE_FAILED
HRESULT_RPC_S_CALL_FAILED
SYSPREP_ONLINE_CONFIGURATION_FAILED
HRESULT_RPC_S_CALL_CANCELLED
ERROR_CANCELLED
SYSPREP_ONLINE_CONFIGURED
HRESULT_RPC_E_DISCONNECTED
RPC_S_PROTSEQ_NOT_SUPPORTED
HRESULT_ERROR_NOT_SUPPORTED
HyperVFeatureID
SessionID
sessionID
collabStationID
currentStationID
primaryStationID
stationID
DATAID_WMS_TASK_STATUS_SUSPEND
DATAID_WMS_TASK_DESKTOPS_CHAT_SEND
HRESULT_ERROR_FILE_NOT_FOUND
HRESULT_ERROR_PATH_NOT_FOUND
HRESULT_ERROR_NOT_FOUND
DATAID_WMS_TASK_HOME_DISCUSSION_BOARD
DATAID_WMS_TASK_USERS_CHANGE_PASSWORD
CRED_TYPE_DOMAIN_PASSWORD
CERT_SYSTEM_STORE_CURRENT_SERVICE
DATAID_WMS_TASK_HOME_MAINTENANCE
EWX_FORCE
DATAID_WMS_TASK_DESKTOPS_UNBLOCK_USB_STORAGE
DATAID_WMS_TASK_DESKTOPS_BLOCK_USB_STORAGE
DATAID_WMS_TASK_DESKTOPS_MESSAGE
DATAID_WMS_TASK_DESKTOPS_ENLARGE
HRESULT_WS_E_ENDPOINT_UNREACHABLE
HRESULT_RPC_S_SERVER_UNAVAILABLE
DATAID_WMS_TASK_DESKTOPS_AUTOLAUNCH_ENABLE
DATAID_WMS_TASK_DESKTOPS_CHAT_ENABLE
DATAID_WMS_TASK_DESKTOPS_AUTOLAUNCH_DISABLE
DATAID_WMS_TASK_DESKTOPS_CHAT_DISABLE
LOAD_LIBRARY_AS_DATAFILE
ERROR_INVALID_DOMAIN_ROLE
ERROR_BAD_USERNAME
LOOPBACK_ADAPTER_SERVICE_NAME
DATAID_WMS_TASK_USERS_CHANGE_FULL_NAME
DATAID_WMS_TASK_STATUS_STATION_NAME
CERT_SYSTEM_STORE_LOCAL_MACHINE
HRESULT_ERROR_BAD_FILE_TYPE
NERR_BASE
CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE
SID_NAME_USE
DATAID_WMS_TASK_DESKTOPS_SHOW_ACTIVE
SECURITY_MAX_SID_SIZE
DATAID_WMS_TASK_DESKTOPS_CHANGE_SIZE
WTS_SESSION_LOGOFF
DATAID_WMS_TASK_STATUS_LOGOFF
EWX_POWEROFF
CERT_STORE_ENUM_ARCHIVED_FLAG
CERT_STORE_MAXIMUM_ALLOWED_FLAG
CERT_STORE_UPDATE_KEYID_FLAG
CERT_STORE_MANIFOLD_FLAG
CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG
CERT_STORE_SET_LOCALIZED_NAME_FLAG
CERT_STORE_BACKUP_RESTORE_FLAG
CERT_STORE_SHARE_STORE_FLAG
CERT_STORE_NO_CRYPT_RELEASE_FLAG
CERT_STORE_DELETE_FLAG
CERT_STORE_OPEN_EXISTING_FLAG
CERT_STORE_UNSAFE_PHYSICAL_FLAG
CERT_STORE_SHARE_CONTEXT_FLAG
CERT_STORE_CREATE_NEW_FLAG
CERT_STORE_READONLY_FLAG
FLASHW_TIMERNOFG
DATAID_WMS_TASK_DESKTOPS_SORT_ASCENDING
DATAID_WMS_TASK_DESKTOPS_SORT_DESCENDING
DATAID_WMS_TASK_DESKTOPS_STOP_SHARING
LSA_STRING
EWX_FORCEIFHUNG
DATAID_WMS_TASK_DESKTOPS_SEARCH
ERROR_BAD_NETPATH
ERROR_UNTRUSTED_IP_WITH_DEFAULT_AUTH
DATAID_WMS_TASK_DESKTOPS_STOP_LIMIT_WEB_MULTI
DATAID_WMS_TASK_DESKTOPS_LIMIT_WEB_MULTI
DATAID_WMS_TASK_DESKTOPS_SHARE_MULTI
DATAID_WMS_TASK_DESKTOPS_LOGOFF_MULTI
DATAID_WMS_TASK_DESKTOPS_UNBLOCK_MULTI
DATAID_WMS_TASK_DESKTOPS_BLOCK_MULTI
DATAID_WMS_TASK_DESKTOPS_LAUNCH_APP_MULTI
DATAID_WMS_TASK_DESKTOPS_UNBLOCK
DATAID_WMS_TASK_DESKTOPS_BLOCK
WTS_SESSION_UNLOCK
WTS_SESSION_LOCK
LOCAL
DATAID_WMS_TASK_HOME_NORMAL
HRESULT_ERROR_INVALID_ACL
SYSPREP_CONTINUING_STAGED_INSTALL
DATAID_WMS_TASK_DESKTOPS_STOP_LIMIT_WEB_ALL
DATAID_WMS_TASK_DESKTOPS_LIMIT_WEB_ALL
DATAID_WMS_TASK_DESKTOPS_SHARE_SELECTED_ALL
DATAID_WMS_TASK_STATUS_SUSPEND_ALL
DATAID_WMS_TASK_DESKTOPS_UNBLOCK_USB_STORAGE_ALL
DATAID_WMS_TASK_DESKTOPS_BLOCK_USB_STORAGE_ALL
DATAID_WMS_TASK_DESKTOPS_SHARE_ALL
DATAID_WMS_TASK_DESKTOPS_LOGOFF_ALL
DATAID_WMS_TASK_STATUS_LOGOFF_ALL
DATAID_WMS_TASK_DESKTOPS_UNBLOCK_ALL
DATAID_WMS_TASK_DESKTOPS_BLOCK_ALL
DATAID_WMS_TASK_DESKTOPS_LAUNCH_APP_ALL
FLASHW_ALL
DATAID_WMS_TASK_DESKTOPS_SHOW_ALL
DATAID_WMS_TASK_STATUS_STOP_IDENTIFY_ALL
DATAID_WMS_TASK_STATUS_IDENTIFY_ALL
HRESULT_ERROR_DISK_FULL
WTS_SESSION_REMOTE_CONTROL
DATAID_WMS_TASK_DESKTOPS_REMOTE_CONTROL
E_NOTIMPL
DATAID_WMS_TASK_DESKTOPS_INCLUDE_SYSTEM
DATAID_WMS_TASK_DESKTOPS_EXCLUDE_SYSTEM
CERT_STORE_PROV_SYSTEM
get_IM
set_IM
SendIM
HandleIM
ConnectIM
DisconnectIM
DATAID_WMS_TASK_STATUS_UNSPLIT_SCREEN
DATAID_WMS_TASK_STATUS_SPLIT_SCREEN
HRESULT_ERROR_NO_TOKEN
DATAID_WMS_TASK_VDI_NEW_DESKTOP_TEMPLATE_DOMAIN
ERROR_NO_SUCH_DOMAIN
DATAID_WMS_TASK_VDI_OPEN_DESKTOP_DOMAIN
DATAID_WMS_TASK_VDI_NEW_DESKTOP_DOMAIN
DATAID_WMS_TASK_STATUS_AUTOLOGON
WTS_SESSION_LOGON
SERVICE_SESSION
ERROR_NO_SUCH_LOGON_SESSION
DATAID_WMS_TASK_VDI_NEW_DESKTOP_TEMPLATE_VHD_LOCATION
DATAID_WMS_TASK_VDI_IMPORT_DESKTOP_VHD_LOCATION
DATAID_WMS_TASK_VDI_NEW_DESKTOP_VHD_LOCATION
SYSPREP_FRESH_INSTALLATION
DATAID_WMS_TASK_VDI_ENABLE_FAIL_DURATION
DATAID_WMS_TASK_VDI_DISABLE_FAIL_DURATION
DATAID_WMS_TASK_VDI_NEW_DESKTOP_TEMPLATE_FAIL_DURATION
DATAID_WMS_TASK_HOME_ENABLE_DP_FAIL_DURATION
DATAID_WMS_TASK_HOME_DISABLE_DP_FAIL_DURATION
DATAID_WMS_TASK_VDI_OPEN_DESKTOP_FAIL_DURATION
DATAID_WMS_TASK_VDI_IMPORT_DESKTOP_FAIL_DURATION
DATAID_WMS_TASK_VDI_NEW_DESKTOP_FAIL_DURATION
DATAID_WMS_TASK_VDI_ENABLE_SUCCESS_DURATION
DATAID_WMS_TASK_VDI_DISABLE_SUCCESS_DURATION
DATAID_WMS_TASK_VDI_NEW_DESKTOP_TEMPLATE_SUCCESS_DURATION
DATAID_WMS_TASK_HOME_ENABLE_DP_SUCCESS_DURATION
DATAID_WMS_TASK_HOME_DISABLE_DP_SUCCESS_DURATION
DATAID_WMS_TASK_VDI_OPEN_DESKTOP_SUCCESS_DURATION
DATAID_WMS_TASK_VDI_IMPORT_DESKTOP_SUCCESS_DURATION
DATAID_WMS_TASK_VDI_NEW_DESKTOP_SUCCESS_DURATION
DATAID_WMS_TASK_DESKTOPS_SORT_BY_STATION
DATAID_WMS_TASK_HOME_SAVE_CONNECTION
FLASHW_CAPTION
DATAID_WMS_UI_EXCEPTION
EWX_HYBRID_SHUTDOWN
DATAID_WMS_TASK_HOME_SHUTDOWN
EWX_SHUTDOWN
CRED_TYPE_UNKNOWN
WTSINFO
WMS_SESSION_INFO
System.IO
DATAID_WMS_TASK_HOME_REMAP
WMS_Setting_Unique_IP
DATAID_WMS_TASK_DESKTOPS_HELP
FLASHW_STOP
DATAID_WMS_TASK_DESKTOPS_CLOSE_APP
DATAID_WMS_TASK_DESKTOPS_UNGROUP
ERROR_INSUFFICIENT_BUFFER
MAX_BUFFER
FLASHW_TIMER
CERT_SYSTEM_STORE_CURRENT_USER
CREDUIWIN_ENUMERATE_CURRENT_USER
DATAID_WMS_TASK_DESKTOPS_SORT_BY_USER
HRESULT_ERROR_INVALID_PARAMETER
E_POINTER
DATAID_WMS_TASK_DESKTOPS_GROUP_BY_COMPUTER
DATAID_WMS_TASK_DESKTOPS_SORT_BY_COMPUTER
PRODUCT_MULTIPOINT_STANDARD_SERVER
PRODUCT_MULTIPOINT_PREMIUM_SERVER
ThrowExceptionForHR
DATAID_WMS_TASK_VDI_ENABLE_FAIL_ERROR
DATAID_WMS_TASK_VDI_DISABLE_FAIL_ERROR
DATAID_WMS_TASK_VDI_NEW_DESKTOP_TEMPLATE_FAIL_ERROR
DATAID_WMS_TASK_HOME_ENABLE_DP_FAIL_ERROR
DATAID_WMS_TASK_HOME_DISABLE_DP_FAIL_ERROR
DATAID_WMS_TASK_VDI_OPEN_DESKTOP_FAIL_ERROR
DATAID_WMS_TASK_VDI_IMPORT_DESKTOP_FAIL_ERROR
DATAID_WMS_TASK_VDI_NEW_DESKTOP_FAIL_ERROR
CERT_SYSTEM_STORE_SERVICES
DATAID_WMS_TASK_DESKTOPS_CLEAR_CHAT_MESSAGES
DATAID_WMS_DASHBOARD_DURATION_MINUTES
DATAID_WMS_MANAGER_DURATION_MINUTES
DATAID_WMS_TASK_HOME_SETTINGS
DATAID_WMS_SETTINGS
DATAID_WMS_TASK_HOME_ADD_CALS
DATAID_WMS_TASK_HOME_MANAGE_CALS
DATAID_WMS_TASK_HOME_REMOVE_CALS
CREDUIWIN_ENUMERATE_ADMINS
EWX_RESTARTAPPS
SystemOperatingModePS
UserTypePS
ThumbnailSizePS
EDisplayOrientationPS
CERT_SYSTEM_STORE_USERS
DATAID_WMS_TASK_HOME_MANAGE_COMPUTERS
DATAID_WMS_MANAGED_SERVERS
DATAID_WMS_TASK_USERS_CHANGE_ACCESS
ERROR_SUCCESS
RPC_S_CALL_IN_PROGRESS
ERROR_FILE_EXISTS
ArrayOfWMS_SESSION_INFO_WS
ArrayOfWMS_RUNNING_APP_WS
ArrayOfWMS_USER_WS
ERROR_BAD_FORMAT
WTS_CONSOLE_DISCONNECT
WTS_REMOTE_DISCONNECT
WTS_CONSOLE_CONNECT
WTS_REMOTE_CONNECT
DATAID_WMS_TASK_DESKTOPS_CONFIG_WEB_LIMIT
DATAID_WMS_TASK_USERS_ADD_ACCOUNT
NETSETUP_PROVISION_REUSE_ACCOUNT
DATAID_WMS_TASK_USERS_DELETE_ACCOUNT
EWX_REBOOT
CREDUIWIN_SECURE_PROMPT
DATAID_WMS_TASK_HOME_RESTART
DATAID_WMS_TASK_VDI_ENABLE_START
DATAID_WMS_TASK_VDI_DISABLE_START
DATAID_WMS_TASK_VDI_NEW_DESKTOP_TEMPLATE_START
DATAID_WMS_TASK_HOME_ENABLE_DP_START
DATAID_WMS_TASK_HOME_DISABLE_DP_START
DATAID_WMS_TASK_VDI_OPEN_DESKTOP_START
DATAID_WMS_TASK_VDI_IMPORT_DESKTOP_START
DATAID_WMS_TASK_VDI_NEW_DESKTOP_START
HRESULT_ERROR_TIMEOUT
HRESULT_WS_E_OPERATION_TIMED_OUT
get_SKU
set_SKU
GetSKU
lpMachineAccountOU
get_ScheduleUpdateRunWU
set_ScheduleUpdateRunWU
DATAID_WMS_TASK_DESKTOPS_THUMBNAIL_VIEW
CREDUIWIN_PACK_32_WOW
CredReadW
CredDeleteW
CredWriteW
HtmlHelpW
CREDUIWIN_CHECKBOX
FLASHW_TRAY
CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY
CERT_SYSTEM_STORE_CURRENT_USER_GROUP_POLICY
DEVICE_NOT_READY
DATAID_WMS_TASK_STATUS_IDENTIFY
CREDUIWIN_IN_CRED_ONLY
CREDUIWIN_AUTHPACKAGE_ONLY
E_OUTOFMEMORY
CERT_STORE_PROV_MEMORY
ERROR_RETRY
CERT_STORE_PROV_SYSTEM_REGISTRY
value__
PowershellSchema
PowershellWmsEndpointSchema
schema
get_Data
CoreData
pProvisionBinData
get_ExtensionData
set_ExtensionData
pProvisionTextData
GetDiskProtectionNeededSpaceInGb
mscorlib
owfCredBlob
credentialBlob
KeyboardOrMouseFoundOnRootHub
Dynamic
HtmlHelp_DisplayTopic
HhDisplayTopic
topic
System.Collections.Generic
TraceLoggingWriteUiMetric
metric
ShowWindowAsync
get_TimeStampInUtc
set_TimeStampInUtc
WtsOEMId
durationDataId
errorDataId
dataId
get_CollabId
set_CollabId
get_VirtualMachineId
set_VirtualMachineId
pwsVirtualMachineId
virtualMachineId
WtsClientHardwareId
get_UniqueId
set_UniqueId
GetSessionFromId
domainId
get_SessionId
set_SessionId
GetStationFromSessionId
teacherSessionId
WtsSessionId
studentSessionId
currentSessionId
sessionId
get_StationId
set_StationId
stationId
procesId
get_ProcessId
set_ProcessId
get_ChatId
set_ChatId
sGuidChatId
guidChatId
IMultiPointChat.GetChatId
guidDestChatId
WtsClientProductId
SqmDatapointId
get_WindowId
set_WindowId
windowId
ePropertyId
EWmsRemoteManagementPropertyId
stopWorkerThread
workerThread
PrivTagsAdvanced
OnDeviceAdded
add_StationDeviceAdded
remove_StationDeviceAdded
add_StationAdded
remove_StationAdded
OnStationAdded
add_PeerServerAdded
remove_PeerServerAdded
OnPeerServerAdded
GetFreeSpaceNeeded
Suspended
add_BootToConsoleModeChanged
remove_BootToConsoleModeChanged
add_SystemModeChanged
remove_SystemModeChanged
add_SessionStateChanged
remove_SessionStateChanged
add_SessionProjectionStateChanged
remove_SessionProjectionStateChanged
add_DesktopMonitoringChanged
remove_DesktopMonitoringChanged
add_ScheduledUpdateSettingsChanged
remove_ScheduledUpdateSettingsChanged
OnScheduledUpdateSettingsChanged
add_PropertyChanged
remove_PropertyChanged
INotifyPropertyChanged
get_IsLocked
set_IsLocked
pfIsLocked
tmpIsLocked
isLocked
IsUsbStorageDeviceBlocked
get_IsUsbStorageBlocked
set_IsUsbStorageBlocked
add_SessionBlocked
remove_SessionBlocked
OnSessionBlocked
add_SessionUnblocked
remove_SessionUnblocked
OnSessionUnblocked
Interlocked
get_Blanked
set_Blanked
get_BootToConsoleModeEnabled
set_BootToConsoleModeEnabled
fBootToConsoleModeEnabled
get_IsScheduleUpdateEnabled
set_IsScheduleUpdateEnabled
isScheduleUpdateEnabled
get_DesktopMonitoringEnabled
set_DesktopMonitoringEnabled
fDesktopMonitoringEnabled
isDesktopMonitoringEnabled
get_IsIPPerSessionEnabled
set_IsIPPerSessionEnabled
IsVirtualIpPerSessionEnabled
get_IsAdminOrchestrationEnabled
set_IsAdminOrchestrationEnabled
IsConfigurationEnabled
isConfigurationEnabled
IsVirtualDesktopEnabled
get_IsChatEnabled
set_IsChatEnabled
IsPolicyEnabled
AutoLogonCredentialFailed
get_WebServiceCallFailed
get_CoreCallFailed
IsInstalled
isInstalled
get_DiskProtectionNotInstalled
get_DiskProtectionAlreadyInstalled
WMS_Domin_Joined
IsHostDomainJoined
WMS_Domain_notJoined
NetSetupUnjoined
bytesReturned
returned
LandscapeFlipped
PortraitFlipped
EventSinkStillRegistered
EventSinkAlreadyUnregistered
add_PeerServerDiscovered
remove_PeerServerDiscovered
OnPeerServerDiscovered
NERR_DS8DCRequired
NERR_LDAPCapableDCRequired
add_StationConfigured
remove_StationConfigured
NotConfigured
disposed
Paused
OnGroupUpdated
add_UserGroupUpdated
remove_UserGroupUpdated
add_UserUpdated
remove_UserUpdated
OnUserUpdated
add_UserCreated
remove_UserCreated
OnUserCreated
NotConnected
OnSessionDisconnected
add_StationSessionDisconnected
remove_StationSessionDisconnected
get_IsDisconnected
set_IsDisconnected
pfIsDisconnected
tmpIsDisconnected
isDisconnected
add_UserDeleted
remove_UserDeleted
OnUserDeleted
IsSessionWebLimited
get_IsWebLimited
set_IsWebLimited
IpAddressListCommaDelimited
IsMultiPointProtocolVersionSupported
NERR_ProvisioningBlobUnsupported
NERR_TargetVersionUnsupported
LsaConnectUntrusted
add_MessageReceived
remove_MessageReceived
OnMessageReceived
add_ErrorReceived
remove_ErrorReceived
OnErrorReceived
add_SystemAlertArrived
remove_SystemAlertArrived
add_StationAlertArrived
remove_StationAlertArrived
OnDeviceRemoved
add_StationDeviceRemoved
remove_StationDeviceRemoved
add_StationRemoved
remove_StationRemoved
OnStationRemoved
add_PeerServerRemoved
remove_PeerServerRemoved
OnPeerServerRemoved
reserved
get_IsDesktopMonitoringAllowed
set_IsDesktopMonitoringAllowed
Fixed
System.Collections.Specialized
ForceMinimized
ShowMinimized
ShowMaximized
IsUserAuthorized
cbSid
WinRemoteLogonIdSid
WinWorldSid
WinNetworkServiceSid
WinLocalServiceSid
WinServiceSid
WinRestrictedCodeSid
WinInteractiveSid
WinSelfSid
WinBatchSid
GetLengthSid
WinNetworkSid
WinLocalSid
WinNullSid
WinLocalSystemSid
WinBuiltinDomainSid
CreateWellKnownSid
WinDialupSid
WinCreatorGroupSid
UsersGroupSid
AdministratorsGroupSid
WinCreatorOwnerSid
WinAuthenticatedUserSid
WinTerminalServerSid
WinCreatorGroupServerSid
WinCreatorOwnerServerSid
WinBuiltinReplicatorSid
WinAccountAdministratorSid
WinLogonIdsSid
WinAccountSchemaAdminsSid
WinAccountEnterpriseAdminsSid
WinAccountDomainAdminsSid
WinAccountCertAdminsSid
WinAccountPolicyAdminsSid
WinEnterpriseControllersSid
WinAccountControllersSid
WinAccountDomainUsersSid
WinBuiltinUsersSid
WinBuiltinRemoteDesktopUsersSid
WinBuiltinPowerUsersSid
WinAccountComputersSid
WinAccountRasAndIasServersSid
WinBuiltinSystemOperatorsSid
WinBuiltinNetworkConfigurationOperatorsSid
WinBuiltinBackupOperatorsSid
WinBuiltinPrintOperatorsSid
WinBuiltinAccountOperatorsSid
WinBuiltinAdministratorsSid
WinBuiltinPreWindows2000CompatibleAccessSid
WinAccountDomainGuestsSid
WinBuiltinGuestsSid
WinAnonymousSid
WinAccountKrbtgtSid
LookupAccountSid
WinAccountGuestSid
WinNtAuthoritySid
WinProxySid
get_id
set_id
IsSessionIdValid
IsStationIdValid
SidTypeInvalid
get_AutoLogonNameIsInvalid
NewGuid
extensionDataField
ProcessIdField
WindowIdField
idField
wsFullNameField
wsUserNameField
wsNameField
CreateTimeField
UserTypeField
stateField
<IM>k__BackingField
<SKU>k__BackingField
<ScheduleUpdateRunWU>k__BackingField
<TimeStampInUtc>k__BackingField
<CollabId>k__BackingField
<VirtualMachineId>k__BackingField
<UniqueId>k__BackingField
<SessionId>k__BackingField
<StationId>k__BackingField
<ProcessId>k__BackingField
<ChatId>k__BackingField
<WindowId>k__BackingField
<IsLocked>k__BackingField
<IsUsbStorageBlocked>k__BackingField
<Blanked>k__BackingField
<BootToConsoleModeEnabled>k__BackingField
<IsScheduleUpdateEnabled>k__BackingField
<DesktopMonitoringEnabled>k__BackingField
<IsIPPerSessionEnabled>k__BackingField
<IsAdminOrchestrationEnabled>k__BackingField
<IsChatEnabled>k__BackingField
<IsDisconnected>k__BackingField
<IsWebLimited>k__BackingField
<IsDesktopMonitoringAllowed>k__BackingField
<Password>k__BackingField
<AutoLogOnPassword>k__BackingField
<ErrorCode>k__BackingField
<Mode>k__BackingField
<BootToConsoleMode>k__BackingField
<AutomaticUpdateMode>k__BackingField
<ScheduledUpdateMode>k__BackingField
<OperatingMode>k__BackingField
<ThumbnailImage>k__BackingField
<Message>k__BackingField
<BlankedMessage>k__BackingField
<ConnectionErrorMessage>k__BackingField
<IsBitmapUnavailable>k__BackingField
<IsOrchestratable>k__BackingField
<Title>k__BackingField
<Name>k__BackingField
<VirtualMachineName>k__BackingField
<ParentVirtualMachineName>k__BackingField
<FullName>k__BackingField
<VmName>k__BackingField
<DomainName>k__BackingField
<DomainOrWorkgroupName>k__BackingField
<UserName>k__BackingField
<AutoLogOnUserName>k__BackingField
<PublisherUserName>k__BackingField
<ComputerName>k__BackingField
<ServerName>k__BackingField
<RemoteConnectionServerName>k__BackingField
<ClientName>k__BackingField
<VirtualMachineHostName>k__BackingField
<FriendlyName>k__BackingField
<CreateTime>k__BackingField
<IsVirtualMachine>k__BackingField
<VMType>k__BackingField
<DeviceType>k__BackingField
<NotificationType>k__BackingField
<UserType>k__BackingField
<DiscoverType>k__BackingField
<ManagedSystemsType>k__BackingField
<EventType>k__BackingField
<AlertType>k__BackingField
<State>k__BackingField
<ReturnState>k__BackingField
<ScheduleUpdatesReturnState>k__BackingField
<ScreenBroadcastState>k__BackingField
<IsPrivate>k__BackingField
<OverrideAdminWarning>k__BackingField
<DesktopMonitoring>k__BackingField
<ConnectionString>k__BackingField
<IsInLimiting>k__BackingField
<VirtualDiskPath>k__BackingField
<CustomScriptFullPath>k__BackingField
<Block>k__BackingField
<eventSink>k__BackingField
<DoWork>k__BackingField
<Credential>k__BackingField
<AutoLogonCredential>k__BackingField
<IsRail>k__BackingField
<Thumbnail>k__BackingField
<All>k__BackingField
<RemoteControl>k__BackingField
<OperatingSystem>k__BackingField
<IsAutoLogOn>k__BackingField
<IsAllowRemoteManagementOn>k__BackingField
<VirtualMachineFqdn>k__BackingField
<ServerFqdn>k__BackingField
<ManagedServerFqdn>k__BackingField
<PeerServerFqdn>k__BackingField
<SessionHostFqdn>k__BackingField
<StationHostFqdn>k__BackingField
<IsAdmin>k__BackingField
<DisableAutoLogon>k__BackingField
<ProtocolVersion>k__BackingField
<ServerVersion>k__BackingField
<WmsServerVersion>k__BackingField
<ClientVersion>k__BackingField
<WmsClientVersion>k__BackingField
<IPPerSession>k__BackingField
<SuppressPrivacyNotification>k__BackingField
<AdminOrchestration>k__BackingField
<Configuration>k__BackingField
<Invitation>k__BackingField
<DisplayOrientation>k__BackingField
<WindowsEdition>k__BackingField
<Description>k__BackingField
<FileToRun>k__BackingField
<Desktop>k__BackingField
<IsMOGUser>k__BackingField
<SingleSessionPerUser>k__BackingField
<IsSingleSessionPerUser>k__BackingField
<HasNonLoopbackAdapter>k__BackingField
<Server>k__BackingField
<SessionHostServer>k__BackingField
<ConnectionError>k__BackingField
<UpdateStartHour>k__BackingField
<DeviceTypes>k__BackingField
<IpAddresses>k__BackingField
<ManagedServerIpAddresses>k__BackingField
<HourToScheduleUpdates>k__BackingField
<Sites>k__BackingField
<CustomScriptMaxRuntimeMinutes>k__BackingField
<PersonalComputers>k__BackingField
<ExcludedPersonalComputers>k__BackingField
<CloudServers>k__BackingField
<ExcludedCloudServers>k__BackingField
<MultiPointServers>k__BackingField
<ExcludedMultiPointServers>k__BackingField
<MaxViewers>k__BackingField
<PeerServerIpAddress>k__BackingField
<Progress>k__BackingField
<ThumbnailBits>k__BackingField
<Results>k__BackingField
<DeviceCounts>k__BackingField
<NetJoinStatus>k__BackingField
<AlertStatus>k__BackingField
<IsSplit>k__BackingField
<DeviceCount>k__BackingField
<CustomScript>k__BackingField
<ScheduleUpdateCustomScript>k__BackingField
<MaxTimeAllowedForCustomScript>k__BackingField
<IsAllowList>k__BackingField
<SessionHost>k__BackingField
<LocalSessionHost>k__BackingField
<UseHardwareGpu>k__BackingField
<Allow>k__BackingField
<AlertSeverity>k__BackingField
<ExceptionProperty>k__BackingField
HashPiiField
DropPiiField
fIsRailField
wsDomainField
wsWinStationField
wsDescriptionField
hrField
get_BitField
set_BitField
WmsBitField
bitField
WmsVcfSecondWarningThreshold
WmsVcfFirstWarningThreshold
LockWmsUsbStorageCommand
UnlockWmsUsbStorageCommand
EnableWmsScheduledUpdateCommand
DisableWmsScheduledUpdateCommand
GetWmsScheduledUpdateCommand
SetWmsScheduledUpdateCommand
EnableWmsWebLimitingCommand
DisableWmsWebLimitingCommand
GetWmsWebLimitingCommand
SetWmsWebLimitingCommand
AddWmsSystemCommand
RemoveWmsSystemCommand
SearchWmsSystemCommand
StopWmsSystemCommand
GetWmsSystemCommand
SetWmsSystemCommand
RestartWmsSystemCommand
GetWmsVersionCommand
CloseWmsSessionCommand
LockWmsSessionCommand
UnlockWmsSessionCommand
DisconnectWmsSessionCommand
GetWmsSessionCommand
UpdateWmsStationCommand
JoinWmsStationCommand
ClearWmsStationCommand
GetWmsStationCommand
SetWmsStationCommand
SplitWmsStationCommand
SuspendWmsDiskProtectionCommand
EnableWmsDiskProtectionCommand
DisableWmsDiskProtectionCommand
ResumeWmsDiskProtectionCommand
GetWmsDiskProtectionCommand
PublishWmsDesktopCommand
UnpublishWmsDesktopCommand
ShowWmsDesktopCommand
OpenWmsAppCommand
HideWmsIdentifierCommand
ShowWmsIdentifierCommand
RemoveWmsUserCommand
GetWmsUserCommand
SetWmsUserCommand
NewWmsUserCommand
GetRunningAppsCommand
GetWmsAlertCommand
showCommand
command
Append
RegistryValueKind
NERR_DS8DCNotFound
get_PublishedSessionNotFound
BringWindowToForeground
set_IsBackground
method
Discard
WMS_Sku_Standard
ErrorRecord
ProcessRecord
SetDword
get_Password
set_Password
remotePassword
pwsWmsControlPassword
m_controlPassword
GenerateRandomPassword
get_AutoLogOnPassword
set_AutoLogOnPassword
autologonPassword
wsPassword
pwsWmsManagementPassword
pcchMaxPassword
pszPassword
password
Reserved44Keyword
CriticalDataKeyword
MeasuresKeyword
TelemetryKeyword
EEM_Role_Oobe
EEM_Connector_Oobe
Replace
neededSpace
DomainNameRegexPeriodSpace
GroupNameRegexPeriodSpace
UserNameRegexPeriodSpace
ComputerNameRegexPeriodSpace
IsNullOrWhiteSpace
wmiNamespace
WmsPowerShellNamespace
CimV2namespace
set_Runspace
runspace
get_StackTrace
HubMissingRequiredDevice
UnInstallDiskProtectionService
ProductAndServicePerformance
Maintenance
InkingTypingAndSpeechUtterance
CreateInstance
hInstance
CriticalPersistence
NormalPersistence
m_fqdnSource
BitmapSource
TelemetryEventSource
get_ErrorCode
set_ErrorCode
NativeErrorCode
SecurityEventCode
hostNamePunyCode
WMS_Setting_Boot_To_Console_Mode
get_Mode
set_Mode
SetDiskProtectionServiceInDiscardMode
SystemInSafeMode
HandleMode
get_BootToConsoleMode
set_BootToConsoleMode
HandleBootToConsoleMode
IsBootToConsoleMode
SetBootToConsoleMode
bootToConsoleMode
peMode
EAutomaticUpdateMode
get_AutomaticUpdateMode
set_AutomaticUpdateMode
EScheduledUpdateMode
get_ScheduledUpdateMode
set_ScheduledUpdateMode
SetDiskProtectionServiceInPassiveMode
get_OperatingMode
set_OperatingMode
SystemOperatingMode
get_SystemMode
set_SystemMode
requestedSystemMode
GetSystemMode
systemMode
set_UserNamePasswordValidationMode
GetSystemOperationMode
IsAdminOrchestrationMode
SetAdminOrchestrationMode
EDiskProtectionMode
get_DiskProtectionMode
set_DiskProtectionMode
GetDiskProtectionMode
diskProtectionMode
EExecutionMode
ShutdownMode
EWmsMode
SwitchWmsMode
SetWmsMode
GetMode
SetMode
get_BootMode
InstanceContextMode
SecurityMode
get_Unicode
ZeroFreeGlobalAllocUnicode
SecureStringToGlobalAllocUnicode
hostNameUnicode
GetUnicode
Include
Exclude
CredFree
CoTaskMemFree
NetApiBufferFree
authPackage
LsaLookupAuthenticationPackage
get_ThumbnailImage
set_ThumbnailImage
get_SystemImage
set_SystemImage
systemImage
ProductAndServiceUsage
get_Message
set_Message
encodedMessage
get_BlankedMessage
set_BlankedMessage
wsLockMessage
lockMessage
SetBlockAllMessage
get_NotificationMessage
set_NotificationMessage
notificationMessage
get_ConnectionErrorMessage
set_ConnectionErrorMessage
wsMessage
message
OnBootToConsoleModeChange
OnSystemModeChange
OnProjectionStateChange
OnDesktopMonitoringChange
OnServiceControlSessionChange
CompareExchange
Large
pullCookie
cookie
EndInvoke
BeginInvoke
get_ESystemAlertWmsAlertTypeTable
eSystemAlertWmsAlertTypeTable
get_EStationAlertWmsAlertTypeTable
eStationAlertWmsAlertTypeTable
get_WmsAlertSeverityTable
alertSeverityTable
ThrowErrorIfMogIsNotApplicable
get_IsBitmapUnavailable
set_IsBitmapUnavailable
fEnable
enable
Enumerable
IDisposable
get_IsOrchestratable
set_IsOrchestratable
get_Handle
LsaHandle
RuntimeFieldHandle
RuntimeTypeHandle
CloseHandle
GetTypeFromHandle
LocalServerHandle
ITerminalServerHandle
serverHandle
EventWaitHandle
parentHandle
get_MainWindowHandle
windowHandle
handle
hFile
WorkProfile
ProfessionalAndPersonalProfile
IsVolatile
IsInRole
Console
get_Title
set_Title
wsTitle
title
GetUpdateSchedule
SetUpdateSchedule
module
WindowShowStyle
get_Name
set_Name
lpDcName
serviceName
eventSourceName
PackageName
DashboardExeFileName
ManagerExeFileName
lpFileName
moduleName
get_MachineName
get_VirtualMachineName
set_VirtualMachineName
tempVirtualMachineName
pwsVirtualMachineName
get_ParentVirtualMachineName
set_ParentVirtualMachineName
virtualMachineName
lpMachineName
machineName
storeName
exeName
cchName
get_FullName
set_FullName
ValidateFullName
get_wsFullName
set_wsFullName
fullName
get_VmName
set_VmName
lpSystemName
pwszSystemName
get_DomainName
set_DomainName
cbDomainName
cchReferencedDomainName
NetSetupDomainName
WtsDomainName
pwsDomainName
pszDomainName
pwszDomainName
domainName
WtsApplicationName
endpointConfigurationName
WtsWinStationName
wsStationName
SetStationName
get_WindowStationName
windowStationName
stationName
ProviderSectionName
remoteServerConnectionName
lpName
virtualDesktopName
FullMogGroupName
MultipointOperatorGroupName
NetSetupWorkgroupName
get_DomainOrWorkgroupName
set_DomainOrWorkgroupName
MultiPointTelemetryProviderName
bstrTeacherName
wsTeacherName
teacherName
GetProcessOwnerName
get_UserName
set_UserName
autologonCombinedUserName
ValidateUserName
remoteUserName
WmsCallbackUserName
WmsShellUserName
get_LoggedInUserName
set_LoggedInUserName
loggedInUserName
get_AutoLogOnUserName
set_AutoLogOnUserName
ValidateDomainUserName
tempAutologonUserName
autologonUserName
wsTeacherUserName
teacherUserName
get_PublisherUserName
set_PublisherUserName
pbstrUserName
WtsUserName
get_wsUserName
set_wsUserName
FormatUserName
pcchMaxUserName
pszUserName
userName
get_ComputerName
set_ComputerName
ValidateComputerName
LocalComputerName
computerName
get_ServerName
set_ServerName
IMultiPointStation.GetStationServerName
SetStationServerName
get_RemoteConnectionServerName
set_RemoteConnectionServerName
remoteConnectionServerName
wsTeacherServerName
teacherServerName
bstrServerName
pwsServerName
serverName
GetLocalBuiltInAdministratorName
WmsShellProcessName
get_wsName
set_wsName
ProductName
oldTargetName
newTargetName
targetName
get_ClientName
set_ClientName
WtsClientName
clientName
SystemSubTabEventName
VirtualDesktopSubTabEventName
UsersSubTabEventName
StatusSubTabEventName
WizardLoadedEventName
TaskCompletedEventName
OrchestrationAppEventName
TryGetEventName
eventName
cbAccountName
WmsControlAccountName
pwszAccountName
GetSystemShortName
shortName
GetFullyQualifiedHostName
get_VirtualMachineHostName
set_VirtualMachineHostName
bstrVirtualMachineHostName
remoteHostName
wsWmsSystemHostName
wsHostName
ExtractHostName
GetHostName
get_FriendlyName
set_FriendlyName
IMultiPointStation.GetStationFriendlyName
IMultiPointStation.SetStationFriendlyName
HandleSetStationFriendlyName
pwsFriendlyName
pcchMaxDomainame
username
get_SetWmsStationInvalidHostname
pwsVirtualMachineHostname
IMultiPointServer.GetVirtualMachineHostname
NERR_CantVerifyHostname
hostname
BitmapFrame
WtsIdleTime
idleTime
lastWritten_highDateTime
lastWritten_lowDateTime
updateTime
get_CreateTime
set_CreateTime
ullCreateTime
createTime
WorkTime
WtsLogonTime
ConnectTime
DisconnectTime
CurrentTime
LastInputTime
WaitOne
get_NewLine
Combine
IsLocalMachine
get_IsVirtualMachine
set_IsVirtualMachine
ManagedSystemOffline
add_ManagedServerOffline
remove_ManagedServerOffline
OnManagedServerOffline
add_VirtualDesktopOnline
remove_VirtualDesktopOnline
OnVirtualDesktopOnline
add_ManagedServerOnline
remove_ManagedServerOnline
OnManagedServerOnline
Landscape
ManagementScope
get_VMType
set_VMType
WellKnownSidType
X509FindType
EDeviceType
get_DeviceType
set_DeviceType
supportedDeviceType
UserNameType
EHostNameType
hostNameType
VirtualMachineType
peType
ValueType
dwEncodingType
MonitoringType
monitoringType
AuthType
authType
VirtualDiskType
MessageCredentialType
set_ClientCredentialType
HttpClientCredentialType
set_ProxyCredentialType
HttpProxyCredentialType
WtsClientProtocolType
get_MonitoringSystemType
set_MonitoringSystemType
get_NotificationType
set_NotificationType
EVirtualDesktopNotificationType
eVirtualDesktopNotificationType
collectionType
get_ConnectionType
set_ConnectionType
VirtualMachineConnectionType
connectionType
get_UserType
set_UserType
userType
EDiscoverType
get_DiscoverType
set_DiscoverType
eDiscoverType
get_ManagedSystemsType
set_ManagedSystemsType
ValidateManagedSystemsType
GetManagedSystemsType
managedSystemsType
OperationSystemProductType
WmsFaultType
eMgmtType
EWmsRemoteManagementType
get_EventType
set_EventType
ServiceControlSessionEventType
dwEventType
endpointType
get_AlertType
set_AlertType
ESystemAlertType
esystemAlertType
EStationAlertType
estationAlertType
GetWmsAlertType
wmsAlertType
alertType
SessionHostType
EWmsRemoteManagementHostType
Compare
Where
System.Core
PresentationCore
X509Store
CertCloseStore
CertOpenStore
hCertStore
m_MultiPointCertStore
Restore
Swrestore
NERR_ConnectionInsecure
PtrToStructure
structure
get_Culture
set_Culture
resourceCulture
get_InvariantCulture
get_CurrentCulture
SidNameUse
peUse
WSHttpBindingBase
ServiceHostBase
LicensingAndPurchase
GetChatIdResponse
GetStationServerNameResponse
GetStationFriendlyNameResponse
SetStationFriendlyNameResponse
GetVirtualMachineHostnameResponse
SetSslCertificateResponse
GetReplacementSslCertificateResponse
SetReplacementSslCertificateResponse
RequestSslCertificateResponse
GetWmsWebLimitingResponse
SendMsgResponse
RegisterCoreEventSinkResponse
RegisterChatEventSinkResponse
ConfigureWebLimitingAllResponse
GetServerVersionResponse
GetClientVersionResponse
RunFileSessionResponse
LockSessionResponse
IdentifySessionResponse
GetStationAutoLogonInformationResponse
GetStationInformationResponse
IdentifyStationResponse
LoadWindowsEditionResponse
SetUserInfoResponse
ShareDesktopResponse
OnboardVirtualDesktopResponse
ViewDesktopResponse
AddUserResponse
RemoveUserResponse
SendErrorResponse
GetScheduledUpdateSettingsResponse
SetScheduledUpdateSettingsResponse
RequestWmsControlCredentialsResponse
GetAllSessionsResponse
GetSessionRunningAppsResponse
EnumerateUsersResponse
GetVirtualMachineIpAddressResponse
GetThumbnailBitsResponse
GetNetJoinStatusResponse
ConnectResponse
DisconnectResponse
ValidateAutoLogonAccountResponse
GetPeerWmsServerListResponse
GetPeerWmsConnectorListResponse
OnNewServerCertificateReadyResponse
OnManagedServerOfflineNotifyResponse
OnManagedServerOnlineNotifyResponse
CurrentActivityResponse
Close
Dispose
TryParse
X509Certificate
set_Certificate
get_ServiceCertificate
ppSslCertificate
IMultiPointCredentialRequest.SetSslCertificate
IMultiPointServer.GetReplacementSslCertificate
IMultiPointServer.SetReplacementSslCertificate
IMultiPointCertificateRequest.RequestSslCertificate
certificate
Validate
WmsScheduledUpdate
Create
MulticastDelegate
Negotiate
get_TakeControlWindowTitleTemplate
VirtualDesktopTemplate
get_State
set_State
EditorBrowsableState
VirtualMachineState
peState
GetScreenState
peSplitScreenState
TSSessionState
peIdentifyStationState
identifyStationState
get_ConnectionState
SystemConnectionState
GetConnectionState
connectionState
get_InvalidDiskProtectionState
get_ReturnState
set_ReturnState
peReturnState
EScheduleUpdateReturnState
EScheduleUpdatesReturnState
get_ScheduleUpdatesReturnState
set_ScheduleUpdatesReturnState
ImageSysprepState
PreviousState
WtsConnectState
tempSplitState
screenBroadCastState
EScreenBroadcastState
get_ScreenBroadcastState
set_ScreenBroadcastState
get_state
set_state
get_IsPrivate
set_IsPrivate
pfIsPrivate
tmpIsPrivate
isPrivate
ShowNormalNoActivate
ShowMinNoActivate
ShowNoActivate
EventWrite
Remote
CompilerGeneratedAttribute
ContractNamespaceAttribute
GeneratedCodeAttribute
UnverifiableCodeAttribute
DebuggerNonUserCodeAttribute
SuppressMessageAttribute
DebuggableAttribute
EditorBrowsableAttribute
ComVisibleAttribute
AssemblyKeyFileAttribute
AssemblyTitleAttribute
OutputTypeAttribute
AllowEmptyStringAttribute
DebuggerStepThroughAttribute
TargetFrameworkAttribute
AssemblyDelaySignAttribute
AssemblyFileVersionAttribute
SecurityPermissionAttribute
AssemblyConfigurationAttribute
AssemblyDescriptionAttribute
InternalsVisibleToAttribute
DataMemberAttribute
DefaultMemberAttribute
MessageBodyMemberAttribute
MessageParameterAttribute
ServiceBehaviorAttribute
AliasAttribute
FlagsAttribute
CompilationRelaxationsAttribute
CollectionDataContractAttribute
ServiceContractAttribute
MessageContractAttribute
OperationContractAttribute
FaultContractAttribute
AssemblyProductAttribute
CmdletAttribute
AssemblyCopyrightAttribute
CLSCompliantAttribute
XmlRootAttribute
AssemblyCompanyAttribute
RuntimeCompatibilityAttribute
ProcessQueue
TryDequeue
Enqueue
get_Value
dataValue
get_HasValue
TryGetValue
SetValue
GetPropertyValue
value
fSave
NERR_CantLoadOfflineHive
PhysicalDrive
Passive
Active
Remove
pdwProvisionBinDataSize
cbSize
credentialBlobSize
set_MaxReceivedMessageSize
EOrchestrationThumbnailSize
eBitmapSize
SystemDefaultCharSize
InAuthBufferSize
refOutAuthBufferSize
Serialize
Deserialize
SuppressFinalize
Minimize
Maximize
SizeOf
IndexOf
TurnedOff
FullNameBuf
autologonConfig
autoConfig
System.Diagnostics.Tracing
Differencing
System.Threading
NERR_NoJoinPending
WSHttpBinding
m_wsHttpBinding
m_wsHttpsBinding
binding
Encoding
System.Windows.Media.Imaging
EEM_Staging
EUsbStorageDeviceBlocking
usbStorageDeviceBlocking
enabling
Resuming
Listening
IsServiceRunning
WmsSvcNotRunning
System.Runtime.Versioning
get_OverrideAdminWarning
set_OverrideAdminWarning
overrideAdminWarning
XmlTypeMapping
ImportTypeMapping
IdnMapping
Stopping
WMS_Setting_Allow_Monitoring
get_DesktopMonitoring
set_DesktopMonitoring
HandleDesktopMonitoring
SetDesktopMonitoring
FromBase64String
ToBase64String
LSAString
LoadString
ConvertStringToSecureString
ConvertStringToUnsecureString
IsWellFormedOriginalString
get_InvalidInvitationString
GetDefaultRDSConnectionString
GetWMSConnectionString
get_ConnectionString
set_ConnectionString
GetConnectionString
ToString
QuerySessionInformationForString
ReadElementContentAsString
endpointFormatString
GetString
inputString
Substring
disposing
set_DtdProcessing
Pausing
OnSessionConnecting
ConfigureWebLimiting
IMultiPointServer.GetWmsWebLimiting
get_IsInLimiting
set_IsInLimiting
pfIsInLimiting
isInLimiting
Starting
Existing
TerminalServiceSetting
TSGeneralSetting
autologonSetting
HandleRemoteConnectionSetting
TSNetworkAdapterSetting
WebLimitSetting
Saving
Shadowing
Initializing
CreateLog
EventLog
DecodeJpg
IMultiPointChat.SendMsg
wsErrorMsg
ForEach
Match
VersionMismatch
timesToFlash
Refresh
DefaultVirtualDesktopSubPath
get_VirtualDiskPath
set_VirtualDiskPath
get_WmsCmdlet3DllPath
get_CustomScriptFullPath
set_CustomScriptFullPath
pwsCustomScriptFullPath
SHGetKnownFolderPath
GetFolderPath
ManagementPath
endpointPath
WERRegKeyPath
SqmRegKeyPath
WERConsentRegKeyPath
WMSHKLMRegistryPath
WMSRegistryPath
WMSHKCURegistryPath
VirtualMachineRegistryPath
ManagedServerOnlineRegistryPath
WMSSelfHealingRegistryPath
SessionSettingRegistryPath
AutoLogonRegistryPath
WMSVersionRegistryPath
WMSRemoteManagementRegistryPath
WMSPolicyRegistryPath
pszPath
get_Length
FullNameLength
UserNameLength
ComputerNameLength
FullNameBufLength
MaximumLength
DescriptionLength
RandomPasswordBufferLength
bufferLength
StartsWith
HashPii
MarkPii
DropPii
GetAscii
PtrToStringUni
WinRMHttpUri
StringToHGlobalAnsi
AsyncCallback
RemoteCertificateValidationCallback
set_ServerCertificateValidationCallback
callback
Loopback
RegistryKeyPermissionCheck
collectionCreationLock
get_Block
set_Block
IMultiPointSystemOnlineEventSink
m_fqdnToCoreEventSink
IMultiPointServer.RegisterCoreEventSink
UnregisterCoreEventSink
WmsCoreEventSink
GetCoreEventSink
IMultiPointCoreEventSink
UnregisterEventSink
WmsEventSink
m_fqdnToChatEventSink
IMultiPointServer.RegisterChatEventSink
UnregisterChatEventSink
WmsChatEventSink
GetChatEventSink
MultiPointChatEventSink
MultiPointEventSink
get_eventSink
set_eventSink
get_DoWork
set_DoWork
WmsShellConfigTask
AllocHGlobal
FreeHGlobal
Critical
Marshal
Social
PSCredential
get_Credential
set_Credential
UserNamePasswordServiceCredential
set_NegotiateServiceCredential
X509CertificateRecipientServiceCredential
StoreCredential
defaultSaveCredential
saveCredential
NativeCredential
RemoveCredential
get_AutoLogonCredential
set_AutoLogonCredential
psCredential
GetCredential
UserNamePasswordClientCredential
credential
ShowNormal
PublicPersonal
Microsoft.Diagnostics.Telemetry.Internal
System.Security.Principal
IPrincipal
get_CurrentPrincipal
op_GreaterThanOrEqual
AddUrlAcl
DeleteUrlAcl
urlForAcl
System.ServiceModel
System.Collections.ObjectModel
System.ComponentModel
System.IdentityModel
DoWorkInParallel
IChannel
get_Channel
IMultiPointSystemOnlineEventSinkChannel
IMultiPointCoreEventSinkChannel
IMultiPointSessionChannel
IMultiPointStationChannel
IMultiPointDiskProtectionChannel
IMultiPointUserManagerChannel
IMultiPointServerChannel
IMultiPointChatChannel
IClientChannel
IMultiPointCertificateRequestChannel
IMultiPointCredentialRequestChannel
IContextChannel
CommuteAndTravel
EventLevel
PersistencyLevel
level
get_IsRail
set_IsRail
get_fIsRail
set_fIsRail
get_Thumbnail
set_Thumbnail
GetSessionThumbnail
get_HasDetail
get_All
set_All
EnableWebLimitingAll
IMultiPointSession.ConfigureWebLimitingAll
EnableProjectToAll
EnableProjectAll
StopIdentifyAll
ExecuteCoreCall
ExceptionHandlerCoreCall
Small
Install
Uninstall
ole32.dll
Wtsapi32.dll
wtsapi32.dll
Netapi32.dll
netapi32.dll
advapi32.dll
kernel32.dll
shell32.dll
User32.dll
user32.dll
secur32.dll
Crypt32.dll
crypt32.dll
credui.dll
wmsutils.dll
MultiPoint.dll
PowerShell
EEM_WmsShell
powershell
System.Xml
get_RemoteControl
set_RemoteControl
remoteControl
MemoryStream
WtsInitialProgram
FreeCoTaskMem
get_Item
set_Item
get_OperatingSystem
set_OperatingSystem
get_ShouldProcessRemoveWmsSystem
get_ShouldProcessExitWmsSystem
get_ShouldProcessRestartWmsSystem
GetSystem
HostSystem
system
set_Realm
WmsSqm
AuthenticationMechanism
Medium
WMS_Sku_Premium
get_IsAutoLogOn
set_IsAutoLogOn
get_IsAllowRemoteManagementOn
set_IsAllowRemoteManagementOn
resourceMan
Boolean
TimeSpan
get_VirtualMachineFqdn
set_VirtualMachineFqdn
virtualMachineFqdn
wsRemoteFqdn
get_ServerFqdn
set_ServerFqdn
get_ManagedServerFqdn
set_ManagedServerFqdn
get_PeerServerFqdn
set_PeerServerFqdn
serverFqdn
get_SessionHostFqdn
set_SessionHostFqdn
get_StationHostFqdn
set_StationHostFqdn
hostFqdn
FullScreen
add_StationEnteredSplitScreen
remove_StationEnteredSplitScreen
add_StationExitedSplitScreen
remove_StationExitedSplitScreen
OnEnterSplitScreen
OnExitSplitScreen
pidxSplitScreen
InjectXToken
hToken
CredUIWin
X509Chain
chain
SidTypeDomain
tempAutologonDomain
autologonDomain
isHostJoinedToDomain
lpDomain
AppDomain
get_UserDomain
userDomain
pbstrDomain
get_wsDomain
set_wsDomain
GetDomain
domain
get_IsAdmin
set_IsAdmin
get_DisableAutoLogon
set_DisableAutoLogon
HandleAutoLogon
SetStationAutoLogon
EEM_ResetAutoLogon
SetStationAutologon
get_OSVersion
get_Version
get_ProtocolVersion
set_ProtocolVersion
GetProtocolVersion
GetMultiPointProtocolVersion
protocolVersion
get_ServerVersion
set_ServerVersion
get_WmsServerVersion
set_WmsServerVersion
IMultiPointServer.GetServerVersion
WmsVersion
get_InvalidWindowsVersion
pwsVersion
get_ClientVersion
set_ClientVersion
get_WmsClientVersion
set_WmsClientVersion
IMultiPointServer.GetClientVersion
version
IsLockedSession
pidSession
IMultiPointSession.RunFileSession
LogOffConsoleSession
CloseSession
TerminateSession
LogOffSession
WTSLogoffSession
grfSession
StopLockingSession
StopIdentifyingSession
IsMogSession
IMultiPointSession.LockSession
IsAdminSession
get_IPPerSession
set_IPPerSession
HandleIPPerSession
EnableVirtualIpPerSession
DisableVirtualIpPerSession
ConfigureVirtualIpPerSession
idTeacherSession
ITerminalServicesSession
WmsSession
WTSDisconnectSession
GetSession
idStudentSession
IMultiPointSession
IMultiPointSession.IdentifySession
OnEndIdentifySession
OnBeginIdentifySession
session
ShutdownNotification
add_VirtualDesktopNotification
remove_VirtualDesktopNotification
OnVirtualDesktopNotification
get_SuppressPrivacyNotification
set_SuppressPrivacyNotification
HandleSuppressPrivacyNotification
SetSuppressPrivacyNotification
suppressPrivacyNotification
CloseSessionApplication
CloseWmsSessionApplication
get_UserNameAuthentication
set_ProxyAuthentication
GetDefaultVhdLocation
PreciseUserLocation
System.Management.Automation
requireConfirmation
DemographicInformation
GetStationDeviceInformation
SystemInformation
GetStationSplitScreenInformation
IMultiPointStation.GetStationAutoLogonInformation
WTSQuerySessionInformation
IMultiPointStation.GetStationInformation
eOperation
WMS_Setting_Admin_Orchestration
get_AdminOrchestration
set_AdminOrchestration
enableAdminOrchestration
HandleAdminOrchestration
TraceLoggingWriteUiDuration
SetUiDuration
get_Configuration
set_Configuration
DeviceConnectivityAndConfiguration
peConfiguration
LicenseConfiguration
GetScheduledUpdateConfiguration
SetBooleanConfiguration
EAutoLogonConfiguration
idStation
OnConfigureStation
StopIdentifyingStation
RefreshStation
add_SessionAssociatedWithStation
remove_SessionAssociatedWithStation
OnAssociateSessionWithStation
MultiStation
isLoopbackStation
bstrWinStation
get_wsWinStation
set_wsWinStation
ConnectedToStation
WmsStation
wmsStation
GetStation
SplitStation
UnsplitStation
IMultiPointStation
IMultiPointStation.IdentifyStation
OnEndIdentifyStation
OnBeginIdentifyStation
idPrimaryStation
get_Invitation
set_Invitation
pwsInvitation
invitation
EDisplayOrientation
get_DisplayOrientation
set_DisplayOrientation
HandleDisplayOrientation
GetDisplayOrientation
SetDisplayOrientation
eDisplayRotation
GetDisplayRotation
SetDisplayRotation
station
System.Globalization
System.Runtime.Serialization
System.Xml.Serialization
eAction
UnregisterEventSinkAction
RemoteControlAction
EIdentifyStationAction
exceptionHandlerAction
serverAction
SecurityAction
SupportInteraction
op_Subtraction
System.Reflection
X509Certificate2Collection
srcCollection
CloneCollection
X509CertificateCollection
StringCollection
GetManagedServerListFromCollection
ManagedServerCollection
ManagementObjectCollection
destCollection
SetStationRemoteConnection
DefaultTimeoutForPowershellConnection
defaultTimeoutForPowershellConnection
EnableDiskProtection
DisableDiskProtection
UnInstallDiskProtection
get_ShouldProcessSuspendWmsDiskProtection
get_ShouldProcessEnableWmsDiskProtection
get_ShouldProcessDisableWmsDiskProtection
get_ShouldProcessResumeWmsDiskProtection
IMultiPointDiskProtection
get_WindowsEdition
set_WindowsEdition
IMultiPointServer.LoadWindowsEdition
pwsWindowsEdition
windowsEdition
WorkRecognition
BitmapCacheOption
TelemetryInfoOption
caption
Win32Exception
COMException
get_Exception
SecurityAccessDeniedException
NotImplementedException
ActionNotSupportedException
FileNotFoundException
ItemNotFoundException
EndpointNotFoundException
DirectoryNotFoundException
NullReferenceException
ArgumentOutOfRangeException
TraceLoggingWriteUiException
SetUiException
ExternalException
ArgumentNullException
SecurityTokenException
CommunicationException
InvalidOperationException
get_InnerException
UnauthorizedAccessException
UriFormatException
WmsCmdletException
FaultException
ArgumentException
ReportException
TimeoutException
OutOfMemoryException
exception
System.ServiceModel.Description
get_Description
set_Description
ValidateDescription
get_wsDescription
set_wsDescription
description
ContentConsumption
option
StringComparison
get_Singleton
get_FileToRun
set_FileToRun
bstrFileToRun
wsFileToRun
ShuttingDown
add_ServerShutdown
remove_ServerShutdown
SidTypeUnknown
CopyTo
CredUIInfo
FlashWInfo
Wts_Session_Info
CultureInfo
uiInfo
NERR_BadOfflineJoinInfo
NERR_NoOfflineJoinInfo
NERR_CantCreateJoinInfo
NERR_BadDomainJoinInfo
pcSessionInfo
WtsSessionInfo
sessionInfo
RunspaceConnectionInfo
CreateWSManConnectionInfo
IMultiPointUserManager.SetUserInfo
WtsClientInfo
get_InvalidAccountInfo
SecurityInfo
scenario
PtrToStringAuto
StringToCoTaskMemAuto
fqdnMap
HtmlHelp
WmsSvc.Interop
get_Desktop
set_Desktop
IMultiPointSession.ShareDesktop
StopShareDesktop
IMultiPointServer.OnboardVirtualDesktop
StationVirtualDesktop
WmsVirtualDesktop
WmsDesktop
IMultiPointSession.ViewDesktop
RegisterAsRemoteApp
WmsRunningApp
NonDualMessageSecurityOverHttp
WmsShellConfigTaskBackup
SidTypeGroup
MemberRemovedFromGroup
IsUserInAdminGroup
inAdminGroup
SidTypeWellKnownGroup
MemberAddedToGroup
TelemetryGroup
telemetryGroup
EEM_Role_ServiceStartup
EEM_Connector_ServiceStartup
System.Linq
Clear
AppendChar
WtsClientBuildNumber
StringReader
XmlReader
XmlTextReader
XmlDictionaryReader
CloudServiceProvider
CertOpenStoreProvider
storeProvider
IFormatProvider
StringBuilder
UriBuilder
SpecialFolder
sender
JpegBitmapDecoder
cbAuthBuffer
InAuthBuffer
pAuthBuffer
refOutAuthBuffer
CredUnPackAuthenticationBuffer
lpBuffer
buffer
get_ResourceManager
RefreshCoreManager
coreManager
IMultiPointUserManager
ITerminalServicesManager
ServicePointManager
ManagementObjectSearcher
GetNextStationIdentifier
SecurityIdentifier
CmdletThreadWorker
PropertyChangedEventHandler
System.CodeDom.Compiler
caller
ServiceController
hbmBanner
SetStationAutologonHelper
NativeMethodsHelper
LsaStringWrapper
WmsSvcComWrapper
wmsSvcComWrapper
IdentifySessionWrapper
get_IsMOGUser
set_IsMOGUser
IMultiPointUserManager.AddUser
SetCurrentDashboardUser
currentDashboardUser
SidTypeUser
IMultiPointUserManager.RemoveUser
MogUser
IsValidDomainUser
get_SingleSessionPerUser
set_SingleSessionPerUser
HandleSingleSessionPerUser
get_IsSingleSessionPerUser
set_IsSingleSessionPerUser
isSingleSessionPerUser
SetSingleSessionPerUser
get_ShouldProcessRemoveWmsUser
wsUser
CurrentUser
SwitchParameter
StringWriter
TextWriter
Enter
get_HasNonLoopbackAdapter
set_HasNonLoopbackAdapter
XmlReflectionImporter
AddRemoteManagedComputer
RemoveRemoteManagedComputer
SidTypeComputer
get_Server
set_Server
ValidateManagedServer
managedServer
wsFqdnManagingServer
NewOrExistingServer
newOrExistingServer
hServer
GetLocalServer
ITerminalServer
fqdnServer
IMultiPointServer
LocalMultiPointServer
get_SessionHostServer
set_SessionHostServer
AllowRemoteSessionHostServer
sessionHostServer
server
CreateXmlSerializer
get_hr
set_hr
GetLastWin32Error
win32Error
get_Error
IMultiPointChat.SendError
WriteError
authError
lastAuthenticationError
get_ConnectionError
set_ConnectionError
TraceLoggingWriteUiScenarioError
hrError
LoopbackAdaptersError
SetError
WmsCmdletError
ThrowExceptionFromLastError
error
EnvironmentalSensor
set_CustomUserNamePasswordValidator
EventSinkUsernamePasswordValidator
IEnumerator
ManagementObjectEnumerator
GetEnumerator
Administrator
.ctor
.cctor
Monitor
ConvertStructureToPtr
IntPtr
thisWindowPtr
get_UpdateStartHour
set_UpdateStartHour
piScheduledUpdateStartHour
EnumerateStationIDs
pprgWmsSessionInfoWs
pprgwsWmsRunningAppWs
pprgWmsUsersWs
SidTypeAlias
targetAlias
NoPotentialStationHubs
MonitorsWithoutPotentialStationHubs
System.Diagnostics
sessionIds
stationIds
setcreds
Microsoft.WindowsServerSolutions.MultipointServer.PowerShell.Commands
get_TotalSeconds
DefaultPollingPeriodInSeconds
VirtualDesktopCmdletTimeoutInSeconds
DefaultCmdletTimeoutInSeconds
durationSeconds
NativeMethods
FinancialAccountingAndRecords
set_Keywords
EventKeywords
System.Management.Automation.Runspaces
cDevices
BlockUsbStorageDevices
UnblockUsbStorageDevices
System.Runtime.InteropServices
System.Runtime.CompilerServices
System.DirectoryServices
GetWmiInstances
GetInstances
System.Resources
Microsoft.WindowsServerSolutions.MultipointServer.PowerShell.Commands.Library.Properties.Resources.resources
DebuggingModes
Microsoft.WindowsServerSolutions.MultipointServer.PowerShell.Commands.Library.Properties
ImportModules
moduleNames
GetSubKeyNames
get_Frames
WtsIncomingFrames
WtsOutgoingFrames
get_DeviceTypes
set_DeviceTypes
ManagedSystemTypes
cLicenses
get_IpAddresses
set_IpAddresses
get_ManagedServerIpAddresses
set_ManagedServerIpAddresses
wsIpAddresses
System.Security.Cryptography.X509Certificates
get_Certificates
get_TimeToScheduleUpdates
set_TimeToScheduleUpdates
timeToScheduleUpdates
get_HourToScheduleUpdates
set_HourToScheduleUpdates
get_Sites
set_Sites
InterestsAndFavorites
attributes
get_CustomScriptMaxRuntimeMinutes
set_CustomScriptMaxRuntimeMinutes
MinAllowedTimeToRunCustomScriptInMinutes
MaxAllowedTimeToRunCustomScriptInMinutes
AllowedTimeIncrementToRunCustomScriptInMinutes
timeAllowedForCustomScriptInMinutes
returnedBytes
IncomingCompressedBytes
OutgoingCompressedBytes
ArrayOfBytes
WtsIncomingBytes
WtsOutgoingBytes
GetBytes
GetValues
EventFieldTags
EventTags
PartA_PrivTags
validFlags
CertOpenStoreFlags
NativeCredentialFlags
UpdateSessionFlags
GetSessionFlags
dwFlags
FlashWindowFlags
flags
ArrayOfStrings
DataPointStrings
FeedbackAndRatings
EventSourceSettings
IMultiPointDiskProtection.GetScheduledUpdateSettings
IMultiPointDiskProtection.SetScheduledUpdateSettings
GetServerSettings
SessionStateChangedEventArgs
PropertyChangedEventArgs
MessageReceivedEventArgs
ErrorReceivedEventArgs
StationDeviceEventArgs
BootToConsoleModeEventArgs
SystemModeEventArgs
VirtualDesktopOnlineEventArgs
SessionProjectionStateEventArgs
DesktopMonitoringEventArgs
SessionEventArgs
VirtualDesktopNotificationEventArgs
SessionAssociatedWithStationEventArgs
UserEventArgs
ManagedServerEventArgs
PeerServerEventArgs
ScheduledUpdateSettingsEventArgs
SystemAlertEventArgs
StationAlertEventArgs
<>4__this
System.Diagnostics.CodeAnalysis
pdwInactiveTicks
get_Credentials
AddRemoteManagedComputerUsingSuppliedCredentials
ServiceCredentials
IMultiPointCredentialRequest.RequestWmsControlCredentials
TransferCredentials
CredUIPromptForWindowsCredentials
get_ClientCredentials
Equals
System.ServiceModel.Channels
Microsoft.SharedComputing.Utils
get_Streams
PSDataStreams
get_EnableWmsScheduledUpdateInvalidParams
get_LockWmsSessionInvalidParams
get_SetWmsStationInvalidParams
get_OpenWmsAppInvalidParams
get_RemoveWmsUserInvalidParams
get_GetWmsUserInvalidParams
get_SetWmsUserInvalidParams
WindowsAndOtherPrograms
ManagedSystems
System.Windows.Forms
System.IdentityModel.Tokens
Contains
WMS_Setting_Multiple_Sessions
get_Sessions
WTSEnumerateSessions
IMultiPointServer.GetAllSessions
StopIdentifySessions
System.Text.RegularExpressions
sessions
System.Security.Permissions
TSPublishedApplications
MicrosoftCommunications
BlockUsbStorageDevicesAllStations
UnblockUsbStorageDevicesAllStations
RemapStations
GetStations
StopIdentifyStations
stations
WorkplaceInteractions
System.Collections
EventSourceOptions
BitmapCreateOptions
ConnectionOptions
MeasuresOptions
AccessOptions
ObjectGetOptions
dwOptions
TelemetryOptions
RegistryOptions
HandleIdentifyExceptions
GetSessionInfos
Kerberos
IMultiPointSession.GetSessionRunningApps
GetRunningApps
DomainNameRegexInvalidChars
GroupNameRegexInvalidChars
UserNameRegexInvalidChars
ComputerNameRegexInvalidChars
RuntimeHelpers
IMultiPointUserManager.EnumerateUsers
get_DuplicateAutoLogonUsers
get_PersonalComputers
set_PersonalComputers
get_ExcludedPersonalComputers
set_ExcludedPersonalComputers
get_ManagedServers
get_ExcludedManagedServers
GetManagedServers
get_CloudServers
set_CloudServers
get_ExcludedCloudServers
set_ExcludedCloudServers
get_MultiPointServers
set_MultiPointServers
get_ExcludedMultiPointServers
set_ExcludedMultiPointServers
DefaultMaxProjectionViewers
get_MaxViewers
set_MaxViewers
iMaxViewers
maxViewers
SslPolicyErrors
sslPolicyErrors
System.IdentityModel.Selectors
Wts_Info_Class
EventNotificationServiceClass
wtsInfoClass
infoClass
ManagementClass
get_Success
idProcess
ShouldProcess
System.ServiceProcess
LsaDeregisterLogonProcess
GetCurrentProcess
IsLocalIPAddress
remoteAddress
pbstrVirtualMachineIpAddress
IMultiPointServer.GetVirtualMachineIpAddress
wsWmsSystemIpAddress
get_PeerServerIpAddress
set_PeerServerIpAddress
wsIpAddress
WtsClientAddress
EndpointAddress
get_Progress
set_Progress
idProgress
WorkContracts
System.Net.Sockets
cbDataBits
ppbDataBits
dataBits
thumbnailJpgBits
get_ThumbnailBits
set_ThumbnailBits
IMultiPointSession.GetThumbnailBits
WindowsCoreTelemetryTraits
MicrosoftTelemetryTraits
CompensationAndBenefits
get_Results
set_Results
Constants
FOLDERID_PublicDocuments
GetReaderAtDetailContents
get_DeviceCounts
set_DeviceCounts
returnReservedUserAccounts
GetSystemAlerts
GetStationAlerts
GetAlerts
Exists
get_Status
peStatus
get_NetJoinStatus
set_NetJoinStatus
peNetJoinStatus
IMultiPointServer.GetNetJoinStatus
WmsSessionStatus
NetSetupUnknownStatus
ServiceControllerStatus
retStatus
GetSessionAgentStatus
eAccountStatus
EAutoLogonAccountStatus
EAlertStatus
get_AlertStatus
set_AlertStatus
GetSystemAlertStatus
GetStationAlertStatus
alertStatus
status
Concat
WMS_Setting_Allow_Chat
EnableChat
ConfigureChat
pguidStudentChat
IMultiPointChat
GetSitesInInternalFormat
ConvertWebsiteArrayToInternalFormat
CredentialTargetFormat
WmsSystemKeyFormat
AlertKeyFormat
ConfirmImpact
CustomerContact
PSObject
IExtensibleDataObject
ExtensionDataObject
ManagementBaseObject
WriteObject
hObject
ICommunicationObject
ToObject
ManagementObject
object
Project
Select
IMultiPointChat.Connect
get_AttemptingToConnect
set_AttemptingToConnect
attemptingToConnect
get_RetryAttemptToConnect
set_RetryAttemptToConnect
retryAttemptToConnect
IMultiPointChat.Disconnect
serializerDict
QuerySessionInformationForStruct
NetUserModalsGet
System.Net
IsSuppressPrivacyNotificationSet
isSuppressPrivacyNotificationSet
NERR_ValuesNotSet
userNameTarget
fqdnTarget
target
PSCmdlet
WmsRemoteCmdlet
WmsCmdlet
Reset
Portrait
op_Explicit
get_IsSplit
set_IsSplit
CreateMessageFault
ShowDefault
get_HResult
IAsyncResult
hResult
pdwResult
result
ToLowerInvariant
MultiPointSystemOnlineEventSinkClient
MultiPointCoreEventSinkClient
m_fqdnToISessionClient
MultiPointSessionClient
m_fqdnToIStationClient
MultiPointStationClient
stationClient
m_fqdnToIDiskProtectionClient
MultiPointDiskProtectionClient
m_fqdnToIUserManagerClient
MultiPointUserManagerClient
m_fqdnToIServerClient
MultiPointServerClient
m_fqdnToIChatClient
MultiPointChatClient
m_fqdnToICertificateRequestClient
MultiPointCertificateRequestClient
MultiPointCredentialRequestClient
client
System.Management
WMS_Setting_Remote_Management
comment
Environment
LearningAndDevelopment
Recruitment
PaymentInstrument
hwndParent
get_Current
GetCurrent
System.Collections.Concurrent
IsHypervisorPresent
get_IsPresent
CustomerContent
SupportContent
TraceLoggingWriteUiEvent
ManualResetEvent
manualResetEvent
AutoResetEvent
returnStateUint
MultiPoint
SetDatapoint
AddServiceEndpoint
bstrUriSinkEndpoint
OpenEndpoint
uriForEndpoint
endpoint
multipoint
pwsSslCertificateThumbprint
__AlertType_Count
get_Count
get_DeviceCount
set_DeviceCount
deviceCount
get_LicenseCount
set_LicenseCount
GetLicenseCount
licenseCount
attributeCount
get_ConnectionCount
set_ConnectionCount
GetConnectionCount
connectionCount
uCount
SidTypeDeletedAccount
IMultiPointServer.ValidateAutoLogonAccount
get_IsAdministrativeUserAccount
NetProvisionComputerAccount
syncRoot
Reboot
AddScript
get_ConvertWindowsImagePowershellScript
get_CustomScript
set_CustomScript
get_ScheduleUpdateCustomScript
set_ScheduleUpdateCustomScript
get_MaxTimeAllowedForCustomScript
set_MaxTimeAllowedForCustomScript
maxTimeAllowedForCustomScript
pcMaxMinutesAllowedForCustomScript
customScript
prompt
ParameterizedThreadStart
NERR_JoinPerformedMustRestart
ValidateWmsServerCert
passwordForCert
GetEndpointCert
OnSystemAlert
OnStationAlert
CreateWmsAlert
Convert
pSslPort
Support
get_Transport
GetChatIdRequest
GetStationServerNameRequest
GetStationFriendlyNameRequest
SetStationFriendlyNameRequest
GetVirtualMachineHostnameRequest
SetSslCertificateRequest
GetReplacementSslCertificateRequest
SetReplacementSslCertificateRequest
RequestSslCertificateRequest
IMultiPointCertificateRequest
GetWmsWebLimitingRequest
SendMsgRequest
RegisterCoreEventSinkRequest
RegisterChatEventSinkRequest
IMultiPointCredentialRequest
ConfigureWebLimitingAllRequest
GetServerVersionRequest
GetClientVersionRequest
RunFileSessionRequest
LockSessionRequest
IdentifySessionRequest
GetStationAutoLogonInformationRequest
GetStationInformationRequest
IdentifyStationRequest
LoadWindowsEditionRequest
SetUserInfoRequest
ShareDesktopRequest
OnboardVirtualDesktopRequest
ViewDesktopRequest
AddUserRequest
RemoveUserRequest
SendErrorRequest
GetScheduledUpdateSettingsRequest
SetScheduledUpdateSettingsRequest
RequestWmsControlCredentialsRequest
GetAllSessionsRequest
GetSessionRunningAppsRequest
EnumerateUsersRequest
GetVirtualMachineIpAddressRequest
GetThumbnailBitsRequest
GetNetJoinStatusRequest
ConnectRequest
DisconnectRequest
ValidateAutoLogonAccountRequest
GetPeerWmsServerListRequest
GetPeerWmsConnectorListRequest
OnNewServerCertificateReadyRequest
OnManagedServerOfflineNotifyRequest
OnManagedServerOnlineNotifyRequest
CurrentActivityRequest
request
sessionIdList
fIsAllowedList
HostnameList
hostnameList
PtrToStructureList
pwsBlockList
blockList
urlList
masterStationList
ToList
DelegatedGetPeerList
AddToExcludedServerList
RemoveFromManagedServerList
GetManagedServerList
SetManagedServerList
RemoveFromAnyManagedServerList
managedServerList
GetAvailableServerList
IMultiPointServer.GetPeerWmsServerList
prgwsServerList
serverList
IMultiPointServer.GetPeerWmsConnectorList
prgwsConnectorList
masterSessionsList
get_AddressList
wmsIpAddressList
prgwsIpAddressList
CustomerContactList
structList
get_IsAllowList
set_IsAllowList
pfIsAllowList
isAllowList
pwsAllowList
allowList
persist
get_Host
ServiceHost
serviceHost
get_SessionHost
set_SessionHost
get_LocalSessionHost
set_LocalSessionHost
pwsSessionHost
sessionHost
wsStationHost
stationHost
First
set_IdleTimeout
MinPowershellRunspaceIdleTimeout
set_CancelTimeout
set_OpenTimeout
set_OperationTimeout
WaitForConnectionTimeout
WaitForServicesTimeout
dwTimeout
MoveNext
System.Text
pszMessageText
pszCaptionText
threadContext
set_EstablishSecurityContext
get_UseHardwareGpu
set_UseHardwareGpu
fUseHardwareGpu
GetUseHardwareGpu
SetUseHardwareGpu
useHardwareGpu
get_Now
get_UtcNow
promptNow
idWindow
IsForegroundWindow
GetForegroundWindow
SetForegroundWindow
StopFlashingWindow
FlashWindow
GetProcessMainWindow
ShowWindow
nCmdShow
get_Allow
set_Allow
ReportExceptionEx
FlashWindowEx
LoadLibraryEx
nBufferMax
hhctrl.ocx
Regex
WtsClientDisplay
InitializeArray
ToArray
ToCharArray
wmsRunningAppWsArray
userWsArray
SetPrincipalPolicy
SetBooleanPolicy
CostDeferredLatency
RealtimeLatency
NormalLatency
IMultiPointSystemOnlineEventSink.OnNewServerCertificateReady
queueReady
MarkReady
add_SessionAgentReady
remove_SessionAgentReady
OnSessionAgentReady
NotReady
GetChatIdResponseBody
GetStationServerNameResponseBody
GetStationFriendlyNameResponseBody
SetStationFriendlyNameResponseBody
GetVirtualMachineHostnameResponseBody
SetSslCertificateResponseBody
GetReplacementSslCertificateResponseBody
SetReplacementSslCertificateResponseBody
RequestSslCertificateResponseBody
GetWmsWebLimitingResponseBody
SendMsgResponseBody
RegisterCoreEventSinkResponseBody
RegisterChatEventSinkResponseBody
ConfigureWebLimitingAllResponseBody
GetServerVersionResponseBody
GetClientVersionResponseBody
RunFileSessionResponseBody
LockSessionResponseBody
IdentifySessionResponseBody
GetStationAutoLogonInformationResponseBody
GetStationInformationResponseBody
IdentifyStationResponseBody
LoadWindowsEditionResponseBody
SetUserInfoResponseBody
ShareDesktopResponseBody
OnboardVirtualDesktopResponseBody
ViewDesktopResponseBody
AddUserResponseBody
RemoveUserResponseBody
SendErrorResponseBody
GetScheduledUpdateSettingsResponseBody
SetScheduledUpdateSettingsResponseBody
RequestWmsControlCredentialsResponseBody
GetAllSessionsResponseBody
GetSessionRunningAppsResponseBody
EnumerateUsersResponseBody
GetVirtualMachineIpAddressResponseBody
GetThumbnailBitsResponseBody
GetNetJoinStatusResponseBody
ConnectResponseBody
DisconnectResponseBody
ValidateAutoLogonAccountResponseBody
GetPeerWmsServerListResponseBody
GetPeerWmsConnectorListResponseBody
OnNewServerCertificateReadyResponseBody
OnManagedServerOfflineNotifyResponseBody
OnManagedServerOnlineNotifyResponseBody
CurrentActivityResponseBody
GetChatIdRequestBody
GetStationServerNameRequestBody
GetStationFriendlyNameRequestBody
SetStationFriendlyNameRequestBody
GetVirtualMachineHostnameRequestBody
SetSslCertificateRequestBody
GetReplacementSslCertificateRequestBody
SetReplacementSslCertificateRequestBody
RequestSslCertificateRequestBody
GetWmsWebLimitingRequestBody
SendMsgRequestBody
RegisterCoreEventSinkRequestBody
RegisterChatEventSinkRequestBody
ConfigureWebLimitingAllRequestBody
GetServerVersionRequestBody
GetClientVersionRequestBody
RunFileSessionRequestBody
LockSessionRequestBody
IdentifySessionRequestBody
GetStationAutoLogonInformationRequestBody
GetStationInformationRequestBody
IdentifyStationRequestBody
LoadWindowsEditionRequestBody
SetUserInfoRequestBody
ShareDesktopRequestBody
OnboardVirtualDesktopRequestBody
ViewDesktopRequestBody
AddUserRequestBody
RemoveUserRequestBody
SendErrorRequestBody
GetScheduledUpdateSettingsRequestBody
SetScheduledUpdateSettingsRequestBody
RequestWmsControlCredentialsRequestBody
GetAllSessionsRequestBody
GetSessionRunningAppsRequestBody
EnumerateUsersRequestBody
GetVirtualMachineIpAddressRequestBody
GetThumbnailBitsRequestBody
GetNetJoinStatusRequestBody
ConnectRequestBody
DisconnectRequestBody
ValidateAutoLogonAccountRequestBody
GetPeerWmsServerListRequestBody
GetPeerWmsConnectorListRequestBody
OnNewServerCertificateReadyRequestBody
OnManagedServerOfflineNotifyRequestBody
OnManagedServerOnlineNotifyRequestBody
CurrentActivityRequestBody
CreateSubKey
DeleteSubKey
OpenSubKey
managedServersRegKey
ServerVersionKey
ClientVersionKey
configurationKey
AutoLogonRegistryKey
Identify
IMultiPointSystemOnlineEventSink.OnManagedServerOfflineNotify
IMultiPointSystemOnlineEventSink.OnManagedServerOnlineNotify
get_Assembly
get_AddressFamily
StandardVgaAdapterOnly
WindowsOnly
WaitAny
IDictionary
Microsoft.WindowsServerSolutions.MultipointServer.PowerShell.Commands.Library
SearchRequestsAndQuery
TSLicenseKeyPackQuery
Win32OperatingSystemQuery
PartOfDomainQuery
TSLicenseServerQuery
ObjectQuery
ConnectQuery
SLProductQuery
query
ErrorCategory
WTSFreeMemory
RtlZeroMemory
memory
WtsWorkingDirectory
WtsClientDirectory
SoftwareSetupAndInventory
BrowsingHistory
Microsoft.Diagnostics.Telemetry
WindowsCoreTelemetry
MicrosoftTelemetry
IPHostEntry
GetHostEntry
DirectoryEntry
Registry
get_Capacity
op_Equality
op_Inequality
PSUtility
PSLibUtility
EAlertSeverity
get_AlertSeverity
set_AlertSeverity
GetWmsAlertSeverity
alertSeverity
System.ServiceModel.Security
System.Security
System.Net.Security
get_Security
WSHttpSecurity
HttpTransportSecurity
IIdentity
get_Identity
WindowsIdentity
FitnessAndActivity
IMultiPointSession.CurrentActivity
pwsCurrentActivity
GetCurrentActivity
currentActivity
activity
DefaultIfEmpty
allowNullEmpty
IsNullOrEmpty
FileNameProperty
rdpTargetServerConnectionProperty
get_ExceptionProperty
set_ExceptionProperty
QueryRemoteManagementProperty
property
GetIMultiPointSessionProxy
GetIMultiPointStationProxy
GetIMultiPointDiskProtectionProxy
GetHttpProxy
GetIMultiPointUserManagerProxy
GetIMultiPointServerProxy
GetIMultiPointChatProxy
GetClientProxy
GetIMultiPointCertificateRequestProxy
proxy
ETW_GROUP
{4f50731a-89cf-4782-b3e0-dce8c90476ba}
{c7de053a-0c2e-4a44-91a2-5222ec2ecdf1}
Username or password is null.
WmsControl
Username is wrong.
Password is wrong.
ED4824AF-DCE4-45A8-81E2-FC7965083634
wmiNamespace
query
userName
userName is null or empty
[.\s]
UserName cannot be null or empty and its length cannot be greater than 
[/\\"\[\]:|<>=;,\?\*@]
UserName has invalid characters
fullName
Input parameter fullName is null.
FullName cannot be null and its length cannot be greater than 
description
Input parameter description is null.
description cannot be null and its length cannot be greater than 
computerName
computerName is null or empty
computerName cannot be null or empty and its length cannot be greater than 
computerName has invalid characters
value
exception
innerException:
MultiPointVdi.psd1
destCollection
\\.\root\cimv2\TerminalServices:Win32_TSPublishedApplication
remoteapplicationmode:i:1
alternate shell:s:||{0}
remoteapplicationprogram:s:||{1}
remoteapplicationname:s:{2}
remoteapplicationcmdline:s:
{0}\{1}\{2}
Windows MultiPoint Server
Alias
IconIndex
CommandLineSetting
IconPath
RDPFileContents
ShowInPortal
VPath
{0}{1}{2}{3}{4}
bitmapcachesize:i:32000
high resolution mouse:i:0
multimediaenableredirection:i:1
redirectclipboard:i:1
redirectposdevices:i:0
redirectprinters:i:0
redirectcomports:i:0
redirectsmartcards:i:0
devicestoredirect:s:
drivestoredirect:s:*
redirectdrives:i:1
session bpp:i:32
prompt for credentials on client:i:1
span monitors:i:1
use multimon:i:1
server port:i:3389
allow font smoothing:i:1
connection type:i:6
disable wallpaper:i:0
allow desktop composition:i:1
disable full window drag:i:0
disable menu anims:i:0
promptcredentialonce:i:1
authentication level:i:2
gatewayusagemethod:i:2
gatewayprofileusagemethod:i:0
gatewaycredentialssource:i:0
gatewayhostname:s:
\\{0}\root\cimv2\TerminalServices
Select * from Win32_TSPublishedApplication
{0}{1}
{0}\{1}
Software\Microsoft\Windows MultiPoint Server
HostType
HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows MultiPoint Server
HKEY_LOCAL_MACHINE\Software\Microsoft\Windows MultiPoint Server
Mog user is not applicable for the current system
sessionId
IsUserInAdminGroup failed
HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server
fSingleSessionPerUser
EnableDesktopMonitoring
password
secureString
moduleNames
moduleNames is null or empty
runspace
runspace is null or empty
http://{0}:5985/wsman
LsaDeregisterLogonProcess in CredUIPromptForWindowsCredentials() failed, error code: {0}. May cause memory leak.
Win32_NetworkAdapterSetting
Element
AdapterTypeID
ServiceName
kmloop
PhysicalAdapter
MacAddress
BootToConsoleMode
SuppressPrivacyNotification
HKEY_LOCAL_MACHINE\Software\Policies\Microsoft\Windows MultiPoint Server
HKEY_LOCAL_MACHINE\Software\Microsoft\Windows MultiPoint Server\Version
Client
Server
ManagedSystemsType should be one of CloudServers, MultiPointServers or PersonalComputers
The specified server name is not a valid hostname (or) not a valid IPV4 address (or) is not reachable. Please verify and check if the server is reachable.
http://
IsWellFormedOriginalString returns false
WinNT://{0}/{1},user
Hyper-V\Virtual Hard Disks
WmsOperators
Managed Servers
full address:s:
Current Operating System version not supported by TerminalServicesSession function
Exception: {0}, StackTrace: {1}
Unable to find SQM event name for dataId: {0}
Microsoft.Windows.RemoteDesktop.MultiPoint
MANAGED_SERVERS
SETTINGS
TASK_HOME_RESTART
TASK_HOME_SHUTDOWN
TASK_HOME_MAINTENANCE
TASK_HOME_NORMAL
TASK_HOME_MANAGE_CALS
TASK_HOME_ADD_CALS
TASK_HOME_REMOVE_CALS
TASK_HOME_SETTINGS
TASK_HOME_REMAP
TASK_HOME_SAVE_CONNECTION
TASK_HOME_MANAGE_COMPUTERS
TASK_HOME_WEB
TASK_HOME_DISCUSSION_BOARD
TASK_STATUS_IDENTIFY
TASK_STATUS_SUSPEND
TASK_STATUS_LOGOFF
TASK_STATUS_STATION_NAME
TASK_STATUS_AUTOLOGON
TASK_STATUS_SPLIT_SCREEN
TASK_STATUS_UNSPLIT_SCREEN
TASK_STATUS_IDENTIFY_ALL
TASK_STATUS_STOP_IDENTIFY_ALL
TASK_STATUS_SUSPEND_ALL
TASK_STATUS_LOGOFF_ALL
TASK_USERS_DELETE_ACCOUNT
TASK_USERS_CHANGE_PASSWORD
TASK_USERS_CHANGE_FULL_NAME
TASK_USERS_CHANGE_ACCESS
TASK_USERS_ADD_ACCOUNT
TASK_DESKTOPS_BLOCK_ALL
TASK_DESKTOPS_UNBLOCK_ALL
TASK_DESKTOPS_MESSAGE
TASK_DESKTOPS_CHANGE_SIZE
TASK_DESKTOPS_LIMIT_WEB_ALL
TASK_DESKTOPS_CONFIG_WEB_LIMIT
TASK_DESKTOPS_LOGOFF_ALL
TASK_DESKTOPS_STOP_SHARING
TASK_DESKTOPS_SHOW_ALL
TASK_DESKTOPS_SHOW_ACTIVE
TASK_DESKTOPS_ENLARGE
TASK_DESKTOPS_THUMBNAIL_VIEW
TASK_DESKTOPS_BLOCK
TASK_DESKTOPS_UNBLOCK
TASK_DESKTOPS_LAUNCH_APP_ALL
TASK_DESKTOPS_LAUNCH_APP_MULTI
TASK_DESKTOPS_CLOSE_APP
TASK_DESKTOPS_LIMIT_WEB_MULTI
TASK_DESKTOPS_STOP_LIMIT_WEB_MULTI
TASK_DESKTOPS_SHARE_MULTI
TASK_DESKTOPS_SHARE_SELECTED_ALL
TASK_DESKTOPS_HELP
TASK_DESKTOPS_UNBLOCK_MULTI
TASK_DESKTOPS_STOP_LIMIT_WEB_ALL
TASK_DESKTOPS_SHARE_ALL
TASK_DESKTOPS_BLOCK_MULTI
UI_EXCEPTION
MANAGER
DASHBOARD
TASK_DESKTOPS_CLEAR_CHAT_MESSAGES
TASK_DESKTOPS_CHAT_SEND
TASK_DESKTOPS_CHAT_ENABLE
TASK_DESKTOPS_CHAT_DISABLE
TASK_DESKTOPS_AUTOLAUNCH_ENABLE
TASK_DESKTOPS_AUTOLAUNCH_DISABLE
TASK_DESKTOPS_BLOCK_USB_STORAGE_ALL
TASK_DESKTOPS_UNBLOCK_USB_STORAGE_ALL
TASK_DESKTOPS_BLOCK_USB_STORAGE
TASK_DESKTOPS_UNBLOCK_USB_STORAGE
TASK_DESKTOPS_REMOTE_CONTROL
TASK_DESKTOPS_LOGOFF_MULTI
TASK_DESKTOPS_INCLUDE_SYSTEM
TASK_DESKTOPS_EXCLUDE_SYSTEM
TASK_DESKTOPS_SEARCH
TASK_DESKTOPS_SORT_BY_COMPUTER
TASK_DESKTOPS_SORT_BY_STATION
TASK_DESKTOPS_SORT_BY_USER
TASK_DESKTOPS_SORT_ASCENDING
TASK_DESKTOPS_SORT_DESCENDING
TASK_DESKTOPS_GROUP_BY_COMPUTER
TASK_DESKTOPS_UNGROUP
TASK_VDI_IMPORT_DESKTOP_VHD_LOCATION
TASK_VDI_NEW_DESKTOP_DOMAIN
TASK_VDI_NEW_DESKTOP_VHD_LOCATION
TASK_VDI_NEW_DESKTOP_TEMPLATE_DOMAIN
TASK_VDI_NEW_DESKTOP_TEMPLATE_VHD_LOCATION
TASK_VDI_OPEN_DESKTOP_DOMAIN
TASK_VDI_ENABLE_START
TASK_VDI_ENABLE_SUCCESS_DURATION
TASK_VDI_ENABLE_FAIL_ERROR
TASK_VDI_ENABLE_FAIL_DURATION
TASK_VDI_DISABLE_START
TASK_VDI_DISABLE_SUCCESS_DURATION
TASK_VDI_DISABLE_FAIL_ERROR
TASK_VDI_DISABLE_FAIL_DURATION
TASK_VDI_IMPORT_DESKTOP_START
TASK_VDI_IMPORT_DESKTOP_SUCCESS_DURATION
TASK_VDI_IMPORT_DESKTOP_FAIL_ERROR
TASK_VDI_IMPORT_DESKTOP_FAIL_DURATION
TASK_VDI_NEW_DESKTOP_START
TASK_VDI_NEW_DESKTOP_SUCCESS_DURATION
TASK_VDI_NEW_DESKTOP_FAIL_ERROR
TASK_VDI_NEW_DESKTOP_FAIL_DURATION
TASK_VDI_NEW_DESKTOP_TEMPLATE_START
TASK_VDI_NEW_DESKTOP_TEMPLATE_SUCCESS_DURATION
TASK_VDI_NEW_DESKTOP_TEMPLATE_FAIL_ERROR
TASK_VDI_NEW_DESKTOP_TEMPLATE_FAIL_DURATION
TASK_VDI_OPEN_DESKTOP_START
TASK_VDI_OPEN_DESKTOP_SUCCESS_DURATION
TASK_VDI_OPEN_DESKTOP_FAIL_ERROR
TASK_VDI_OPEN_DESKTOP_FAIL_DURATION
TASK_HOME_ENABLE_DP_START
TASK_HOME_ENABLE_DP_SUCCESS_DURATION
TASK_HOME_ENABLE_DP_FAIL_ERROR
TASK_HOME_ENABLE_DP_FAIL_DURATION
TASK_HOME_DISABLE_DP_START
TASK_HOME_DISABLE_DP_SUCCESS_DURATION
TASK_HOME_DISABLE_DP_FAIL_ERROR
TASK_HOME_DISABLE_DP_FAIL_DURATION
MultiPoint Services Certificates
server
MultiPoint/IMultiPointCoreEventSink/{0}/
Ignoring {0} calling UnregisterCoreEventSink on server {1}
Parameter is null or empty
teacherServerName
teacherUserName
teacherSessionId
MultiPoint/IMultiPointChatEventSink/{0}/
HKEY_LOCAL_MACHINE\Software\Microsoft\Windows MultiPoint Server\Remote Management
SslCertificateThumbprint
https
Ignoring {0} calling UnregisterChatEventSink on server {1}
Invalid Scheduled Update Mode state.
stationID
ManagedSystemsType should be one of MultiPointServers & PersonalComputers
Web service call failed
stationId
stations
sessions
Software\Microsoft\Windows MultiPoint Server\ProjectingMyOwnDesktop
remoteHostName
remoteHostName is null or empty
title
title is null or empty
prompt
prompt is null or empty
Needed space
WmsShell
WMSReserved
MultiPoint/IMultiPointCertificateRequest
MultiPoint/IMultiPointChat
MultiPoint/IMultiPointStation
MultiPoint/IMultiPointServer
MultiPoint/IMultiPointUserManager
MultiPoint/IMultiPointSession
MultiPoint/IMultiPointDiskProtection
{0} was already added to {1}
SystemMode
DiskProtectionMode
ConnectionCount
LicenseCount
State
MonitoringSystemType
IsScheduleUpdateEnabled
TimeToScheduleUpdates
SystemImage
Could not connect to remote WMS System {0}, error: {1}.
system is null or empty
system
ComputerName: {0}
FullName
Description
UserType
ComputerName
VirtualMachineName
ConnectionType
NotificationMessage
StationId
LoggedInUserName
view is null
Microsoft.WindowsServerSolutions.MultipointServer.PowerShell.Commands.Library.Properties.Resources
AutoLogonNameIsInvalid
ConvertWindowsImagePowershellScript
CoreCallFailed
DiskProtectionAlreadyInstalled
DiskProtectionNotInstalled
DuplicateAutoLogonUsers
EnableWmsScheduledUpdateInvalidParams
GetWmsUserInvalidParams
InvalidAccountInfo
InvalidDiskProtectionState
InvalidInvitationString
InvalidWindowsVersion
IsAdministrativeUserAccount
LockWmsSessionInvalidParams
OpenWmsAppInvalidParams
PublishedSessionNotFound
RemoveWmsUserInvalidParams
SetWmsStationInvalidHostname
SetWmsStationInvalidParams
SetWmsUserInvalidParams
ShouldProcessDisableWmsDiskProtection
ShouldProcessEnableWmsDiskProtection
ShouldProcessExitWmsSystem
ShouldProcessRemoveWmsSystem
ShouldProcessRemoveWmsUser
ShouldProcessRestartWmsSystem
ShouldProcessResumeWmsDiskProtection
ShouldProcessSuspendWmsDiskProtection
TakeControlWindowTitleTemplate
WebServiceCallFailed
import-module -Name 
moduleName
moduleName is null or empty
Windows MultiPoint Server
WmsManager.exe
WmsDashboard.exe
Convert-WindowsImage.PS1
Select * from Win32_TSGeneralSetting
Select * from Win32_TSNetworkAdapterSetting
Select * from Win32_TerminalServiceSetting
Select * from Win32_TSLicenseServer
Select * from Win32_TSLicenseKeyPack
Select * from Win32_ComputerSystem
Select * from SoftwareLicensingProduct
Select * from Win32_OperatingSystem
Select * from Win32_TSPublishedApplication
[/\\"\[\]:|<>=;,\?\*@]
[.\s]
S-1-5-32-544
S-1-5-32-545
http://{0}:5985/wsman
http://schemas.microsoft.com/powershell/Microsoft.PowerShell
http://schemas.microsoft.com/powershell/WMSReserved
Microsoft.WindowsServerSolutions.MultipointServer.PowerShell.Commands.Library
WmsShell
WMSReserved
WmsControl
WmsOperators
root\cimv2
wssg.wms
fileName
HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server
HKEY_LOCAL_MACHINE\Software\Policies\Microsoft\Windows MultiPoint Server
HKEY_LOCAL_MACHINE\Software\Microsoft\Virtual Machine\Guest\Parameters
HKEY_LOCAL_MACHINE\Software\Microsoft\Windows MultiPoint Server
HKEY_LOCAL_MACHINE\Software\Microsoft\Windows MultiPoint Server\Remote Management
Software\Microsoft\Windows MultiPoint Server
Software\Microsoft\Windows MultiPoint Server\ConfigTasks\Skip
CreateWmsShell
CreateWmsShellBackup
AllowRemoteSessionHostServer
Hostname
Software\Microsoft\Windows NT\CurrentVersion\Winlogon
AutoAdminLogon
BootToConsoleMode
SuppressPrivacyNotification
IsVirtualDesktopEnabled
HKEY_LOCAL_MACHINE\Software\Microsoft\Windows MultiPoint Server\Version
Server
Client
HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows MultiPoint Server
HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\SQMClient\Windows
HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\Windows Error Reporting
HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\Windows Error Reporting\Consent
{0}\{1}
{0}$$${1}$$${2}
Software\Microsoft\Windows MultiPoint Server\Managed Server Notifications
6609FBE6-15C0-437B-90AA-B782ADFDD1CA
7621215C-EBB0-4D76-B6C7-28E15ED80B9E
B792CA7A-F156-4DD1-B45B-ADC89CA110C4
CD742EB2-467C-4494-9976-E15EDDF9D27E
2B57672B-F986-4DFB-B654-41E98FF09C09
DC3641D5-F6BE-4950-BCD1-5D9F4881B28E
0B747D09-1DEB-40E5-984D-D8F234FA8E06
Hyper-V\Virtual Hard Disks
kmloop
MultiPoint Services Certificates
System.Security.Permissions.SecurityPermissionAttribute, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089
SkipVerification
WrapNonExceptionThrows
HMicrosoft.WindowsServerSolutions.MultiPointServer.PowerShell.Commandlets
XWMS.Test.AXP, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9
http://MultiPoint
ClrNamespace
multipoint1
http://MultiPoint
ClrNamespace
multipoint1
.NETFramework,Version=v4.6
*Microsoft (R) Windows (R) Operating System
9Copyright (c) Microsoft Corporation. All rights reserved.
Microsoft Corporation
10.0.10011.16384
Id:\os\public\amd64fre\onecoreuap\internal\strongnamekeys\fake\windows.snk
ActionShttp://MultiPoint/RemoteManagement/IMultiPointCertificateRequest/GetProtocolVersionT
ReplyAction[http://MultiPoint/RemoteManagement/IMultiPointCertificateRequest/GetProtocolVersionResponsef
multipoint1.WmsFaultType
Action+http://MultiPoint/RemoteManagement/WmsFaultT
WmsFaultType
ActionVhttp://MultiPoint/RemoteManagement/IMultiPointCertificateRequest/RequestSslCertificateT
ReplyAction^http://MultiPoint/RemoteManagement/IMultiPointCertificateRequest/RequestSslCertificateResponse
ActionQhttp://MultiPoint/RemoteManagement/IMultiPointCredentialRequest/SetSslCertificateT
ReplyActionYhttp://MultiPoint/RemoteManagement/IMultiPointCredentialRequest/SetSslCertificateResponse
Action\http://MultiPoint/RemoteManagement/IMultiPointCredentialRequest/RequestWmsControlCredentialsT
ReplyActiondhttp://MultiPoint/RemoteManagement/IMultiPointCredentialRequest/RequestWmsControlCredentialsResponse
Action`http://MultiPoint/RemoteManagement/IMultiPointSystemOnlineEventSink/OnManagedServerOfflineNotifyT
ReplyAction`http://MultiPoint/RemoteManagement/IMultiPointSystemOnlineEventSink/OnManagedServerOfflineNotify
Action_http://MultiPoint/RemoteManagement/IMultiPointSystemOnlineEventSink/OnManagedServerOnlineNotifyT
ReplyAction_http://MultiPoint/RemoteManagement/IMultiPointSystemOnlineEventSink/OnManagedServerOnlineNotify
Action_http://MultiPoint/RemoteManagement/IMultiPointSystemOnlineEventSink/OnNewServerCertificateReadyT
ReplyAction_http://MultiPoint/RemoteManagement/IMultiPointSystemOnlineEventSink/OnNewServerCertificateReady
ActionChttp://MultiPoint/RemoteManagement/IMultiPointServer/GetAllSessionsT
ReplyActionKhttp://MultiPoint/RemoteManagement/IMultiPointServer/GetAllSessionsResponse
ActionEhttp://MultiPoint/RemoteManagement/IMultiPointServer/GetClientVersionT
ReplyActionMhttp://MultiPoint/RemoteManagement/IMultiPointServer/GetClientVersionResponse
ActionIhttp://MultiPoint/RemoteManagement/IMultiPointServer/GetPeerWmsServerListT
ReplyActionQhttp://MultiPoint/RemoteManagement/IMultiPointServer/GetPeerWmsServerListResponse
ActionLhttp://MultiPoint/RemoteManagement/IMultiPointServer/GetPeerWmsConnectorListT
ReplyActionThttp://MultiPoint/RemoteManagement/IMultiPointServer/GetPeerWmsConnectorListResponse
ActionEhttp://MultiPoint/RemoteManagement/IMultiPointServer/GetServerVersionT
ReplyActionMhttp://MultiPoint/RemoteManagement/IMultiPointServer/GetServerVersionResponse
ActionIhttp://MultiPoint/RemoteManagement/IMultiPointServer/GetSystemAlertStatusT
ReplyActionQhttp://MultiPoint/RemoteManagement/IMultiPointServer/GetSystemAlertStatusResponse
ActionBhttp://MultiPoint/RemoteManagement/IMultiPointServer/GetSystemModeT
ReplyActionJhttp://MultiPoint/RemoteManagement/IMultiPointServer/GetSystemModeResponse
ActionOhttp://MultiPoint/RemoteManagement/IMultiPointServer/GetVirtualMachineIpAddressT
ReplyActionWhttp://MultiPoint/RemoteManagement/IMultiPointServer/GetVirtualMachineIpAddressResponse
ActionJhttp://MultiPoint/RemoteManagement/IMultiPointServer/OnboardVirtualDesktopT
ReplyActionRhttp://MultiPoint/RemoteManagement/IMultiPointServer/OnboardVirtualDesktopResponse
Action;http://MultiPoint/RemoteManagement/IMultiPointServer/RebootT
ReplyActionChttp://MultiPoint/RemoteManagement/IMultiPointServer/RebootResponse
ActionJhttp://MultiPoint/RemoteManagement/IMultiPointServer/RegisterChatEventSinkT
ReplyActionRhttp://MultiPoint/RemoteManagement/IMultiPointServer/RegisterChatEventSinkResponse
ActionJhttp://MultiPoint/RemoteManagement/IMultiPointServer/RegisterCoreEventSinkT
ReplyActionRhttp://MultiPoint/RemoteManagement/IMultiPointServer/RegisterCoreEventSinkResponse
Action=http://MultiPoint/RemoteManagement/IMultiPointServer/ShutdownT
ReplyActionEhttp://MultiPoint/RemoteManagement/IMultiPointServer/ShutdownResponse
ActionLhttp://MultiPoint/RemoteManagement/IMultiPointServer/UnregisterChatEventSinkT
ReplyActionThttp://MultiPoint/RemoteManagement/IMultiPointServer/UnregisterChatEventSinkResponse
ActionLhttp://MultiPoint/RemoteManagement/IMultiPointServer/UnregisterCoreEventSinkT
ReplyActionThttp://MultiPoint/RemoteManagement/IMultiPointServer/UnregisterCoreEventSinkResponse
Action?http://MultiPoint/RemoteManagement/IMultiPointServer/EnableChatT
ReplyActionGhttp://MultiPoint/RemoteManagement/IMultiPointServer/EnableChatResponse
ActionDhttp://MultiPoint/RemoteManagement/IMultiPointServer/GetLicenseCountT
ReplyActionLhttp://MultiPoint/RemoteManagement/IMultiPointServer/GetLicenseCountResponse
ActionJhttp://MultiPoint/RemoteManagement/IMultiPointServer/GetManagedSystemsTypeT
ReplyActionRhttp://MultiPoint/RemoteManagement/IMultiPointServer/GetManagedSystemsTypeResponse
ActionEhttp://MultiPoint/RemoteManagement/IMultiPointServer/GetNetJoinStatusT
ReplyActionMhttp://MultiPoint/RemoteManagement/IMultiPointServer/GetNetJoinStatusResponse
ActionNhttp://MultiPoint/RemoteManagement/IMultiPointServer/GetVirtualMachineHostnameT
ReplyActionVhttp://MultiPoint/RemoteManagement/IMultiPointServer/GetVirtualMachineHostnameResponse
ActionFhttp://MultiPoint/RemoteManagement/IMultiPointServer/GetWmsWebLimitingT
ReplyActionNhttp://MultiPoint/RemoteManagement/IMultiPointServer/GetWmsWebLimitingResponse
ActionHhttp://MultiPoint/RemoteManagement/IMultiPointServer/IsBootToConsoleModeT
ReplyActionPhttp://MultiPoint/RemoteManagement/IMultiPointServer/IsBootToConsoleModeResponse
ActionMhttp://MultiPoint/RemoteManagement/IMultiPointServer/IsAdminOrchestrationModeT
ReplyActionUhttp://MultiPoint/RemoteManagement/IMultiPointServer/IsAdminOrchestrationModeResponse
ActionBhttp://MultiPoint/RemoteManagement/IMultiPointServer/IsChatEnabledT
ReplyActionJhttp://MultiPoint/RemoteManagement/IMultiPointServer/IsChatEnabledResponse
ActionOhttp://MultiPoint/RemoteManagement/IMultiPointServer/IsDesktopMonitoringAllowedT
ReplyActionWhttp://MultiPoint/RemoteManagement/IMultiPointServer/IsDesktopMonitoringAllowedResponse
ActionHhttp://MultiPoint/RemoteManagement/IMultiPointServer/IsHypervisorPresentT
ReplyActionPhttp://MultiPoint/RemoteManagement/IMultiPointServer/IsHypervisorPresentResponse
ActionKhttp://MultiPoint/RemoteManagement/IMultiPointServer/IsSingleSessionPerUserT
ReplyActionShttp://MultiPoint/RemoteManagement/IMultiPointServer/IsSingleSessionPerUserResponse
ActionUhttp://MultiPoint/RemoteManagement/IMultiPointServer/IsSuppressPrivacyNotificationSetT
ReplyAction]http://MultiPoint/RemoteManagement/IMultiPointServer/IsSuppressPrivacyNotificationSetResponse
ActionQhttp://MultiPoint/RemoteManagement/IMultiPointServer/IsVirtualIpPerSessionEnabledT
ReplyActionYhttp://MultiPoint/RemoteManagement/IMultiPointServer/IsVirtualIpPerSessionEnabledResponse
ActionGhttp://MultiPoint/RemoteManagement/IMultiPointServer/LoadWindowsEditionT
ReplyActionOhttp://MultiPoint/RemoteManagement/IMultiPointServer/LoadWindowsEditionResponse
ActionGhttp://MultiPoint/RemoteManagement/IMultiPointServer/SetBlockAllMessageT
ReplyActionOhttp://MultiPoint/RemoteManagement/IMultiPointServer/SetBlockAllMessageResponse
ActionIhttp://MultiPoint/RemoteManagement/IMultiPointServer/SetBootToConsoleModeT
ReplyActionQhttp://MultiPoint/RemoteManagement/IMultiPointServer/SetBootToConsoleModeResponse
ActionNhttp://MultiPoint/RemoteManagement/IMultiPointServer/SetAdminOrchestrationModeT
ReplyActionVhttp://MultiPoint/RemoteManagement/IMultiPointServer/SetAdminOrchestrationModeResponse
ActionShttp://MultiPoint/RemoteManagement/IMultiPointServer/SetSuppressPrivacyNotificationT
ReplyAction[http://MultiPoint/RemoteManagement/IMultiPointServer/SetSuppressPrivacyNotificationResponse
ActionMhttp://MultiPoint/RemoteManagement/IMultiPointServer/ValidateAutoLogonAccountT
ReplyActionUhttp://MultiPoint/RemoteManagement/IMultiPointServer/ValidateAutoLogonAccountResponse
ActionNhttp://MultiPoint/RemoteManagement/IMultiPointServer/EnableVirtualIpPerSessionT
ReplyActionVhttp://MultiPoint/RemoteManagement/IMultiPointServer/EnableVirtualIpPerSessionResponse
ActionIhttp://MultiPoint/RemoteManagement/IMultiPointServer/SetDesktopMonitoringT
ReplyActionQhttp://MultiPoint/RemoteManagement/IMultiPointServer/SetDesktopMonitoringResponse
ActionLhttp://MultiPoint/RemoteManagement/IMultiPointServer/SetSingleSessionPerUserT
ReplyActionThttp://MultiPoint/RemoteManagement/IMultiPointServer/SetSingleSessionPerUserResponse
ActionQhttp://MultiPoint/RemoteManagement/IMultiPointServer/GetReplacementSslCertificateT
ReplyActionYhttp://MultiPoint/RemoteManagement/IMultiPointServer/GetReplacementSslCertificateResponse
ActionQhttp://MultiPoint/RemoteManagement/IMultiPointServer/SetReplacementSslCertificateT
ReplyActionYhttp://MultiPoint/RemoteManagement/IMultiPointServer/SetReplacementSslCertificateResponse
ActionFhttp://MultiPoint/RemoteManagement/IMultiPointServer/GetUseHardwareGpuT
ReplyActionNhttp://MultiPoint/RemoteManagement/IMultiPointServer/GetUseHardwareGpuResponse
ActionFhttp://MultiPoint/RemoteManagement/IMultiPointServer/SetUseHardwareGpuT
ReplyActionNhttp://MultiPoint/RemoteManagement/IMultiPointServer/SetUseHardwareGpuResponse
ActionAhttp://MultiPoint/RemoteManagement/IMultiPointUserManager/AddUserT
ReplyActionIhttp://MultiPoint/RemoteManagement/IMultiPointUserManager/AddUserResponse
ActionHhttp://MultiPoint/RemoteManagement/IMultiPointUserManager/EnumerateUsersT
ReplyActionPhttp://MultiPoint/RemoteManagement/IMultiPointUserManager/EnumerateUsersResponse
ActionDhttp://MultiPoint/RemoteManagement/IMultiPointUserManager/RemoveUserT
ReplyActionLhttp://MultiPoint/RemoteManagement/IMultiPointUserManager/RemoveUserResponse
ActionEhttp://MultiPoint/RemoteManagement/IMultiPointUserManager/SetUserInfoT
ReplyActionMhttp://MultiPoint/RemoteManagement/IMultiPointUserManager/SetUserInfoResponse
ActionNhttp://MultiPoint/RemoteManagement/IMultiPointStation/GetNextStationIdentifierT
ReplyActionVhttp://MultiPoint/RemoteManagement/IMultiPointStation/GetNextStationIdentifierResponse
ActionKhttp://MultiPoint/RemoteManagement/IMultiPointStation/GetStationAlertStatusT
ReplyActionShttp://MultiPoint/RemoteManagement/IMultiPointStation/GetStationAlertStatusResponse
ActionThttp://MultiPoint/RemoteManagement/IMultiPointStation/GetStationAutoLogonInformationT
ReplyAction\http://MultiPoint/RemoteManagement/IMultiPointStation/GetStationAutoLogonInformationResponse
ActionQhttp://MultiPoint/RemoteManagement/IMultiPointStation/GetStationDeviceInformationT
ReplyActionYhttp://MultiPoint/RemoteManagement/IMultiPointStation/GetStationDeviceInformationResponse
ActionLhttp://MultiPoint/RemoteManagement/IMultiPointStation/GetStationFriendlyNameT
ReplyActionThttp://MultiPoint/RemoteManagement/IMultiPointStation/GetStationFriendlyNameResponse
ActionKhttp://MultiPoint/RemoteManagement/IMultiPointStation/GetStationInformationT
ReplyActionShttp://MultiPoint/RemoteManagement/IMultiPointStation/GetStationInformationResponse
ActionJhttp://MultiPoint/RemoteManagement/IMultiPointStation/GetStationServerNameT
ReplyActionRhttp://MultiPoint/RemoteManagement/IMultiPointStation/GetStationServerNameResponse
ActionVhttp://MultiPoint/RemoteManagement/IMultiPointStation/GetStationSplitScreenInformationT
ReplyAction^http://MultiPoint/RemoteManagement/IMultiPointStation/GetStationSplitScreenInformationResponse
ActionEhttp://MultiPoint/RemoteManagement/IMultiPointStation/IdentifyStationT
ReplyActionMhttp://MultiPoint/RemoteManagement/IMultiPointStation/IdentifyStationResponse
ActionDhttp://MultiPoint/RemoteManagement/IMultiPointStation/RefreshStationT
ReplyActionLhttp://MultiPoint/RemoteManagement/IMultiPointStation/RefreshStationResponse
ActionChttp://MultiPoint/RemoteManagement/IMultiPointStation/RemapStationsT
ReplyActionKhttp://MultiPoint/RemoteManagement/IMultiPointStation/RemapStationsResponse
ActionWhttp://MultiPoint/RemoteManagement/IMultiPointStation/BlockUsbStorageDevicesAllStationsT
ReplyAction_http://MultiPoint/RemoteManagement/IMultiPointStation/BlockUsbStorageDevicesAllStationsResponse
ActionYhttp://MultiPoint/RemoteManagement/IMultiPointStation/UnblockUsbStorageDevicesAllStationsT
ReplyActionahttp://MultiPoint/RemoteManagement/IMultiPointStation/UnblockUsbStorageDevicesAllStationsResponse
ActionLhttp://MultiPoint/RemoteManagement/IMultiPointStation/BlockUsbStorageDevicesT
ReplyActionThttp://MultiPoint/RemoteManagement/IMultiPointStation/BlockUsbStorageDevicesResponse
ActionNhttp://MultiPoint/RemoteManagement/IMultiPointStation/UnblockUsbStorageDevicesT
ReplyActionVhttp://MultiPoint/RemoteManagement/IMultiPointStation/UnblockUsbStorageDevicesResponse
ActionOhttp://MultiPoint/RemoteManagement/IMultiPointStation/IsUsbStorageDeviceBlockedT
ReplyActionWhttp://MultiPoint/RemoteManagement/IMultiPointStation/IsUsbStorageDeviceBlockedResponse
ActionIhttp://MultiPoint/RemoteManagement/IMultiPointStation/SetStationAutoLogonT
ReplyActionQhttp://MultiPoint/RemoteManagement/IMultiPointStation/SetStationAutoLogonResponse
ActionLhttp://MultiPoint/RemoteManagement/IMultiPointStation/SetStationFriendlyNameT
ReplyActionThttp://MultiPoint/RemoteManagement/IMultiPointStation/SetStationFriendlyNameResponse
ActionJhttp://MultiPoint/RemoteManagement/IMultiPointStation/SetStationServerNameT
ReplyActionRhttp://MultiPoint/RemoteManagement/IMultiPointStation/SetStationServerNameResponse
ActionBhttp://MultiPoint/RemoteManagement/IMultiPointStation/SplitStationT
ReplyActionJhttp://MultiPoint/RemoteManagement/IMultiPointStation/SplitStationResponse
ActionLhttp://MultiPoint/RemoteManagement/IMultiPointStation/StopIdentifyingStationT
ReplyActionThttp://MultiPoint/RemoteManagement/IMultiPointStation/StopIdentifyingStationResponse
ActionHhttp://MultiPoint/RemoteManagement/IMultiPointStation/GetDisplayRotationT
ReplyActionPhttp://MultiPoint/RemoteManagement/IMultiPointStation/GetDisplayRotationResponse
ActionHhttp://MultiPoint/RemoteManagement/IMultiPointStation/SetDisplayRotationT
ReplyActionPhttp://MultiPoint/RemoteManagement/IMultiPointStation/SetDisplayRotationResponse
ActionEhttp://MultiPoint/RemoteManagement/IMultiPointSession/CurrentActivityT
ReplyActionMhttp://MultiPoint/RemoteManagement/IMultiPointSession/CurrentActivityResponse
ActionMhttp://MultiPoint/RemoteManagement/IMultiPointSession/CloseSessionApplicationT
ReplyActionUhttp://MultiPoint/RemoteManagement/IMultiPointSession/CloseSessionApplicationResponse
ActionJhttp://MultiPoint/RemoteManagement/IMultiPointSession/ConfigureWebLimitingT
ReplyActionRhttp://MultiPoint/RemoteManagement/IMultiPointSession/ConfigureWebLimitingResponse
ActionMhttp://MultiPoint/RemoteManagement/IMultiPointSession/ConfigureWebLimitingAllT
ReplyActionUhttp://MultiPoint/RemoteManagement/IMultiPointSession/ConfigureWebLimitingAllResponse
ActionHhttp://MultiPoint/RemoteManagement/IMultiPointSession/EnableProjectToAllT
ReplyActionPhttp://MultiPoint/RemoteManagement/IMultiPointSession/EnableProjectToAllResponse
ActionJhttp://MultiPoint/RemoteManagement/IMultiPointSession/EnableWebLimitingAllT
ReplyActionRhttp://MultiPoint/RemoteManagement/IMultiPointSession/EnableWebLimitingAllResponse
ActionDhttp://MultiPoint/RemoteManagement/IMultiPointSession/GetScreenStateT
ReplyActionLhttp://MultiPoint/RemoteManagement/IMultiPointSession/GetScreenStateResponse
ActionKhttp://MultiPoint/RemoteManagement/IMultiPointSession/GetSessionAgentStatusT
ReplyActionShttp://MultiPoint/RemoteManagement/IMultiPointSession/GetSessionAgentStatusResponse
ActionKhttp://MultiPoint/RemoteManagement/IMultiPointSession/GetSessionRunningAppsT
ReplyActionShttp://MultiPoint/RemoteManagement/IMultiPointSession/GetSessionRunningAppsResponse
ActionFhttp://MultiPoint/RemoteManagement/IMultiPointSession/GetThumbnailBitsT
ReplyActionNhttp://MultiPoint/RemoteManagement/IMultiPointSession/GetThumbnailBitsResponse
ActionEhttp://MultiPoint/RemoteManagement/IMultiPointSession/IdentifySessionT
ReplyActionMhttp://MultiPoint/RemoteManagement/IMultiPointSession/IdentifySessionResponse
ActionEhttp://MultiPoint/RemoteManagement/IMultiPointSession/GetSessionFlagsT
ReplyActionMhttp://MultiPoint/RemoteManagement/IMultiPointSession/GetSessionFlagsResponse
ActionAhttp://MultiPoint/RemoteManagement/IMultiPointSession/LockSessionT
ReplyActionIhttp://MultiPoint/RemoteManagement/IMultiPointSession/LockSessionResponse
ActionChttp://MultiPoint/RemoteManagement/IMultiPointSession/LogOffSessionT
ReplyActionKhttp://MultiPoint/RemoteManagement/IMultiPointSession/LogOffSessionResponse
ActionDhttp://MultiPoint/RemoteManagement/IMultiPointSession/RunFileSessionT
ReplyActionLhttp://MultiPoint/RemoteManagement/IMultiPointSession/RunFileSessionResponse
ActionBhttp://MultiPoint/RemoteManagement/IMultiPointSession/ShareDesktopT
ReplyActionJhttp://MultiPoint/RemoteManagement/IMultiPointSession/ShareDesktopResponse
ActionLhttp://MultiPoint/RemoteManagement/IMultiPointSession/StopIdentifyingSessionT
ReplyActionThttp://MultiPoint/RemoteManagement/IMultiPointSession/StopIdentifyingSessionResponse
ActionHhttp://MultiPoint/RemoteManagement/IMultiPointSession/StopLockingSessionT
ReplyActionPhttp://MultiPoint/RemoteManagement/IMultiPointSession/StopLockingSessionResponse
ActionFhttp://MultiPoint/RemoteManagement/IMultiPointSession/StopShareDesktopT
ReplyActionNhttp://MultiPoint/RemoteManagement/IMultiPointSession/StopShareDesktopResponse
ActionAhttp://MultiPoint/RemoteManagement/IMultiPointSession/ViewDesktopT
ReplyActionIhttp://MultiPoint/RemoteManagement/IMultiPointSession/ViewDesktopResponse
ActionGhttp://MultiPoint/RemoteManagement/IMultiPointSession/DisconnectSessionT
ReplyActionOhttp://MultiPoint/RemoteManagement/IMultiPointSession/DisconnectSessionResponse
ActionJhttp://MultiPoint/RemoteManagement/IMultiPointSession/LogOffConsoleSessionT
ReplyActionRhttp://MultiPoint/RemoteManagement/IMultiPointSession/LogOffConsoleSessionResponse
ActionOhttp://MultiPoint/RemoteManagement/IMultiPointDiskProtection/GetFreeSpaceNeededT
ReplyActionWhttp://MultiPoint/RemoteManagement/IMultiPointDiskProtection/GetFreeSpaceNeededResponse
ActionDhttp://MultiPoint/RemoteManagement/IMultiPointDiskProtection/GetModeT
ReplyActionLhttp://MultiPoint/RemoteManagement/IMultiPointDiskProtection/GetModeResponse
ActionWhttp://MultiPoint/RemoteManagement/IMultiPointDiskProtection/GetScheduledUpdateSettingsT
ReplyAction_http://MultiPoint/RemoteManagement/IMultiPointDiskProtection/GetScheduledUpdateSettingsResponse
ActionDhttp://MultiPoint/RemoteManagement/IMultiPointDiskProtection/InstallT
ReplyActionLhttp://MultiPoint/RemoteManagement/IMultiPointDiskProtection/InstallResponse
ActionHhttp://MultiPoint/RemoteManagement/IMultiPointDiskProtection/IsInstalledT
ReplyActionPhttp://MultiPoint/RemoteManagement/IMultiPointDiskProtection/IsInstalledResponse
ActionDhttp://MultiPoint/RemoteManagement/IMultiPointDiskProtection/SetModeT
ReplyActionLhttp://MultiPoint/RemoteManagement/IMultiPointDiskProtection/SetModeResponse
ActionWhttp://MultiPoint/RemoteManagement/IMultiPointDiskProtection/SetScheduledUpdateSettingsT
ReplyAction_http://MultiPoint/RemoteManagement/IMultiPointDiskProtection/SetScheduledUpdateSettingsResponse
ActionFhttp://MultiPoint/RemoteManagement/IMultiPointDiskProtection/UninstallT
ReplyActionNhttp://MultiPoint/RemoteManagement/IMultiPointDiskProtection/UninstallResponse
Action:http://MultiPoint/RemoteManagement/IMultiPointChat/ConnectT
ReplyActionBhttp://MultiPoint/RemoteManagement/IMultiPointChat/ConnectResponse
Action=http://MultiPoint/RemoteManagement/IMultiPointChat/DisconnectT
ReplyActionEhttp://MultiPoint/RemoteManagement/IMultiPointChat/DisconnectResponse
Action<http://MultiPoint/RemoteManagement/IMultiPointChat/GetChatIdT
ReplyActionDhttp://MultiPoint/RemoteManagement/IMultiPointChat/GetChatIdResponse
Action7http://MultiPoint/RemoteManagement/IMultiPointChat/PingT
ReplyAction?http://MultiPoint/RemoteManagement/IMultiPointChat/PingResponse
Action<http://MultiPoint/RemoteManagement/IMultiPointChat/SendErrorT
ReplyActionDhttp://MultiPoint/RemoteManagement/IMultiPointChat/SendErrorResponse
Action:http://MultiPoint/RemoteManagement/IMultiPointChat/SendMsgT
ReplyActionBhttp://MultiPoint/RemoteManagement/IMultiPointChat/SendMsgResponse
ActionYhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnAssociateSessionWithStationT
ReplyActionahttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnAssociateSessionWithStationResponse
ActionRhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnBeginIdentifySessionT
ReplyActionZhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnBeginIdentifySessionResponse
ActionRhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnBeginIdentifyStationT
ReplyActionZhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnBeginIdentifyStationResponse
ActionUhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnBootToConsoleModeChangeT
ReplyAction]http://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnBootToConsoleModeChangeResponse
ActionNhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnConfigureStationT
ReplyActionVhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnConfigureStationResponse
ActionUhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnDesktopMonitoringChangeT
ReplyAction]http://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnDesktopMonitoringChangeResponse
ActionIhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnDeviceAddedT
ReplyActionQhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnDeviceAddedResponse
ActionKhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnDeviceRemovedT
ReplyActionShttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnDeviceRemovedResponse
ActionPhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnEndIdentifySessionT
ReplyActionXhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnEndIdentifySessionResponse
ActionPhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnEndIdentifyStationT
ReplyActionXhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnEndIdentifyStationResponse
ActionNhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnEnterSplitScreenT
ReplyActionVhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnEnterSplitScreenResponse
ActionMhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnExitSplitScreenT
ReplyActionUhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnExitSplitScreenResponse
ActionRhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnManagedServerOfflineT
ReplyActionZhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnManagedServerOfflineResponse
ActionQhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnManagedServerOnlineT
ReplyActionYhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnManagedServerOnlineResponse
ActionMhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnPeerServerAddedT
ReplyActionUhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnPeerServerAddedResponse
ActionRhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnPeerServerDiscoveredT
ReplyActionZhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnPeerServerDiscoveredResponse
ActionOhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnPeerServerRemovedT
ReplyActionWhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnPeerServerRemovedResponse
ActionShttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnProjectionStateChangeT
ReplyAction[http://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnProjectionStateChangeResponse
Action\http://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnScheduledUpdateSettingsChangedT
ReplyActiondhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnScheduledUpdateSettingsChangedResponse
ActionYhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnServiceControlSessionChangeT
ReplyActionahttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnServiceControlSessionChangeResponse
ActionOhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnSessionAgentReadyT
ReplyActionWhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnSessionAgentReadyResponse
ActionLhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnSessionBlockedT
ReplyActionThttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnSessionBlockedResponse
ActionOhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnSessionConnectingT
ReplyActionWhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnSessionConnectingResponse
ActionQhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnSessionDisconnectedT
ReplyActionYhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnSessionDisconnectedResponse
ActionNhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnSessionUnblockedT
ReplyActionVhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnSessionUnblockedResponse
ActionJhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnStationAddedT
ReplyActionRhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnStationAddedResponse
ActionJhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnStationAlertT
ReplyActionRhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnStationAlertResponse
ActionLhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnStationRemovedT
ReplyActionThttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnStationRemovedResponse
ActionIhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnSystemAlertT
ReplyActionQhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnSystemAlertResponse
ActionNhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnSystemModeChangeT
ReplyActionVhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnSystemModeChangeResponse
ActionXhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnVirtualDesktopNotificationT
ReplyAction`http://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnVirtualDesktopNotificationResponse
ActionRhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnVirtualDesktopOnlineT
ReplyActionZhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnVirtualDesktopOnlineResponse
ActionPhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/ShutdownNotificationT
ReplyActionXhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/ShutdownNotificationResponse
ActionIhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnUserCreatedT
ReplyActionQhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnUserCreatedResponse
ActionIhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnUserUpdatedT
ReplyActionQhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnUserUpdatedResponse
ActionIhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnUserDeletedT
ReplyActionQhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnUserDeletedResponse
ActionJhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnGroupUpdatedT
ReplyActionRhttp://MultiPoint/RemoteManagement/IMultiPointCoreEventSink/OnGroupUpdatedResponseK
RequestSslCertificateT
Namespace
http://MultiPointT
Order
RequestSslCertificateResponseT
Namespace
http://MultiPointT
Order
Order
EmitDefaultValue
Order
EmitDefaultValue
Order
SetSslCertificateT
Namespace
http://MultiPointT
Order
EmitDefaultValue
Order
Order
EmitDefaultValue
Order
SetSslCertificateResponseT
Namespace
http://MultiPointT
Order
RequestWmsControlCredentialsT
Namespace
http://MultiPointT
Order
Name$RequestWmsControlCredentialsResponseT
Namespace
http://MultiPointT
Order
OnManagedServerOfflineNotifyT
Namespace
http://MultiPointT
Order
Name$OnManagedServerOfflineNotifyResponseT
Namespace
http://MultiPointT
Order
OnManagedServerOnlineNotifyT
Namespace
http://MultiPointT
Order
Name#OnManagedServerOnlineNotifyResponseT
Namespace
http://MultiPointT
Order
OnNewServerCertificateReadyT
Namespace
http://MultiPointT
Order
Name#OnNewServerCertificateReadyResponseT
Namespace
http://MultiPointT
Order
GetAllSessionsT
Namespace
http://MultiPointT
Order
GetAllSessionsResponseT
Namespace
http://MultiPointT
Order
GetClientVersionT
Namespace
http://MultiPointT
Order
GetClientVersionResponseT
Namespace
http://MultiPointT
Order
GetPeerWmsServerListT
Namespace
http://MultiPointT
Order
GetPeerWmsServerListResponseT
Namespace
http://MultiPointT
Order
GetPeerWmsConnectorListT
Namespace
http://MultiPointT
Order
GetPeerWmsConnectorListResponseT
Namespace
http://MultiPointT
Order
GetServerVersionT
Namespace
http://MultiPointT
Order
GetServerVersionResponseT
Namespace
http://MultiPointT
Order
GetVirtualMachineIpAddressT
Namespace
http://MultiPointT
Order
Name"GetVirtualMachineIpAddressResponseT
Namespace
http://MultiPointT
Order
OnboardVirtualDesktopT
Namespace
http://MultiPointT
Order
OnboardVirtualDesktopResponseT
Namespace
http://MultiPointT
Order
EmitDefaultValue
Order
RegisterChatEventSinkT
Namespace
http://MultiPointT
Order
Order
RegisterChatEventSinkResponseT
Namespace
http://MultiPointT
Order
RegisterCoreEventSinkT
Namespace
http://MultiPointT
Order
RegisterCoreEventSinkResponseT
Namespace
http://MultiPointT
Order
GetNetJoinStatusT
Namespace
http://MultiPointT
Order
GetNetJoinStatusResponseT
Namespace
http://MultiPointT
Order
GetVirtualMachineHostnameT
Namespace
http://MultiPointT
Order
Name!GetVirtualMachineHostnameResponseT
Namespace
http://MultiPointT
Order
GetWmsWebLimitingT
Namespace
http://MultiPointT
Order
GetWmsWebLimitingResponseT
Namespace
http://MultiPointT
Order
LoadWindowsEditionT
Namespace
http://MultiPointT
Order
LoadWindowsEditionResponseT
Namespace
http://MultiPointT
Order
ValidateAutoLogonAccountT
Namespace
http://MultiPointT
Order
Name ValidateAutoLogonAccountResponseT
Namespace
http://MultiPointT
Order
GetReplacementSslCertificateT
Namespace
http://MultiPointT
Order
Name$GetReplacementSslCertificateResponseT
Namespace
http://MultiPointT
Order
SetReplacementSslCertificateT
Namespace
http://MultiPointT
Order
Name$SetReplacementSslCertificateResponseT
Namespace
http://MultiPointT
Order
AddUserT
Namespace
http://MultiPointT
Order
Order
Order
AddUserResponseT
Namespace
http://MultiPointT
Order
EnumerateUsersT
Namespace
http://MultiPointT
Order
EnumerateUsersResponseT
Namespace
http://MultiPointT
Order
RemoveUserT
Namespace
http://MultiPointT
Order
RemoveUserResponseT
Namespace
http://MultiPointT
Order
SetUserInfoT
Namespace
http://MultiPointT
Order
SetUserInfoResponseT
Namespace
http://MultiPointT
Order
GetStationAutoLogonInformationT
Namespace
http://MultiPointT
Order
Name&GetStationAutoLogonInformationResponseT
Namespace
http://MultiPointT
Order
GetStationFriendlyNameT
Namespace
http://MultiPointT
Order
GetStationFriendlyNameResponseT
Namespace
http://MultiPointT
Order
GetStationInformationT
Namespace
http://MultiPointT
Order
GetStationInformationResponseT
Namespace
http://MultiPointT
Order
GetStationServerNameT
Namespace
http://MultiPointT
Order
GetStationServerNameResponseT
Namespace
http://MultiPointT
Order
IdentifyStationT
Namespace
http://MultiPointT
Order
IdentifyStationResponseT
Namespace
http://MultiPointT
Order
SetStationFriendlyNameT
Namespace
http://MultiPointT
Order
SetStationFriendlyNameResponseT
Namespace
http://MultiPointT
Order
CurrentActivityT
Namespace
http://MultiPointT
Order
CurrentActivityResponseT
Namespace
http://MultiPointT
Order
ConfigureWebLimitingAllT
Namespace
http://MultiPointT
Order
ConfigureWebLimitingAllResponseT
Namespace
http://MultiPointT
Order
GetSessionRunningAppsT
Namespace
http://MultiPointT
Order
GetSessionRunningAppsResponseT
Namespace
http://MultiPointT
Order
GetThumbnailBitsT
Namespace
http://MultiPointT
Order
GetThumbnailBitsResponseT
Namespace
http://MultiPointT
Order
IdentifySessionT
Namespace
http://MultiPointT
Order
IdentifySessionResponseT
Namespace
http://MultiPointT
Order
LockSessionT
Namespace
http://MultiPointT
Order
LockSessionResponseT
Namespace
http://MultiPointT
Order
RunFileSessionT
Namespace
http://MultiPointT
Order
RunFileSessionResponseT
Namespace
http://MultiPointT
Order
ShareDesktopT
Namespace
http://MultiPointT
Order
ShareDesktopResponseT
Namespace
http://MultiPointT
Order
ViewDesktopT
Namespace
http://MultiPointT
Order
ViewDesktopResponseT
Namespace
http://MultiPointT
Order
GetScheduledUpdateSettingsT
Namespace
http://MultiPointT
Order
Name"GetScheduledUpdateSettingsResponseT
Namespace
http://MultiPointT
Order
SetScheduledUpdateSettingsT
Namespace
http://MultiPointT
Order
Name"SetScheduledUpdateSettingsResponseT
Namespace
http://MultiPointT
Order
ConnectT
Namespace
http://MultiPointT
Order
ConnectResponseT
Namespace
http://MultiPointT
Order
DisconnectT
Namespace
http://MultiPointT
Order
DisconnectResponseT
Namespace
http://MultiPointT
Order
GetChatIdT
Namespace
http://MultiPointT
Order
GetChatIdResponseT
Namespace
http://MultiPointT
Order
SendErrorT
Namespace
http://MultiPointT
Order
SendErrorResponseT
Namespace
http://MultiPointT
Order
SendMsgT
Namespace
http://MultiPointT
Order
SendMsgResponseT
Namespace
http://MultiPointT
Order
System.ServiceModel
4.0.0.0
Namespace
http://MultiPointT
ConfigurationName
IMultiPointCertificateRequest
IsWrapped
Namespace
http://MultiPointS
Namespace
http://MultiPointT
ConfigurationName
IMultiPointCredentialRequestW
Namespace
http://MultiPointT
ConfigurationName IMultiPointSystemOnlineEventSinkH
Namespace
http://MultiPointT
ConfigurationName
IMultiPointServerM
Namespace
http://MultiPointT
ConfigurationName
IMultiPointUserManagerI
Namespace
http://MultiPointT
ConfigurationName
IMultiPointStationI
Namespace
http://MultiPointT
ConfigurationName
IMultiPointSessionP
Namespace
http://MultiPointT
ConfigurationName
IMultiPointDiskProtectionF
Namespace
http://MultiPointT
ConfigurationName
IMultiPointChatO
Namespace
http://MultiPointT
ConfigurationName
IMultiPointCoreEventSink)
System.Runtime.Serialization
4.0.0.0
WmsFaultTypeT
Namespace
http://MultiPointc
ArrayOfWMS_SESSION_INFO_WST
Namespace
http://MultiPointT
ItemName
prgWmsSessionInfoWs=
WMS_SESSION_INFO_WST
Namespace
http://MultiPointK
ArrayOfStringsT
Namespace
http://MultiPointT
ItemName
prgData[
ArrayOfWMS_USER_WST
Namespace
http://MultiPointT
ItemName
prgWmsSessionInfoWs5
WMS_USER_WST
Namespace
http://MultiPointa
ArrayOfWMS_RUNNING_APP_WST
Namespace
http://MultiPointT
ItemName
prgWmsRunningAppWs<
WMS_RUNNING_APP_WST
Namespace
http://MultiPointI
ArrayOfBytesT
Namespace
http://MultiPointT
ItemName
prgData
WmsSystem
WMicrosoft.WindowsServerSolutions.MultipointServer.PowerShell.Commands.Library.WmsSystem
Clear
WmsStation
SupportsShouldProcess
Close
WmsApp
SupportsShouldProcess
Close
WmsSession
SupportsShouldProcess
Disable
WmsDiskProtection
SupportsShouldProcess
System.Management.Automation.ConfirmImpact, System.Management.Automation, Version=1.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35
ConfirmImpact
Disable
WmsScheduledUpdate
Disable
WmsWebLimiting
SupportsShouldProcess
Disconnect
WmsSession
SupportsShouldProcess
Enable
WmsDiskProtection
SupportsShouldProcess
System.Management.Automation.ConfirmImpact, System.Management.Automation, Version=1.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35
ConfirmImpact
Enable
WmsScheduledUpdate
`Microsoft.WindowsServerSolutions.MultipointServer.PowerShell.Commands.Library.WmsScheduledUpdate
Enable
WmsWebLimiting
SupportsShouldProcess
WmsSystem
SupportsShouldProcess
System.Management.Automation.ConfirmImpact, System.Management.Automation, Version=1.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35
ConfirmImpact
WmsAlert
VMicrosoft.WindowsServerSolutions.MultipointServer.PowerShell.Commands.Library.WmsAlert
WmsDiskProtection
`Microsoft.WindowsServerSolutions.MultipointServer.PowerShell.Commands.Library.DiskProtectionMode
WmsApp
[Microsoft.WindowsServerSolutions.MultipointServer.PowerShell.Commands.Library.WmsRunningApp
WmsScheduledUpdate
WmsSession
XMicrosoft.WindowsServerSolutions.MultipointServer.PowerShell.Commands.Library.WmsSession
WmsStation
XMicrosoft.WindowsServerSolutions.MultipointServer.PowerShell.Commands.Library.WmsStation
WmsSystem
WmsUser
UMicrosoft.WindowsServerSolutions.MultipointServer.PowerShell.Commands.Library.WmsUser
WmsVersion
XMicrosoft.WindowsServerSolutions.MultipointServer.PowerShell.Commands.Library.WmsVersion
WmsWebLimiting
]Microsoft.WindowsServerSolutions.MultipointServer.PowerShell.Commands.Library.WebLimitSetting
WmsIdentifier
SupportsShouldProcess
WmsStation
WmsSession
WmsUsbStorage
WmsUser
SupportsShouldProcess
WmsApp
SupportsShouldProcess
Publish
WmsDesktop
SupportsShouldProcess
XMicrosoft.WindowsServerSolutions.MultipointServer.PowerShell.Commands.Library.WmsDesktop
Remove
WmsSystem
SupportsShouldProcess
System.Management.Automation.ConfirmImpact, System.Management.Automation, Version=1.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35
ConfirmImpact
Remove
WmsUser
SupportsShouldProcess
System.Management.Automation.ConfirmImpact, System.Management.Automation, Version=1.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35
ConfirmImpact
Restart
WmsSystem
SupportsShouldProcess
System.Management.Automation.ConfirmImpact, System.Management.Automation, Version=1.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35
ConfirmImpact
Resume
WmsDiskProtection
SupportsShouldProcess
System.Management.Automation.ConfirmImpact, System.Management.Automation, Version=1.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35
ConfirmImpact
Search
WmsSystem
ZSystem.String, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089
WmsScheduledUpdate
WmsStation
WmsSystem
WmsUser
WmsWebLimiting
WmsDesktop
WmsIdentifier
Split
WmsStation
Suspend
WmsDiskProtection
SupportsShouldProcess
System.Management.Automation.ConfirmImpact, System.Management.Automation, Version=1.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35
ConfirmImpact
Unlock
WmsSession
Unlock
WmsUsbStorage
Update
WmsStation
Unpublish
WmsDesktop
System.ServiceModel.InstanceContextMode, System.ServiceModel, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089
InstanceContextMode
ConvertSqmDataPoint.pl
1.0.0.0
3System.Resources.Tools.StronglyTypedResourceBuilder
4.0.0.0
pProtocolVersion
peSeverity
peType
pcLicenses)
pEWmsRemoteManagementHostType
pfBootToConsoleMode$
pfAdminOrchestrationMode
pfEnabled&
pfDesktopMonitoringAllowed
pfHypervisorPresent"
pfSingleSessionPerUser,
Name pfSuppressPrivacyNotificationSet
pfUseHardwareGpu
pidNextStation
pdwDeviceCount
pidPrimaryStation%
peUsbStorageDeviceBlocked
peDisplayRotation#
peCurrentBroadCastState"
peIdentifyStationState
pgrfSession
pullFreeSpaceNeeded
pfIsInstalled
IsRequired
IsRequired
EmitDefaultValue
IsRequired
EmitDefaultValue
Order
IsRequired
EmitDefaultValue
Order
IsRequired
Order
IsRequired
EmitDefaultValue
Order
IsRequired
EmitDefaultValue
Order
IsRequired
Order
IsRequired
Order
IsRequired
Order
Mandatory
ValueFromPipelineByPropertyName
Position
Mandatory
Position
Mandatory
Position
Mandatory
ValueFromPipelineByPropertyName
Position
Mandatory
ValueFromPipelineByPropertyName
Position
Mandatory
ValueFromPipelineByPropertyName
Position
Mandatory
ValueFromPipelineByPropertyName
ParameterSetName
CloseByIdT
Position
Mandatory
ParameterSetName
CloseAllf
Mandatory
ValueFromPipelineByPropertyName
ParameterSetName
WebLimitSessionT
Position
Mandatory
ParameterSetName
WebLimitAlle
Mandatory
ValueFromPipelineByPropertyName
ParameterSetName
DisconnectByIdT
Position
Mandatory
ParameterSetName
DisconnectAll4
Mandatory
ValueFromPipelineByPropertyName
Mandatory
ValueFromPipelineByPropertyName
ParameterSetName
GetByIdT
Position
Mandatory
ParameterSetName
GetAll
Mandatory
Mandatory
ParameterSetName
GetAll,
Mandatory
ParameterSetName
GetUser0
Mandatory
ParameterSetName
GetAllUsers_
Mandatory
ValueFromPipelineByPropertyName
ParameterSetName
HideIdentifyBySessionId<
Mandatory
ParameterSetName
HideIdentifyByStationId4
Mandatory
ParameterSetName
HideIdentifyAll_
Mandatory
ValueFromPipelineByPropertyName
ParameterSetName
JoinByIdT
Position
Mandatory
ParameterSetName
JoinAll_
Mandatory
ValueFromPipelineByPropertyName
ParameterSetName
LockByIdT
Position
Mandatory
ParameterSetName
LockAll 
Mandatory
Position
Mandatory
Position
Mandatory
Position
Mandatory
ValueFromPipeline
ValueFromPipelineByPropertyName
Position
Mandatory
ParameterSetName
FriendlyName4
Mandatory
ParameterSetName
AutoLogonEnable4
Mandatory
ParameterSetName
AutoLogonEnable5
Mandatory
ParameterSetName
DisableAutoLogon5
Mandatory
ParameterSetName
RemoteConnection7
Mandatory
ParameterSetName
RemoteConnectionVM<
Mandatory
ParameterSetName
DisableRemoteConnection7
Mandatory
ParameterSetName
DisplayOrientation#
IsDesktopMonitoringAllowed
IsChatEnabled
IsIPPerSessionEnabled
IsSingleSessionPerUser
IsAdminOrchestrationEnabled
Mandatory
ParameterSetName
UseUserNameT
Position
Mandatory
ParameterSetName
UseCredsT
Position
Mandatory
ParameterSetName
AllowList.
Mandatory
ParameterSetName
BlockList`
Mandatory
ValueFromPipelineByPropertyName
ParameterSetName
AllowListT
Position
Mandatory
ValueFromPipelineByPropertyName
ParameterSetName
BlockListT
Position
Mandatory
ValueFromPipelineByPropertyName
ParameterSetName
ShowSessionListT
Position
Mandatory
ParameterSetName
ShowAlll
Mandatory
ValueFromPipeline
ValueFromPipelineByPropertyName
ParameterSetName
ShowSessionListd
Mandatory
ValueFromPipeline
ValueFromPipelineByPropertyName
ParameterSetName
ShowAllj
Mandatory
ValueFromPipeline
ValueFromPipelineByPropertyName
ParameterSetName
RemoteControl2
Mandatory
ParameterSetName
RemoteControlY
Mandatory
ValueFromPipelineByPropertyName
ParameterSetName
IdentifyBySessionY
Mandatory
ValueFromPipelineByPropertyName
ParameterSetName
IdentifyByStation0
Mandatory
ParameterSetName
IdentifyAll`
Mandatory
ValueFromPipelineByPropertyName
ParameterSetName
SplitByIdT
Position
Mandatory
ParameterSetName
SplitAlla
Mandatory
ValueFromPipelineByPropertyName
ParameterSetName
UnlockByIdT
Position
Mandatory
ParameterSetName
UnlockAlla
Mandatory
ValueFromPipelineByPropertyName
ParameterSetName
UpdateByIdT
Position
Mandatory
ParameterSetName
UpdateAll
ComputerName
lSystem.Resources.ResourceReader, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089#System.Resources.RuntimeResourceSet
PADPADP
AutoLogonNameIsInvalid
ConvertWindowsImagePowershellScript3
CoreCallFailed
DiskProtectionAlreadyInstalled
DiskProtectionNotInstalled
DuplicateAutoLogonUsers
EnableWmsScheduledUpdateInvalidParams
GetWmsUserInvalidParams
InvalidAccountInfo
InvalidDiskProtectionState
InvalidInvitationString
InvalidWindowsVersion
IsAdministrativeUserAccount
LockWmsSessionInvalidParams
OpenWmsAppInvalidParams
PublishedSessionNotFound
RemoveWmsUserInvalidParams
SetWmsStationInvalidHostname
SetWmsStationInvalidParams
SetWmsUserInvalidParams
ShouldProcessDisableWmsDiskProtection
ShouldProcessEnableWmsDiskProtection
ShouldProcessExitWmsSystem
ShouldProcessRemoveWmsSystem
ShouldProcessRemoveWmsUser
ShouldProcessRestartWmsSystem
ShouldProcessResumeWmsDiskProtection
ShouldProcessSuspendWmsDiskProtection
TakeControlWindowTitleTemplate
WebServiceCallFailed
1The specified Auto-logon account name is invalid.
    .SYNOPSIS
        Creates a bootable VHD(X) based on Windows 7 or Windows 8 installation media.
    .DESCRIPTION
        Creates a bootable VHD(X) based on Windows 7 or Windows 8 installation media.
    .PARAMETER SourcePath
        The complete path to the WIM or ISO file that will be converted to a Virtual Hard Disk.
        The ISO file must be valid Windows installation media to be recognized successfully.
    .PARAMETER VHDPath
        The name and path of the Virtual Hard Disk to create.
        Omitting this parameter will create the Virtual Hard Disk is the current directory, (or,
        if specified by the -WorkingDirectory parameter, the working directory) and will automatically 
        name the file in the following format:
        <build>.<revision>.<architecture>.<branch>.<timestamp>_<skufamily>_<sku>_<language>.<extension>
        i.e.:
        8250.0.amd64chk.winmain_win8beta.120217-1520_client_enterprise_en-us.vhd(x)
    .PARAMETER WorkingDirectory
        Specifies the directory where the VHD(X) file should be generated.  
        If specified along with -VHDPath, the -WorkingDirectory value is ignored.
        The default value is the current directory ($pwd).
    .PARAMETER SizeBytes
        The size of the Virtual Hard Disk to create.
        For fixed disks, the VHD(X) file will be allocated all of this space immediately.
        For dynamic disks, this will be the maximum size that the VHD(X) can grow to.
        The default value is 40GB.
    .PARAMETER VHDFormat
        Specifies whether to create a VHD or VHDX formatted Virtual Hard Disk.
        The default is VHD.
    .PARAMETER VHDType
        Specifies whether to create a fixed (fully allocated) VHD(X) or a dynamic (sparse) VHD(X).
        The default is dynamic.
    .PARAMETER UnattendPath
        The complete path to an unattend.xml file that can be injected into the VHD(X).
    .PARAMETER Edition
        The name or image index of the image to apply from the WIM.
    .PARAMETER Passthru
        Specifies that the full path to the VHD(X) that is created should be
        returned on the pipeline.
    .PARAMETER BCDBoot
        By default, the version of BCDBOOT.EXE that is present in \Windows\System32
        is used by Convert-WindowsImage.  If you need to specify an alternate version,
        use this parameter to do so.
    .PARAMETER ShowUI
        Specifies that the Graphical User Interface should be displayed.
    .EXAMPLE
        .\Convert-WindowsImage.ps1 -SourcePath D:\foo\install.wim -Edition Enterprise -WorkingDirectory D:\foo
        This command will create a 40GB dynamically expanding VHD in the D:\foo folder.
        The VHD will be based on the Enterprise edition from D:\foo\install.wim,
        and will be named automatically.
    .EXAMPLE
        .\Convert-WindowsImage.ps1 -SourcePath D:\foo\Win7SP1.iso -Edition Ultimate -VHDPath D:\foo\Win7_Ultimate_SP1.vhd
        This command will parse the ISO file D:\foo\Win7SP1.iso and try to locate
        \sources\install.wim.  If that file is found, it will be used to create a 
        dynamically-expanding 40GB VHD containing the Ultimate SKU, and will be 
        named D:\foo\Win7_Ultimate_SP1.vhd
    .OUTPUTS
        System.IO.FileInfo
    .LINK
        Microsoft Permissive License - https://www.microsoft.com/opensource/licenses.mspx#Ms-PL
    .NOTES 
        NAME:      Create-WindowsImage.ps1
        LASTEDIT:  02 MAR 2012 11:18:00 AM
        
        Convert-WindowsImage and the associated documentation are provided "AS-IS". 
        You bear the risk of using it. No express warranties, guarantees or conditions
        are provided. It is not supported or endorsed by Microsoft Corporation and 
        should be used at your own risk.
        Please visit <INSERT_NEW_URL /> for licensing information 
        and documentation.
        This script is released under the Microsoft Public License (Ms-PL).
        https://www.microsoft.com/opensource/licenses.mspx#Ms-PL
#Requires -Version 3.0
[CmdletBinding(DefaultParameterSetName="SRC")]
param(
    [Parameter(ParameterSetName="SRC", Mandatory=$true, ValueFromPipeline=$true)]
    [Alias("WIM")]
    [string]
    [ValidateNotNullOrEmpty()]
    [ValidateScript({ Test-Path $(Resolve-Path $_) })]
    $SourcePath,
    [Parameter(ParameterSetName="SRC")]
    [Alias("VHD")]
    [string]
    [ValidateNotNullOrEmpty()]
    $VHDPath,
    [Parameter(ParameterSetName="SRC")]
    [Alias("WorkDir")]
    [string]
    [ValidateNotNullOrEmpty()]
    [ValidateScript({ Test-Path $_ })]
    $WorkingDirectory = $pwd,
    [Parameter(ParameterSetName="SRC")]
    [Alias("Size")]
    [UInt64]
    [ValidateNotNullOrEmpty()]
    [ValidateRange(512MB, 64TB)]
    $SizeBytes        = 40GB,
    [Parameter(ParameterSetName="SRC")]
    [Alias("Format")]
    [string]
    [ValidateNotNullOrEmpty()]
    [ValidateSet("VHD", "VHDX")]
    $VHDFormat        = "VHD",
    [Parameter(ParameterSetName="SRC")]
    [Alias("DiskType")]
    [string]
    [ValidateNotNullOrEmpty()]
    [ValidateSet("Dynamic", "Fixed")]
    $VHDType          = "Dynamic",
    [Parameter(ParameterSetName="SRC")]
    [Alias("Unattend")]
    [string]
    [ValidateNotNullOrEmpty()]
    [ValidateScript({ Test-Path $(Resolve-Path $_) })]
    $UnattendPath,
    [Parameter(ParameterSetName="SRC")]
    [Alias("SKU")]
    [string]
    [ValidateNotNullOrEmpty()]
    $Edition,
    [Parameter(ParameterSetName="SRC")]
    [Parameter(ParameterSetName="UI")]
    [string]
    $BCDBoot          = "bcdboot.exe",
    [Parameter(ParameterSetName="SRC")]
    [Parameter(ParameterSetName="UI")]
    [switch]
    $Passthru,
    [Parameter(ParameterSetName="UI")]
    [switch]
    $ShowUI
##########################################################################################
#                             Constants and Pseudo-Constants
##########################################################################################
$PARTITION_STYLE_MBR = 0x00000000                                   # The default value
$PARTITION_STYLE_GPT = 0x00000001                                   # Just in case...
$BETA_SYMBOL         = [char]0x3B2
# Version information that can be populated by timebuild.
$ScriptVersion = DATA {
    ConvertFrom-StringData -StringData @"
        Major     = 6
        Minor     = 2
        Build     = 8319
        QFE       = 0
        Branch    = private
        Timestamp = 120312-0902
        Flavor    = amd64fre
$vQuality            = $BETA_SYMBOL
$myVersion           = "$($ScriptVersion.Major).$($ScriptVersion.Minor).$($ScriptVersion.Build).$($ScriptVersion.QFE).$($ScriptVersion.Flavor).$($ScriptVersion.Branch).$($ScriptVersion.Timestamp)"
$scriptName          = "Convert-WindowsImage"                       # Name of the script, obviously.
$sessionKey          = [Guid]::NewGuid().ToString()                 # Session key, used for keeping records unique between multiple runs.
$logFolder           = "$($env:Temp)\$($scriptName)\$($sessionKey)" # Log folder path.
$vhdMaxSize          = 2040GB                                       # Maximum size for VHD is ~2040GB.
$vhdxMaxSize         = 64TB                                         # Maximum size for VHDX is ~64TB.
$lowestSupportedVersion = New-Object Version "10.0"                 # The lowest supported *image* version; we require Windows 10 or higher.
$transcripting       = $false
# Since we use the VHDFormat in output, make it uppercase.
# We'll make it lowercase again when we use it as a file extension.
$VHDFormat = $VHDFormat.ToUpper()
##########################################################################################
#                                      Here Strings
##########################################################################################
# Text used for flag file embedded in VHD(X)
$mkWasHere = @"
This $VHDFormat was created by Convert-WindowsImage.ps1 (WIM2VHD8) $myVersion $vQuality
on $([DateTime]::Now).
# Banner text displayed during each run.
$header    = @"
Windows(R) Image to Virtual Hard Disk (WIM2VHD) Converter for Windows(R) 8
Copyright (C) Microsoft Corporation.  All rights reserved.
Version $myVersion $vQuality
# Text used as the banner in the UI.
$uiHeader  = @"
You can use the fields below to configure the VHD or VHDX that you want to create!
# C# code to wrap the native APIs in VIRTDISK.DLL and WIMGAPI.DLL.  
# This code allows Convert-WindowsImage to run without the need for IMAGEX.EXE (and the entire AIK/ADK).
$code      = @"
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Security;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using System.Xml.Linq;
using System.Xml.XPath;
using Microsoft.Win32.SafeHandles;
namespace WIM2VHD {
    /// <summary>
    /// P/Invoke methods and associated enums, flags, and structs.
    /// </summary>
    public class
    NativeMethods {
        #region Delegates and Callbacks
        #region WIMGAPI
        ///<summary>
        ///User-defined function used with the RegisterMessageCallback or UnregisterMessageCallback function.
        ///</summary>
        ///<param name="MessageId">Specifies the message being sent.</param>
        ///<param name="wParam">Specifies additional message information. The contents of this parameter depend on the value of the
        ///MessageId parameter.</param>
        ///<param name="lParam">Specifies additional message information. The contents of this parameter depend on the value of the
        ///MessageId parameter.</param>
        ///<param name="UserData">Specifies the user-defined value passed to RegisterCallback.</param>
        ///<returns>
        ///To indicate success and to enable other subscribers to process the message return WIM_MSG_SUCCESS.
        ///To prevent other subscribers from receiving the message, return WIM_MSG_DONE.
        ///To cancel an image apply or capture, return WIM_MSG_ABORT_IMAGE when handling the WIM_MSG_PROCESS message.
        ///</returns>
        public delegate uint
        WimMessageCallback(
            uint   MessageId,
            IntPtr wParam,
            IntPtr lParam,
            IntPtr UserData
        );
        public static void
        RegisterMessageCallback(
            WimFileHandle hWim,
            WimMessageCallback callback) {
            uint _callback = NativeMethods.WimRegisterMessageCallback(hWim, callback, IntPtr.Zero);
            int rc = Marshal.GetLastWin32Error();
            if (0 != rc) {
                // Throw an exception if something bad happened on the Win32 end.
                throw
                    new InvalidOperationException(
                        string.Format(
                            CultureInfo.CurrentCulture,
                            "Unable to register message callback."
                ));
            }
        }
        public static void 
        UnregisterMessageCallback(
            WimFileHandle hWim,
            WimMessageCallback registeredCallback) {
            bool status = NativeMethods.WimUnregisterMessageCallback(hWim, registeredCallback);
            int rc = Marshal.GetLastWin32Error();
            if (!status) {
                throw
                    new InvalidOperationException(
                        string.Format(
                            CultureInfo.CurrentCulture,
                            "Unable to unregister message callback."
                ));
            }
        }
        #endregion WIMGAPI
        #endregion Delegates and Callbacks
        #region Constants
        #region VDiskInterop
        /// <summary>
        /// The default depth in a VHD parent chain that this library will search through.
        /// If you want to go more than one disk deep into the parent chain, provide a different value.
        /// </summary>
        public   const uint  OPEN_VIRTUAL_DISK_RW_DEFAULT_DEPTH   = 0x00000001;
        public   const uint  DEFAULT_BLOCK_SIZE                   = 0x00080000;
        public   const uint  DISK_SECTOR_SIZE                     = 0x00000200;
        internal const uint  ERROR_VIRTDISK_NOT_VIRTUAL_DISK      = 0xC03A0015;
        internal const uint  ERROR_NOT_FOUND                      = 0x00000490;
        internal const uint  ERROR_IO_PENDING                     = 0x000003E5;
        internal const uint  ERROR_INSUFFICIENT_BUFFER            = 0x0000007A;
        internal const uint  ERROR_ERROR_DEV_NOT_EXIST            = 0x00000037;
        internal const uint  ERROR_BAD_COMMAND                    = 0x00000016;
        internal const uint  ERROR_SUCCESS                        = 0x00000000;
        public   const uint  GENERIC_READ                         = 0x80000000;
        public   const uint  GENERIC_WRITE                        = 0x40000000;
        public   const short FILE_ATTRIBUTE_NORMAL                = 0x00000080;
        public   const uint  CREATE_NEW                           = 0x00000001;
        public   const uint  CREATE_ALWAYS                        = 0x00000002;
        public   const uint  OPEN_EXISTING                        = 0x00000003;
        public   const short INVALID_HANDLE_VALUE                 = -1;
        internal static Guid VirtualStorageTypeVendorUnknown      = new Guid("00000000-0000-0000-0000-000000000000");
        internal static Guid VirtualStorageTypeVendorMicrosoft    = new Guid("EC984AEC-A0F9-47e9-901F-71415A66345B");
        #endregion VDiskInterop
        #region WIMGAPI
        public   const uint  WIM_FLAG_VERIFY                      = 0x00000002;
        public   const uint  WIM_FLAG_INDEX                       = 0x00000004;
        public   const uint  WM_APP                               = 0x00008000;
        #endregion WIMGAPI
        #endregion Constants
        #region Enums and Flags
        #region VDiskInterop
        /// <summary>
        /// Indicates the version of the virtual disk to create.
        /// </summary>
        public enum CreateVirtualDiskVersion : int {
            VersionUnspecified         = 0x00000000,
            Version1                   = 0x00000001,
            Version2                   = 0x00000002
        }
        public enum OpenVirtualDiskVersion : int {
            VersionUnspecified         = 0x00000000,
            Version1                   = 0x00000001,
            Version2                   = 0x00000002
        }
        /// <summary>
        /// Contains the version of the virtual hard disk (VHD) ATTACH_VIRTUAL_DISK_PARAMETERS structure to use in calls to VHD functions.
        /// </summary>
        public enum AttachVirtualDiskVersion : int {
            VersionUnspecified         = 0x00000000,
            Version1                   = 0x00000001,
            Version2                   = 0x00000002
        }
        public enum CompactVirtualDiskVersion : int {
            VersionUnspecified         = 0x00000000,
            Version1                   = 0x00000001
        }
        /// <summary>
        /// Contains the type and provider (vendor) of the virtual storage device.
        /// </summary>
        public enum VirtualStorageDeviceType : int {
            /// <summary>
            /// The storage type is unknown or not valid.
            /// </summary>
            Unknown                    = 0x00000000,
            /// <summary>
            /// For internal use only.  This type is not supported.
            /// </summary>
            ISO                        = 0x00000001,
            /// <summary>
            /// Virtual Hard Disk device type.
            /// </summary>
            VHD                        = 0x00000002,
            /// <summary>
            /// Virtual Hard Disk v2 device type.
            /// </summary>
            VHDX                       = 0x00000003
        }
        /// <summary>
        /// Contains virtual hard disk (VHD) open request flags.
        /// </summary>
        [Flags]
        public enum OpenVirtualDiskFlags {
            /// <summary>
            /// No flags. Use system defaults.
            /// </summary>
            None                       = 0x00000000,
            /// <summary>
            /// Open the VHD file (backing store) without opening any differencing-chain parents. Used to correct broken parent links.
            /// </summary>
            NoParents                  = 0x00000001,
            /// <summary>
            /// Reserved.
            /// </summary>
            BlankFile                  = 0x00000002,
            /// <summary>
            /// Reserved.
            /// </summary>
            BootDrive                  = 0x00000004,
        }
        /// <summary>
        /// Contains the bit mask for specifying access rights to a virtual hard disk (VHD).
        /// </summary>
        [Flags]
        public enum VirtualDiskAccessMask {
            /// <summary>
            /// Only Version2 of OpenVirtualDisk API accepts this parameter
            /// </summary>
            None                       = 0x00000000,
            /// <summary>
            /// Open the virtual disk for read-only attach access. The caller must have READ access to the virtual disk image file.
            /// </summary>
            /// <remarks>
            /// If used in a request to open a virtual disk that is already open, the other handles must be limited to either
            /// VIRTUAL_DISK_ACCESS_DETACH or VIRTUAL_DISK_ACCESS_GET_INFO access, otherwise the open request with this flag will fail.
            /// </remarks>
            AttachReadOnly             = 0x00010000,
            /// <summary>
            /// Open the virtual disk for read-write attaching access. The caller must have (READ | WRITE) access to the virtual disk image file.
            /// </summary>
            /// <remarks>
            /// If used in a request to open a virtual disk that is already open, the other handles must be limited to either
            /// VIRTUAL_DISK_ACCESS_DETACH or VIRTUAL_DISK_ACCESS_GET_INFO access, otherwise the open request with this flag will fail.
            /// If the virtual disk is part of a differencing chain, the disk for this request cannot be less than the readWriteDepth specified
            /// during the prior open request for that differencing chain.
            /// </remarks>
            AttachReadWrite            = 0x00020000,
            /// <summary>
            /// Open the virtual disk to allow detaching of an attached virtual disk. The caller must have
            /// (FILE_READ_ATTRIBUTES | FILE_READ_DATA) access to the virtual disk image file.
            /// </summary>
            Detach                     = 0x00040000,
            /// <summary>
            /// Information retrieval access to the virtual disk. The caller must have READ access to the virtual disk image file.
            /// </summary>
            GetInfo                    = 0x00080000,
            /// <summary>
            /// Virtual disk creation access.
            /// </summary>
            Create                     = 0x00100000,
            /// <summary>
            /// Open the virtual disk to perform offline meta-operations. The caller must have (READ | WRITE) access to the virtual
            /// disk image file, up to readWriteDepth if working with a differencing chain.
            /// </summary>
            /// <remarks>
            /// If the virtual disk is part of a differencing chain, the backing store (host volume) is opened in RW exclusive mode up to readWriteDepth.
            /// </remarks>
            MetaOperations             = 0x00200000,
            /// <summary>
            /// Reserved.
            /// </summary>
            Read                       = 0x000D0000,
            /// <summary>
            /// Allows unrestricted access to the virtual disk. The caller must have unrestricted access rights to the virtual disk image file.
            /// </summary>
            All                        = 0x003F0000,
            /// <summary>
            /// Reserved.
            /// </summary>
            Writable                   = 0x00320000
        }
        /// <summary>
        /// Contains virtual hard disk (VHD) creation flags.
        /// </summary>
        [Flags]
        public enum CreateVirtualDiskFlags {
            /// <summary>
            /// Contains virtual hard disk (VHD) creation flags.
            /// </summary>
            None                       = 0x00000000,
            /// <summary>
            /// Pre-allocate all physical space necessary for the size of the virtual disk.
            /// </summary>
            /// <remarks>
            /// The CREATE_VIRTUAL_DISK_FLAG_FULL_PHYSICAL_ALLOCATION flag is used for the creation of a fixed VHD.
            /// </remarks>
            FullPhysicalAllocation     = 0x00000001
        }
        /// <summary>
        /// Contains virtual disk attach request flags.
        /// </summary>
        [Flags]
        public enum AttachVirtualDiskFlags {
            /// <summary>
            /// No flags. Use system defaults.
            /// </summary>
            None                       = 0x00000000,
            /// <summary>
            /// Attach the virtual disk as read-only.
            /// </summary>
            ReadOnly                   = 0x00000001,
            /// <summary>
            /// No drive letters are assigned to the disk's volumes.
            /// </summary>
            /// <remarks>Oddly enough, this doesn't apply to NTFS mount points.</remarks>
            NoDriveLetter              = 0x00000002,
            /// <summary>
            /// Will decouple the virtual disk lifetime from that of the VirtualDiskHandle.
            /// The virtual disk will be attached until the Detach() function is called, even if all open handles to the virtual disk are closed.
            /// </summary>
            PermanentLifetime          = 0x00000004,
            /// <summary>
            /// Reserved.
            /// </summary>
            NoLocalHost                = 0x00000008
        }
        [Flags]
        public enum DetachVirtualDiskFlag {
            None                       = 0x00000000
        }
        [Flags]
        public enum CompactVirtualDiskFlags {
            None                       = 0x00000000,
            NoZeroScan                 = 0x00000001,
            NoBlockMoves               = 0x00000002
        }
        #endregion VDiskInterop
        #region WIMGAPI
        [FlagsAttribute]
        internal enum 
        WimCreateFileDesiredAccess 
            : uint {
            WimQuery                   = 0x00000000,
            WimGenericRead             = 0x80000000
        }
        /// <summary>
        /// Specifies how the file is to be treated and what features are to be used.
        /// </summary>
        [FlagsAttribute]
        internal enum
        WimApplyFlags
            : uint {
            /// <summary>
            /// No flags.
            /// </summary>
            WimApplyFlagsNone          = 0x00000000,
            /// <summary>
            /// Reserved.
            /// </summary>
            WimApplyFlagsReserved      = 0x00000001,
            /// <summary>
            /// Verifies that files match original data.
            /// </summary>
            WimApplyFlagsVerify        = 0x00000002,
            /// <summary>
            /// Specifies that the image is to be sequentially read for caching or performance purposes.
            /// </summary>
            WimApplyFlagsIndex         = 0x00000004,
            /// <summary>
            /// Applies the image without physically creating directories or files. Useful for obtaining a list of files and directories in the image.
            /// </summary>
            WimApplyFlagsNoApply       = 0x00000008,
            /// <summary>
            /// Disables restoring security information for directories.
            /// </summary>
            WimApplyFlagsNoDirAcl      = 0x00000010,
            /// <summary>
            /// Disables restoring security information for files
            /// </summary>
            WimApplyFlagsNoFileAcl     = 0x00000020,
            /// <summary>
            /// The .wim file is opened in a mode that enables simultaneous reading and writing.
            /// </summary>
            WimApplyFlagsShareWrite    = 0x00000040,
            /// <summary>
            /// Sends a WIM_MSG_FILEINFO message during the apply operation.
            /// </summary>
            WimApplyFlagsFileInfo      = 0x00000080,
            /// <summary>
            /// Disables automatic path fixups for junctions and symbolic links.
            /// </summary>
            WimApplyFlagsNoRpFix       = 0x00000100,
            /// <summary>
            /// Returns a handle that cannot commit changes, regardless of the access level requested at mount time.
            /// </summary>
            WimApplyFlagsMountReadOnly = 0x00000200,
            /// <summary>
            /// Reserved.
            /// </summary>
            WimApplyFlagsMountFast     = 0x00000400,
            /// <summary>
            /// Reserved.
            /// </summary>
            WimApplyFlagsMountLegacy   = 0x00000800
        }
        public enum WimMessage : uint {
            WIM_MSG                    = WM_APP + 0x1476,                
            WIM_MSG_TEXT,
            ///<summary>
            ///Indicates an update in the progress of an image application.
            ///</summary>
            WIM_MSG_PROGRESS,
            ///<summary>
            ///Enables the caller to prevent a file or a directory from being captured or applied.
            ///</summary>
            WIM_MSG_PROCESS,
            ///<summary>
            ///Indicates that volume information is being gathered during an image capture.
            ///</summary>
            WIM_MSG_SCANNING,
            ///<summary>
            ///Indicates the number of files that will be captured or applied.
            ///</summary>
            WIM_MSG_SETRANGE,
            ///<summary>
            ///Indicates the number of files that have been captured or applied.
            ///</summary>
            WIM_MSG_SETPOS,
            ///<summary>
            ///Indicates that a file has been either captured or applied.
            ///</summary>
            WIM_MSG_STEPIT,
            ///<summary>
            ///Enables the caller to prevent a file resource from being compressed during a capture.
            ///</summary>
            WIM_MSG_COMPRESS,
            ///<summary>
            ///Alerts the caller that an error has occurred while capturing or applying an image.
            ///</summary>
            WIM_MSG_ERROR,
            ///<summary>
            ///Enables the caller to align a file resource on a particular alignment boundary.
            ///</summary>
            WIM_MSG_ALIGNMENT,
            WIM_MSG_RETRY,
            ///<summary>
            ///Enables the caller to align a file resource on a particular alignment boundary.
            ///</summary>
            WIM_MSG_SPLIT,
            WIM_MSG_SUCCESS            = 0x00000000,                
            WIM_MSG_ABORT_IMAGE        = 0xFFFFFFFF
        }
        internal enum 
        WimCreationDisposition 
            : uint {
            WimOpenExisting            = 0x00000003,
        }
        internal enum 
        WimActionFlags 
            : uint {
            WimIgnored                 = 0x00000000
        }
        internal enum 
        WimCompressionType 
            : uint {
            WimIgnored                 = 0x00000000
        }
        internal enum 
        WimCreationResult 
            : uint {
            WimCreatedNew              = 0x00000000,
            WimOpenedExisting          = 0x00000001
        }
        #endregion WIMGAPI
        #endregion Enums and Flags
        #region Structs
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
        public struct CreateVirtualDiskParameters {
            /// <summary>
            /// A CREATE_VIRTUAL_DISK_VERSION enumeration that specifies the version of the CREATE_VIRTUAL_DISK_PARAMETERS structure being passed to or from the virtual hard disk (VHD) functions.
            /// </summary>
            public CreateVirtualDiskVersion Version;
            /// <summary>
            /// Unique identifier to assign to the virtual disk object. If this member is set to zero, a unique identifier is created by the system.
            /// </summary>
            public Guid UniqueId;
            /// <summary>
            /// The maximum virtual size of the virtual disk object. Must be a multiple of 512.
            /// If a ParentPath is specified, this value must be zero.
            /// If a SourcePath is specified, this value can be zero to specify the size of the source VHD to be used, otherwise the size specified must be greater than or equal to the size of the source disk.
            /// </summary>
            public ulong MaximumSize;
            /// <summary>
            /// Internal size of the virtual disk object blocks.
            /// The following are predefined block sizes and their behaviors. For a fixed VHD type, this parameter must be zero.
            /// </summary>
            public uint BlockSizeInBytes;
            /// <summary>
            /// Internal size of the virtual disk object sectors. Must be set to 512.
            /// </summary>
            public uint SectorSizeInBytes;
            /// <summary>
            /// Optional path to a parent virtual disk object. Associates the new virtual disk with an existing virtual disk.
            /// If this parameter is not NULL, SourcePath must be NULL.
            /// </summary>
            public string ParentPath;
            /// <summary>
            /// Optional path to pre-populate the new virtual disk object with block data from an existing disk. This path may refer to a VHD or a physical disk.
            /// If this parameter is not NULL, ParentPath must be NULL.
            /// </summary>
            public string SourcePath;
            /// <summary>
            /// Flags for opening the VHD
            /// </summary>
            public OpenVirtualDiskFlags OpenFlags;
            /// <summary>
            /// GetInfoOnly flag for V2 handles
            /// </summary>
            public bool GetInfoOnly;
            /// <summary>
            /// Virtual Storage Type of the parent disk
            /// </summary>
            public VirtualStorageType ParentVirtualStorageType;
            /// <summary>
            /// Virtual Storage Type of the source disk
            /// </summary>
            public VirtualStorageType SourceVirtualStorageType;
            /// <summary>
            /// A GUID to use for fallback resiliency over SMB.
            /// </summary>
            public Guid ResiliencyGuid;
        }
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
        public struct VirtualStorageType {
            public VirtualStorageDeviceType DeviceId;
            public Guid VendorId;
        }
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
        public struct SecurityDescriptor {
            public byte revision;
            public byte size;
            public short control;
            public IntPtr owner;
            public IntPtr group;
            public IntPtr sacl;
            public IntPtr dacl;
        }
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
        public struct
        OpenVirtualDiskParameters {
            public OpenVirtualDiskVersion Version;
            public bool GetInfoOnly;
            public Guid ResiliencyGuid;
        }
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
        public struct VirtualDiskProgress {
            public int OperationStatus;
            public ulong CurrentValue;
            public ulong CompletionValue;
        }
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
        public struct AttachVirtualDiskParameters {
            public AttachVirtualDiskVersion Version;
            public int Reserved;
        }
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
        public struct CompactVirtualDiskParameters {
            public CompactVirtualDiskVersion Version;
            public uint Reserved;
        }
        #endregion Structs
        #region VirtDisk.DLL P/Invoke
        [DllImport("virtdisk.dll", CharSet = CharSet.Unicode)]
        public static extern uint
        CreateVirtualDisk(
            [In, Out] ref VirtualStorageType VirtualStorageType,
            [In]          string Path,
            [In]          VirtualDiskAccessMask VirtualDiskAccessMask,
            [In, Out] ref SecurityDescriptor SecurityDescriptor,
            [In]          CreateVirtualDiskFlags Flags,
            [In]          uint ProviderSpecificFlags,
            [In, Out] ref CreateVirtualDiskParameters Parameters,
            [In]          IntPtr Overlapped,
            [Out]     out SafeFileHandle Handle);
        [DllImport("virtdisk.dll", CharSet = CharSet.Unicode)]
        internal static extern uint
        OpenVirtualDisk(
            [In, Out] ref VirtualStorageType VirtualStorageType,
            [In]          string Path,
            [In]          VirtualDiskAccessMask VirtualDiskAccessMask,
            [In]          OpenVirtualDiskFlags Flags,
            [In, Out] ref OpenVirtualDiskParameters Parameters,
            [Out]     out SafeFileHandle Handle);
        /// <summary>
        /// GetVirtualDiskOperationProgress API allows getting progress info for the async virtual disk operations (ie. Online Mirror)
        /// </summary>
        /// <param name="VirtualDiskHandle"></param>
        /// <param name="Overlapped"></param>
        /// <param name="Progress"></param>
        /// <returns></returns>
        [DllImport("virtdisk.dll", CharSet = CharSet.Unicode)]
        internal static extern uint
        GetVirtualDiskOperationProgress(
            [In]          SafeFileHandle VirtualDiskHandle,
            [In]          IntPtr Overlapped,
            [In, Out] ref VirtualDiskProgress Progress);
        [DllImport("virtdisk.dll", CharSet = CharSet.Unicode)]
        public static extern uint
        AttachVirtualDisk(
            [In]          SafeFileHandle VirtualDiskHandle,
            [In, Out] ref SecurityDescriptor SecurityDescriptor,
            [In]          AttachVirtualDiskFlags Flags,
            [In]          uint ProviderSpecificFlags,
            [In, Out] ref AttachVirtualDiskParameters Parameters,
            [In]          IntPtr Overlapped);
        [DllImport("virtdisk.dll", CharSet = CharSet.Unicode)]
        public static extern uint
        DetachVirtualDisk(
            [In]          SafeFileHandle VirtualDiskHandle,
            [In]          NativeMethods.DetachVirtualDiskFlag Flags,
            [In]          uint ProviderSpecificFlags);
        [DllImport("virtdisk.dll", CharSet = CharSet.Unicode)]
        public static extern uint
        CompactVirtualDisk(
            [In]          SafeFileHandle VirtualDiskHandle,
            [In]          CompactVirtualDiskFlags Flags,
            [In, Out] ref CompactVirtualDiskParameters Parameters,
            [In]          IntPtr Overlapped);
        [DllImport("virtdisk.dll", CharSet = CharSet.Unicode)]
        public static extern uint
        GetVirtualDiskPhysicalPath(
            [In]          SafeFileHandle VirtualDiskHandle,
            [In, Out] ref uint DiskPathSizeInBytes,
            [Out]         StringBuilder DiskPath);
        #endregion VirtDisk.DLL P/Invoke
        #region Win32 P/Invoke
        [DllImport("advapi32", SetLastError = true)]
        public static extern bool InitializeSecurityDescriptor(
            [Out]     out SecurityDescriptor pSecurityDescriptor,
            [In]          uint dwRevision);
        /// <summary>
        /// CreateEvent API is used while calling async Online Mirror API
        /// </summary>
        /// <param name="lpEventAttributes"></param>
        /// <param name="bManualReset"></param>
        /// <param name="bInitialState"></param>
        /// <param name="lpName"></param>
        /// <returns></returns>
        [DllImport("kernel32.dll", CharSet = CharSet.Unicode)]
        internal static extern IntPtr
        CreateEvent(
            [In, Optional]  IntPtr lpEventAttributes,
            [In]            bool bManualReset,
            [In]            bool bInitialState,
            [In, Optional]  string lpName);
        #endregion Win32 P/Invoke
        #region WIMGAPI P/Invoke
        #region SafeHandle wrappers for WimFileHandle and WimImageHandle
        public sealed class WimFileHandle : SafeHandle {
            public WimFileHandle(
                string wimPath)
                : base(IntPtr.Zero, true) {
                if (String.IsNullOrEmpty(wimPath)) {
                    throw new ArgumentNullException("wimPath");
                }
                if (!File.Exists(Path.GetFullPath(wimPath))) {
                    throw new FileNotFoundException((new FileNotFoundException()).Message, wimPath);
                }
                NativeMethods.WimCreationResult creationResult;
                this.handle = NativeMethods.WimCreateFile(
                    wimPath,
                    NativeMethods.WimCreateFileDesiredAccess.WimGenericRead,
                    NativeMethods.WimCreationDisposition.WimOpenExisting,
                    NativeMethods.WimActionFlags.WimIgnored,
                    NativeMethods.WimCompressionType.WimIgnored,
                    out creationResult
                );
                // Check results.
                if (creationResult != NativeMethods.WimCreationResult.WimOpenedExisting) {
                    throw new Win32Exception();
                }
                if (this.handle == IntPtr.Zero) {
                    throw new Win32Exception();
                }
                // Set the temporary path.
                NativeMethods.WimSetTemporaryPath(
                    this,
                    Environment.ExpandEnvironmentVariables("%TEMP%")
                );
            }
            protected override bool ReleaseHandle() {
                return NativeMethods.WimCloseHandle(this.handle);
            }
            public override bool IsInvalid {
                get { return this.handle == IntPtr.Zero; }
            }
        }
        public sealed class WimImageHandle : SafeHandle {
            public WimImageHandle(
                WimFile Container,
                uint ImageIndex)
                : base(IntPtr.Zero, true) {
                if (null == Container) {
                    throw new ArgumentNullException("Container");
                }
                if ((Container.Handle.IsClosed) || (Container.Handle.IsInvalid)) {
                    throw new ArgumentNullException("The handle to the WIM file has already been closed, or is invalid.", "Container");
                }
                if (ImageIndex > Container.ImageCount) {
                    throw new ArgumentOutOfRangeException("ImageIndex", "The index does not exist in the specified WIM file.");
                }
                this.handle = NativeMethods.WimLoadImage(
                    Container.Handle.DangerousGetHandle(),
                    ImageIndex);
            }
            protected override bool ReleaseHandle() {
                return NativeMethods.WimCloseHandle(this.handle);
            }
            public override bool IsInvalid {
                get { return this.handle == IntPtr.Zero; }
            }
        }
        #endregion SafeHandle wrappers for WimFileHandle and WimImageHandle
        [DllImport("Wimgapi.dll", CharSet = CharSet.Unicode, SetLastError = true, EntryPoint = "WIMCreateFile")]
        internal static extern IntPtr
        WimCreateFile(
            [In, MarshalAs(UnmanagedType.LPWStr)] string WimPath,
            [In]    WimCreateFileDesiredAccess DesiredAccess,
            [In]    WimCreationDisposition CreationDisposition,
            [In]    WimActionFlags FlagsAndAttributes,
            [In]    WimCompressionType CompressionType,
            [Out, Optional] out WimCreationResult CreationResult
        );
        [DllImport("Wimgapi.dll", CharSet = CharSet.Unicode, SetLastError = true, EntryPoint = "WIMCloseHandle")]
        [return: MarshalAs(UnmanagedType.Bool)]
        internal static extern bool
        WimCloseHandle(
            [In]    IntPtr Handle
        );
        [DllImport("Wimgapi.dll", CharSet = CharSet.Unicode, SetLastError = true, EntryPoint = "WIMLoadImage")]
        internal static extern IntPtr
        WimLoadImage(
            [In]    IntPtr Handle,
            [In]    uint ImageIndex
        );
        [DllImport("Wimgapi.dll", CharSet = CharSet.Unicode, SetLastError = true, EntryPoint = "WIMGetImageCount")]
        internal static extern uint
        WimGetImageCount(
            [In]    WimFileHandle Handle
        );
        [DllImport("Wimgapi.dll", CharSet = CharSet.Unicode, SetLastError = true, EntryPoint = "WIMApplyImage")]
        internal static extern bool
        WimApplyImage(
            [In]    WimImageHandle Handle,
            [In, Optional, MarshalAs(UnmanagedType.LPWStr)] string Path,
            [In]    WimApplyFlags Flags
        );
        [DllImport("Wimgapi.dll", CharSet = CharSet.Unicode, SetLastError = true, EntryPoint = "WIMGetImageInformation")]
        [return: MarshalAs(UnmanagedType.Bool)]
        internal static extern bool
        WimGetImageInformation(
            [In]        SafeHandle Handle,
            [Out]   out StringBuilder ImageInfo,
            [Out]   out uint SizeOfImageInfo
        );
        [DllImport("Wimgapi.dll", CharSet = CharSet.Unicode, SetLastError = true, EntryPoint = "WIMSetTemporaryPath")]
        [return: MarshalAs(UnmanagedType.Bool)]
        internal static extern bool
        WimSetTemporaryPath(
            [In]    WimFileHandle Handle,
            [In]    string TempPath
        );
        [DllImport("Wimgapi.dll", CharSet = CharSet.Unicode, SetLastError = true, EntryPoint = "WIMRegisterMessageCallback", CallingConvention = CallingConvention.StdCall)]
        internal static extern uint
        WimRegisterMessageCallback(
            [In, Optional] WimFileHandle      hWim,
            [In]           WimMessageCallback MessageProc,
            [In, Optional] IntPtr             ImageInfo
        );
        [DllImport("Wimgapi.dll", CharSet = CharSet.Unicode, SetLastError = true, EntryPoint = "WIMUnregisterMessageCallback", CallingConvention = CallingConvention.StdCall)]
        [return: MarshalAs(UnmanagedType.Bool)]
        internal static extern bool
        WimUnregisterMessageCallback(
            [In, Optional] WimFileHandle      hWim,
            [In]           WimMessageCallback MessageProc
        );
        #endregion WIMGAPI P/Invoke
    }
    #region WIM Interop
    public class WimFile {
        internal XDocument m_xmlInfo;
        internal List<WimImage> m_imageList;
        private static NativeMethods.WimMessageCallback wimMessageCallback;
        
        #region Events
        
        /// <summary>
        /// DefaultImageEvent handler
        /// </summary>
        public delegate void DefaultImageEventHandler(object sender, DefaultImageEventArgs e);
        ///<summary>
        ///ProcessFileEvent handler
        ///</summary>
        public delegate void ProcessFileEventHandler(object sender, ProcessFileEventArgs e);
                
        ///<summary>
        ///Enable the caller to prevent a file resource from being compressed during a capture.
        ///</summary>
        public event ProcessFileEventHandler ProcessFileEvent;
        ///<summary>
        ///Indicate an update in the progress of an image application.
        ///</summary>
        public event DefaultImageEventHandler ProgressEvent;
        ///<summary>
        ///Alert the caller that an error has occurred while capturing or applying an image.
        ///</summary>
        public event DefaultImageEventHandler ErrorEvent;
        ///<summary>
        ///Indicate that a file has been either captured or applied.
        ///</summary>
        public event DefaultImageEventHandler StepItEvent;
        ///<summary>
        ///Indicate the number of files that will be captured or applied.
        ///</summary>
        public event DefaultImageEventHandler SetRangeEvent;
        ///<summary>
        ///Indicate the number of files that have been captured or applied.
        ///</summary>
        public event DefaultImageEventHandler SetPosEvent;
        #endregion Events
        private
        enum
        ImageEventMessage : uint {
            ///<summary>
            ///Enables the caller to prevent a file or a directory from being captured or applied.
            ///</summary>
            Progress = NativeMethods.WimMessage.WIM_MSG_PROGRESS,
            ///<summary>
            ///Notification sent to enable the caller to prevent a file or a directory from being captured or applied.
            ///To prevent a file or a directory from being captured or applied, call WindowsImageContainer.SkipFile().
            ///</summary>
            Process = NativeMethods.WimMessage.WIM_MSG_PROCESS,
            ///<summary>
            ///Enables the caller to prevent a file resource from being compressed during a capture.
            ///</summary>
            Compress = NativeMethods.WimMessage.WIM_MSG_COMPRESS,
            ///<summary>
            ///Alerts the caller that an error has occurred while capturing or applying an image.
            ///</summary>
            Error = NativeMethods.WimMessage.WIM_MSG_ERROR,
            ///<summary>
            ///Enables the caller to align a file resource on a particular alignment boundary.
            ///</summary>
            Alignment = NativeMethods.WimMessage.WIM_MSG_ALIGNMENT,
            ///<summary>
            ///Enables the caller to align a file resource on a particular alignment boundary.
            ///</summary>
            Split = NativeMethods.WimMessage.WIM_MSG_SPLIT,
            ///<summary>
            ///Indicates that volume information is being gathered during an image capture.
            ///</summary>
            Scanning = NativeMethods.WimMessage.WIM_MSG_SCANNING,
            ///<summary>
            ///Indicates the number of files that will be captured or applied.
            ///</summary>
            SetRange = NativeMethods.WimMessage.WIM_MSG_SETRANGE,
            ///<summary>
            ///Indicates the number of files that have been captured or applied.
            /// </summary>
            SetPos = NativeMethods.WimMessage.WIM_MSG_SETPOS,
            ///<summary>
            ///Indicates that a file has been either captured or applied.
            ///</summary>
            StepIt = NativeMethods.WimMessage.WIM_MSG_STEPIT,
            ///<summary>
            ///Success.
            ///</summary>
            Success = NativeMethods.WimMessage.WIM_MSG_SUCCESS,
            ///<summary>
            ///Abort.
            ///</summary>
            Abort = NativeMethods.WimMessage.WIM_MSG_ABORT_IMAGE
        }
        ///<summary>
        ///Event callback to the Wimgapi events
        ///</summary>
        private        
        uint
        ImageEventMessagePump(
            uint MessageId,
            IntPtr wParam,
            IntPtr lParam,
            IntPtr UserData) {
            uint status = (uint) NativeMethods.WimMessage.WIM_MSG_SUCCESS;
            DefaultImageEventArgs eventArgs = new DefaultImageEventArgs(wParam, lParam, UserData);
            switch ((ImageEventMessage)MessageId) {
                case ImageEventMessage.Progress:
                    ProgressEvent(this, eventArgs);
                    break;
                case ImageEventMessage.Process:
                    if (null != ProcessFileEvent) {
                        string fileToImage = Marshal.PtrToStringUni(wParam);
                        ProcessFileEventArgs fileToProcess = new ProcessFileEventArgs(fileToImage, lParam);
                        ProcessFileEvent(this, fileToProcess);
                        if (fileToProcess.Abort == true) {
                            status = (uint)ImageEventMessage.Abort;
                        }
                    }
                    break;
                case ImageEventMessage.Error:
                    if (null != ErrorEvent) {
                        ErrorEvent(this, eventArgs);
                    }
                    break;
                    
                case ImageEventMessage.SetRange:
                    if (null != SetRangeEvent) {
                        SetRangeEvent(this, eventArgs);
                    }
                    break;
                case ImageEventMessage.SetPos:
                    if (null != SetPosEvent) {
                        SetPosEvent(this, eventArgs);
                    }
                    break;
                case ImageEventMessage.StepIt:
                    if (null != StepItEvent) {
                        StepItEvent(this, eventArgs);
                    }
                    break;
                default:
                    break;
            }
            return status;
            
        }
        /// <summary>
        /// Constructor.
        /// </summary>
        /// <param name="wimPath">Path to the WIM container.</param>
        public
        WimFile(string wimPath) {
            if (string.IsNullOrEmpty(wimPath)) {
                throw new ArgumentNullException("wimPath");
            }
            if (!File.Exists(Path.GetFullPath(wimPath))) {
                throw new FileNotFoundException((new FileNotFoundException()).Message, wimPath);
            }
            Handle = new NativeMethods.WimFileHandle(wimPath);
            // Hook up the events before we return.
            //wimMessageCallback = new NativeMethods.WimMessageCallback(ImageEventMessagePump);
            //NativeMethods.RegisterMessageCallback(this.Handle, wimMessageCallback);
        }
        /// <summary>
        /// Closes the WIM file.
        /// </summary>
        public void
        Close() {
            foreach (WimImage image in Images) {
                image.Close();
            }
            if (null != wimMessageCallback) {
                NativeMethods.UnregisterMessageCallback(this.Handle, wimMessageCallback);
                wimMessageCallback = null;
            }
            if ((!Handle.IsClosed) && (!Handle.IsInvalid)) {
                Handle.Close();
            }
        }
        /// <summary>
        /// Provides a list of WimImage objects, representing the images in the WIM container file.
        /// </summary>
        public List<WimImage>
        Images {
            get {
                if (null == m_imageList) {
                    int imageCount = (int)ImageCount;
                    m_imageList = new List<WimImage>(imageCount);
                    for (int i = 0; i < imageCount; i++) {
                        // Load up each image so it's ready for us.
                        m_imageList.Add(
                            new WimImage(this, (uint)i + 1));
                    }
                }
                return m_imageList;
            }
        }
        /// <summary>
        /// Provides a list of names of the images in the specified WIM container file.
        /// </summary>
        public List<string>
        ImageNames {
            get {
                List<string> nameList = new List<string>();
                foreach (WimImage image in Images) {
                    nameList.Add(image.ImageName);
                }
                return nameList;
            }
        }
        /// <summary>
        /// Indexer for WIM images inside the WIM container, indexed by the image number.
        /// The list of Images is 0-based, but the WIM container is 1-based, so we automatically compensate for that.
        /// this[1] returns the 0th image in the WIM container.
        /// </summary>
        /// <param name="ImageIndex">The 1-based index of the image to retrieve.</param>
        /// <returns>WinImage object.</returns>
        public WimImage
        this[int ImageIndex] {
            get { return Images[ImageIndex - 1]; }
        }
        /// <summary>
        /// Indexer for WIM images inside the WIM container, indexed by the image name.
        /// WIMs created by different processes sometimes contain different information - including the name.
        /// Some images have their name stored in the Name field, some in the Flags field, and some in the EditionID field.
        /// We take all of those into account in while searching the WIM.
        /// </summary>
        /// <param name="ImageName"></param>
        /// <returns></returns>
        public WimImage
        this[string ImageName] {
            get {
                return
                    Images.Where(i => (
                        i.ImageName.ToUpper()  == ImageName.ToUpper() ||
                        i.ImageFlags.ToUpper() == ImageName.ToUpper() ))
                    .DefaultIfEmpty(null)
                        .FirstOrDefault<WimImage>();
            }
        }
        /// <summary>
        /// Returns the number of images in the WIM container.
        /// </summary>
        internal uint
        ImageCount {
            get { return NativeMethods.WimGetImageCount(Handle); }
        }
        /// <summary>
        /// Returns an XDocument representation of the XML metadata for the WIM container and associated images.
        /// </summary>
        internal XDocument
        XmlInfo {
            get {
                if (null == m_xmlInfo) {
                    StringBuilder builder;
                    uint bytes;
                    if (!NativeMethods.WimGetImageInformation(Handle, out builder, out bytes)) {
                        throw new Win32Exception();
                    }
                    // Ensure the length of the returned bytes to avoid garbage characters at the end.
                    int charCount = (int)bytes / sizeof(char);
                    if (null != builder) {
                        // Get rid of the unicode file marker at the beginning of the XML.
                        builder.Remove(0, 1);
                        builder.EnsureCapacity(charCount - 1);
                        builder.Length = charCount - 1;
                        // This isn't likely to change while we have the image open, so cache it.
                        m_xmlInfo = XDocument.Parse(builder.ToString().Trim());
                    } else {
                        m_xmlInfo = null;
                    }
                }
                return m_xmlInfo;
            }
        }
        public NativeMethods.WimFileHandle Handle {
            get;
            private set;
        }
    }
    public class
    WimImage {
        internal XDocument m_xmlInfo;
        public
        WimImage(
            WimFile Container,
            uint ImageIndex) {
            if (null == Container) {
                throw new ArgumentNullException("Container");
            }
            if ((Container.Handle.IsClosed) || (Container.Handle.IsInvalid)) {
                throw new ArgumentNullException("The handle to the WIM file has already been closed, or is invalid.", "Container");
            }
            if (ImageIndex > Container.ImageCount) {
                throw new ArgumentOutOfRangeException("ImageIndex", "The index does not exist in the specified WIM file.");
            }
            Handle = new NativeMethods.WimImageHandle(Container, ImageIndex);
        }
        public enum
        Architectures : uint {
            x86   = 0x0,
            ARM   = 0x5,
            IA64  = 0x6,
            AMD64 = 0x9
        }
        public void
        Close() {
            if ((!Handle.IsClosed) && (!Handle.IsInvalid)) {
                Handle.Close();
            }
        }
        public void
        Apply(
            string ApplyToPath) {
            if (string.IsNullOrEmpty(ApplyToPath)) {
                throw new ArgumentNullException("ApplyToPath");
            }
            ApplyToPath = Path.GetFullPath(ApplyToPath);
            if (!Directory.Exists(ApplyToPath)) {
                throw new DirectoryNotFoundException("The WIM cannot be applied because the specified directory was not found.");
            }
            if (!NativeMethods.WimApplyImage(
                this.Handle,
                ApplyToPath,
                NativeMethods.WimApplyFlags.WimApplyFlagsNone
            )) {
                throw new Win32Exception();
            }
        }
        public NativeMethods.WimImageHandle
        Handle {
            get;
            private set;
        }
        internal XDocument
        XmlInfo {
            get {
                if (null == m_xmlInfo) {
                    StringBuilder builder;
                    uint bytes;
                    if (!NativeMethods.WimGetImageInformation(Handle, out builder, out bytes)) {
                        throw new Win32Exception();
                    }
                    // Ensure the length of the returned bytes to avoid garbage characters at the end.
                    int charCount = (int)bytes / sizeof(char);
                    if (null != builder) {
                        // Get rid of the unicode file marker at the beginning of the XML.
                        builder.Remove(0, 1);
                        builder.EnsureCapacity(charCount - 1);
                        builder.Length = charCount - 1;
                        // This isn't likely to change while we have the image open, so cache it.
                        m_xmlInfo = XDocument.Parse(builder.ToString().Trim());
                    } else {
                        m_xmlInfo = null;
                    }
                }
                return m_xmlInfo;
            }
        }
        public string 
        ImageIndex {
            get { return XmlInfo.Element("IMAGE").Attribute("INDEX").Value; }
        }
        public string
        ImageName {
            get { return XmlInfo.XPathSelectElement("/IMAGE/NAME").Value; }
        }
        public string
        ImageEditionId {
            get { return XmlInfo.XPathSelectElement("/IMAGE/WINDOWS/EDITIONID").Value; }
        }
        public string
        ImageFlags {
            get { return XmlInfo.XPathSelectElement("/IMAGE/FLAGS").Value; }
        }
        public string
        ImageProductType {
            get {
                return XmlInfo.XPathSelectElement("/IMAGE/WINDOWS/PRODUCTTYPE").Value;
            }
        }
        public string
        ImageInstallationType {
            get { return XmlInfo.XPathSelectElement("/IMAGE/WINDOWS/INSTALLATIONTYPE").Value; }
        }
        public string
        ImageDescription {
            get { return XmlInfo.XPathSelectElement("/IMAGE/DESCRIPTION").Value; }
        }
        public ulong
        ImageSize {
            get { return ulong.Parse(XmlInfo.XPathSelectElement("/IMAGE/TOTALBYTES").Value); }
        }
        public Architectures
        ImageArchitecture {
            get {
                int arch = -1;
                try {
                    arch = int.Parse(XmlInfo.XPathSelectElement("/IMAGE/WINDOWS/ARCH").Value);
                } catch { }
                return (Architectures)arch;
            }
        }
        public string
        ImageDefaultLanguage {
            get {
                string lang = null;
                try {
                    lang = XmlInfo.XPathSelectElement("/IMAGE/WINDOWS/LANGUAGES/DEFAULT").Value;
                } catch { }
                return lang;
            }
        }
        public Version
        ImageVersion {
            get {
                int major = 0;
                int minor = 0;
                int build = 0;
                int revision = 0;
                try {
                    major = int.Parse(XmlInfo.XPathSelectElement("/IMAGE/WINDOWS/VERSION/MAJOR").Value);
                    minor = int.Parse(XmlInfo.XPathSelectElement("/IMAGE/WINDOWS/VERSION/MINOR").Value);
                    build = int.Parse(XmlInfo.XPathSelectElement("/IMAGE/WINDOWS/VERSION/BUILD").Value);
                    revision = int.Parse(XmlInfo.XPathSelectElement("/IMAGE/WINDOWS/VERSION/SPBUILD").Value);
                } catch { }
                return (new Version(major, minor, build, revision));
            }
        }
        public string
        ImageDisplayName {
            get { return XmlInfo.XPathSelectElement("/IMAGE/DISPLAYNAME").Value; }
        }
        public string
        ImageDisplayDescription {
            get { return XmlInfo.XPathSelectElement("/IMAGE/DISPLAYDESCRIPTION").Value; }
        }
    }
    ///<summary>
    ///Describes the file that is being processed for the ProcessFileEvent.
    ///</summary>
    public class
    DefaultImageEventArgs : EventArgs {
        ///<summary>
        ///Default constructor.
        ///</summary>
        public
        DefaultImageEventArgs(
            IntPtr wideParameter, 
            IntPtr leftParameter, 
            IntPtr userData) {
            
            WideParameter = wideParameter;
            LeftParameter = leftParameter;
            UserData      = userData;
        }
        ///<summary>
        ///wParam
        ///</summary>
        public IntPtr WideParameter {
            get;
            private set;
        }
        ///<summary>
        ///lParam
        ///</summary>
        public IntPtr LeftParameter {
            get;
            private set;
        }
        ///<summary>
        ///UserData
        ///</summary>
        public IntPtr UserData {
            get;
            private set;
        }
    }
    ///<summary>
    ///Describes the file that is being processed for the ProcessFileEvent.
    ///</summary>
    public class
    ProcessFileEventArgs : EventArgs {
        ///<summary>
        ///Default constructor.
        ///</summary>
        ///<param name="file">Fully qualified path and file name. For example: c:\file.sys.</param>
        ///<param name="skipFileFlag">Default is false - skip file and continue.
        ///Set to true to abort the entire image capture.</param>
        public
        ProcessFileEventArgs(
            string file, 
            IntPtr skipFileFlag) {
            m_FilePath = file;
            m_SkipFileFlag = skipFileFlag;
        }
        ///<summary>
        ///Skip file from being imaged.
        ///</summary>
        public void
        SkipFile() {
            byte[] byteBuffer = {
                    0
            };
            int byteBufferSize = byteBuffer.Length;
            Marshal.Copy(byteBuffer, 0, m_SkipFileFlag, byteBufferSize);
        }
        ///<summary>
        ///Fully qualified path and file name.
        ///</summary>
        public string 
        FilePath {
            get {
                string stringToReturn = "";
                if (m_FilePath != null) {
                    stringToReturn = m_FilePath;
                }
                return stringToReturn;
            }
        }
        ///<summary>
        ///Flag to indicate if the entire image capture should be aborted.
        ///Default is false - skip file and continue. Setting to true will
        ///abort the entire image capture.
        ///</summary>
        public bool Abort {
            set { m_Abort = value; }
            get { return m_Abort;  }
        }
        private string m_FilePath;
        private bool m_Abort;
        private IntPtr m_SkipFileFlag;
    }
    #endregion WIM Interop
    #region VHD Interop
    // Based on code written by the Hyper-V Test team.
    /// <summary>
    /// The Virtual Hard Disk class provides methods for creating and manipulating Virtual Hard Disk files.
    /// </summary>
    public class
    VirtualHardDisk : IDisposable {
        #region Member Variables
        private SafeFileHandle m_virtualHardDiskHandle = null;
        private string m_filePath = null;
        private bool m_isDisposed;
        private NativeMethods.VirtualStorageDeviceType m_deviceType = NativeMethods.VirtualStorageDeviceType.Unknown;
        #endregion Member Variables
        #region IDisposable Members
        /// <summary>
        /// Disposal method for Virtual Hard Disk objects.
        /// </summary>
        public void
        Dispose() {
            this.Dispose(true);
            GC.SuppressFinalize(this);
        }
        /// <summary>
        /// Disposal method for Virtual Hard Disk objects.
        /// </summary>
        /// <param name="disposing"></param>
        public void
        Dispose(
            bool disposing) {
            // Check to see if Dispose has already been called.
            if (!this.m_isDisposed) {
                // If disposing equals true, dispose all managed
                // and unmanaged resources.
                if (disposing) {
                    // Dispose managed resources.
                    if (this.DiskIndex != 0) {
                        this.Close();
                    }
                }
                // Call the appropriate methods to clean up
                // unmanaged resources here.
                // If disposing is false,
                // only the following code is executed.
                // Note disposing has been done.
                m_isDisposed = true;
            }
        }
        #endregion IDisposable Members
        #region Constructor
        private VirtualHardDisk(
            SafeFileHandle Handle,
            string Path,
            NativeMethods.VirtualStorageDeviceType DeviceType) {
            if (Handle.IsInvalid || Handle.IsClosed) {
                throw new InvalidOperationException("The handle to the Virtual Hard Disk is invalid.");
            }
            m_virtualHardDiskHandle = Handle;
            m_filePath = Path;
            m_deviceType = DeviceType;
        }
        #endregion Constructor
        #region Gozer the Destructor
        /// <summary>
        /// Destroys a VHD object.
        /// </summary>
        ~VirtualHardDisk() {
            this.Dispose(false);
        }
        #endregion Gozer the Destructor
        #region Static Methods
        #region Sparse Disks
        /// <summary>
        /// Abbreviated signature of CreateSparseDisk so it's easier to use from WIM2VHD.
        /// </summary>
        /// <param name="virtualStorageDeviceType">The type of disk to create, VHD or VHDX.</param>
        /// <param name="path">The path of the disk to create.</param>
        /// <param name="size">The maximum size of the disk to create.</param>
        /// <param name="overwrite">Overwrite the VHD if it already exists.</param>
        /// <returns>Virtual Hard Disk object</returns>
        public static VirtualHardDisk
        CreateSparseDisk(
            NativeMethods.VirtualStorageDeviceType virtualStorageDeviceType,
            string path,
            ulong size,
            bool overwrite) {
            return CreateSparseDisk(
                path,
                size,
                overwrite,
                null,
                IntPtr.Zero,
                (virtualStorageDeviceType == NativeMethods.VirtualStorageDeviceType.VHD) 
                    ? NativeMethods.DEFAULT_BLOCK_SIZE
                    : 0,
                virtualStorageDeviceType,
                NativeMethods.DISK_SECTOR_SIZE);
        }
        /// <summary>
        /// Creates a new sparse (dynamically expanding) virtual hard disk (.vhd). Supports both sync and async modes.
        /// The VHD image file uses only as much space on the backing store as needed to store the actual data the VHD currently contains. 
        /// </summary>
        /// <param name="path">The path and name of the VHD to create.</param>
        /// <param name="size">The size of the VHD to create in bytes.  
        /// When creating this type of VHD, the VHD API does not test for free space on the physical backing store based on the maximum size requested, 
        /// therefore it is possible to successfully create a dynamic VHD with a maximum size larger than the available physical disk free space.
        /// The maximum size of a dynamic VHD is 2,040 GB.  The minimum size is 3 MB.</param>
        /// <param name="source">Optional path to pre-populate the new virtual disk object with block data from an existing disk
        /// This path may refer to a VHD or a physical disk.  Use NULL if you don't want a source.</param>
        /// <param name="overwrite">If the VHD exists, setting this parameter to 'True' will delete it and create a new one.</param>
        /// <param name="overlapped">If not null, the operation runs in async mode</param>
        /// <param name="blockSizeInBytes">Block size for the VHD.</param>
        /// <param name="virtualStorageDeviceType">VHD format version (VHD1 or VHD2)</param>
        /// <param name="sectorSizeInBytes">Sector size for the VHD.</param>
        /// <returns>Returns a SafeFileHandle corresponding to the virtual hard disk that was created.</returns>
        /// <exception cref="ArgumentOutOfRangeException">Thrown when an invalid size is specified</exception>
        /// <exception cref="FileNotFoundException">Thrown when source VHD is not found.</exception>
        /// <exception cref="SecurityException">Thrown when there was an error while creating the default security descriptor.</exception>
        /// <exception cref="Win32Exception">Thrown when an error occurred while creating the VHD.</exception>
        public static VirtualHardDisk
        CreateSparseDisk(
            string path,
            ulong size,
            bool overwrite,
            string source,
            IntPtr overlapped,
            uint blockSizeInBytes,
            NativeMethods.VirtualStorageDeviceType virtualStorageDeviceType,
            uint sectorSizeInBytes) {
            // Validate the virtualStorageDeviceType
            if (virtualStorageDeviceType != NativeMethods.VirtualStorageDeviceType.VHD && virtualStorageDeviceType != NativeMethods.VirtualStorageDeviceType.VHDX) {
                throw (
                    new ArgumentOutOfRangeException(
                        "virtualStorageDeviceType",
                        virtualStorageDeviceType,
                        "VirtualStorageDeviceType must be VHD or VHDX."
                ));
            }
            // Validate size.  It needs to be a multiple of DISK_SECTOR_SIZE (512)...
            if ((size % NativeMethods.DISK_SECTOR_SIZE) != 0) {
                throw (
                    new ArgumentOutOfRangeException(
                        "size", 
                        size, 
                        "The size of the virtual disk must be a multiple of 512."
                ));
            }
            if ((!String.IsNullOrEmpty(source)) && (!System.IO.File.Exists(source))) {
                throw (
                    new System.IO.FileNotFoundException(
                        "Unable to find the source file.",
                        source
                ));
            }
            if ((overwrite) && (System.IO.File.Exists(path))) {
                System.IO.File.Delete(path);
            }
            NativeMethods.CreateVirtualDiskParameters createParams = new NativeMethods.CreateVirtualDiskParameters();
            // Select the correct version.
            createParams.Version = (virtualStorageDeviceType == NativeMethods.VirtualStorageDeviceType.VHD)
                ? NativeMethods.CreateVirtualDiskVersion.Version1
                : NativeMethods.CreateVirtualDiskVersion.Version2;
            createParams.UniqueId                 = Guid.NewGuid();
            createParams.MaximumSize              = size;
            createParams.BlockSizeInBytes         = blockSizeInBytes;
            createParams.SectorSizeInBytes        = sectorSizeInBytes;
            createParams.ParentPath               = null;
            createParams.SourcePath               = source;
            createParams.OpenFlags                = NativeMethods.OpenVirtualDiskFlags.None;
            createParams.GetInfoOnly              = false;
            createParams.ParentVirtualStorageType = new NativeMethods.VirtualStorageType();
            createParams.SourceVirtualStorageType = new NativeMethods.VirtualStorageType();
            //
            // Create and init a security descriptor.
            // Since we're creating an essentially blank SD to use with CreateVirtualDisk
            // the VHD will take on the security values from the parent directory.
            //
            NativeMethods.SecurityDescriptor securityDescriptor;
            if (!NativeMethods.InitializeSecurityDescriptor(out securityDescriptor, 1)) {
                throw (
                    new SecurityException(
                        "Unable to initialize the security descriptor for the virtual disk."
                ));
            }
            NativeMethods.VirtualStorageType virtualStorageType = new NativeMethods.VirtualStorageType();
            virtualStorageType.DeviceId = virtualStorageDeviceType;
            virtualStorageType.VendorId = NativeMethods.VirtualStorageTypeVendorMicrosoft;
            SafeFileHandle vhdHandle;
            uint returnCode = NativeMethods.CreateVirtualDisk(
                ref virtualStorageType,
                    path,
                    (virtualStorageDeviceType == NativeMethods.VirtualStorageDeviceType.VHD)
                        ? NativeMethods.VirtualDiskAccessMask.All
                        : NativeMethods.VirtualDiskAccessMask.None,
                ref securityDescriptor,
                    NativeMethods.CreateVirtualDiskFlags.None,
                    0,
                ref createParams,
                    overlapped,
                out vhdHandle);
            if (NativeMethods.ERROR_SUCCESS != returnCode && NativeMethods.ERROR_IO_PENDING != returnCode) {
                throw (
                    new Win32Exception(
                        (int)returnCode
                ));
            }
            return new VirtualHardDisk(vhdHandle, path, virtualStorageDeviceType);
        }
        #endregion Sparse Disks
        #region Fixed Disks
        /// <summary>
        /// Abbreviated signature of CreateFixedDisk so it's easier to use from WIM2VHD.
        /// </summary>
        /// <param name="virtualStorageDeviceType">The type of disk to create, VHD or VHDX.</param>
        /// <param name="path">The path of the disk to create.</param>
        /// <param name="size">The maximum size of the disk to create.</param>
        /// <param name="overwrite">Overwrite the VHD if it already exists.</param>
        /// <returns>Virtual Hard Disk object</returns>
        public static VirtualHardDisk
        CreateFixedDisk(
            NativeMethods.VirtualStorageDeviceType virtualStorageDeviceType,
            string path,
            ulong size,
            bool overwrite) {
            return CreateFixedDisk(
                path,
                size,
                overwrite,
                null,
                IntPtr.Zero,
                0,
                virtualStorageDeviceType,
                NativeMethods.DISK_SECTOR_SIZE);
        }
        /// <summary>
        /// Creates a fixed-size Virtual Hard Disk. Supports both sync and async modes. This methods always calls the V2 version of the 
        /// CreateVirtualDisk API, and creates VHD2. 
        /// </summary>
        /// <param name="path">The path and name of the VHD to create.</param>
        /// <param name="size">The size of the VHD to create in bytes.  
        /// The VHD image file is pre-allocated on the backing store for the maximum size requested.
        /// The maximum size of a dynamic VHD is 2,040 GB.  The minimum size is 3 MB.</param>
        /// <param name="source">Optional path to pre-populate the new virtual disk object with block data from an existing disk
        /// This path may refer to a VHD or a physical disk.  Use NULL if you don't want a source.</param>
        /// <param name="overwrite">If the VHD exists, setting this parameter to 'True' will delete it and create a new one.</param>
        /// <param name="overlapped">If not null, the operation runs in async mode</param>
        /// <param name="blockSizeInBytes">Block size for the VHD.</param>
        /// <param name="virtualStorageDeviceType">Virtual storage device type: VHD1 or VHD2.</param>
        /// <param name="sectorSizeInBytes">Sector size for the VHD.</param>
        /// <returns>Returns a SafeFileHandle corresponding to the virtual hard disk that was created.</returns>
        /// <remarks>Creating a fixed disk can be a time consuming process!</remarks>  
        /// <exception cref="ArgumentOutOfRangeException">Thrown when an invalid size or wrong virtual storage device type is specified.</exception>
        /// <exception cref="FileNotFoundException">Thrown when source VHD is not found.</exception>
        /// <exception cref="SecurityException">Thrown when there was an error while creating the default security descriptor.</exception>
        /// <exception cref="Win32Exception">Thrown when an error occurred while creating the VHD.</exception>
        public static VirtualHardDisk
        CreateFixedDisk(
            string path,
            ulong size,
            bool overwrite,
            string source,
            IntPtr overlapped,
            uint blockSizeInBytes,
            NativeMethods.VirtualStorageDeviceType virtualStorageDeviceType,
            uint sectorSizeInBytes) {
            // Validate the virtualStorageDeviceType
            if (virtualStorageDeviceType != NativeMethods.VirtualStorageDeviceType.VHD && virtualStorageDeviceType != NativeMethods.VirtualStorageDeviceType.VHDX) {
                throw (
                    new ArgumentOutOfRangeException(
                        "virtualStorageDeviceType",
                        virtualStorageDeviceType,
                        "VirtualStorageDeviceType must be VHD or VHDX."
                ));
            }
            // Validate size.  It needs to be a multiple of DISK_SECTOR_SIZE (512)...
            if ((size % NativeMethods.DISK_SECTOR_SIZE) != 0) {
                throw (
                    new ArgumentOutOfRangeException(
                        "size",
                        size,
                        "The size of the virtual disk must be a multiple of 512."
                ));
            }
            if ((!String.IsNullOrEmpty(source)) && (!System.IO.File.Exists(source))) {
                throw (
                    new System.IO.FileNotFoundException(
                        "Unable to find the source file.",
                        source
                ));
            }
            if ((overwrite) && (System.IO.File.Exists(path))) {
                System.IO.File.Delete(path);
            }
            NativeMethods.CreateVirtualDiskParameters createParams = new NativeMethods.CreateVirtualDiskParameters();
            // Select the correct version.
            createParams.Version = (virtualStorageDeviceType == NativeMethods.VirtualStorageDeviceType.VHD)
                ? NativeMethods.CreateVirtualDiskVersion.Version1
                : NativeMethods.CreateVirtualDiskVersion.Version2;
            createParams.UniqueId                 = Guid.NewGuid();
            createParams.MaximumSize              = size;
            createParams.BlockSizeInBytes         = blockSizeInBytes;
            createParams.SectorSizeInBytes        = sectorSizeInBytes;
            createParams.ParentPath               = null;
            createParams.SourcePath               = source;
            createParams.OpenFlags                = NativeMethods.OpenVirtualDiskFlags.None;
            createParams.GetInfoOnly              = false;
            createParams.ParentVirtualStorageType = new NativeMethods.VirtualStorageType();
            createParams.SourceVirtualStorageType = new NativeMethods.VirtualStorageType();
            //
            // Create and init a security descriptor.
            // Since we're creating an essentially blank SD to use with CreateVirtualDisk
            // the VHD will take on the security values from the parent directory.
            //
            NativeMethods.SecurityDescriptor securityDescriptor;
            if (!NativeMethods.InitializeSecurityDescriptor(out securityDescriptor, 1)) {
                throw (
                    new SecurityException(
                        "Unable to initialize the security descriptor for the virtual disk."
                ));
            }
            NativeMethods.VirtualStorageType virtualStorageType = new NativeMethods.VirtualStorageType();
            virtualStorageType.DeviceId = virtualStorageDeviceType;
            virtualStorageType.VendorId = NativeMethods.VirtualStorageTypeVendorMicrosoft;
            SafeFileHandle vhdHandle;
            uint returnCode = NativeMethods.CreateVirtualDisk(
                ref virtualStorageType,
                    path,
                    (virtualStorageDeviceType == NativeMethods.VirtualStorageDeviceType.VHD)
                        ? NativeMethods.VirtualDiskAccessMask.All
                        : NativeMethods.VirtualDiskAccessMask.None,
                ref securityDescriptor,
                    NativeMethods.CreateVirtualDiskFlags.FullPhysicalAllocation,
                    0,
                ref createParams,
                    overlapped,
                out vhdHandle);
            if (NativeMethods.ERROR_SUCCESS != returnCode && NativeMethods.ERROR_IO_PENDING != returnCode) {
                throw (
                    new Win32Exception(
                        (int)returnCode
                ));
            }
            return new VirtualHardDisk(vhdHandle, path, virtualStorageDeviceType);
        }
        #endregion Fixed Disks
        #region Open
        /// <summary>
        /// Opens a virtual hard disk (VHD) using the V2 of OpenVirtualDisk Win32 API for use, allowing you to explicitly specify OpenVirtualDiskFlags, 
        /// Read/Write depth, and Access Mask information.
        /// </summary>
        /// <param name="path">The path and name of the Virtual Hard Disk file to open.</param>
        /// <param name="accessMask">Contains the bit mask for specifying access rights to a virtual hard disk (VHD).  Default is All.</param>
        /// <param name="readWriteDepth">Indicates the number of stores, beginning with the child, of the backing store chain to open as read/write. 
        /// The remaining stores in the differencing chain will be opened read-only. This is necessary for merge operations to succeed.  Default is 0x1.</param>
        /// <param name="flags">An OpenVirtualDiskFlags object to modify the way the Virtual Hard Disk is opened.  Default is Unknown.</param>
        /// <param name="virtualStorageDeviceType">VHD Format Version (VHD1 or VHD2)</param>
        /// <returns>VirtualHardDisk object</returns>
        /// <exception cref="FileNotFoundException">Thrown if the VHD at path is not found.</exception>
        /// <exception cref="Win32Exception">Thrown if an error occurred while opening the VHD.</exception>
        public static VirtualHardDisk
        Open(
            string path,
            NativeMethods.VirtualDiskAccessMask accessMask,
            uint readWriteDepth,
            NativeMethods.OpenVirtualDiskFlags flags,
            NativeMethods.VirtualStorageDeviceType virtualStorageDeviceType) {
            if (!File.Exists(path)) {
                throw new FileNotFoundException("The specified VHD was not found.  Please check your path and try again.", path);
            }
            NativeMethods.OpenVirtualDiskParameters openParams = new NativeMethods.OpenVirtualDiskParameters();
            // Select the correct version.
            openParams.Version = (virtualStorageDeviceType == NativeMethods.VirtualStorageDeviceType.VHD)
                ? NativeMethods.OpenVirtualDiskVersion.Version1
                : NativeMethods.OpenVirtualDiskVersion.Version2;
            openParams.GetInfoOnly = false;
            NativeMethods.VirtualStorageType virtualStorageType = new NativeMethods.VirtualStorageType();
            virtualStorageType.DeviceId = virtualStorageDeviceType;
            virtualStorageType.VendorId = (virtualStorageDeviceType == NativeMethods.VirtualStorageDeviceType.Unknown)
                ? virtualStorageType.VendorId = NativeMethods.VirtualStorageTypeVendorUnknown
                : virtualStorageType.VendorId = NativeMethods.VirtualStorageTypeVendorMicrosoft;
            SafeFileHandle vhdHandle;
            uint returnCode = NativeMethods.OpenVirtualDisk(
                ref virtualStorageType,
                    path,
                    accessMask,
                    flags,
                ref openParams,
                out vhdHandle);
            if (NativeMethods.ERROR_SUCCESS != returnCode) {
                throw new Win32Exception((int)returnCode);
            }
            return new VirtualHardDisk(vhdHandle, path, virtualStorageDeviceType);
        }
        #endregion Open
        #region Other
        /// <summary>
        /// Retrieves a collection of drive letters that are currently available on the system.
        /// </summary>
        /// <remarks>Drives A and B are not included in the collection, even if they are available.</remarks>
        /// <returns>A collection of drive letters that are currently available on the system.</returns>
        public static ReadOnlyCollection<Char>
        GetAvailableDriveLetters() {
            List<Char> availableDrives = new List<Char>();
            for (int i = (byte)'C'; i <= (byte)'Z'; i++) {
                availableDrives.Add((char)i);
            }
            foreach (string drive in System.Environment.GetLogicalDrives()) {
                availableDrives.Remove(drive.ToUpper(CultureInfo.InvariantCulture)[0]);
            }
            return new ReadOnlyCollection<char>(availableDrives);
        }
        /// <summary>
        /// Gets the first available drive letter on the current system.
        /// </summary>
        /// <remarks>Drives A and B will not be returned, even if they are available.</remarks>
        /// <returns>Char representing the first available drive letter.</returns>
        public static char
        GetFirstAvailableDriveLetter() {
            return GetAvailableDriveLetters()[0];
        }
        #endregion Other
        #endregion Static Methods
        #region AsyncHelpers
        /// <summary>
        /// Creates a NativeOverlapped object, initializes its EventHandle property, and pins the object to the memory.
        /// This overlapped objects are useful when executing VHD meta-ops in async mode.
        /// </summary>
        /// <returns>Returns the GCHandle for the pinned overlapped structure</returns>
        public static GCHandle
        CreatePinnedOverlappedObject() {
            NativeOverlapped overlapped = new NativeOverlapped();
            overlapped.EventHandle = NativeMethods.CreateEvent(IntPtr.Zero, true, false, null);
            GCHandle handleForOverllapped = GCHandle.Alloc(overlapped, GCHandleType.Pinned);
            return handleForOverllapped;
        }
        /// <summary>
        /// GetVirtualDiskOperationProgress API allows getting progress info for the async virtual disk operations (ie. Online Mirror)
        /// </summary>
        /// <param name="progress"></param>
        /// <param name="overlapped"></param>
        /// <returns></returns>
        /// <exception cref="Win32Exception">Thrown when an error occurred while mirroring the VHD.</exception>
        public uint
        GetVirtualDiskOperationProgress(
            ref NativeMethods.VirtualDiskProgress progress,
                IntPtr overlapped) {
            uint returnCode = NativeMethods.GetVirtualDiskOperationProgress(
                    this.m_virtualHardDiskHandle,
                    overlapped,
                ref progress);
            return returnCode;
        }
        #endregion AsyncHelpers
        #region Public Methods
        /// <summary>
        /// Closes all open handles to the Virtual Hard Disk object.
        /// If the VHD is currently attached, and the PermanentLifetime was not specified, this operation will detach it.
        /// </summary>
        public void
        Close() {
            m_virtualHardDiskHandle.Close();
        }
        /// <summary>
        /// Attaches a virtual hard disk (VHD) by locating an appropriate VHD provider to accomplish the attachment.
        /// </summary>
        /// <param name="attachVirtualDiskFlags">
        /// A combination of values from the attachVirtualDiskFlags enumeration which will dictate how the behavior of the VHD once mounted.
        /// </param>
        /// <exception cref="Win32Exception">Thrown when an error occurred while attaching the VHD.</exception>
        /// <exception cref="SecurityException">Thrown when an error occurred while creating the default security descriptor.</exception>
        public void
        Attach(
            NativeMethods.AttachVirtualDiskFlags attachVirtualDiskFlags) {
            if (!this.IsAttached) {
                // Get the current disk index.  We need it later.
                int diskIndex = this.DiskIndex;
                NativeMethods.AttachVirtualDiskParameters attachParameters = new NativeMethods.AttachVirtualDiskParameters();
                // For attach, the correct version is always Version1 for Win7 and Win8.
                attachParameters.Version = NativeMethods.AttachVirtualDiskVersion.Version1;
                attachParameters.Reserved = 0;
                NativeMethods.SecurityDescriptor securityDescriptor;
                if (!NativeMethods.InitializeSecurityDescriptor(out securityDescriptor, 1)) {
                    throw (new SecurityException("Unable to initialize the security descriptor for the virtual disk."));
                }
                uint returnCode = NativeMethods.AttachVirtualDisk(
                         m_virtualHardDiskHandle,
                    ref  securityDescriptor,
                         attachVirtualDiskFlags,
                         0,
                    ref  attachParameters,
                         IntPtr.Zero);
                switch (returnCode) {
                    case NativeMethods.ERROR_SUCCESS:
                        break;
                    default:
                        throw new Win32Exception((int)returnCode);
                }
                // There's apparently a bit of a timing issue here on some systems.
                // If the disk index isn't updated, keep checking once per second for five seconds.
                // If it's not updated after that, it's probably not our fault.
                short attempts = 5;
                while ((attempts-- >= 0) && (diskIndex == this.DiskIndex)) {
                    System.Threading.Thread.Sleep(1000);
                }
            }
        }
        /// <summary>
        /// Attaches a virtual hard disk (VHD) by locating an appropriate VHD provider to accomplish the attachment.
        /// </summary>
        /// <remarks>
        /// This method attaches the VHD with no flags.
        /// </remarks>
        /// <exception cref="Win32Exception">Thrown when an error occurred while attaching the VHD.</exception>
        /// <exception cref="SecurityException">Thrown when an error occurred while creating the default security descriptor.</exception>
        public void
        Attach() {
            this.Attach(NativeMethods.AttachVirtualDiskFlags.None);
        }
        /// <summary>
        /// Unsurfaces (detaches) a virtual hard disk (VHD) by locating an appropriate VHD provider to accomplish the operation.
        /// </summary>
        public void
        Detach() {
            if (this.IsAttached) {
                uint returnCode = NativeMethods.DetachVirtualDisk(
                    m_virtualHardDiskHandle,
                    NativeMethods.DetachVirtualDiskFlag.None,
                    0);
                switch (returnCode) {
                    case NativeMethods.ERROR_NOT_FOUND:
                    // There's nothing to do here.  The device wasn't found, which means there's a 
                    // really good chance that it wasn't attached to begin with.
                    // And, since we were asked to detach it anyway, we can assume that the system
                    // is already in the desired state.
                    case NativeMethods.ERROR_SUCCESS:
                        break;
                    default:
                        throw new Win32Exception((int)returnCode);
                }
            }
        }
        /// <summary>
        /// Reduces the size of the virtual hard disk (VHD) backing store file. Supports both sync and async modes.
        /// </summary>
        /// <param name="overlapped">If not null, the operation runs in async mode</param>
        public uint
        Compact(IntPtr overlapped) {
            return this.Compact(
                overlapped,
                NativeMethods.CompactVirtualDiskFlags.None);
        }
        /// <summary>
        /// Reduces the size of the virtual hard disk (VHD) backing store file. Supports both sync and async modes.
        /// </summary>
        /// <param name="overlapped">If not null, the operation runs in async mode</param>
        /// <param name="flags">Flags for Compact operation</param>
        public uint
        Compact(
            IntPtr overlapped,
            NativeMethods.CompactVirtualDiskFlags flags) {
            NativeMethods.CompactVirtualDiskParameters compactParams = new NativeMethods.CompactVirtualDiskParameters();
            compactParams.Version = NativeMethods.CompactVirtualDiskVersion.Version1;
            uint returnCode = NativeMethods.CompactVirtualDisk(
                m_virtualHardDiskHandle,
                flags,
            ref compactParams,
                overlapped);
            if ((overlapped == IntPtr.Zero && NativeMethods.ERROR_SUCCESS != returnCode) ||
                (overlapped != IntPtr.Zero && NativeMethods.ERROR_IO_PENDING != returnCode)) {
                throw new Win32Exception((int)returnCode);
            }
            return returnCode;
        }
        #endregion Public Methods
        #region Public Properties
        /// <summary>
        /// The SafeFileHandle object for the opened VHD.
        /// </summary>
        public SafeFileHandle
        VirtualHardDiskHandle {
            get {
                return m_virtualHardDiskHandle;
            }
        }
        /// <summary>
        /// Indicates the index of the disk when attached.
        /// If the virtual hard disk is not currently attached, -1 will be returned.
        /// </summary>
        public int
        DiskIndex {
            get {
                string path = PhysicalPath;
                if (null != path) {
                    Match match = Regex.Match(path, @"\d+$"); // look for the last digits in the path
                    return System.Convert.ToInt32(match.Value, CultureInfo.InvariantCulture);
                } else {
                    return -1;
                }
            }
        }
        /// <summary>
        /// Indicates whether the current Virtual Hard Disk is attached to the system.
        /// </summary>
        public bool
        IsAttached {
            get {
                return (this.DiskIndex != -1);
            }
        }
        /// <summary>
        /// Retrieves the path to the physical device object that contains a virtual hard disk (VHD), if the VHD is attached.
        /// If it is not attached, NULL will be returned.
        /// </summary>
        public string
        PhysicalPath {
            get {
                uint pathSize = 1024;  // Isn't MAX_PATH 255?
                StringBuilder path = new StringBuilder((int)pathSize);
                uint returnCode = 0;
                returnCode = NativeMethods.GetVirtualDiskPhysicalPath(
                        m_virtualHardDiskHandle,
                    ref pathSize,
                        path);
                if (NativeMethods.ERROR_ERROR_DEV_NOT_EXIST == returnCode) {
                    return null;
                } else if (NativeMethods.ERROR_SUCCESS == returnCode) {
                    return path.ToString();
                } else {
                    throw new Win32Exception((int)returnCode);
                }
            }
        }
        #endregion Public Properties
    }
    #endregion VHD Interop
#region Helper Functions
##########################################################################################
#                                   Helper Functions
##########################################################################################
    Functions to mount and dismount registry hives.
    These hives will automatically be accessible via the HKLM:\ registry PSDrive.
    It should be noted that I have more confidence in using the RegLoadKey and
    RegUnloadKey Win32 APIs than I do using REG.EXE - it just seems like we should
    do things ourselves if we can, instead of using yet another binary. 
    Consider this a TODO for future versions.
Function Mount-RegistryHive {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true, Position = 0)]
        [System.IO.FileInfo]
        [ValidateNotNullOrEmpty()]
        [ValidateScript({ $_.Exists })]
        $Hive
    )
    $mountKey = [System.Guid]::NewGuid().ToString()
    $regPath  = "REG.EXE"
    if (Test-Path HKLM:\$mountKey) {
        throw "The registry path already exists.  I should just regenerate it, but I'm lazy."
    }
    $regArgs = (
        "LOAD",
        "HKLM\$mountKey",
        $Hive.Fullname
    )
    try {
        Run-Executable -Executable $regPath -Arguments $regArgs
    } catch {
        throw
    }
    # Set a global variable containing the name of the mounted registry key
    # so we can unmount it if there's an error.
    $global:mountedHive = $mountKey
    return $mountKey
##########################################################################################
Function Dismount-RegistryHive {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true, Position = 0)]
        [string]
        [ValidateNotNullOrEmpty()]
        $HiveMountPoint
    )
    $regPath = "REG.EXE"
    $regArgs = (
        "UNLOAD",
        "HKLM\$($HiveMountPoint)"
    )
    Run-Executable -Executable $regPath -Arguments $regArgs
    $global:mountedHive = $null
##########################################################################################
Function 
Apply-BCDStoreChanges {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [string]
        [ValidateNotNullOrEmpty()]
        $BcdStoreFile,
        [Parameter()]
        [string]
        [ValidateNotNullOrEmpty()]
        [ValidateScript({ ($_ -eq $PARTITION_STYLE_MBR) -or ($_ -eq $PARTITION_STYLE_GPT) })]
        $PartitionStyle = $PARTITION_STYLE_MBR,
        [Parameter()]
        [UInt64]
        [ValidateScript({ $_ -ge 0 })]
        $DiskSignature,
        [Parameter()]
        [UInt64]
        [ValidateScript({ $_ -ge 0 })]
        $PartitionOffset
    )
    #########  Set Constants #########
    $BOOTMGR_ID              = "{9DEA862C-5CDD-4E70-ACC1-F32B344D4795}"
    $DEFAULT_TYPE            = 0x23000003
    $APPLICATION_DEVICE_TYPE = 0x11000001
    $OS_DEVICE_TYPE          = 0x21000001
    ##################################
    Write-W2VInfo "Opening $($BcdStoreFile) for configuration..."
    Write-W2VTrace "Partition Style : $PartitionStyle"
    Write-W2VTrace "Disk Signature  : $DiskSignature"
    Write-W2VTrace "Partition Offset: $PartitionOffset"
    $conn    = New-Object Management.ConnectionOptions
    $scope   = New-Object Management.ManagementScope -ArgumentList "\\.\ROOT\WMI", $conn
    $scope.Connect()
    $path    = New-Object Management.ManagementPath `
               -ArgumentList "\\.\ROOT\WMI:BCDObject.Id=`"$($BOOTMGR_ID)`",StoreFilePath=`"$($BcdStoreFile.Replace('\', '\\'))`""
    $options = New-Object Management.ObjectGetOptions
    $bootMgr = New-Object Management.ManagementObject -ArgumentList $scope, $path, $options
    try {
        $bootMgr.Get()
    } catch {
        throw "Could not get the BootMgr object from the VHD's BCDStore."
    }
    Write-W2VTrace "Setting Qualified Partition Device Element for VHD boot..."
    $ret = $bootMgr.SetQualifiedPartitionDeviceElement($APPLICATION_DEVICE_TYPE, $PartitionStyle, $DiskSignature, $PartitionOffset)
    if (!$ret.ReturnValue) {
        throw "Unable to set Qualified Partition Device Element in VHD's BCDStore."
    }
    Write-W2VTrace "Getting the default boot entry..."
    $defaultBootEntryId = ($bootMgr.GetElement($DEFAULT_TYPE)).Element.Id
    Write-W2VTrace "Getting the OS Loader..."
    $path    = New-Object Management.ManagementPath `
             -ArgumentList "\\.\ROOT\WMI:BCDObject.Id=`"$($defaultBootEntryId)`",StoreFilePath=`"$($BcdStoreFile.Replace('\', '\\'))`""
    $osLoader= New-Object Management.ManagementObject -ArgumentList $scope, $path, $options
    try {
        $osLoader.Get()
    } catch {
        throw "Could not get the OS Loader..."
    }
    Write-W2VTrace "Setting Qualified Partition Device Element in the OS Loader Application..."
    $ret = $osLoader.SetQualifiedPartitionDeviceElement($APPLICATION_DEVICE_TYPE, $PartitionStyle, $DiskSignature, $PartitionOffset)
    if (!$ret.ReturnValue) {
        throw "Could not set Qualified Partition Device Element in the OS Loader Application."
    }
    Write-W2VTrace "Setting Qualified Partition Device Element in the OS Loader Device..."
    $ret = $osLoader.SetQualifiedPartitionDeviceElement($OS_DEVICE_TYPE, $PartitionStyle, $DiskSignature, $PartitionOffset)
    if (!$ret.ReturnValue) {
        throw "Could not set Qualified Partition Device Element in the OS Loader Device."
    }
    Write-W2VInfo "BCD configuration complete. Moving on..."
##########################################################################################
function 
Test-Admin {
    <#
        .SYNOPSIS
            Short function to determine whether the logged-on user is an administrator.
        .EXAMPLE
            Do you honestly need one?  There are no parameters!
        .OUTPUTS
            $true if user is admin.
            $false if user is not an admin.
    #>
    [CmdletBinding()]
    param()
    $currentUser = New-Object Security.Principal.WindowsPrincipal $([Security.Principal.WindowsIdentity]::GetCurrent())
    $isAdmin = $currentUser.IsInRole([Security.Principal.WindowsBuiltinRole]::Administrator)
    Write-W2VTrace "isUserAdmin? $isAdmin"
    return $isAdmin
##########################################################################################
function
Write-W2VInfo {
# Function to make the # Write-Host output a bit prettier. 
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true)]
        [string]
        [ValidateNotNullOrEmpty()]
        $text
    )
    Write-Verbose "INFO   : $($text)"
##########################################################################################
function
Write-W2VTrace {
# Function to make the Write-Verbose output... well... exactly the same as it was before.
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true)]
        [string]
        [ValidateNotNullOrEmpty()]
        $text
    )
    Write-Verbose $text
##########################################################################################
function
Write-W2VError {
# Function to make the # Write-Host (NOT Write-Error) output prettier in the case of an error.
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true)]
        [string]
        [ValidateNotNullOrEmpty()]
        $text
    )
    Write-Verbose "ERROR  : $($text)"
##########################################################################################
function
Write-W2VWarn {
# Function to make the # Write-Host (NOT Write-Warning) output prettier.
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true)]
        [string]
        [ValidateNotNullOrEmpty()]
        $text
    )
    Write-Verbose "WARN   : $($text)"
##########################################################################################
function
Run-Executable {
    <#
        .SYNOPSIS
            Runs an external executable file, and validates the error level.
        .PARAMETER Executable
            The path to the executable to run and monitor.
        .PARAMETER Arguments
            An array of arguments to pass to the executable when it's executed.
        .PARAMETER SuccessfulErrorCode
            The error code that means the executable ran successfully.
            The default value is 0.  
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$true)]
        [string]
        [ValidateNotNullOrEmpty()]
        $Executable,
        [Parameter(Mandatory=$true)]
        [string[]]
        [ValidateNotNullOrEmpty()]
        $Arguments,
        [Parameter()]
        [int]
        [ValidateNotNullOrEmpty()]
        $SuccessfulErrorCode = 0
    )
    Write-W2VTrace "Running $Executable $Arguments"
    $ret = Start-Process           `
        -FilePath $Executable      `
        -ArgumentList $Arguments   `
        -WindowStyle Hidden        `
        -Wait                      `
        -RedirectStandardOutput "$($env:temp)\$($scriptName)\$($sessionKey)\$($Executable)-StandardOutput.txt" `
        -RedirectStandardError  "$($env:temp)\$($scriptName)\$($sessionKey)\$($Executable)-StandardError.txt"  `
        -Passthru
    Write-W2VTrace "Return code was $($ret.ExitCode)."
    if ($ret.ExitCode -ne $SuccessfulErrorCode) {
        throw "$Executable failed with code $($ret.ExitCode)!"
    }
##########################################################################################
Function Test-IsNetworkLocation {
    <#
        .SYNOPSIS
            Determines whether or not a given path is a network location or a local drive.
            
        .DESCRIPTION
            Function to determine whether or not a specified path is a local path, a UNC path,
            or a mapped network drive.
        .PARAMETER Path
            The path that we need to figure stuff out about,
    #>
    [CmdletBinding()]
    param(
        [Parameter(ValueFromPipeLine = $true)]
        [string]
        [ValidateNotNullOrEmpty()]
        $Path
    )
    $result = $false
    if ([bool]([URI]$Path).IsUNC) {
        $result = $true
    } else {
        $driveInfo = [IO.DriveInfo]((Resolve-Path $Path).Path)
        if ($driveInfo.DriveType -eq "Network") {
            $result = $true
        }
    }
    return $result
##########################################################################################
#endregion Helper Functions
$openWim      = $null
$openVhd      = $null
$openIso      = $null
$openImage    = $null
$vhdFinalName = $null
$vhdFinalPath = $null
$mountedHive  = $null
$isoPath      = $null
Write-Verbose $header
try {
    # Create log folder
    if (Test-Path $logFolder) {
        $null = rd $logFolder -Force -Recurse
    }
    $null = md $logFolder -Force
    # Try to start transcripting.  If it's already running, we'll get an exception and swallow it.
    try {
        $null = Start-Transcript -Path (Join-Path $logFolder "Convert-WindowsImageTranscript.txt") -Force -ErrorAction SilentlyContinue
        $transcripting = $true
    } catch {
        Write-W2VWarn "Transcription is already running.  No Convert-WindowsImage-specific transcript will be created."
        $transcripting = $false
    }
    Add-Type -TypeDefinition $code -ReferencedAssemblies "System.Xml","System.Linq","System.Xml.Linq"
    # Check to make sure we're running as Admin.
    if (!(Test-Admin)) {
        throw "Images can only be applied by an administrator.  Please launch PowerShell elevated and run this script again."
    }
    # Resolve the path for the unattend file.
    if (![string]::IsNullOrEmpty($UnattendPath)) {
        $UnattendPath = (Resolve-Path $UnattendPath).Path
    }
    if ($ShowUI) { 
        
        Write-W2VInfo "Launching UI..."
        Add-Type -AssemblyName System.Drawing,System.Windows.Forms
        #region Form Objects
        $frmMain                = New-Object System.Windows.Forms.Form
        $groupBox4              = New-Object System.Windows.Forms.GroupBox
        $btnGo                  = New-Object System.Windows.Forms.Button
        $groupBox3              = New-Object System.Windows.Forms.GroupBox
        $txtVhdName             = New-Object System.Windows.Forms.TextBox
        $label6                 = New-Object System.Windows.Forms.Label
        $btnWrkBrowse           = New-Object System.Windows.Forms.Button
        $cmbVhdSizeUnit         = New-Object System.Windows.Forms.ComboBox
        $numVhdSize             = New-Object System.Windows.Forms.NumericUpDown
        $cmbVhdFormat           = New-Object System.Windows.Forms.ComboBox
        $label5                 = New-Object System.Windows.Forms.Label
        $txtWorkingDirectory    = New-Object System.Windows.Forms.TextBox
        $cmbVhdType             = New-Object System.Windows.Forms.ComboBox
        $label4                 = New-Object System.Windows.Forms.Label
        $label3                 = New-Object System.Windows.Forms.Label
        $label2                 = New-Object System.Windows.Forms.Label
        $label7                 = New-Object System.Windows.Forms.Label
        $txtUnattendFile        = New-Object System.Windows.Forms.TextBox
        $btnUnattendBrowse      = New-Object System.Windows.Forms.Button
        $groupBox2              = New-Object System.Windows.Forms.GroupBox
        $cmbSkuList             = New-Object System.Windows.Forms.ComboBox
        $label1                 = New-Object System.Windows.Forms.Label
        $groupBox1              = New-Object System.Windows.Forms.GroupBox
        $txtSourcePath          = New-Object System.Windows.Forms.TextBox
        $btnBrowseWim           = New-Object System.Windows.Forms.Button
        $openFileDialog1        = New-Object System.Windows.Forms.OpenFileDialog
        $openFolderDialog1      = New-Object System.Windows.Forms.FolderBrowserDialog
        $InitialFormWindowState = New-Object System.Windows.Forms.FormWindowState
        #endregion Form Objects
        #----------------------------------------------
        # Event blocks for the form
        #----------------------------------------------
        $btnGo_OnClick                          = {
            $frmMain.Close()
        }
        $btnWrkBrowse_OnClick                   = {
            $openFolderDialog1.RootFolder       = "Desktop"
            $openFolderDialog1.Description      = "Select the folder you'd like your VHD(X) to be created in."
            $openFolderDialog1.SelectedPath     = $WorkingDirectory
        
            $ret = $openFolderDialog1.ShowDialog()
            if ($ret -ilike "ok") {
                $WorkingDirectory = $txtWorkingDirectory = $openFolderDialog1.SelectedPath
                Write-W2VInfo "Selected Working Directory is $WorkingDirectory..."
            }
        }
        $btnUnattendBrowse_OnClick              = {
            $openFileDialog1.InitialDirectory   = $pwd
            $openFileDialog1.Filter             = "XML files (*.xml)|*.XML|All files (*.*)|*.*"
            $openFileDialog1.FilterIndex        = 1
            $openFileDialog1.CheckFileExists    = $true
            $openFileDialog1.CheckPathExists    = $true
            $openFileDialog1.FileName           = $null
            $openFileDialog1.ShowHelp           = $false
            $openFileDialog1.Title              = "Select an unattend file..."
        
            $ret = $openFileDialog1.ShowDialog()
            if ($ret -ilike "ok") {
                $UnattendPath = $txtUnattendFile.Text = $openFileDialog1.FileName
            }
        }
        $btnBrowseWim_OnClick                   = {
            $openFileDialog1.InitialDirectory   = $pwd
            $openFileDialog1.Filter             = "All compatible files (*.ISO, *.WIM)|*.ISO;*.WIM|All files (*.*)|*.*"
            $openFileDialog1.FilterIndex        = 1
            $openFileDialog1.CheckFileExists    = $true
            $openFileDialog1.CheckPathExists    = $true
            $openFileDialog1.FileName           = $null
            $openFileDialog1.ShowHelp           = $false
            $openFileDialog1.Title              = "Select a source file..."
        
            $ret = $openFileDialog1.ShowDialog()
            if ($ret -ilike "ok") {
                if (([IO.FileInfo]$openFileDialog1.FileName).Extension -ilike ".iso") {
                    
                    if (Test-IsNetworkLocation $openFileDialog1.FileName) {
                        Write-W2VInfo "Copying ISO $(Split-Path $openFileDialog1.FileName -Leaf) to temp folder..."
                        Write-W2VWarn "The UI may become non-responsive while this copy takes place..."                        
                        Copy-Item -Path $openFileDialog1.FileName -Destination $env:Temp -Force
                        $openFileDialog1.FileName = "$($env:Temp)\$(Split-Path $openFileDialog1.FileName -Leaf)"
                    }
                    
                    $txtSourcePath.Text = $isoPath = (Resolve-Path $openFileDialog1.FileName).Path
                    Write-W2VInfo "Opening ISO $(Split-Path $isoPath -Leaf)..."
                    
                    $openIso     = Mount-DiskImage -ImagePath $isoPath -StorageType ISO -PassThru
                    # Refresh the DiskImage object so we can get the real information about it.  I assume this is a bug.
                    $openIso     = Get-DiskImage -ImagePath $isoPath
                    $driveLetter = ($openIso | Get-Volume).DriveLetter
                    $SourcePath  = "$($driveLetter):\sources\install.wim"
                    # Check to see if there's a WIM file we can muck about with.
                    Write-W2VInfo "Looking for $($SourcePath)..."
                    if (!(Test-Path $SourcePath)) {
                        throw "The specified ISO does not appear to be valid Windows installation media."
                    }
                } else {
                    $txtSourcePath.Text = $SourcePath = $openFileDialog1.FileName
                }
                # Check to see if the WIM is local, or on a network location.  If the latter, copy it locally.
                if (Test-IsNetworkLocation $SourcePath) {
                    Write-W2VInfo "Copying WIM $(Split-Path $SourcePath -Leaf) to temp folder..."
                    Write-W2VWarn "The UI may become non-responsive while this copy takes place..."
                    Copy-Item -Path $SourcePath -Destination $env:Temp -Force
                    $txtSourcePath.Text = $SourcePath = "$($env:Temp)\$(Split-Path $SourcePath -Leaf)"
                }
                $SourcePath = (Resolve-Path $SourcePath).Path
                Write-W2VInfo "Scanning WIM metadata..."
        
                $tempOpenWim = $null
                try {
                    $tempOpenWim   = New-Object WIM2VHD.WimFile $SourcePath
                    # Let's see if we're running against an unstaged build.  If we are, we need to blow up.
                    if ($tempOpenWim.ImageNames.Contains("Windows Longhorn Client") -or
                        $tempOpenWim.ImageNames.Contains("Windows Longhorn Server") -or
                        $tempOpenWim.ImageNames.Contains("Windows Longhorn Server Core")) {
                        [Windows.Forms.MessageBox]::Show(
                            "Convert-WindowsImage cannot run against unstaged builds. Please try again with a staged build.",
                            "WIM is incompatible!",
                            "OK",
                            "Error"
                        )
                        return
                    } else {
                    
                        $tempOpenWim.Images | %{ $cmbSkuList.Items.Add($_.ImageFlags) }
                        $cmbSkuList.SelectedIndex = 0
                    }
                } catch {
                    throw "Unable to load WIM metadata!"
                } finally {
                    $tempOpenWim.Close()
                    Write-W2VTrace "Closing WIM metadata..."
                }
            }
        }
        $OnLoadForm_StateCorrection = {
            # Correct the initial state of the form to prevent the .Net maximized form issue
            $frmMain.WindowState      = $InitialFormWindowState
        }
        # Figure out VHD size and size unit.
        $unit = $null
        switch ([Math]::Round($SizeBytes.ToString().Length / 3)) {
            3 { $unit = "MB"; break }
            4 { $unit = "GB"; break }
            5 { $unit = "TB"; break }
            default { $unit = ""; break }
        }
        $quantity = Invoke-Expression -Command "$($SizeBytes) / 1$($unit)"
        #region Form Code
        #region frmMain
        $frmMain.DataBindings.DefaultDataSourceUpdateMode = 0
        $System_Drawing_Size          = New-Object System.Drawing.Size
        $System_Drawing_Size.Height   = 579
        $System_Drawing_Size.Width    = 512
        $frmMain.ClientSize           = $System_Drawing_Size
        $frmMain.Font                 = New-Object System.Drawing.Font("Segoe UI",10,0,3,1)
        $frmMain.FormBorderStyle      = 1
        $frmMain.MaximizeBox          = $False
        $frmMain.MinimizeBox          = $False
        $frmMain.Name                 = "frmMain"
        $frmMain.StartPosition        = 1
        $frmMain.Text                 = "Convert-WindowsImage UI"
        #endregion frmMain
        #region groupBox4
        $groupBox4.DataBindings.DefaultDataSourceUpdateMode = 0
        $System_Drawing_Point         = New-Object System.Drawing.Point
        $System_Drawing_Point.X       = 10
        $System_Drawing_Point.Y       = 498
        $groupBox4.Location           = $System_Drawing_Point
        $groupBox4.Name               = "groupBox4"
        $System_Drawing_Size          = New-Object System.Drawing.Size
        $System_Drawing_Size.Height   = 69
        $System_Drawing_Size.Width    = 489
        $groupBox4.Size               = $System_Drawing_Size
        $groupBox4.TabIndex           = 8
        $groupBox4.TabStop            = $False
        $groupBox4.Text               = "4. Make the VHD!"
        $frmMain.Controls.Add($groupBox4)
        #endregion groupBox4
        #region btnGo
        $btnGo.DataBindings.DefaultDataSourceUpdateMode = 0
        $System_Drawing_Point         = New-Object System.Drawing.Point
        $System_Drawing_Point.X       = 39
        $System_Drawing_Point.Y       = 24
        $btnGo.Location               = $System_Drawing_Point
        $btnGo.Name                   = "btnGo"
        $System_Drawing_Size          = New-Object System.Drawing.Size
        $System_Drawing_Size.Height   = 33
        $System_Drawing_Size.Width    = 415
        $btnGo.Size                   = $System_Drawing_Size
        $btnGo.TabIndex               = 0
        $btnGo.Text                   = "&Make my VHD"
        $btnGo.UseVisualStyleBackColor = $True
        $btnGo.DialogResult           = "OK"
        $btnGo.add_Click($btnGo_OnClick)
        $groupBox4.Controls.Add($btnGo)
        $frmMain.AcceptButton = $btnGo
        #endregion btnGo
        #region groupBox3
        $groupBox3.DataBindings.DefaultDataSourceUpdateMode = 0
        $System_Drawing_Point         = New-Object System.Drawing.Point
        $System_Drawing_Point.X       = 10
        $System_Drawing_Point.Y       = 243
        $groupBox3.Location           = $System_Drawing_Point
        $groupBox3.Name               = "groupBox3"
        $System_Drawing_Size          = New-Object System.Drawing.Size
        $System_Drawing_Size.Height   = 245
        $System_Drawing_Size.Width    = 489
        $groupBox3.Size               = $System_Drawing_Size
        $groupBox3.TabIndex           = 7
        $groupBox3.TabStop            = $False
        $groupBox3.Text               = "3. Choose configuration options"
        $frmMain.Controls.Add($groupBox3)
        #endregion groupBox3
        #region txtVhdName
        $txtVhdName.DataBindings.DefaultDataSourceUpdateMode = 0
        $System_Drawing_Point         = New-Object System.Drawing.Point
        $System_Drawing_Point.X       = 25
        $System_Drawing_Point.Y       = 150
        $txtVhdName.Location          = $System_Drawing_Point
        $txtVhdName.Name              = "txtVhdName"
        $System_Drawing_Size          = New-Object System.Drawing.Size
        $System_Drawing_Size.Height   = 25
        $System_Drawing_Size.Width    = 418
        $txtVhdName.Size              = $System_Drawing_Size
        $txtVhdName.TabIndex          = 10
        $groupBox3.Controls.Add($txtVhdName)
        #endregion txtVhdName
        #region txtUnattendFile
        $txtUnattendFile.DataBindings.DefaultDataSourceUpdateMode = 0
        $System_Drawing_Point         = New-Object System.Drawing.Point
        $System_Drawing_Point.X       = 25
        $System_Drawing_Point.Y       = 198
        $txtUnattendFile.Location     = $System_Drawing_Point
        $txtUnattendFile.Name         = "txtUnattendFile"
        $System_Drawing_Size          = New-Object System.Drawing.Size
        $System_Drawing_Size.Height   = 25
        $System_Drawing_Size.Width    = 418
        $txtUnattendFile.Size         = $System_Drawing_Size
        $txtUnattendFile.TabIndex     = 11
        $groupBox3.Controls.Add($txtUnattendFile)
        #endregion txtUnattendFile
        #region label7
        $label7.DataBindings.DefaultDataSourceUpdateMode = 0
        $System_Drawing_Point         = New-Object System.Drawing.Point
        $System_Drawing_Point.X       = 23
        $System_Drawing_Point.Y       = 180
        $label7.Location              = $System_Drawing_Point
        $label7.Name                  = "label7"
        $System_Drawing_Size          = New-Object System.Drawing.Size
        $System_Drawing_Size.Height   = 23
        $System_Drawing_Size.Width    = 175
        $label7.Size                  = $System_Drawing_Size
        $label7.Text                  = "Unattend File (Optional)"
        $groupBox3.Controls.Add($label7)
        #endregion label7
        #region label6
        $label6.DataBindings.DefaultDataSourceUpdateMode = 0
        $System_Drawing_Point         = New-Object System.Drawing.Point
        $System_Drawing_Point.X       = 23
        $System_Drawing_Point.Y       = 132
        $label6.Location              = $System_Drawing_Point
        $label6.Name                  = "label6"
        $System_Drawing_Size          = New-Object System.Drawing.Size
        $System_Drawing_Size.Height   = 23
        $System_Drawing_Size.Width    = 175
        $label6.Size                  = $System_Drawing_Size
        $label6.Text                  = "VHD Name (Optional)"
        $groupBox3.Controls.Add($label6)
        #endregion label6
        #region btnUnattendBrowse
        $btnUnattendBrowse.DataBindings.DefaultDataSourceUpdateMode = 0
        $System_Drawing_Point         = New-Object System.Drawing.Point
        $System_Drawing_Point.X       = 449
        $System_Drawing_Point.Y       = 199
        $btnUnattendBrowse.Location   = $System_Drawing_Point
        $btnUnattendBrowse.Name       = "btnUnattendBrowse"
        $System_Drawing_Size          = New-Object System.Drawing.Size
        $System_Drawing_Size.Height   = 25
        $System_Drawing_Size.Width    = 27
        $btnUnattendBrowse.Size       = $System_Drawing_Size
        $btnUnattendBrowse.TabIndex   = 9
        $btnUnattendBrowse.Text       = "..."
        $btnUnattendBrowse.UseVisualStyleBackColor = $True
        $btnUnattendBrowse.add_Click($btnUnattendBrowse_OnClick)
        $groupBox3.Controls.Add($btnUnattendBrowse)
        #endregion btnUnattendBrowse
        #region btnWrkBrowse
        $btnWrkBrowse.DataBindings.DefaultDataSourceUpdateMode = 0
        $System_Drawing_Point         = New-Object System.Drawing.Point
        $System_Drawing_Point.X       = 449
        $System_Drawing_Point.Y       = 98
        $btnWrkBrowse.Location        = $System_Drawing_Point
        $btnWrkBrowse.Name            = "btnWrkBrowse"
        $System_Drawing_Size          = New-Object System.Drawing.Size
        $System_Drawing_Size.Height   = 25
        $System_Drawing_Size.Width    = 27
        $btnWrkBrowse.Size            = $System_Drawing_Size
        $btnWrkBrowse.TabIndex        = 9
        $btnWrkBrowse.Text            = "..."
        $btnWrkBrowse.UseVisualStyleBackColor = $True
        $btnWrkBrowse.add_Click($btnWrkBrowse_OnClick)
        $groupBox3.Controls.Add($btnWrkBrowse)
        #endregion btnWrkBrowse
        #region cmbVhdSizeUnit
        $cmbVhdSizeUnit.DataBindings.DefaultDataSourceUpdateMode = 0
        $cmbVhdSizeUnit.FormattingEnabled = $True
        $cmbVhdSizeUnit.Items.Add("MB") | Out-Null
        $cmbVhdSizeUnit.Items.Add("GB") | Out-Null
        $cmbVhdSizeUnit.Items.Add("TB") | Out-Null
        $System_Drawing_Point         = New-Object System.Drawing.Point
        $System_Drawing_Point.X       = 409
        $System_Drawing_Point.Y       = 42
        $cmbVhdSizeUnit.Location      = $System_Drawing_Point
        $cmbVhdSizeUnit.Name          = "cmbVhdSizeUnit"
        $System_Drawing_Size          = New-Object System.Drawing.Size
        $System_Drawing_Size.Height   = 25
        $System_Drawing_Size.Width    = 67
        $cmbVhdSizeUnit.Size          = $System_Drawing_Size
        $cmbVhdSizeUnit.TabIndex      = 5
        $cmbVhdSizeUnit.Text          = $unit
        $groupBox3.Controls.Add($cmbVhdSizeUnit)
        #endregion cmbVhdSizeUnit
        #region numVhdSize
        $numVhdSize.DataBindings.DefaultDataSourceUpdateMode = 0
        $System_Drawing_Point         = New-Object System.Drawing.Point
        $System_Drawing_Point.X       = 340
        $System_Drawing_Point.Y       = 42
        $numVhdSize.Location          = $System_Drawing_Point
        $numVhdSize.Name              = "numVhdSize"
        $System_Drawing_Size          = New-Object System.Drawing.Size
        $System_Drawing_Size.Height   = 25
        $System_Drawing_Size.Width    = 63
        $numVhdSize.Size              = $System_Drawing_Size
        $numVhdSize.TabIndex          = 4
        $numVhdSize.Value             = $quantity
        $groupBox3.Controls.Add($numVhdSize)
        #endregion numVhdSize
        #region cmbVhdFormat
        $cmbVhdFormat.DataBindings.DefaultDataSourceUpdateMode = 0
        $cmbVhdFormat.FormattingEnabled = $True
        $cmbVhdFormat.Items.Add("VHD")  | Out-Null
        $cmbVhdFormat.Items.Add("VHDX") | Out-Null
        $System_Drawing_Point         = New-Object System.Drawing.Point
        $System_Drawing_Point.X       = 25
        $System_Drawing_Point.Y       = 42
        $cmbVhdFormat.Location        = $System_Drawing_Point
        $cmbVhdFormat.Name            = "cmbVhdFormat"
        $System_Drawing_Size          = New-Object System.Drawing.Size
        $System_Drawing_Size.Height   = 25
        $System_Drawing_Size.Width    = 136
        $cmbVhdFormat.Size            = $System_Drawing_Size
        $cmbVhdFormat.TabIndex        = 0
        $cmbVhdFormat.Text            = $VHDFormat
        $groupBox3.Controls.Add($cmbVhdFormat)
        #endregion cmbVhdFormat
        #region label5
        $label5.DataBindings.DefaultDataSourceUpdateMode = 0
        $System_Drawing_Point         = New-Object System.Drawing.Point
        $System_Drawing_Point.X       = 23
        $System_Drawing_Point.Y       = 76
        $label5.Location              = $System_Drawing_Point
        $label5.Name                  = "label5"
        $System_Drawing_Size          = New-Object System.Drawing.Size
        $System_Drawing_Size.Height   = 23
        $System_Drawing_Size.Width    = 264
        $label5.Size                  = $System_Drawing_Size
        $label5.TabIndex              = 8
        $label5.Text                  = "Working Directory"
        $groupBox3.Controls.Add($label5)
        #endregion label5
        #region txtWorkingDirectory
        $txtWorkingDirectory.DataBindings.DefaultDataSourceUpdateMode = 0
        $System_Drawing_Point         = New-Object System.Drawing.Point
        $System_Drawing_Point.X       = 25
        $System_Drawing_Point.Y       = 99
        $txtWorkingDirectory.Location = $System_Drawing_Point
        $txtWorkingDirectory.Name     = "txtWorkingDirectory"
        $System_Drawing_Size          = New-Object System.Drawing.Size
        $System_Drawing_Size.Height   = 25
        $System_Drawing_Size.Width    = 418
        $txtWorkingDirectory.Size     = $System_Drawing_Size
        $txtWorkingDirectory.TabIndex = 7
        $txtWorkingDirectory.Text     = $WorkingDirectory
        $groupBox3.Controls.Add($txtWorkingDirectory)
        #endregion txtWorkingDirectory
        #region cmbVhdType
        $cmbVhdType.DataBindings.DefaultDataSourceUpdateMode = 0
        $cmbVhdType.FormattingEnabled = $True
        $cmbVhdType.Items.Add("Dynamic") | Out-Null
        $cmbVhdType.Items.Add("Fixed")   | Out-Null
        $System_Drawing_Point         = New-Object System.Drawing.Point
        $System_Drawing_Point.X       = 176
        $System_Drawing_Point.Y       = 42
        $cmbVhdType.Location          = $System_Drawing_Point
        $cmbVhdType.Name              = "cmbVhdType"
        $System_Drawing_Size          = New-Object System.Drawing.Size
        $System_Drawing_Size.Height   = 25
        $System_Drawing_Size.Width    = 144
        $cmbVhdType.Size              = $System_Drawing_Size
        $cmbVhdType.TabIndex          = 2
        $cmbVhdType.Text              = $VHDType
        $groupBox3.Controls.Add($cmbVhdType)
        #endregion cmbVhdType
        #region label4
        $label4.DataBindings.DefaultDataSourceUpdateMode = 0
        $System_Drawing_Point         = New-Object System.Drawing.Point
        $System_Drawing_Point.X       = 340
        $System_Drawing_Point.Y       = 21
        $label4.Location              = $System_Drawing_Point
        $label4.Name                  = "label4"
        $System_Drawing_Size          = New-Object System.Drawing.Size
        $System_Drawing_Size.Height   = 27
        $System_Drawing_Size.Width    = 86
        $label4.Size                  = $System_Drawing_Size
        $label4.TabIndex              = 6
        $label4.Text                  = "VHD Size"
        $groupBox3.Controls.Add($label4)
        #endregion label4
        #region label3
        $label3.DataBindings.DefaultDataSourceUpdateMode = 0
        $System_Drawing_Point         = New-Object System.Drawing.Point
        $System_Drawing_Point.X       = 176
        $System_Drawing_Point.Y       = 21
        $label3.Location              = $System_Drawing_Point
        $label3.Name                  = "label3"
        $System_Drawing_Size          = New-Object System.Drawing.Size
        $System_Drawing_Size.Height   = 27
        $System_Drawing_Size.Width    = 92
        $label3.Size                  = $System_Drawing_Size
        $label3.TabIndex              = 3
        $label3.Text                  = "VHD Type"
        $groupBox3.Controls.Add($label3)
        #endregion label3
        #region label2
        $label2.DataBindings.DefaultDataSourceUpdateMode = 0
        $System_Drawing_Point         = New-Object System.Drawing.Point
        $System_Drawing_Point.X       = 25
        $System_Drawing_Point.Y       = 21
        $label2.Location              = $System_Drawing_Point
        $label2.Name                  = "label2"
        $System_Drawing_Size          = New-Object System.Drawing.Size
        $System_Drawing_Size.Height   = 30
        $System_Drawing_Size.Width    = 118
        $label2.Size                  = $System_Drawing_Size
        $label2.TabIndex              = 1
        $label2.Text                  = "VHD Format"
        $groupBox3.Controls.Add($label2)
        #endregion label2
        #region groupBox2
        $groupBox2.DataBindings.DefaultDataSourceUpdateMode = 0
        $System_Drawing_Point         = New-Object System.Drawing.Point
        $System_Drawing_Point.X       = 10
        $System_Drawing_Point.Y       = 169
        $groupBox2.Location           = $System_Drawing_Point
        $groupBox2.Name               = "groupBox2"
        $System_Drawing_Size          = New-Object System.Drawing.Size
        $System_Drawing_Size.Height   = 68
        $System_Drawing_Size.Width    = 490
        $groupBox2.Size               = $System_Drawing_Size
        $groupBox2.TabIndex           = 6
        $groupBox2.TabStop            = $False
        $groupBox2.Text               = "2. Choose a SKU from the list"
        $frmMain.Controls.Add($groupBox2)
        #endregion groupBox2
        #region cmbSkuList
        $cmbSkuList.DataBindings.DefaultDataSourceUpdateMode = 0
        $cmbSkuList.FormattingEnabled = $True
        $System_Drawing_Point         = New-Object System.Drawing.Point
        $System_Drawing_Point.X       = 25
        $System_Drawing_Point.Y       = 24
        $cmbSkuList.Location          = $System_Drawing_Point
        $cmbSkuList.Name              = "cmbSkuList"
        $System_Drawing_Size          = New-Object System.Drawing.Size
        $System_Drawing_Size.Height   = 25
        $System_Drawing_Size.Width    = 452
        $cmbSkuList.Size              = $System_Drawing_Size
        $cmbSkuList.TabIndex          = 2
        $groupBox2.Controls.Add($cmbSkuList)
        #endregion cmbSkuList
        #region label1
        $label1.DataBindings.DefaultDataSourceUpdateMode = 0
        $System_Drawing_Point         = New-Object System.Drawing.Point
        $System_Drawing_Point.X       = 23
        $System_Drawing_Point.Y       = 21
        $label1.Location              = $System_Drawing_Point
        $label1.Name                  = "label1"
        $System_Drawing_Size          = New-Object System.Drawing.Size
        $System_Drawing_Size.Height   = 71
        $System_Drawing_Size.Width    = 464
        $label1.Size                  = $System_Drawing_Size
        $label1.TabIndex              = 5
        $label1.Text                  = $uiHeader
        $frmMain.Controls.Add($label1)
        #endregion label1
        #region groupBox1
        $groupBox1.DataBindings.DefaultDataSourceUpdateMode = 0
        $System_Drawing_Point         = New-Object System.Drawing.Point
        $System_Drawing_Point.X       = 10
        $System_Drawing_Point.Y       = 95
        $groupBox1.Location           = $System_Drawing_Point
        $groupBox1.Name               = "groupBox1"
        $System_Drawing_Size          = New-Object System.Drawing.Size
        $System_Drawing_Size.Height   = 68
        $System_Drawing_Size.Width    = 490
        $groupBox1.Size               = $System_Drawing_Size
        $groupBox1.TabIndex           = 4
        $groupBox1.TabStop            = $False
        $groupBox1.Text               = "1. Choose a source"
        $frmMain.Controls.Add($groupBox1)
        #endregion groupBox1
        #region txtSourcePath
        $txtSourcePath.DataBindings.DefaultDataSourceUpdateMode = 0
        $System_Drawing_Point         = New-Object System.Drawing.Point
        $System_Drawing_Point.X       = 25
        $System_Drawing_Point.Y       = 24
        $txtSourcePath.Location       = $System_Drawing_Point
        $txtSourcePath.Name           = "txtSourcePath"
        $System_Drawing_Size          = New-Object System.Drawing.Size
        $System_Drawing_Size.Height   = 25
        $System_Drawing_Size.Width    = 418
        $txtSourcePath.Size           = $System_Drawing_Size
        $txtSourcePath.TabIndex       = 0
        $groupBox1.Controls.Add($txtSourcePath)
        #endregion txtSourcePath
        #region btnBrowseWim
        $btnBrowseWim.DataBindings.DefaultDataSourceUpdateMode = 0
        $System_Drawing_Point         = New-Object System.Drawing.Point
        $System_Drawing_Point.X       = 449
        $System_Drawing_Point.Y       = 24
        $btnBrowseWim.Location        = $System_Drawing_Point
        $btnBrowseWim.Name            = "btnBrowseWim"
        $System_Drawing_Size          = New-Object System.Drawing.Size
        $System_Drawing_Size.Height   = 25
        $System_Drawing_Size.Width    = 28
        $btnBrowseWim.Size            = $System_Drawing_Size
        $btnBrowseWim.TabIndex        = 1
        $btnBrowseWim.Text            = "..."
        $btnBrowseWim.UseVisualStyleBackColor = $True
        $btnBrowseWim.add_Click($btnBrowseWim_OnClick)
        $groupBox1.Controls.Add($btnBrowseWim)
        #endregion btnBrowseWim
        $openFileDialog1.FileName     = "openFileDialog1"
        $openFileDialog1.ShowHelp     = $True
        #endregion Form Code
        # Save the initial state of the form
        $InitialFormWindowState       = $frmMain.WindowState
        # Init the OnLoad event to correct the initial state of the form
        $frmMain.add_Load($OnLoadForm_StateCorrection)
        # Return the constructed form.
        $ret = $frmMain.ShowDialog()
        if (!($ret -ilike "OK")) {
            throw "Form session has been cancelled."
        }
        if ([string]::IsNullOrEmpty($SourcePath)) {
            throw "No source path specified."
        }
        # VHD Format
        $VHDFormat        = $cmbVhdFormat.SelectedItem
        # VHD Size
        $SizeBytes        = Invoke-Expression "$($numVhdSize.Value)$($cmbVhdSizeUnit.SelectedItem)"
        # VHD Type
        $VHDType          = $cmbVhdType.SelectedItem
        # Working Directory
        $WorkingDirectory = $txtWorkingDirectory.Text
        # VHDPath
        if (![string]::IsNullOrEmpty($txtVhdName.Text)) {
            $VHDPath      = "$($WorkingDirectory)\$($txtVhdName.Text)"
        }
        # Edition
        if (![string]::IsNullOrEmpty($cmbSkuList.SelectedItem)) {
            $Edition      = $cmbSkuList.SelectedItem
        }
        # Because we used ShowDialog, we need to manually dispose of the form.
        # This probably won't make much of a difference, but let's free up all of the resources we can
        # before we start the conversion process.
        $frmMain.Dispose()
    }
    # There's a difference between the maximum sizes for VHDs and VHDXs.  Make sure we follow it.
    if ("VHD" -ilike $VHDFormat) {
        if ($SizeBytes -gt $vhdMaxSize) {
            Write-W2VWarn "For the VHD file format, the maximum file size is ~2040GB.  We're automatically setting the size to 2040GB for you."
            $SizeBytes = 2040GB
        }
    }
    # Check if -VHDPath and -WorkingDirectory were both specified.
    if ((![String]::IsNullOrEmpty($VHDPath)) -and (![String]::IsNullOrEmpty($WorkingDirectory))) {
        if ($WorkingDirectory -ne $pwd) {
            # If the WorkingDirectory is anything besides $pwd, tell people that the WorkingDirectory is being ignored.
            Write-W2VWarn "Specifying -VHDPath and -WorkingDirectory at the same time is contradictory."
            Write-W2VWarn "Ignoring the WorkingDirectory specification."
            $WorkingDirectory = Split-Path $VHDPath -Parent
        }
    }
    if ($VHDPath) {
        # Check to see if there's a conflict between the specified file extension and the VHDFormat being used.
        $ext = ([IO.FileInfo]$VHDPath).Extension
        if (!($ext -ilike ".$($VHDFormat)")) {
            throw "There is a mismatch between the VHDPath file extension ($($ext.ToUpper())), and the VHDFormat (.$($VHDFormat)).  Please ensure that these match and try again."
        }
    }
    # Create a temporary name for the VHD(x).  We'll name it properly at the end of the script.
    if ([String]::IsNullOrEmpty($VHDPath)) {
        $VHDPath      = Join-Path $WorkingDirectory "$($sessionKey).$($VHDFormat.ToLower())"
    } else {
        # Since we can't do Resolve-Path against a file that doesn't exist, we need to get creative in determining 
        # the full path that the user specified (or meant to specify if they gave us a relative path).
        # Check to see if the path has a root specified.  If it doesn't, use the working directory.
        if (![IO.Path]::IsPathRooted($VHDPath)){
            $VHDPath  = Join-Path $WorkingDirectory $VHDPath
        }
        $vhdFinalName = Split-Path $VHDPath -Leaf
        $VHDPath      = Join-Path (Split-Path $VHDPath -Parent) "$($sessionKey).$($VHDFormat.ToLower())"
    }
    Write-W2VTrace "Temporary $VHDFormat path is : $VHDPath"
    # If we're using an ISO, mount it and get the path to the WIM file.
    if (([IO.FileInfo]$SourcePath).Extension -ilike ".ISO") { 
        # If the ISO isn't local, copy it down so we don't have to worry about resource contention
        # or about network latency.
        if (Test-IsNetworkLocation $SourcePath) {
            Write-W2VInfo "Copying ISO $(Split-Path $SourcePath -Leaf) to temp folder..."
            Copy-Item -Path $SourcePath -Destination $env:Temp -Force
            $SourcePath = "$($env:Temp)\$(Split-Path $SourcePath -Leaf)"
        }
        $isoPath = (Resolve-Path $SourcePath).Path
        Write-W2VInfo "Opening ISO $(Split-Path $isoPath -Leaf)..."
        $openIso     = Mount-DiskImage -ImagePath $isoPath -StorageType ISO -PassThru
        # Refresh the DiskImage object so we can get the real information about it.  I assume this is a bug.
        $openIso     = Get-DiskImage -ImagePath $isoPath
        $driveLetter = ($openIso | Get-Volume).DriveLetter
        $SourcePath  = "$($driveLetter):\sources\install.wim"
        # Check to see if there's a WIM file we can muck about with.
        Write-W2VInfo "Looking for $($SourcePath)..."
        if (!(Test-Path $SourcePath)) {
            throw "The specified ISO does not appear to be valid Windows installation media."
        }
    }
    # Check to see if the WIM is local, or on a network location.  If the latter, copy it locally.
    if (Test-IsNetworkLocation $SourcePath) {
        Write-W2VInfo "Copying WIM $(Split-Path $SourcePath -Leaf) to temp folder..."
        Copy-Item -Path $SourcePath -Destination $env:Temp -Force
        $SourcePath = "$($env:Temp)\$(Split-Path $SourcePath -Leaf)"
    }
    $SourcePath  = (Resolve-Path $SourcePath).Path
    # We're good.  Open the WIM container.
    $openWim     = New-Object WIM2VHD.WimFile $SourcePath
    # Hardcode edition to enterprise SKU (this is the only SKU that is supported)
    $SupportedEdition = "Enterprise"
    $Edition = "null"
    foreach ($image in $openWim.Images)
    {
        if ($image.ImageFlags.Contains($SupportedEdition) -eq $true)
        {
             $Edition = $image.ImageFlags;
             break;
        }
    }
    if ($Edition -eq "null") {
        Write-W2VError "You must specify an Edition or SKU index, since the WIM has more than one image."
        Write-W2VError "Valid edition names are:"
        $openWim.Images | %{ Write-W2VError "  $($_.ImageFlags)" }
        throw new-object ArgumentOutOfRangeException("Edition", "Enterprise edition does not exist in the specified WIM file.");
    } 
    $openImage = $openWim[$Edition]
    if ($null -eq $openImage) {
        Write-W2VError "The specified edition does not appear to exist in the specified WIM."
        Write-W2VError "Valid edition names are:"
        $openWim.Images | %{ Write-W2VError "  $($_.ImageFlags)" }
        throw new-object ArgumentOutOfRangeException("Edition", "Enterprise edition does not exist in the specified WIM file.");
    }
    Write-W2VInfo "Image $($openImage.ImageIndex) selected ($($openImage.ImageFlags))..."
    # Check to make sure that the image we're applying is Windows 7 or greater.
    if ($openImage.ImageVersion -lt $lowestSupportedVersion) {
        throw "Windows 10 or higher is required."
    }
    <#
        Create the VHD using the VirtDisk Win32 API.
        So, why not use the New-VHD cmdlet here?
        
        New-VHD depends on the Hyper-V Cmdlets, which aren't installed by default.
        Installing those cmdlets isn't a big deal, but they depend on the Hyper-V WMI
        APIs, which in turn depend on Hyper-V.  In order to prevent Convert-WindowsImage
        from being dependent on Hyper-V (and thus, x64 systems only), we're using the 
        VirtDisk APIs directly.
    #>
    if ($VHDType -eq "Dynamic") {
        Write-W2VInfo "Creating sparse disk..."
        $openVhd = [WIM2VHD.VirtualHardDisk]::CreateSparseDisk(
            $VHDFormat,
            $VHDPath,
            $SizeBytes,
            $true
        )
    } else {
        Write-W2VInfo "Creating fixed disk..."
        $openVhd = [WIM2VHD.VirtualHardDisk]::CreateFixedDisk(
            $VHDFormat,
            $VHDPath,
            $SizeBytes,
            $true
        )
    }
    # Attach the VHD.
    Write-W2VInfo "Attaching $VHDFormat..."
    $openVhd.Attach()
    Initialize-Disk -Number $openVhd.DiskIndex -PartitionStyle MBR
    $disk      = Get-Disk -Number $openVhd.DiskIndex
    Write-W2VInfo "Disk initialized..."
    $partition = New-Partition -DiskNumber $openVhd.DiskIndex -Size $disk.LargestFreeExtent -MbrType IFS -IsActive
    Write-W2VInfo "Disk partitioned..."
    $volume    = Format-Volume -Partition $partition -FileSystem NTFS -Force -Confirm:$false
    Write-W2VInfo "Volume formatted..."
    $partition | Add-PartitionAccessPath -AssignDriveLetter
    $drive     = $(Get-Partition -Disk $disk).AccessPaths[0]
    Write-W2VInfo "Access path ($drive) has been assigned..."
    Write-W2VInfo "Applying image to $VHDFormat.  This could take a while..."
    $openImage.Apply($drive)
    if (![string]::IsNullOrEmpty($UnattendPath)) {
        Write-W2VInfo "Applying unattend file ($(Split-Path $UnattendPath -Leaf))..."
        Copy-Item -Path $UnattendPath -Destination (Join-Path $drive "unattend.xml") -Force
    }
    Write-W2VInfo "Signing disk..."
    $mkWasHere | Out-File -FilePath (Join-Path $drive "Convert-WindowsImageInfo.txt") -Encoding Unicode -Force
    if ($Flavor -inotlike "woa*") {
        Write-W2VInfo "Image applied.  Making image bootable..."
        $bcdBootArgs = @(
            "$($drive)Windows",    # Path to the \Windows on the VHD
            "/s $drive",           # Specifies the volume letter of the drive to create the \BOOT folder on.
#            "/f ALL",              # Support either a UEFI-based or a BIOS-based computer (https://technet.microsoft.com/en-us/library/dd744347(v=ws.10).aspx)
            "/f BIOS",              # Support BIOS only
            "/v"                   # Enabled verbose logging.
        )
        Run-Executable -Executable $BCDBoot -Arguments $bcdBootArgs
        Apply-BcdStoreChanges                     `
            -BcdStoreFile    "$($drive)boot\bcd"  `
            -PartitionStyle  $PARTITION_STYLE_MBR `
            -DiskSignature   $disk.Signature      `
            -PartitionOffset $partition.Offset    
        Write-W2VInfo "Drive is bootable.  Cleaning up..."
    } else {
        Write-W2VInfo "Not making VHD bootable, since WOA can't boot in VMs."
    }
    if ([String]::IsNullOrEmpty($vhdFinalName)) {
        # We need to generate a file name. 
        Write-W2VInfo "Generating name for $($VHDFormat)..."
        $hive         = Mount-RegistryHive -Hive (Join-Path $drive "Windows\System32\Config\Software")
        $buildLabEx   = (Get-ItemProperty "HKLM:\$($hive)\Microsoft\Windows NT\CurrentVersion").BuildLabEx
        $installType  = (Get-ItemProperty "HKLM:\$($hive)\Microsoft\Windows NT\CurrentVersion").InstallationType
        $editionId    = (Get-ItemProperty "HKLM:\$($hive)\Microsoft\Windows NT\CurrentVersion").EditionID
        $skuFamily    = $null
        Dismount-RegistryHive -HiveMountPoint $hive
        # Is this ServerCore?
        if ($installType.ToUpper().Contains("CORE")) {
            $editionId += "Core"
        }
        # What type of SKU are we?
        if ($installType.ToUpper().Contains("SERVER")) {
            $skuFamily = "Server"
        } elseif ($installType.ToUpper().Contains("CLIENT")) {
            $skuFamily = "Client"
        } else {
            $skuFamily = "Unknown"
        }
        $vhdFinalName = "$($buildLabEx)_$($skuFamily)_$($editionId)_$($openImage.ImageDefaultLanguage).$($VHDFormat.ToLower())"
        Write-W2VTrace "$VHDFormat final name is : $vhdFinalName"
    }
    Write-W2VInfo "Closing $VHDFormat..."
    $openVhd.Close()
    $openVhd = $null
    $vhdFinalPath = Join-Path (Split-Path $VHDPath -Parent) $vhdFinalName
    if (Test-Path $vhdFinalPath) {
        Write-W2VInfo "Deleting pre-existing $VHDFormat : $(Split-Path $vhdFinalPath -Leaf)..."
        Remove-Item -Path $vhdFinalPath -Force
    }
    Rename-Item -Path (Resolve-Path $VHDPath).Path -NewName $vhdFinalName -Force
} catch {
    Write-W2VError $_
    Write-W2VInfo "Log folder is $logFolder"
    throw
} finally { 
    # If we still have a WIM image open, close it.
    if ($openWim -ne $null) {
        Write-W2VInfo "Closing Windows image..."
        $openWim.Close()
    }
    # If we still have a registry hive mounted, dismount it.
    if ($mountedHive -ne $null) {
        Write-W2VInfo "Closing registry hive..."
        Dismount-RegistryHive -HiveMountPoint $mountedHive
    }
    # If we still have a VHD(X) open, close it.
    if ($openVhd -ne $null) {
        Write-W2VInfo "Closing $VHDFormat..."
        $openVhd.Close()
    }
    # If we still have an ISO open, close it.
    if ($openIso -ne $null) {
        Write-W2VInfo "Closing ISO..."
        Dismount-DiskImage $ISOPath
    }
    # Close out the transcript and tell the user we're done.
    Write-W2VInfo "Done."
    if ($transcripting) {
        $null = Stop-Transcript
    }
if (($Passthru) -and (![string]::IsNullOrEmpty($vhdFinalPath)) -and (Test-Path $vhdFinalPath)) {
    return (Get-ChildItem -Path $vhdFinalPath)
Core call failed
*Disk protection service already installed.
)Disk protection service is not installed.
uThe autologon user to be set duplicates the ones on other stations. Two stations cannot have the same autologon user.
RMust either have an AutomaticUpdateMode other than none or supply a custom script.
+Parameter 'Name' must not be null or empty.
+Specified account information is not valid.
Invalid disk-protection state.
9The Desktop's Invitation field must not be null or empty.
@Virtual desktops require Windows 10 Professional or Enterprise. 
!is an administrative user account
.Parameter 'Message' must not be null or empty.
0Parameter 'FileToRun' must not be null or empty.
"Published session cannot be found.
+Parameter 'Name' must not be null or empty.
)SessionHost is empty or same as localhost
]When more than one station ID is supplied, parameter 'FriendlyName' must be omitted or empty.
Must specify a user name.
$Uninstall disk protection and reboot
"Install disk protection and reboot
Shutdown computer
Stop managing the computer
Remove user:
Reboot the computer
!Resume disk protection and reboot
"Suspend disk protection and reboot
Helping {0}
Web service call failed
+qN8t
MultiPoint.pdb
_CorDllMain
mscoree.dll
VS_VERSION_INFO
StringFileInfo
040904B0
CompanyName
Microsoft Corporation
FileDescription
WMS Powershell Cmdlets
FileVersion
10.0.22621.1 (WinBuild.160101.0800)
InternalName
MultiPoint
LegalCopyright
 Microsoft Corporation. All rights reserved.
OriginalFilename
MultiPoint.dll
ProductName
Microsoft
 Windows
 Operating System
ProductVersion
10.0.22621.1
VarFileInfo
Translation
