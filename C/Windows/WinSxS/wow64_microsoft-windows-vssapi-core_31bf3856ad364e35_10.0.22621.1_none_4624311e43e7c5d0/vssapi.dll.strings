!This program cannot be run in DOS mode.
Richh
.text
`.data
.idata
@.didat
.rsrc
@.reloc
CreateWriterEx
base\stor\vss\modules\vssapi\vswriter.cpp
WSHVWRTC
CreateWriter
SubscribeCallback
EventSystem.EventSubscription
CVssWriterImpl::CreateWriter
CVssWriterState::Initialize
*** Constructing object %p
wszWriterInstanceName = %s
WriterName            = %s
Diagnose enabled for (%s)
ActiveWriterStateTimeout
CEventSubscription
WriterInstanceId
Set m_pSidAdmin
Parameters %s
CEventSystem
WriterId
(NULL)
InstanceId for Writer %s is {%.8x-%.4x-%.4x-%.2x%.2x-%.2x%.2x%.2x%.2x%.2x%.2x}
WriterId              = {%.8x-%.4x-%.4x-%.2x%.2x-%.2x%.2x%.2x%.2x%.2x%.2x}
SYSTEM\CurrentControlSet\Services\VSS\Settings
**** Subscribe succeeded for [%p]
EventSystem.EventClassCollection
CVssWriterImpl::CVssWriterImpl
CAutoSid::CreateBasicSid
%s\%s
SYSTEM\CurrentControlSet\Services\VSS\Diag
CVssWriterImpl::SubscribeInternal
base\stor\vss\modules\vswriter\vswrtimp.cpp
WRTWRTIC
CVssSidCollection::AddWellKnownSid
base\stor\vss\modules\sec\security.cxx
CVssSidCollection::ExpandForVerification
Time spent: %02ld:%02ld:%02ld-%04ld; total: %#x; HRESULT: %#x
FALSE
RETURN
SECSECRC
Returning BOOL: %s
ExpandForVerification()
CVssSidCollection::AddSid
base\stor\vss\modules\registry\registry.cxx
REGREGSC
CVssRegistryKey::Open
CVssRegistryValueIterator::ReadCurrentValueDetails
CVssDiag::Initialize
{%.8x-%.4x-%.4x-%.2x%.2x-%.2x%.2x%.2x%.2x%.2x%.2x}
INCTYPEH
CVssRegistryKey::GetValue
CVssSafeCriticalSection::Init
base\stor\vss\inc\vs_types.hxx
CONTEXT
Adding context: '%s' = '%s' (%d)
Adding context: '%s' (%d)
CVssSidCollection::IsSidAllowedToFire
CVssRegistryValueIterator::Attach
CVssRegistryValueIterator::GetCurrentValueContent
GetClientTokenUser
GetCurrentAccessToken
CVssRegistryKey::Create
CVssSidCollection::AddUser
SYSTEM\ControlSet001\Control\MiniNT
CVssMachineInformation::IsDuringWinPE
IsInGroup
VssFreeSnapshotPropertiesInternal
VssAPI::VssFreeSnapshotProperties
GetProviderMgmtInterfaceInternal
base\stor\vss\modules\vssapi\vssapi.cpp
VSSAPICP
Coordinator
EventClassID == 
bad allocation
permission denied
file exists
no such device
filename too long
device or resource busy
io error
directory not empty
invalid argument
no space on device
no such file or directory
function not supported
no lock available
not enough memory
resource unavailable try again
cross device link
operation canceled
too many files open
permission_denied
address_in_use
address_not_available
address_family_not_supported
connection_already_in_progress
bad_file_descriptor
connection_aborted
connection_refused
connection_reset
destination_address_required
bad_address
host_unreachable
operation_in_progress
interrupted
invalid_argument
already_connected
too_many_files_open
message_size
filename_too_long
network_down
network_reset
network_unreachable
no_buffer_space
no_protocol_option
not_connected
not_a_socket
operation_not_supported
protocol_not_supported
wrong_protocol_type
timed_out
operation_would_block
address family not supported
address in use
address not available
already connected
argument list too long
argument out of domain
bad address
bad file descriptor
bad message
broken pipe
connection aborted
connection already in progress
connection refused
connection reset
destination address required
executable format error
file too large
host unreachable
identifier removed
illegal byte sequence
inappropriate io control operation
invalid seek
is a directory
message size
network down
network reset
network unreachable
no buffer space
no child process
no link
no message available
no message
no protocol option
no stream resources
no such device or address
no such process
not a directory
not a socket
not a stream
not connected
not supported
operation in progress
operation not permitted
operation not supported
operation would block
owner dead
protocol error
protocol not supported
read only file system
resource deadlock would occur
result out of range
state not recoverable
stream timeout
text file busy
timed out
too many files open in system
too many links
too many symbolic link levels
value too large
wrong protocol type
OLEAUT32.dll
api-ms-win-core-com-l1-1-0.dll
api-ms-win-service-management-l1-1-0.dll
api-ms-win-service-winsvc-l1-1-0.dll
api-ms-win-security-lsalookup-l1-1-0.dll
api-ms-win-eventlog-legacy-l1-1-0.dll
api-ms-win-security-sddl-l1-1-0.dll
MPR.dll
RPCRT4.dll
XmlLite.dll
samcli.dll
netutils.dll
DSROLE.dll
ESENT.dll
WS2_32.dll
\^F&{
api-ms-win-devices-config-l1-1-1.dll
VirtDisk.dll
SETUPAPI.dll
bcd.dll
Memory allocation error
VssSafeDuplicateStr
INCSTRH
base\stor\vss\inc\vs_str.hxx
StringCchCopy(%s, %d, %s) failed
INCICHLH
base\stor\vss\inc\ichannel.hxx
Channel not open
CVssIOCTLChannel::Call
previous IOCTL hasn't yet completed
CreateEvent(NULL, TRUE, FALSE, NULL)
Could not extend the output buffer
IOCTL sent: %lx on device %s
 Input buffer size: %ld, Output buffer size: %ld
IOCTL %lx failed on device %s - 0x%08lx. Error code = 0x%08lx
IOCTL %lx succeeded on device %s - 0x%08lx. 
 Output buffer: size received = %ld
VssAPI: DllMain got unexpected reason code (%d), lpReserved: %sNULL
CoCreateInstance
GetProviderMgmtInterface
Exception
ReturnNt
ReturnHr
LogNt
LogHr
FailFast
%hs(%u)\%hs!%p: 
%hs!%p: 
(caller: %p) 
%hs(%d) tid(%x) %08X %ws
Msg:[%ws] 
CallContext:[%hs] 
[%hs(%hs)]
[%hs]
kernelbase.dll
onecore\internal\sdk\inc\wil\opensource\wil\resource.h
WilError_03
ntdll.dll
WilFailureNotifyWatchers
CVssJetWriter::InitializeThreadFunc
WSHJTWRC
base\stor\vss\modules\vssapi\jetwriter.cpp
CoInitializeEx failed 0x%08lx
CvssIJetWriter::Initialize failed
CvssIJetWriter::Initialize failed [0x%08lx]
Error loading VSS.DLL [0x%08lx]
VssLoadString
CVssResource::LoadStringW
TRCTRCC
base\stor\vss\modules\trace\fntracer.cpp
Error loading VSS.DLL resource with ID = 0x%08lx [0x%08lx]
ENTER
Unknown
vsstrace.dll
CVssRequestorActivity
BUECXMLC
base\stor\vss\modules\backupext\vsxml\vs_cmxml.cxx
Calling Initialize during safe mode
ResetEvent(cancelEvent)
CVssBackupComponents::PostGatherWriterStatus
::WaitForSingleObject(cancelEvent, INFINITE) 
Registry writer failed to respond, severe error
CoCreateGuid
System
UNDEFINED
CVssWorkerThread::FinalReleaseWorkerThreadObject
INCWORKH
base\stor\vss\inc\worker.hxx
Bad state %d
TornComponentsMax
Returning HRESULT: 0x%08lx
BootableSystemState
SystemService
UserData
Other
TransactionDb
NonTransactionDb
No alternate writer
BackEnd
FrontEnd
SystemRM
Automatic
CVssWriterImpl::SetupEvent
Failure to create event object due to error %d.
CVssWriterImpl::Initialize
You cannot initialize the writer twice
alternate writer not supported
invalid usage type
invalid source typ
Called CVssWriterImpl::Initialize() with:
UsageType             = %s
SourceType            = %s
AppLevel              = %s
FreezeTimeout         = %d (ms)
AlternateWriterState  = %s
IOThrottlingOnly      = %s
Calling Initialize during setup
Writer is not privileged
NULL writer name
Invalid app level %d
Cannot allocate writer instance name
Cannot allocate writer name
InstanceId for Writer %s is{%.8x-%.4x-%.4x-%.2x%.2x-%.2x%.2x%.2x%.2x%.2x%.2x}
Failure to create mutex object due to error %d.
CVssWriterImpl::DoAbort
Entering operation Abort
Abort skipped in state %d
OnAbort failed. hr = 0x%08lx
CVssWriterImpl::Subscribe
Writer is inactive during setup or safe mode
Event System is not present. Writer support is disabled. Error 0x%08lx
You must initialize the writer before other operations
bad event flags
The writer has already called the Subscribe function.
about to enter context callback
IEventSubscription::put_SubscriptionName
IEventSubscription::put_EventClassID
IEventSubscription::put_InterfaceID
IEventSubscription::put_SubscriberInterface
IEventSubscription::put_PerUser
IEventSubscription::PutSubscriberProperty
IEventSystem::Store
IEventSubscription::get_SubscriptionID
CVssWriterState::MarkStateCompleted
CVssSidCollection::Initialize
m_SDWriters.Initialize() failed
m_SDRequestors.Initialize() failed
m_SDBoth.Initialize() failed
SetOwner
SetGroup
CVssSidCollection::IsProcessValidWriter
SYSTEM\CurrentControlSet\Services\VSS\VssAccessControl
CVssRegistryKey::Close
Error on closing key with name %s. lRes == 0x%08lx
CVssRegistryValueIterator::GetCurrentValueName
CVssRegistryValueIterator::GetCurrentValueNameLen
CVssRegistryValueIterator::GetCurrentValueType
CVssMachineInformation::IsDuringSetup
CVssMachineInformation::IsDuringSafeMode
SafeBoot option 0x%08lx
Unrecognized safe mode option %ud
ProductType
OptionValue
SYSTEM\CurrentControlSet\Control\Safeboot\Option
UpgradeInProgress
SystemSetupInProgress
SYSTEM\Setup
JTWIJTWC
base\stor\vss\modules\jetwriter\ijetwriter.cpp
ESENT ERROR {%.8x-%.4x-%.4x-%.2x%.2x-%.2x%.2x%.2x%.2x%.2x%.2x} %s: %ld
Function
EERROR_BAD_FORMAT
GetLastError( )
SOFTWARE\MICROSOFT\WINDOWS NT\CurrentVersion\ASR\RestoreSession
E_FAIL
\\?\GLOBALROOT%s
\Device\VolMgrControl
hDisk
InstanceCount
puiDriveTypeOut
GetDriveTypeByHandle
::NtQueryVolumeInformationFile( hDisk, &IoStatusBlock, &DeviceInfo,sizeof(DeviceInfo), FileFsDeviceInformation)
?Tf^a
*ppwszAttributeData
hError
7rR,Z
ActivityStoppedAutomatically
VSS_BackupComponents_OpResult
CVssBackupComponents
State
SessionId
SnapshotSetId
StateFlags
Context
HrCoordInit
CVssFunctionTracer
FunctionName
FileAlias
FileName
LineNumber
CurrentContexts
HResult
ExtraParam1
VSS_BackupComponents_OpResult
CVssBackupComponents
State
SessionId
SnapshotSetId
StateFlags
Context
HrCoordInit
CVssFunctionTracer
FunctionName
FileAlias
FileName
LineNumber
CurrentContexts
HResult
ExtraParam1
VSS_BackupComponents_OpResult
CVssBackupComponents
State
SessionId
SnapshotSetId
StateFlags
Context
HrCoordInit
CVssFunctionTracer
FunctionName
FileAlias
FileName
LineNumber
CurrentContexts
HResult
ExtraParam1
ExtraParam2
ExtraParam3
ActivityError
PartA_PrivTags
wilActivity
hresult
fileName
lineNumber
module
failureType
message
threadId
callContext
originatingContextId
originatingContextName
originatingContextMessage
currentContextId
currentContextName
currentContextMessage
failureId
failureCount
function
ActivityError
PartA_PrivTags
wilActivity
hresult
fileName
lineNumber
module
failureType
message
threadId
callContext
originatingContextId
originatingContextName
originatingContextMessage
currentContextId
currentContextName
currentContextMessage
CVssRequestorActivity
PartA_PrivTags
wilActivity
hresult
threadId
phase
CVssBackupComponents
State
SessionId
SnapshotSetId
StateFlags
Context
HrCoordInit
CVssRequestorActivity
PartA_PrivTags
PartA_PrivTags
wilActivity
hresult
fileName
lineNumber
module
failureType
message
threadId
callContext
originatingContextId
originatingContextName
originatingContextMessage
currentContextId
currentContextName
currentContextMessage
phase
CVssBackupComponents
State
SessionId
SnapshotSetId
StateFlags
Context
HrCoordInit
WriterMetadata
IdInstance
IdWriter
InstanceName
WriterName
BackupSchema
ExpressWriter
WriterHasRestorePlan
Usage
Source
RestoreMethod
WriterRestore
Reboot
MajorVersion
MinorVersion
TotalComponents
State
HrWriterFailure
HrApplication
WriterMetadata
IdInstance
IdWriter
InstanceName
WriterName
BackupSchema
ExpressWriter
WriterHasRestorePlan
Usage
Source
RestoreMethod
WriterRestore
Reboot
MajorVersion
MinorVersion
TotalComponents
State
HrWriterFailure
HrApplication
ComponentTypes
HComponentsPerType
VSS_BackupComponents_OpResult
CVssBackupComponents
State
SessionId
SnapshotSetId
StateFlags
Context
HrCoordInit
CVssFunctionTracer
FunctionName
FileAlias
FileName
LineNumber
CurrentContexts
HResult
CVssRequestorActivity
PartA_PrivTags
wilActivity
threadId
CVssRequestorActivity
PartA_PrivTags
wilActivity
hresult
threadId
CVssRequestorActivity
PartA_PrivTags
PartA_PrivTags
wilActivity
hresult
fileName
lineNumber
module
failureType
message
threadId
callContext
originatingContextId
originatingContextName
originatingContextMessage
currentContextId
currentContextName
currentContextMessage
FallbackError
PartA_PrivTags
wilResult
hresult
fileName
lineNumber
module
failureType
message
threadId
callContext
originatingContextId
originatingContextName
originatingContextMessage
currentContextId
currentContextName
currentContextMessage
failureId
failureCount
function
FallbackError
PartA_PrivTags
wilResult
hresult
fileName
lineNumber
module
failureType
message
threadId
callContext
originatingContextId
originatingContextName
originatingContextMessage
currentContextId
currentContextName
currentContextMessage
Microsoft.Windows.Storage.VSSTraceLogProvider
API-MS-Win-Core-LocalRegistry-L1-1-0.dll
RegDeleteKeyExW
advapi32.dll
RegDeleteKeyW
CLSID
ForceRemove
NoRemove
Delete
TYPELIB
HKEY_CLASSES_ROOT
HKEY_CURRENT_USER
HKEY_LOCAL_MACHINE
HKEY_USERS
HKEY_PERFORMANCE_DATA
HKEY_DYN_DATA
HKEY_CURRENT_CONFIG
Module
LocalServer32
REGISTRY
generic
unknown error
iostream
iostream stream error
system
Arithmetic overflow.  wAlignmentOffset = %hu was larger than m_wAlignmentBytes = %hu
CVssIOCTLChannel::ApplyAlignment
Arithmetic overflow. m_wAlignmentBytes = %hu too large
Opening a handle to %s (access = 0x%08lx, share = 0x%08lx)
CVssIOCTLChannel::Open
Error: the buffer is too small to fit %s (%d < %d)
Error: the object name %s does terminate with a backslash
StringCchCopyN
Could not open the object '%s'. [0x%08lx]
The object '%s'. was opened under the device handle 0x%08lx
GetVolumeNameForVolumeMountPoint(%s,...) failed with error code 0x%08lx
\\?\UNC\
VssAPI::IsVolumeSnapshotted
IsVolumeSnapshottedInternal
FAILED as insufficient privileges to call shim
FAILED as invalid parameters
OpenSCManager(NULL,NULL,SC_MANAGER_CONNECT)
 OpenService (shSCManager, '%s', SERVICE_QUERY_STATUS)
QueryServiceStatus (shSCService, &sSStat)
CoCreateInstance(CLSID_VSSCoordinator)
RegOpenKeyExW(%ld,%s\%s,...) = ERROR_FILE_NOT_FOUND
Encountering a non-fixed volume (%s) - %ud
Volume (%s) not supported for snapshots 0x%08lx
this function can only be called by an admin
Software Provider
ShouldBlockRevertInternal
method not implemented in client SKU
Invalid name for key under WritersBlockingRevert
CreateVssBackupComponents
InitializeForBackup
DisableWriterClasses
GatherWriterMetadata
QueryStatus
QueryStatus OUT param
Application %s has registered to block volumes.
Invalid type for value under ApplicationsBlockingRevert
Application %s has successfully blocked volume %s from revert using value %s.
Value %s identified as volume name or mount point, but does not match the queried volume.
Key value element %s does not match the volume name and is not a mount point.
CheckFilesOnVolume
GetWriterMetadataCount
GetWriterMetadata
GetIdentity
GetFileCounts
GetComponent
GetComponentInfo
GetFile
GetPath
GetVolumePathName
Volume reported for this component is invalid. We assume that component is not torn.
StringCchCopy
GetDatabaseFile
GetDatabaseLogFile
GetVolumeNameForVolumeMountPoint
GetVolumeName
NormalizeUNCPath
pwszOriginalUNCPath=%s bNormalizeToFQDN=%d
Server name %s normalization failed
\\%s\%s\
StringCchPrintf(%p, %d, %s, %s) failed
GetRootAndLogicalPrefixPathsInternal
NULL required input parameter.
GetVolumePathName is fail on the path %s, winerror 0x%08lx.
Expand mapped drive letter of share failed
GetVolumeNameForVolumeMountPoint is now failing on the volume, winerror 0x%08lx. 
Memory allocation failed.
ResolveDfsTargets
GetVolumePathName fail on DfsTarget: %s, winerror 0x%08lx.
NormalizeUNCPath for DFS RootPath
Invalid uLogicalPrefixPathSize length
CoTaskMemAlloc for uLogicalPrefixPathSize
NormalizeUNCPath for non-DFS RootPath
invalid string position
string too long
CVssIOCTLChannel::Unpack
Output buffer overflow. Trying to read non-existent arguments. m_pbOutputBuffer = %p, m_dwOutputCurrentOffset = %lu, dwSize = %lu, m_dwOutputCurrentOffset = %lu
IOCTL Unpack overflow
Output buffer overflow. Reading bad arguments. dwSize = %lu
Arithmetic overflow. m_dwOutputCurrentOffset = %lu or dwSize = %lu too large.
Providers
SYSTEM\CurrentControlSet\Services\VSS\Settings
SYSTEM\CurrentControlSet\Services\VSS\Settings\WritersBlockingRevert
SYSTEM\CurrentControlSet\Services\VSS
SYSTEM\CurrentControlSet\Services\VSS\Settings\ApplicationsBlockingRevert
TornComponentsBlockRevert
InitializeCriticalSectionAndSpinCount(&m_cs, 0x80000400)
Initialization failed
Unexpected error
RaiseFailFastException
RtlDllShutdownInProgress
RtlDisownModuleHeapAllocation
SNAPSHOT_SET_DESCRIPTION
snapshotSetId
xmlns
x-schema:#VssComponentMetadata
context
CreateVssBackupComponentsInternal
NULL output pointer
The client process is not running under an administrator account or does not have backup privilege enabled
CreateVssExamineWriterMetadataInternal
Cannot allocate CVssExamineWriterMetadataLite
XML passed to CreateVssExamineWriterMetadata was invalid
Cannot allocate CVssExamineWriterMetadata
CreateVssSnapshotSetDescription
NULL output parameter.
Missing root element
Can't allocate snapshot set description.
LoadVssSnapshotSetDescription
Cannot allocate snapshot set description.
CreateVssExpressWriterInternal
IVssExpressWriter
{00000000-0000-0000-0000-00000000-0000}
Caller has insufficient privileges for creating express writer
Local\SM0:%lu:%lu:%hs
NP6:+
CVssJetWriter::Initialize
CreateThread failed with error %d
CVssJetWriter::OnIdentify
CVssJetWriter::OnPrepareBackupBegin
CVssJetWriter::OnPrepareBackupEnd
CVssJetWriter::OnPrepareSnapshotBegin
CVssJetWriter::OnPrepareSnapshotEnd
CVssJetWriter::OnFreezeBegin
CVssJetWriter::OnFreezeEnd
CVssJetWriter::OnThawBegin
CVssJetWriter::OnThawEnd
CVssJetWriter::OnPostSnapshot
CVssJetWriter::OnAbortBegin
CVssJetWriter::OnAbortEnd
CVssJetWriter::OnBackupCompleteBegin
CVssJetWriter::OnBackupCompleteEnd
CVssJetWriter::OnPreRestoreBegin
CVssJetWriter::OnPreRestoreEnd
CVssJetWriter::OnPostRestoreBegin
CVssJetWriter::OnPostRestoreEnd
CVssJetWriter::GetCurrentVolumeArray
CVssJetWriter::GetCurrentVolumeCount
CVssJetWriter::GetSnapshotDeviceName
CVssJetWriter::GetCurrentSnapshotSetId
CVssJetWriter::GetContext
CVssJetWriter::GetCurrentLevel
CVssJetWriter::IsPathAffected
CVssJetWriter::IsBootableSystemStateBackedUp
CVssJetWriter::AreComponentsSelected
CVssJetWriter::GetBackupType
CVssJetWriter::GetRestoreType
CVssJetWriter::IsPartialFileSupportEnabled
CVssJetWriter::SetWriterFailure
CVssModuleKeeper::CVssModuleKeeper
MDULKPRC
base\stor\vss\modules\vssapi\modulekeeper.cxx
CVssModuleKeeper::~CVssModuleKeeper
VssReallocString
CVssAutoCoString::Reallocate
CVssAutoCoString::Append
StringCchCatW(m_pwsz, cchNewLength + 1, pwsz)
COM Call %S failed [0x%08lx]
0x%08lx, %s
0x%08lx
Tracing started or updated. PID=%d, CommandLine=[%s], UserName=[%s]. SQN=[%d -> %d]
TRACING_STARTED
CVssFunctionTracer::UpdateLocalIsTracingEnabledFlag
StaticTrace failed due to out of memory condition
STATIC
DebugTrace failed due to out of memory condition
TraceInternalWithFormat failed due to out of memory condition
internal tracing buffer - out of memory
CVssFunctionTracer::GetCurrentContexts
Name: %s\%s, SID:%s
TRACE
TRACE_BINARY
THROW
re-throwing %#x
HRESULT 0x%08lx rethrown by %s
CVssFunctionTracer::ReThrow
Out of memory detected in function %s
ERROR_DISK_FULL detected in function %s
VSS_E_SNAPSHOT_SET_IN_PROGRESS detected in function %s
Unexpected error in routine %s.  hr = 0x%08lx
Out of memory detected in function %s - %s
ERROR_DISK_FULL detected in function %s - %s
Unexpected error in routine %s - %s. hr = 0x%08lx
Unexpected error in routine %s. hr = 0x%08lx
Out of memory detected. %s. Provider ID = {%.8x-%.4x-%.4x-%.2x%.2x-%.2x%.2x%.2x%.2x%.2x%.2x}
Invalid argument detected. %s. Provider ID = {%.8x-%.4x-%.4x-%.2x%.2x-%.2x%.2x%.2x%.2x%.2x%.2x}
Provider veto detected. %s. Provider ID = {%.8x-%.4x-%.4x-%.2x%.2x-%.2x%.2x%.2x%.2x%.2x%.2x}
Volume not supported. %s. Provider ID = {%.8x-%.4x-%.4x-%.2x%.2x-%.2x%.2x%.2x%.2x%.2x%.2x}
Bad state. %s. Provider ID = {%.8x-%.4x-%.4x-%.2x%.2x-%.2x%.2x%.2x%.2x%.2x%.2x}
Snapshot id not found. %s. Provider ID = {%.8x-%.4x-%.4x-%.2x%.2x-%.2x%.2x%.2x%.2x%.2x%.2x}
Volume not supported by provider. %s. Provider ID = {%.8x-%.4x-%.4x-%.2x%.2x-%.2x%.2x%.2x%.2x%.2x%.2x}
Cannot revert DiskID. %s. Provider ID = {%.8x-%.4x-%.4x-%.2x%.2x-%.2x%.2x%.2x%.2x%.2x%.2x}
Insufficient storage. %s. Provider ID = {%.8x-%.4x-%.4x-%.2x%.2x-%.2x%.2x%.2x%.2x%.2x%.2x}
Snapshot set creation is already in progress. %s. Provider ID = {%.8x-%.4x-%.4x-%.2x%.2x-%.2x%.2x%.2x%.2x%.2x%.2x}
Unexpected error calling a provider routine: %s  [hr = 0x%08lx] Provider ID = {%.8x-%.4x-%.4x-%.2x%.2x-%.2x%.2x%.2x%.2x%.2x%.2x}
ERROR_DISK_FULL detected. %s
Out of memory detected. %s.
Invalid device when calling a provider routine: %s
Timeout error calling a provider routine: %s.
Unexpected error calling a provider routine: %s  [hr = 0x%08lx] 
%s event failed at one writer. hr = 0x%08lx
CVssFunctionTracer::TranslateWriterReturnCode
WARNING: %s [hr = 0x%08lx]
CVssFunctionTracer::LogVssStartupAttempt
VSS information: Service starting at request of process '%s'. [0x%08x]
RegisterEventSource failed, %#x
CVssFunctionTracer::SafeLogEvent
Too many substitution strings, %d
ReportEvent failed, %#x
CVssFunctionTracer::LogError
- Code: %8ls%08lu- Call: %8ls%08lu- PID:  %08lu- TID:  %08lu- CMD:  %-*ls- User: %-*ls
Current context: '%s'
Error on RegisterEventSourceW 0x%08lx
Error on ReportEventW 0x%08lx
Error on DeregisterEventSource 0x%08lx
INFO: %s [hr = 0x%08lx]
%s, 0x%08lx, %s
%s, 0x%08lx
HRESULT exception caught: hr: 0x%x
Unexpected COM exception caught: hr: 0x%x
COM error caught: hr: 0x%x
bad_alloc STL exception caught: hr: 0x%x
Unexpected STL exception caught: %s
WRITER_METADATA
x-schema:#VssWriterMetadataInfo
IDENTIFICATION
writerId
instanceId
instanceName
friendlyName
usage
dataSource
majorVersion
minorVersion
BACKUP_LOCATIONS
INCLUDE_FILES
EXCLUDE_FILES
EXCLUDE_FILES_FROM_SNAPSHOT
DATABASE
FILE_GROUP
RESTORE_METHOD
method
service
userProcedure
writerRestore
rebootRequired
ALTERNATE_LOCATION_MAPPING
logicalPath
componentName
caption
restoreMetadata
notifyOnBackupComplete
selectable
selectableForRestore
DATABASE_FILES
DATABASE_LOGFILES
FILE_LIST
DEPENDENCY
componentFlags
filespecBackupType
onWriterId
onLogicalPath
onComponentName
filespec
recursive
alternatePath
version
backupSchema
CVssExamineWriterMetadata::LoadDocument
BUEWXMLC
base\stor\vss\modules\backupext\vsxml\vs_wmxml.cxx
CVssExamineWriterMetadata::Initialize
CVssExamineWriterMetadata::GetIdentity
CVssExamineWriterMetadata::GetFileCounts
IXMLDOMNode::get_nodeType
IXMLDOMNode::get_nodeName
CVssExamineWriterMetadata::GetFileType
BACKUP_LOCATIONS element was not found.
%s element was not found
Can't create CVssWMFiledesc due to allocation failure.
CVssExamineWriterMetadata::GetIncludeFile
CVssExamineWriterMetadata::GetExcludeFile
CVssExamineWriterMetadata::GetComponent
BACKUP_LOCATIONS element was not found
Component was not found
Component %d was not found
Cannot allocate CVssWMComponent due to allocation failure.
CVssExamineWriterMetadata::GetRestoreMethod
CVssExamineWriterMetadata::GetAlternateLocationMapping
NULL output parameter
Cannot find RESTORE_METHOD element
Cannot find ALTERNATE_LOCATION_MAPPING element
Cannot create CVssAlternateLocationMapping due to allocation failure.
CVssExamineWriterMetadata::GetBackupSchema
NULL out parameter
CVssExamineWriterMetadata::GetVersion
CVssExamineWriterMetadata::GetExcludeFromSnapshotCount
CVssExamineWriterMetadata::GetExcludeFromSnapshotFile
CVssExamineWriterMetadata::GetDocument
CVssExamineWriterMetadata::SaveAsXML
CVssExamineWriterMetadata::LoadFromXML
Required input parameter is NULL.
CVssExamineWriterMetadata::QueryInterface
CVssExamineWriterMetadata::GetIdentityEx
CVssExamineWriterMetadata failed. 0x%08lx
CVssWMComponent::GetComponentInfo
Failed to create VSS_COMPONENTINFO
CVssWMComponent::FreeComponentInfo
CVssWMComponent::GetFile
CVssWMComponent::GetDatabaseFile
CVssWMComponent::GetDatabaseLogFile
CVssWMComponent::GetDependency
Cannot find %s element
Cannot find element %s.
Cannot create CVssWMDependency due to allocation failure.
CVssWMComponent::GetComponentFile
Cannot create CVssWMFiledesc due to allocation failure.
CVssWMFiledesc::GetPath
CVssWMFiledesc::GetFilespec
CVssWMFiledesc::GetRecursive
CVssWMFiledesc::GetAlternateLocation
CVssWMFiledesc::GetBackupTypeMask
CVssWMDependency::GetWriterId
CVssWMDependency::GetLogicalPath
CVssWMDependency::GetComponentName
CVssCreateWriterMetadata::Initialize
NULL string input parameter
CVssCreateWriterMetadata::AddIncludeFiles
CVssCreateWriterMetadata::AddExcludeFiles
CVssCreateWriterMetadata::AddExcludeFilesFromSnapshot
CVssCreateWriterMetadata::AddComponent
Component %s already exists
CVssCreateWriterMetadata::AddDatabaseFiles
CVssCreateWriterMetadata::CreateComponentFiles
Invalid element type
BackupLocations element is missing
Component %s::%s was not created
CVssCreateWriterMetadata::AddDatabaseLogFiles
CVssCreateWriterMetadata::AddFilesToFileGroup
CVssCreateWriterMetadata::SetRestoreMethod
CVssCreateWriterMetadata::AddAlternateLocationMapping
RESTORE_METHOD element is not defined.
CVssCreateWriterMetadata::AddComponentDependency
Document contains no components
Component %s\%s was not found
CVssCreateWriterMetadata::SetBackupSchema
CVssCreateWriterMetadata::GetDocument
CVssCreateWriterMetadata::SaveAsXML
CVssCreateWriterMetadata::ConvertMappedNetworkDrivesToUNC
empty document
RANK: new path is %s
RANK: new alt path is %s
CVssCreateWriterMetadata::ConvertMappedDrive
NULL required output parameter.
Input path is not a drive letter
StringCchPrintf
Cannot alloc path
Cannot realloc path
The input path has local drive in it - nothing to convert
Could no map drive %s. WNetGetUniversalName returned %lu
Cannot alloc output
CVssCreateWriterMetadata::QueryInterface
CVssExamineWriterMetadataLite::LoadDocument
CVssExamineWriterMetadataLite::Initialize
CVssExamineWriterMetadataLite::GetIdentity
CVssExamineWriterMetadataLite::GetFileCounts
CVssExamineWriterMetadataLite::GetFileType
CVssExamineWriterMetadataLite::GetIncludeFile
CVssExamineWriterMetadataLite::GetExcludeFile
CVssExamineWriterMetadataLite::GetComponent
CVssExamineWriterMetadataLite::GetRestoreMethod
CVssExamineWriterMetadataLite::GetAlternateLocationMapping
CVssExamineWriterMetadataLite::GetBackupSchema
CVssExamineWriterMetadataLite::GetVersion
CVssExamineWriterMetadataLite::GetExcludeFromSnapshotCount
CVssExamineWriterMetadataLite::GetExcludeFromSnapshotFile
CVssExamineWriterMetadataLite::GetDocument
CVssExamineWriterMetadataLite::SaveAsXML
CVssExamineWriterMetadataLite::LoadFromXML
CVssExamineWriterMetadataLite::QueryInterface
CVssExamineWriterMetadataLite::GetIdentityEx
CVssWMComponentLite::GetComponentInfo
CVssWMComponentLite::FreeComponentInfo
CVssWMComponentLite::GetFile
CVssWMComponentLite::GetDatabaseFile
CVssWMComponentLite::GetDatabaseLogFile
CVssWMComponentLite::GetDependency
CVssWMComponentLite::GetComponentFile
CVssWMFiledescLite::GetPath
CVssWMFiledesc::GetFilespecLite
CVssWMFiledescLite::GetFilespec
CVssWMFiledescLite::GetRecursive
CVssWMFiledescLite::GetAlternateLocation
CVssWMFiledescLite::GetBackupTypeMask
CVssWMDependencyLite::GetWriterId
CVssWMDependencyLite::GetLogicalPath
CVssWMDependencyLite::GetComponentName
BOOTABLE_SYSTEM_STATE
SYSTEM_SERVICE
USER_DATA
OTHER
TRANSACTION_DB
NONTRANSACTIONAL_DB
database
filegroup
never
always
ifReplaceFails
RESTORE_IF_NONE_THERE
RESTORE_IF_CAN_BE_REPLACED
STOP_RESTART_SERVICE
RESTORE_TO_ALTERNATE_LOCATION
REPLACE_AT_REBOOT
REPLACE_AT_REBOOT_IF_CANNOT_REPLACE
RESTORE_STOP_START_SERVICE
CUSTOM
differential
incremental
other
byCopy
import
failed
original
alternate
directed
originalLocation
Atapi
Fibre
iScsi
Virtual
FileBackedVirtual
Spaces
FCPH3
partial
Value %s is neither yes nor no.
CVssMetadataHelper::ConvertToBoolean
BUEHELPC
base\stor\vss\modules\backupext\vsxml\helper.cxx
Value %s is not a valid guid.
CVssMetadataHelper::ConvertToVSS_ID
Invalid usage type
CVssMetadataHelper::WszFromUsageType
The string %s is not a valid usage type
CVssMetadataHelper::ConvertToUsageType
Invalid data source type
CVssMetadataHelper::WszFromSourceType
The string %s is not a valid source type.
CVssMetadataHelper::ConvertToSourceType
Invalid component type
CVssMetadataHelper::WszFromComponentType
The string %s is not a valid component type
CVssMetadataHelper::ConvertToComponentType
Invalid method type %d
CVssMetadataHelper::WszFromRestoreMethod
The string %s is not a valid restore method.
CVssMetadataHelper::ConvertToRestoreMethod
Invalid writerRestore type %d
CVssMetadataHelper::WszFromWriterRestore
CVssMetadataHelper::ConvertToWriterRestore
Invalid backupType %d
CVssMetadataHelper::WszFromBackupType
The string %s is not a valid backup type.
CVssMetadataHelper::ConvertToBackupType
Invalid restore type %d
CVssMetadataHelper::WszFromRestoreType
The string %s is not a valid restore type
CVssMetadataHelper::ConvertToRestoreType
Invalid restoreTarget %d
CVssMetadataHelper::WszFromRestoreTarget
The string %s is not a valid restoreTarget.
CVssMetadataHelper::ConvertToRestoreTarget
CVssMetadataHelper::WszFromFileRestoreStatus
The string %s is not a valid file restore status.
CVssMetadataHelper::ConvertToFileRestoreStatus
Invalid bus type %d
CVssMetadataHelper::WszFromBusType
The string %s is not a valid storage bus type.
CVssMetadataHelper::ConvertToStorageBusType
Invalid interconnect address type %d
CVssMetadataHelper::WszFromInterconnectAddressType
The string %s is not a valid interconnect address type.
CVssMetadataHelper::ConvertToInterconnectAddressType
Invalid rollforward type %d
CVssMetadataHelper::WszFromRollforwardType
The string %s is not a valid rollforward type.
CVssMetadataHelper::ConvertToRollforwardType
CVssMetadataHelper::GetStringAttributeValue
CVssMetadataHelper::GetByteArrayAttributeValue
CVssMetadataHelper::GetVSS_IDAttributeValue
CVssMetadataHelper::GetBooleanAttributeValue
LCMapStringA
CVssMetadataHelper::get_ansi_stringValue
Cannot allocate ANSI string
Failed to allocate byte array.
CVssMetadataHelper::get_byteArrayValue
An empty string is not a valid number
CVssMetadataHelper::get_dwordValue
String %s is not a valid number
CVssMetadataHelper::MissingElement
The %s element is missing.
CVssMetadataHelper::MissingAttribute
The %s attribute is missing.
CVssMetadataHelper::GetElementCount
CVssMetadataHelperLite::GetStringAttributeValue
CVssMetadataHelperLite::GetVSS_IDAttributeValue
CVssMetadataHelperLite::GetBooleanAttributeValue
CVssMetadataHelperLite::get_ansi_stringValue
CVssMetadataHelperLite::get_dwordValue
CVssMetadataHelperLite::GetElementCount
SNAPSHOT_DESCRIPTION
LUN_MAPPING
LUN_INFORMATION
SOURCE_LUN
DESTINATION_LUN
INTERCONNECT_DESCRIPTION
DISK_EXTENT
originalCount
description
metadata
snapshotId
providerId
snapshotAttributes
originatingMachine
isDynamicVolume
serviceMachine
originalVolumeName
timestamp
deviceName
exposedPath
exposedName
startingOffset
extentLength
deviceType
deviceTypeModifier
commandQueueing
busType
vendorId
productId
productRevision
serialNumber
diskSignature
lunID
interconnectAddressType
interconnectAddress
deviceIdentification
sourceDevice
mappedSnapshotId
mappedVolumeName
mappedPathFromRoot
CVssSnapshotSetDescription::LoadFromXML
BUESNAPC
base\stor\vss\modules\backupext\vsxml\snapshot.cxx
Load of snapshot set description document failed
CVssSnapshotDescription::GetProviderId
The provider doesn't exist in the set
CVssSnapshotSetDescription::SaveAsXML
CVssSnapshotSetDescription::GetToplevelNode
CVssSnapshotSetDescription::GetSnapshotSetId
CVssSnapshotSetDescription::GetDescription
CVssSnapshotSetDescription::SetDescription
CVssSnapshotSetDescription::GetMetadata
CVssSnapshotSetDescription::SetMetadata
CVssSnapshotSetDescription::GetContext
CVssSnapshotSetDescription::SetOriginalSnapshotCount
CVssSnapshotSetDescription::GetOriginalSnapshotCount
CVssSnapshotSetDescription::GetSnapshotCount
GetElementCount
CVssSnapshotSetDescription::GetSnapshotDescription
NULL output paramter.
Cannot find the %d snapshot description.
Cannot find the %d snaphot description.
Cannot allocate snapshot description.
CVssSnapshotSetDescription::DeleteSnapshotDescription
CVssSnapshotSetDescription::FindSnapshotHelper
Cannot find the snaphot description for snapshot{%.8x-%.4x-%.4x-%.2x%.2x-%.2x%.2x%.2x%.2x%.2x%.2x}.
CVssSnapshotSetDescription::FindSnapshotDescription
CVssSnapshotSetDescription::AddSnapshotDescription
CVssSnapshotDescription::GetSnapshotId
CVssSnapshotDescription::SetProviderId
CVssSnapshotDescription::GetTimestamp
CVssSnapshotDescription::SetTimestamp
CVssSnapshotDescription::GetAttributes
CVssSnapshotDescription::SetAttributes
CVssSnapshotDescription::GetOrigin
CVssSnapshotDescription::SetOrigin
CVssSnapshotDescription::IsDynamicVolume
CVssSnapshotDescription::SetIsDynamicVolume
CVssSnapshotDescription::GetServiceMachine
CVssSnapshotDescription::SetServiceMachine
CVssSnapshotDescription::GetDeviceName
CVssSnapshotDescription::SetDeviceName
CVssSnapshotDescription::GetExposure
CVssSnapshotDescription::SetExposure
CVssSnapshotDescription::GetMappedSnapshotId
CVssSnapshotDescription::SetMappedSnapshotId
CVssSnapshotDescription::GetMappedOrigin
CVssSnapshotDescription::SetMappedOrigin
CVssSnapshotDescription::GetMappedOriginPath
CVssSnapshotDescription::SetMappedOriginPath
CVssSnapshotDescription::GetLunCount
CVssSnapshotDescription::AddLunMapping
CVssSnapshotDescription::GetLunMapping
Cannot find the %d lun mapping.
Cannot allocate lun mapping.
CVssLunMapping::AddDiskExtent
CVssLunMapping::GetDiskExtentCount
CVssLunMapping::GetDiskExtent
Cannot find the %d disk extent.
CVssLunMapping::GetLunInformation
Cannot find the %s.
Cannot allocate lun information.
CVssLunMapping::GetSourceDevice
CVssLunMapping::SetSourceDevice
CVssLunMapping::GetSourceLun
CVssLunMapping::GetDestinationLun
CVssLunMapping::GetLunId
CVssLunMapping::SetLunId
CVssLunInformation::SetLunBasicType
CVssLunInformation::GetLunBasicType
Bad Device type.
Bad Device type modifier.
CVssLunInformation::GetDiskSignature
CVssLunInformation::SetDiskSignature
CVssLunInformation::AddInterconnectAddress
NULL Required input parameter.
CVssLunInformation::GetInterconnectAddressCount
CVssLunInformation::GetInterconnectAddress
Cannot find the %d interconnect address.
CVssLunInformation::SetStorageDeviceIdDescriptor
NULL required input parameter
CVssLunInformation::GetStorageDeviceIdDescriptor
vssapi.dll
<root>
</root>
BuildDocumentFromString
VSSCHEMA
base\stor\vss\modules\backupext\vsxml\vs_schema.cxx
XML document is too long
First StringCchCat failed
Second StringCchCat failed
Third StringCchCat failed
BuildComponentDocumentFromString
BuildWriterDocumentFromString
BuildExpressWriterDocumentFromString
MaxXmlDocumentSizeMB
SYSTEM\CurrentControlSet\Services\VSS\Settings
Error on initializing the Id 0x%08lx
CVssID::Initialize
AcquireSemaphore
::WaitForSingleObject(semaphore, INFINITE)
::WaitForSingleObject(semaphore, INFINITE) [0x%08lx]
onecore\internal\sdk\inc\wil\opensource\wil\result.h
CInternalWriterData::CComponentIdentifier::CComponentIdentifier
INCCXMLH
base\stor\vss\inc\vs_cmxml.hxx
out of memory
CInternalWriterData::FindRestoreComponent
CInternalWriterData::RemoveRestoreComponent
CInternalWriterData::AddRestoreComponent
component already selected for restore!
could not allocate space for metadata
couldn't allocate space for instance id
BACKUP_COMPONENTS
WRITER_COMPONENTS
BACKUP_METADATA
RESTORE_METADATA
PARTIAL_FILE
DIRECTED_TARGET
RESTORE_TARGET
RESTORE_SUBCOMPONENT
COMPONENT
DIFFERENCED_FILE
bootableSystemStateBackup
componentType
backupSucceeded
ranges
selectComponents
backupType
restoreType
partialFileSupport
backupOptions
restoreOptions
backupStamp
previousBackupStamp
selectedForRestore
additionalRestores
restoreTarget
preRestoreFailureMsg
postRestoreFailureMsg
filesRestored
repair
targetPath
targetFilespec
sourceRanges
targetRanges
lastModifyTimeLow
lastModifyTimeHigh
lastModifyLSN
restoreInstanceId
authRestore
rollForwardType
rollForwardPoint
restoreName
prepareForBackupFailureMsg
PostSnapshotFailureMsg
FailureMsg
ErrorCode
ApplicationErrorCode
VssapiPublisher
CInternalWriterData::SetComponents
ran out of memory
XML data from writer is not valid:{%.8x-%.4x-%.4x-%.2x%.2x-%.2x%.2x%.2x%.2x%.2x%.2x}
CVssComponent::GetLogicalPath
CVssComponent::GetComponentType
CVssComponent::GetComponentName
CVssComponent::GetBackupSucceeded
CVssComponent::GetAlternateLocationMappingCount
CVssComponent::GetPartialFileCount
CVssComponent::GetNewTargetCount
CVssComponent::GetDirectedTargetCount
CVssComponent::GetRestoreSubcomponentCount
CVssComponent::GetFiledescElement
Cannot find %s element.
Couldn't create CVssWMFiledesc due to allocation failure.
CVssComponent::GetAlternateLocationMapping
CVssComponent::GetNewTarget
CVssComponent::GetPartialFile
Cannot find PARTIAL_FILE element.
CVssComponent::GetDirectedTarget
Cannot find DIRECTED_TARGET element.
CVssComponent::GetRestoreSubcomponent
Cannot find RESTORE_SUBCOMPONENT element.
CVssComponent::SetMetadata
Required input paramter is NULL.
Components document is not writeable
CVssComponent::SetBackupMetadata
CVssComponent::SetRestoreMetadata
CVssComponent::GetMetadata
CVssComponent::GetBackupMetadata
CVssComponent::GetRestoreMetadata
CVssComponent::GetPreRestoreFailureMsg
CVssComponent::GetPostRestoreFailureMsg
CVssComponent::GetBackupOptions
CVssComponent::GetRestoreOptions
CVssComponent::GetBackupStamp
CVssComponent::GetPreviousBackupStamp
CVssComponent::IsSelectedForRestore
CVssComponent::GetAdditionalRestores
CVssComponent::AddPartialFile
Cannot be called during restore
Must be called by writer
CVssComponent::AddDirectedTarget
Must be called by writer.
IVssComponent::GetRestoreTarget
Restore target must be Directed.
CVssComponent::SetRestoreTarget
Can only call this function from the writer
Can only be called during restore
CVssComponent::GetRestoreTarget
Must be called during restore.
CVssComponent::SetPreRestoreFailureMsg
Cannot call this function in the requestor.
CVssComponent::SetPostRestoreFailureMsg
CVssComponent::SetBackupStamp
Can only call this function from the writer.
Can only be called during backup.
CVssComponent::GetFileRestoreStatus
CVssComponent::AddDifferencedFilesByLastModifyTime
CVssComponent::AddDifferencedFilesByLastModifyLSN
CVssComponent::GetDifferencedFilesCount
CVssComponent::GetDifferencedFile
Cannot find DIFFERENCED_FILE element.
Invalid parameter specified
CVssComponent::AddDifferencedFiles
CVssComponent::SetPrepareForBackupFailureMsg
Cannot be called during restore.
CVssComponent::SetPostSnapshotFailureMsg
Must be called during backup.
CVssComponent::GetPrepareForBackupFailureMsg
CVssComponent::GetPostSnapshotFailureMsg
CVssComponent::GetAuthoritativeRestore
CVssComponent::GetRollForward
CVssComponent::GetRestoreName
CVssComponent::SetFailure
CVssComponent::SetFailure(%d,%d,%s,%d)
CVssComponent::GetFailure
CVssComponent::GetFailure(%d,%d,%s,%d)
Invalid input parameters.
CVssComponent::GetFailure could not find "%s" attribute.
CVssComponent::QueryInterface
CVssWriterComponents::Initialize
CVssWriterComponents::GetWriterInfo
CVssWriterComponents::GetComponentCount
CVssWriterComponents::GetComponent
Cannot find %d COMPONENT.
Cannot create CVssComponent due to allocation failure
CVssWriterComponents::IsChanged
CVssWriterComponents::SaveAsXML
CVssNULLWriterComponents::GetWriterInfo
CVssNULLWriterComponents::GetComponentCount
CVssNULLWriterComponents::GetComponent
CVssNULLWriterComponents::IsChanged
CVssNULLWriterComponents::SaveAsXML
CVssBackupComponents::CVssBackupComponents
VssModuleKeeper
CVssBackupComponents::~CVssBackupComponents
waiting INFINITE for coordinator thread: %#x
wait returned for coordinator thread: %#x, wait<%d> error<%#x>
CVssBackupComponents already initialized
CVssBackupComponents::BasicInit
CreateSemaphore(NULL, 1, 1,NULL)
CVssBackupComponents::GetSessionId
CLSIDFromString failed
Initialization function was not called
CVssBackupComponents::ValidateInitialized
CVssBackupComponents::InitializeForBackup
Access denied
This Domain Controller has the Active Directory service stopped or is running in Directory Service Restore Mode
GetVSS_IDAttributeValue
ran out of memory allocating snapshot set id!
CVssBackupComponents::SetBackupState
Cannot call this in WinPE
Cannot call this in Safe Mode
CVssBackupComponents::SetRestoreState
CVssBackupComponents::InitializeForRestore
This Domain Controller has the Active Directory service stopped.
CVssAsrWriterRestore::InitializeForRestore
CVssBackupComponents::LoadComponentsDocument
failed to load the following XML document
Load of Backup components document failed
CVssBackupComponents::AddComponent
CVssBackupComponents::AddComponent called at the wrong time
CVssBackupComponents::GetBackupState
Invalid account called function
CVssBackupComponents::GetRestoreState
CVssBackupComponents::CoordGetBackupState
not called from coordinator
CVssBackupComponents::CoordGetRestoreState
Start-from index %u is specified (none zero), but instance-id is %p and bCreateIfNotThere is %u
CVssBackupComponents::PositionOnWriterComponents
WRITER_COMPONENTS element was not found.
Attempt to create a duplicate component.
CVssBackupComponents::FindComponent
Component was not found. %s\%s
CVssBackupComponents::GetCallbackInterface
Error querying for the IDispatch interface.  hr = 0x%08x
VSSEvent
CVssBackupComponents::SetupWriter
CVssBackupComponents::PrepareForBackup
Cannot use this method for restore
Cannot use this method if no writers are involved
Unexpected call to PrepareForBackup in state %d.
CVssBackupComponents::InternalPrepareForBackup
SetEvent(cancelEvent
Requestor
CVssBackupComponents::SaveAsXML
CVssBackupComponents::InternalPrepareForBackup1
IVssWriter::PrepareForBackup (%s)
PostPrepareForBackup failed with hr = 0x%08lx
CVssBackupComponents::PostPrepareForBackup
WaitForSingleObject(cancelEvent, INFINITE) 
CVssBackupComponents::CacheAutoRecoveryInfo
Filling in ComponentFlags Cache info in ProcessAutoRecoverComponent for writer with instance id: {%.8x-%.4x-%.4x-%.2x%.2x-%.2x%.2x%.2x%.2x%.2x%.2x}.
::CreateVssExamineWriterMetadata
IVssExamineWriterMetadata::GetFileCounts
IVssExamineWriterMetadata::GetComponent
IVssWMComponent::GetComponentInfo
Component path= %s ComponentFlag = %u
Memory allocation error while adding to map
Finished Filling in ComponentFlags cache info in ProcessAutoRecoverComponent with %d elements
CVssBackupComponents::ProcessAutoRecoverComponent
CVssBackupComponents::CalculateComponentPath
Component not found!
Found component flag in ProcessAutoRecoverComponent dwComponentFlag = %d elements
Adding VSS_VOLSNAP_ATTR_AUTORECOVER to internal context
IVssBackupComponents::SetContextInternal
CVssBackupComponents::RebuildComponentData
IXMLDOMNode:cloneNode
Cloned node has no children
IXMLDOMNode::replaceChild
CVssBackupComponents::RebuildComponentDataBackup
WRITER_COMPONENTS element didn't contain any components
CVssBackupComponents::RebuildComponentDataRestore
did not find expected component %s\%s under section for writer with instance {%.8x-%.4x-%.4x-%.2x%.2x-%.2x%.2x%.2x%.2x%.2x%.2x}
CVssBackupComponents::AbortBackup
The Coordinator Thread failed to start. No WaitForSingleObject in this case.
SetEvent(m_hTerminateEvent) failed with %u
CVssBackupComponents::StartCoordKeeperThread
Setting impersonation token
SetThreadToken
CoInitializeEx
IVssCoordinatorEx2
SetEvent(m_hReadyEvent) failed with %u
WaitForSingleObject(m_hTerminateEvent, INFINITE) failed with %u
CVssBackupComponents::GatherWriterStatus
CVssBackupComponents::InternalGatherWriterStatus
SetEvent(cancelEvent)
Unable to allocate writer property array
CVssBackupComponents::InternalGatherWriterStatus1
IVssWriter::RequestWriterInfo, Request Writer Status
PostGatherWriterStatus failed with hr = 0x%08lx
CVssBackupComponents::GetWriterStatusCount
NULL output pointer.
GatherWriterStatusAsync was not called or is not complete.
CVssBackupComponents::GetWriterStatus
CVssBackupComponents::GetWriterStatusEx
Invalid writer selection
CVssBackupComponents::FreeWriterStatus
CVssBackupComponents::SetBackupSucceeded
Required input string parameter is NULL.
CVssBackupComponents::SetBackupOptions
CVssBackupComponents::SetSelectedForRestoreEx
Didn't find a running writer with a matching instance id.
Didn't find a running writer that matched the selected component.
cannot restore a component to a different writer class id
The component was previously selected for restore under a different instance
CVssBackupComponents::SetRestoreOptions
CVssAsrWriterRestore::SetRestoreOptions
The ASR object is not created
CVssBackupComponents::SetFileRestoreStatus
CVssBackupComponents::SetAuthoritativeRestore
Can only be called during restore.
CVssBackupComponents::SetRollForward
missing roll-forward point
CVssBackupComponents::SetRestoreName
CVssBackupComponents::AddNewTarget
CVssBackupComponents::SetRangesFilePath
CVssBackupComponents::SetAdditionalRestores
CVssBackupComponents::SetPreviousBackupStamp
CVssBackupComponents::InternalBackupComplete
Invalid state %d for call to BackupComplete.
Can't call BackupComplete without first gathering writer metadata.
A critical piece of information is missing.  Possibly, the backup document was created with an earlier version of the infrastructure.
IVssAsync::Wait
IVssAsync::QueryStatus
DisableWriterInstances
IVssWriter::InternalBackupComplete1
IVssWriter::BackupComplete(%s)
CVssBackupComponents::PostBackupComplete
WaitForSingleObject(cancelEvent, INFINITE)
CVssBackupComponents::BackupComplete
GetWriterComponentsCount
BackupComplete called with no components selected.
CVssBackupComponents::AddAlternativeLocationMapping
CVssBackupComponents::AddRestoreSubcomponent
CVssBackupComponents::InternalPreRestore
Invalid state %d for call to PreRestore.
CVssBackupComponents::InternalPreRestore1
IVssWriter::PreRestore
CVssAsrWriterRestore::PreRestore
CVssBackupComponents::PostPreRestore
CVssBackupComponents::InternalPostRestore
Invalid state %d for call to PostRestore.
CVssBackupComponents::InternalPostRestore1
IVssWriter::InternalPostRestore
CVssAsrWriterRestore::PostRestore
CVssBackupComponents::PostPostRestore
CVssBackupComponents::PreRestore
Cannot use this method for backup
CVssBackupComponents::PostRestore
CVssBackupComponents::FindAndValidateWriterData
Instance id and instance name was not discovered in Identify pass{%.8x-%.4x-%.4x-%.2x%.2x-%.2x%.2x%.2x%.2x%.2x%.2x} %s
WriterSid: %s, TokenOwnerSid: %s
SID for instance id and instance name does not match{%.8x-%.4x-%.4x-%.2x%.2x-%.2x%.2x%.2x%.2x%.2x%.2x} %s
CVssBackupComponents::FindAndValidateWriterDataWithSid
Instance id was not discovered in Identify pass{%.8x-%.4x-%.4x-%.2x%.2x-%.2x%.2x%.2x%.2x%.2x%.2x}
SID for instance id does not match{%.8x-%.4x-%.4x-%.2x%.2x-%.2x%.2x%.2x%.2x%.2x%.2x}
CVssBackupComponents::GetContent
Improper account attempted to call function
Invalid state %d to request BACKUP_COMPONENTS content
CVssBackupComponents::CoordGetContent
not a valid sid
CVssBackupComponents::DoGetContent
A writer that isn't selected for restore is active!
Error querying IXMLDOMElement to the node. 0x%08lx
Failed calling setAttribute on filesRestored with %s
Could not get node interface
CVssBackupComponents::SetContent
CVssBackupComponents::CoordSetContent
Not called from the coordinator
sid is invalid
CVssBackupComponents::GetWriterContent
unexpected NULL pointer
CVssBackupComponents::CoordGetWriterContent
CVssBackupComponents::ExposeCurrentState
     InstanceId for Writer %s is
     wszWriterInstanceName = %s
     exposed state: %d
     exposed failure: 0x%08lx
Invalid Writer state
expose current state called after FreeWriterStatus
CVssBackupComponents::SetContext
The server does not support transportable shadows
Invalid context 0x%08lx
Unexpected call to SetContext in state %d.
Cleared VSS_VOLSNAP_ATTR_TXF_RECOVERY from internal context due to VSS_VOLSNAP_ATTR_NO_AUTORECOVERY presence
IVssSnapshotProvider::SetContext
CVssBackupComponents::SetContextInternal
CVssBackupComponents::StartSnapshotSet
Unexpected call to StartSnapshotSet in state %d.
Failed to allocate BSTR.
CVssBackupComponents::GetSoftwareProviderInterface
QueryInterface(IVssProviderNotifications)
IVssProviderNotifications::OnLoad
CreateEvent(NULL, FALSE, FALSE, NULL)
CVssBackupComponents::GetCoordinatorInterface
passing impersonation token to Coord Keeper Thread
::RevertToSelf()
DuplicateToken(hToken, SecurityImpersonation, m_hInitializeToken)
CreateThread(...)
SetThreadToken(NULL, hToken) failed: %#x
SetThreadToken(NULL, hToken)
rethrowing
::WaitForSingleObject(m_hReadyEvent, INFINITE) 
Failed to create and initialize coordinator proxy
CVssBackupComponents::AddToSnapshotSet
Output parameter is NULL
Cannot call AddToSnapshotSet at this point
CVssBackupComponents::DoSnapshotSet
NULL Output parameter.
Cannot call DoSnapshotSet at this point.
CVssBackupComponents::PostDoSnapshotSet
CVssBackupComponents::DeleteSnapshots
Null output parameter
NULL SourceObjectId
CVssBackupComponents::Query
Error calling Query(). [0x%08lx]
CVssBackupComponents::BreakSnapshotSet
CVssBackupComponents::BreakSnapshotSetEx
CVssBackupComponents::PreFastRecovery
CVssBackupComponents::FastRecovery
CVssBackupComponents::AddSnapshotToRecoverySet
Input snapshot ID is GUID_NULL
Input destination volume is given, but empty string
Must call InitializeForRestore for Resync operation
The client process is not running under an administrator account or does not have restore privilege enabled
Method not implemented on client SKU
Requestor inputs snapID: {%.8x-%.4x-%.4x-%.2x%.2x-%.2x%.2x%.2x%.2x%.2x%.2x}Destination: %s
CVssBackupComponents::ProcessBCD
The SNAPSHOT_SET_DESCRIPTION element is missing. In this case it is possible that the BCD is not that of a transportable snapshot.
IXMLDOMNode::get_xml
CComBSTR::Append
VssCoordinator::InitializeRecoverSet
CVssBackupComponents::RecoverSet
No address given for the ppAsync
CVssBackupComponents::ImportSnapshots
Null output parameter.
CVssBackupComponents::GetSnapshotProperties
GetSnapshot({%.8x-%.4x-%.4x-%.2x%.2x-%.2x%.2x%.2x%.2x%.2x%.2x},%p)
CVssBackupComponents::GatherWriterMetadata
Can't call this function while PrepareForBackup is in progress
Can't call this function twice on the same instance
CVssBackupComponents::GetWriterMetadataCount
Gather writer metadata is not complete
CVssBackupComponents::InternalGatherWriterMetadata
Error querying the IDispatch interface.  hr = 0x%08lx
CVssBackupComponents::InternalGatherWriterMetadata1
IVssWriter::RequestWriterInfo, GatherWriterMetadata
AddExpressWriters failed with 0x%08x
CVssBackupComponents::PostGatherWriterMetadata
Can't allocate writer instance array
Registry Writer did not respond, severe error
CVssBackupComponents::AddWriterData
Two writers with identical instance ids. %s
CreateVssExamineWriterMetadata
IVssExamineWriterMetadata::QueryInterface
IVssExamineWriterMetadata::GetIdentityEx
XML doesn't match parameters to ExposeWriterMetadata
IVssExamineWriterMetadata::GetRestoreMethod
GetBackupSchema
multiple writer with no restore plan
colliding instance names
Cannot create CInternalWriterMetadata because of allocation failure
Didn't find writer with instance id. %s
SID didn't match initialization sid
CVssBackupComponents::AddExpressWriter
StringCchPrintfW to create file name failed with 0x%08x
CreateFile(%s) failed
Application
CreateFile
ReadFile(%s) failed
Non-unicode file found (%s)
Failed AddWriterData
CVssBackupComponents::AddExpressWriters
*.xml
GetWindowsDirectory failed
%s\Vss\Writers\%s\
StringCchPrintfW to create directory failed with 0x%08x
StringCchPrintfW to create mask failed with 0x%08x
FindFirstFile(%s)
FindFirstFile(%s) returned no results
AddExpressWriter failed
Failed FindNextFile with %d
CreateFile("75DFB225-E2E4-4d39-9AC9-FFAFF65DDF06.xml")
AddExpressWriters for System subdirectory failed with 0x%08x
AddExpressWriters for Application subdirectory failed with 0x%08x
wszXMLDocument parameter is NULL
pbIsMetadateStore parameter is NULL
Class or instance IDs are not valid GUIDs
CVssBackupComponents::AddWriterDataWithSid
CVssBackupComponents::ExposeWriterMetadata
    WriterId             = 
    WriterName           = %s
CVssBackupComponents::GetWriterMetadata
CVssBackupComponents::GetWriterMetadataEx
iWriter %d > # of writers(%d)
Cannot create CVssExamineWriterMetadata due to allocation failure.
Metadata supplied by writer {%.8x-%.4x-%.4x-%.2x%.2x-%.2x%.2x%.2x%.2x%.2x%.2x} is invalid.
CVssBackupComponents::FreeWriterMetadata
CVssBackupComponents::FreeWriterComponents
CVssBackupComponents::GetWriterComponentsCount
CVssBackupComponents::GetWriterComponents
Couldn't find %d WRITER_COMPONENT.
Cannot create CVssWriterComponents due to allocation failure.
CVssBackupComponents::IsVolumeSupported
CVssBackupComponents::AddWriterClass
Can't allocate writer class array
CVssBackupComponents::DisableWriterClasses
An invalid combination of arguments was specified
CVssBackupComponents::EnableWriterClasses
Cannot allocate writer class array
CVssBackupComponents::DisableWriterInstances
CVssBackupComponents::IsWriterClassDisabled
CVssBackupComponents::IsWriterInstanceDisabled
CVssBackupComponents::TrimWriters
Couldn't allocate memory for Max Writer Instances
Couldn't allocate memory for Max Writer Instances + 1
Internal error in writer trimming algorithm: iWriterD %d iWriterS %d cWriterInstances %d m_cWriterInstances %d
Internal error in adding deleting writer to trimmed writer array: iWriterD %d iWriterS %d cWriterInstances %d m_cWriterInstances %d
CVssBackupComponents::SetSnapshotSetDescription
Only Volume snapshot service can set snapshot set description.
Rethrow
CVssBackupComponents::ExposeSnapshot
CVssBackupComponents::UnexposeSnapshot
CVssBackupComponents::RevertToSnapshot
RevertToSnapshot({%.8x-%.4x-%.4x-%.2x%.2x-%.2x%.2x%.2x%.2x%.2x%.2x},%s
CVssBackupComponents::QueryRevertStatus
QueryRevertStatus(%s)
CVssBackupComponents::EnableWritersForRestore
CVssBackupComponents::CheckForDeletingWriter
invalid argument
GetVolumePathName is now failing on the volume, winerror 0x%08lx. Autorecovery bit will NOT be set, Deleting writer will NOT do its work even if it should.
GetVolumeNameForVolumeMountPoint is now failing on the volume, winerror 0x%08lx. Autorecovery bit will NOT be set, Deleting writer will NOT do its work even if it should.
IVssExamineWriterMetadata::QueryInterface(IID_IVssExamineWriterMetadataEx)
IVssExamineWriterMetadataEx::GetExcludeFromSnapshotCount
IVssExamineWriterMetadataEx::GetExcludeFromSnapshotFile
GetVolumePathName fails for exclude file path %s
GetVolumeNameForVolumeMountPoint fails for exclude file path %s
Omitted VSS_VOLSNAP_ATTR_AUTORECOVER for internal context due to VSS_VOLSNAP_ATTR_NO_AUTORECOVERY presence
Initialized
SnapshotSetCreated
PrepareForBackup
PrepareForBackupSucceeded
PrepareForBackupFailed
DoSnapshotSet
DoSnapshotSetSucceeded
DoSnapshotSetFailed
BackupComplete
BackupCompleteSucceeded
BackupCompleteFailed
Aborting
Aborted
PreRestore
PreRestoreSucceeded
PreRestoreFailed
PostRestore
PostRestoreSucceeded
PostRestoreFailed
GatheringWriterMetadata
GatheringWriterStatus
CVssBackupComponents::DisconnectWriterCallback
CVssBackupComponents::GetRootAndLogicalPrefixPaths
CVssBackupComponents::LogWriterMetadataAsTelemetry
CVssBackupComponents::LogWritersMetadataAsTelemetry
CVssSafeComPtr<struct IVssCoordinatorEx2>::GetInterface
Error: getting a NULL interface
GetInterfaceFromGlobal({%.8x-%.4x-%.4x-%.2x%.2x-%.2x%.2x%.2x%.2x%.2x%.2x}, %lu)
CVssSafeComPtr<struct IVssCoordinatorEx2>::Reset
RevokeInterfaceFromGlobal(%lu) [%0x08lx]
CVssSafeComPtr<struct IVssCoordinatorEx2>::Initialize
GlobalInterfaceTable
CoCreateInstance-GIT
RegisterInterfaceInGlobal({%.8x-%.4x-%.4x-%.2x%.2x-%.2x%.2x%.2x%.2x%.2x%.2x}, %lu)
DisableAutoRecovery
SYSTEM\CurrentControlSet\Services\VSS\Settings
%I64d
CXMLNode::InsertChild
BUEXMLC
base\stor\vss\modules\backupext\vsxml\vs_xml.cxx
NULL node
IXMLDOMNode::insertBefore
CXMLNode::RemoveChild
IXMLDOMNode::removeChild
CXMLNode::SetAttribute
NULL input argument
IXMLDOMNode::SafeQI
IXMLDOMNode::setAttribute
Error querying IXMLDOMNode to IXMLDOMElement. 0x%08lx
Error querying from IXMLDOMNode to IXMLDOMElement. hr = 0x%08lx
Error querying IXMLDOMElement from the IXMLDOMNode. hr = 0x%08lx
Cannot allocate string
CXMLDocument::Initialize
MSXML30
CXMLDocument::CreateNode
NULL document
IXMLDOMNode::createNode
CXMLNode::InsertNode
CXMLDocument::Next
IXMLDOMNode::get_firstChild
IXMLDOMNode::get_nextSibling
IXMLDOMNode::get_parentNode
CXMLDocument::FindAttribute
NULL argument.
IXMLDOMNode::get_attributes
IXMLDOMNamedNodeMap::getNamedItem
IXMLDOMNode::get_text
CXMLDocument::ResetToDocument
CXMLDocument::ResetToParent
CXMLDocument::IsNodeMatch
IXMLDOMNode::get_NodeType
IXMLDOMNode::get_NodeName
CXMLDocument::FindElement
CXMLDocument::FindElementOneOf
CXMLNode::SaveAsXML
NULL document.
CXMLDocument::LoadFromXML
IXMLDOMNode::loadXML
IXMLDOMDocument::get_parseError
IXMLDOMParseError::get_errorCode
IXMLDOMParseError::get_reason
IXMLDOMParseError::get_srcText
IXMLDOMParseError::get_line
IXMLDOMParseError::get_linepos
XML parse fails, error code 0x%08lx, line %d char %d, reason: %s
(null)
XML parse fails, Problem text: %s
CVssWorkerThread::PrepareJob
_beginthreadex failed. errno = 0x%08lx
CVssWorkerThread::StartJob
ResumeThread(%p) = -1, GetLastError() == 0x%08lx, m_eThreadState == %d
ResumeThread failed. Error: 0x%08lx. State: %d
CVssWorkerThread::ThreadFunction
CVssWorkerThread::Terminate
WaitForSingleObject(%p,INFINITE) == WAIT_FAILED, GetLastError() == 0x%08lx, m_eThreadState == %d
WaitForSingleObject failed. Error: 0x%08lx. State: %d
CVssAsyncBackup::CVssAsyncBackup
BUEASYNC
base\stor\vss\modules\backupext\vsxml\async.cxx
CVssAsyncBackup::~CVssAsyncBackup
CVssAsyncBackup::CreateInstanceAndStartJob
OpenThreadToken( GetCurrentThread(), TOKEN_IMPERSONATE | TOKEN_DUPLICATE | TOKEN_QUERY, TRUE, hToken)
OpenThreadToken succeeded
DuplicateToken(hToken, SecurityImpersonation, hDuplicateToken)
Error creating the CVssAsync instance. hr = 0x%08lx
Error initializing critical section
Error querying the IVssAsync interface. hr = 0x%08lx
CVssAsyncBackup::PrepareJob failed.  hr = 0x%08lx.
Error starting the job. hr = 0x%08lx
Rethrowing after restoring user privilege
CVssAsyncBackup::OnInit
CVssAsyncBackup::OnRun
BackupComponents object is NULL.
Internal PrepareBackup failed. 0x%08lx
Internal BackupComplete failed. 0x%08lx
Internal GatherWriterMetadata failed. 0x%08lx
Internal GatherWriterStatus failed. 0x%08lx
IVssAsync::Wait failed. 0x%08lx
IVssAsync::QueryStatus failed. 0x%08lx
CVssAsyncBackup::OnFinish
CVssAsyncBackup::OnTerminate
CVssAsyncBackup::Cancel
BackupComponents object is NULL
CVssAsyncBackup::Wait
invalid hThread
CVssAsyncBackup::QueryStatus
Output parameter is NULL.
Returning *pHrResult: 0x%08x
GatherWriterStatus
CVssSafeComPtr<struct IVssAsync>::GetInterface
CVssSafeComPtr<struct IVssAsync>::Initialize
CVssSafeComPtr<struct IVssAsync>::Reset
level %d node %s
CVssXMLLiteElement::Trace
INCXLTH
base\stor\vss\inc\vs_xmllite.hxx
XMLLTC
base\stor\vss\modules\xmllite\xmllite.cxx
CreateStreamOnHGlobal
CVssXMLLiteDocument::LoadFromXML
CVssXMLLiteDocument::ResetToDocument
CVssXMLLiteDocument::FindElement
CVssXMLLiteDocument::Next
CVssXMLLiteDocument::FindAttribute
CVssXMLLiteDocument::Parse
CreateXmlReader
UTF-16
CreateXmlReaderInputWithEncodingName
SetInput
GetQualifiedName
MoveToFirstAttribute
GetValue
MoveToElement
vector<T> too long
invalid map/set<T> iterator
map/set<T> too long
CVssExpressWriter::CVssExpressWriter
WRTXWIMP
base\stor\vss\modules\vswriter\vsxwimp.cpp
CVssExpressWriter::~CVssExpressWriter
CVssExpressWriter::CreateMetadata
Already created Express Writer, waiting for save
Already loaded Express Writer, waiting for save
No writer name provided
Writer with this ID or of this type cannot be created
CoCreateGuid failed with 0x%08x
CVssCreateExpressWriterMetadata::CreateInstance failed
First QueryInterface failed
Second QueryInterface failed
Reference count on CVssCreateExpressWriterMetadata is %lu
CVssCreateExpressWriterMetadata::Initialize call failed
CVssExpressWriter::LoadMetadata
Writer identity could not be extracted
CVssExpressWriter::Register
Can't save if not created or loaded beforehand
WriterExists failed with 0x%08x
WriterExists returned 0x%08x - writer already exists
RecreateDirectories returned 0x%08x - directories could not be recreated
CreateFilePath failed with 0x%08x
SaveAsXML call on IVssCreateWriterMetadataEx failed with 0x%08x
CVssExpressWriter::Unregister
Cannot delete, waiting for save
Cannot delete well known writer
WriterExists returned 0x%08x - writer does not exists
DeleteFile for "%s" failed with %d
DeleteFile(%s)
CVssExpressWriter::Cleanup
CVssExpressWriter::CreateFilePath
\Vss\Writers\Application\
\Vss\Writers\System\
GetWindowsDirectoryW failed with %d
%s%s%.8x-%.4x-%.4x-%.2x%.2x-%.2x%.2x%.2x%.2x%.2x%.2x.xml
StringCchPrintfW failed to create file name with 0x%08x
CVssExpressWriter::GetWriterIdentity
CreateVssExamineWriterMetadata failed with 0x%08x
GetIdentity failed with 0x%08x
CVssExpressWriter::SaveData
CreateFile for "%s" failed with %d
CreateFile(%s))
WriteFile for "%s" failed with %d
WriteFile(%s)
CVssExpressWriter::ValidWriterIdentity
Writer ID cannot be GUID_NULL
Using well known writer ID is forbidden
Unsupported usage type provided
CVssExpressWriter::WriterExists
CVssExpressWriter::RecreateDirectories
\Vss\Writers
\Vss\Writers\System
\Vss\Writers\Application
GetWindowsDirectoryW failed with %d.
CVssExpressWriter::RecreateDirectory
StringCchPrintfW failed with %d
D:(A;OICI;FA;;;BO)(A;OICI;FA;;;LS)(A;OICI;FA;;;NS)(A;ID;FA;;;S-1-5-80-956008885-3418522649-1831038044-1853292631-2271478464)(A;CIIOID;GA;;;S-1-5-80-956008885-3418522649-1831038044-1853292631-2271478464)(A;ID;FA;;;SY)(A;OICIIOID;GA;;;SY)(A;ID;FA;;;BA)(A;OICIIOID;GA;;;BA)(A;ID;0x1200a9;;;BU)(A;OICIIOID;GXGR;;;BU)(A;OICIIOID;GA;;;CO)
ConvertStringSecurityDescriptorToSecurityDescriptorW() failed with %d
CreateDirectoryW() failed with %d
GetFileAttributesW() failed with %d
Could not recreate directory, file in place (%08x)
SnapshotTornComponents
EnableRemoteSnapshots
Writer
CVssWriterImpl::Lock
INCWRMPH
base\stor\vss\inc\vswrtimp.h
Lock called when it wasn't initialized
CVssWriterImpl::Unlock
UnsubscribeCallback
CVssWriterImpl::~CVssWriterImpl
*** Destructing object %p
CVssWriterImpl::GetSnapshotDeviceName
A required parameter is NULL
Invalid operation on transportable snapshots with legacy writer involved
GetSnapshotDeviceName must only be called from OnPostSnapshot
Volume %s was not found in the list of snapshot volumes
CVssWriterImpl::BeginSequence
CVssWriterImpl::ResetSequence
CVssWriterImpl::GetSessionId
GetStateForCurrentEvent called from unknown thread
CVssWriterImpl::GetContext
unchanged
auto-recovery masked
Returning context %ld (%s)
CVssWriterImpl::SetWriterFailure
CVssWriterImpl::SetWriterFailureEx
restore
backup
Setting the %s failure status, hr=%#x
The calling thread is not the same thread that originally serviced the event; setting failure state, hr=%#x
CVssWriterImpl::IsPathAffected
IsPathAffected called with path %s
empty volume count
IsPathAffected: Compare m_ppwszVolumeArray[%d]=%s wszVolumeRoot=%s
no matching volume found
CVssWriterImpl::GetCallback
Error querying for IVssWriterCallback interface.  hr = 0x%08lx
Call to CoSetProxyBlanket failed.  hr = 0x%08lx
CVssWriterImpl::CreateBasicWriterMetadata
Cannot create CVssCreateWriterMetadata due to allocation failure.
CVssCreateWriterMetadata::Initialize failed. hr = 0x%08lx
CVssWriterImpl::InternalGetWriterComponents
Cannot allocate instance Id string or instance name string
IVssWriterCallback::GetBackupState failed.  hr = 0x%08lx
IVssWriterCallback::GetRestoreState failed.  hr = 0x%08lx
Cannot get WRITER_COMPONENTS document.  hr = 0x%08lx
Can't allocate CVssWriterComponents object
Internally transferred WRITER_COMPONENTS document is invalid
Failed to initialize WRITER_COMPONENTS document.  hr = 0x%08lx
Internally transferred WRITER_METADATA document is invalid
CVssWriterImpl::InitializeDelayedPostSnapshotCache
Writer is now in Delayed Post Snapshot mode
Error caught. Re-throwing ... hr = 0x%08lx
CVssWriterImpl::InternalGetWriterComponentsCached
CVssWriterImpl::EnterState
Writer state is not a beginning state at the start of snapshot sequence. Previous sequence must have been interupted
Attempt to start snapshot sequence with a duplicate snapshot set id: {%.8x-%.4x-%.4x-%.2x%.2x-%.2x%.2x%.2x%.2x%.2x%.2x}
Sequence for snapshot set {%.8x-%.4x-%.4x-%.2x%.2x-%.2x%.2x%.2x%.2x%.2x%.2x} was aborted.
Current sequence was aborted. Current writer state (%d) does not match the state expected for the state transition (%d)
*** Warning ***: Writer %s with ID {%.8x-%.4x-%.4x-%.2x%.2x-%.2x%.2x%.2x%.2x%.2x%.2x}attempts to reset the previous sequence with Snapshot Set ID {%.8x-%.4x-%.4x-%.2x%.2x-%.2x%.2x%.2x%.2x%.2x%.2x}. Current state = %d
CVssWriterImpl::LeaveState
CVssWriterImpl::StartTimerThreadInternal
SetEvent failed with error %d
CVssWriterImpl::TimerFunc
WaitForSingleObject failed with error %d
Starting Timer Thread
Wait in timer thread failed due to reason %d.
Aborting due to timeout
CVssWriterImpl::RequestWriterInfoInternal
Incorrect flags
Backup Operator privileges are not set
the writer is shutting down
Entering operation RequestWriterInfo(bWriterMetadata == true)
Wait failed due to reason %d.
Writer's OnIdentify method threw and exception.
Writer's OnIdentify method returned false.
ConvertMappedNetworkDrivesToUNC failed with hr = 0x%08lx. Error is ignored
Couldn't allocate memory for ids or name
Cannot save XML document as string. hr = 0x%08lx
Entering operation RequestWriterInfo(bWriterMetadata == false)
Writer %s (%s) has dropped the session status for snapshot set %s
Writer %s exposing state<%d> failure<%#x>
CVssWriterImpl::PrepareForBackupInternal
Entering operation PrepareForBackup
SnapshotSetID         = %s
Couldn't properly begin sequence
Writer's OnPrepareBackup method threw an exception
Writer rejected the preparebackup
CVssWriterImpl::SaveChangedComponents
Couldn't allocate instance id string
Saving WRITER_COMPONENTS document as XML failed.  hr = 0x%08lx
IVssWriterCallback::SetContent failed.  hr = 0x%08lx
CVssWriterImpl::ProcessObjectList
No local volumes in the snapshot set - this is expected only in case of a remote snapshots set
CVssWriterImpl::PrepareForSnapshotInternal
ADMIN privileges are not set
A required in parameter is NULL.
Received Event: PrepareForSnapshot
VolumeNamesList       = %s
improper state transition
a component was torn
Writer's OnPrepareSnapshot method threw an execption
Writer rejected the prepare snapshot
CVssWriterImpl::FreezeInternal
A required parameter is NULL.
Received Event: Freeze
Level                 = %d
Improper entry into state
ResetEvent failed with error %d
Writer's OnFreeze Method threw and exception
Writer rejected the freeze
Cannot create timer args due to allocation failure
Failure to create thread due to error %d.
CVssWriterImpl::ThawInternal
Received Event: Thaw
Writer rejected the thaw
Writer's OnThaw method threw an exception
CVssWriterImpl::PostSnapshotInternal
Received Event: PostSnapshot - Parameters:
SnapshotSetID         = <%s>
SnapshotDevicesList   = <%s>
Writer's OnPostSnapshot method threw an exception
Writer rejected the post Snapshot
CVssWriterImpl::BackupCompleteInternal
Received Event: OnBackupComplete
Empty snapshot set scenario failed to ResetSequence
Writer's OnBackupComplete method threw an exception.
Writer rejected the backup complete
CVssWriterImpl::BackupShutdownInternal
Can only be called from the coordinator
Received Event: OnBackupShutdown
SnapshotSetID = %s
WriterId             = {%.8x-%.4x-%.4x-%.2x%.2x-%.2x%.2x%.2x%.2x%.2x%.2x}
WriterName           = %s
Writer's OnBackupShutdown  method threw an exception.
Writer rejected the backup shutdown
CVssWriterImpl::AbortInternal
Backup privileges are not set
Received Event: Abort
CVssWriterImpl::PreRestoreInternal
Received Event: PreRestore
Restore Operator privileges are not set
backup schema: %#x
The pre-restore event will be serialized
The pre-restore event is not serialized
Writer's OnPreRestore method threw an exception
Writer rejected the prerestore
CVssWriterImpl::PostRestoreInternal
Received Event: PostRestore
The post-restore event will be serialized
The post-restore event is not serialized
Writer's OnPostRestore method threw an exception
Writer rejected the postrestore
CVssWriterImpl::CalculateComponentPath
CVssWriterImpl::CheckTornComponents
skipping torn-component checking due to registry key
caching component data in CheckTornComponents
cIncludes = %u, cExcludes = %u, cComponents = %u
wszWriterQualifiedName = %s
ComponentIndex cache is releasd due to insufficient memory
ComponentIndex cache has %u elements
caching component data finished in CheckTornComponents
IVssComponent::GetComponent
IVssComponent::GetLogicalPath
IVssComponent::GetComponentName
component %s is selected for backup
component %s is found
ComponentIndex cache is released after finding a torn component
warning:  component %s is not found
ComponentIndex cache is released at the end of CheckTornComponents
CVssWriterImpl::CheckTornComponent
checking whether component %s is torn
skipping torn check for the final %d filespecs for performance reasons.  Only the first %d filespecs were checked
CVssWriterImpl::CheckTornFile
path %s in not on any snapshot
Cannot allocate BSTR.
WriterInstanceName
Rethrowing exception
CVssWriterImpl::TerminateTimerThread
CVssWriterImpl::Unsubscribe
Writer infrastructure is in unstable condition due to an unhandled exception.
CVssWriterImpl::UnsubscribeInternal
SubscriptionID == 
allocation of BSTR failed
IEventSystem::Remove
**** Unsubscribe succeeded for [%p] (%u subscriptions removed)
CVssWriterImpl::DisconnectContext
Continuing CoDisconnectContext wait for %d seconds
CoDisconnectContext timed out after %d seconds, but writer unsubscribe will continue
Failed to create CVssWriterImpl.  hr = 0x%08lx
CVssWriterImpl::GetBackupSchemaFromWriterComponents
Unable to generate writer ID string; out of resources
IVssWriterCallback::GetContent
Unable to load the writer components document
Unable to find root element
Unable to find WRITER_COMPONENTS element
CVssWriterImpl::CheckWriterIntegrity
CVssWriterImpl::LogWriterEventRejectedEvent
%#010x
CVssWriterState::CreateNewState
Out of memory error creating writer state object
Out of memory error adding writer state to the list
Old snapshot set
CVssWriterState::LogStateAging
Old operation
Old state
Old failure
Old extended failure hr
Old extended failure message
An older writer session state is being removed. 
CVssWriterState::AgeStates
Removing completed state {%.8x-%.4x-%.4x-%.2x%.2x-%.2x%.2x%.2x%.2x%.2x%.2x}
Removing aborted state {%.8x-%.4x-%.4x-%.2x%.2x-%.2x%.2x%.2x%.2x%.2x%.2x}
Removing zombie state {%.8x-%.4x-%.4x-%.2x%.2x-%.2x%.2x%.2x%.2x%.2x%.2x}
CVssWriterState::FinishBackupComplete
Couldn't call BackupComplete without OnThaw as a previous state [%d]
CVssWriterState::SetBackupCompleteStatus
Can't set backup complete on session id (%#x){%.8x-%.4x-%.4x-%.2x%.2x-%.2x%.2x%.2x%.2x%.2x%.2x}
CVssWriterState::UpdateThreadIdForSession
CVssWriterState::UpdateSessionIdOnBeginSequence
CVssWriterState::GetStateForSession
CVssWriterState::SetNoResponseFailure
Writer sequence no longer in operation, retry
be000cbe-11fe-4426-9c58-531aa6355fc4
ASR Writer
WRTASRWC
base\stor\vss\modules\vswriter\asrwriterrest.cpp
CVssAsrAPIRestore::CreateObject
Asr writer not found
Asr component not found
Exception caught!
CoImpersonateClient
OpenProcessToken
CoRevertToSelf
OpenThreadToken
AllocateAndInitializeSid
CheckTokenMembership
HasPrivilege
PrivilegeCheck
ERROR_INSUFFICIENT_BUFFER expected error . [0x%08lx]
GetTokenInformation
Unexpected error. Final buffer size = %lu, original size was %lu
GetClientTokenOwner
CreateWellKnownSidType
CAutoSid::CreateFromString
ConvertStringSidToSid(%s)
CreateWellKnownSid(type, NULL, NULL, &dwSid)
CreateWellKnownSid(type, NULL, pSid, [%ld])
Invalid user name argument
LookupAccountName fails to give SID size for %s, fReturn %d, winerror %d, dwSid %d, dwDomain %d. This key value is ignored.
User %s specified under VssAccessControl key doesn't exist. This key value is ignored.
LookupAccountName fails for %s, winerror %d. This key value in VssAccessControl is ignored.
LookupAccountName fails unexpectedly for %s, winerror %d. Account ignored.
Invalid SID passed to AddSid
Adding SID %s ...
m_SDRequestors.Deny(...)
m_SDWriters.Deny(...)
m_SDBoth.Deny(...)
m_SDRequestors.Allow(...)
m_SDWriters.Allow(...)
m_SDBoth.Allow(...)
allowed
denied
explicitely
implicitely
WriterSid: %s was %s %s to fire
LookupAccountSid returned with winerror %d, bRes %s.
LookupAccountSid fails unexpectedly, winerror %d.
NetLocalGroupGetMemebers(%s)
NetLocalGroupGetMembers() failed for "%s" with %d
CVssSidCollection::AddSidToRegistry
StringCchVPrintfW()
RegCreateKeyExW(%ld,%s,...)
Key %s already exists
RegCreateKeyExW(%ld,%s,...,[%lu])
RegOpenKeyExW(%ld,%s,...)
CVssRegistryKey::SetValue
RegSetValueExW(0x%08lx,%s,0,REG_DWORD,%ld)
CVssRegistryKey::SetBinaryValue
RegSetValueExW(0x%08lx,%s,0,REG_BINARY,%p.%lu)
RegQueryValueExW(0x%08lx(%s),%s,0,[%lx],0,[%lu])
Unexpected type %lu for a string value 0x%08lx(%s),%s
Expected REG_DWORD type for registry key %s value name %s. The present value has been ignored
Unexpected size %lu for a DWORD value 0x%08lx(%s),%s
Unexpected error: noninitialized iterator
Unexpected error: dwIndex out of scope %lu %lu
CVssRegistryKeyIterator::Attach
RegQueryInfoKeyW(%p, ...)
Unexpected error: attempting to read a value of the wrong type
Unexpected error: current value type changed in the meantime %lu %lu
RegEnumValue(%p,%lu,%p,%lu ...)
Unexpected error: unexpected DWORD size [%ld, %ld]
 NULL or empty parameter
CVssDiag::RecordWriterEvent
CVssDiag::RecordGenericEvent
Parameters %ld, %ld, %ld, 0x%08lx, {%.8x-%.4x-%.4x-%.2x%.2x-%.2x%.2x%.2x%.2x%.2x%.2x}
Event name: %s
CVssDiag::FlushQueue
VSS_IN_IDENTIFY (Enter)
VSS_IN_IDENTIFY (Leave)
VSS_IN_PREPAREBACKUP (Enter)
VSS_IN_PREPAREBACKUP (Leave)
VSS_IN_PREPARESNAPSHOT (Enter)
VSS_IN_PREPARESNAPSHOT (Leave)
VSS_IN_FREEZE (Enter)
VSS_IN_FREEZE (Leave)
VSS_IN_FREEZE_FRONT (Enter)
VSS_IN_FREEZE_FRONT (Leave)
VSS_IN_FREEZE_BACK (Enter)
VSS_IN_FREEZE_BACK (Leave)
VSS_IN_FREEZE_SYSTEM (Enter)
VSS_IN_FREEZE_SYSTEM (Leave)
VSS_IN_FREEZE_RM (Enter)
VSS_IN_FREEZE_RM (Leave)
VSS_IN_FREEZE_KTM (Enter)
VSS_IN_FREEZE_KTM (Leave)
VSS_IN_FREEZE_DTC (Enter)
VSS_IN_FREEZE_DTC (Leave)
VSS_IN_THAW (Enter)
VSS_IN_THAW (Leave)
VSS_IN_THAW_KTM (Enter)
VSS_IN_THAW_KTM (Leave)
VSS_IN_THAW_DTC (Enter)
VSS_IN_THAW_DTC (Leave)
VSS_IN_POSTSNAPSHOT (Enter)
VSS_IN_POSTSNAPSHOT (Leave)
VSS_IN_BACKUPCOMPLETE (Enter)
VSS_IN_BACKUPCOMPLETE (Leave)
VSS_IN_PRERESTORE (Enter)
VSS_IN_PRERESTORE (Leave)
VSS_IN_POSTRESTORE (Enter)
VSS_IN_POSTRESTORE (Leave)
VSS_IN_GETSTATE (Enter)
VSS_IN_GETSTATE (Leave)
VSS_IN_ABORT (Enter)
VSS_IN_ABORT (Leave)
VSS_IN_BACKUPSHUTDOWN (Enter)
VSS_IN_BACKUPSHUTDOWN (Leave)
VSS_IN_BKGND_FREEZE_THREAD (Enter)
VSS_IN_BKGND_FREEZE_THREAD (Leave)
VSS_IN_PROVIDER_BEGINPREPARE (Enter)
VSS_IN_PROVIDER_BEGINPREPARE (Leave)
VSS_IN_PROVIDER_ENDPREPARE (Enter)
VSS_IN_PROVIDER_ENDPREPARE (Leave)
VSS_IN_PROVIDER_PRECOMMIT (Enter)
VSS_IN_PROVIDER_PRECOMMIT (Leave)
VSS_IN_PROVIDER_COMMIT (Enter)
VSS_IN_PROVIDER_COMMIT (Leave)
VSS_IN_PROVIDER_POSTCOMMIT (Enter)
VSS_IN_PROVIDER_POSTCOMMIT (Leave)
VSS_IN_PROVIDER_PREFINALCOMMIT (Enter)
VSS_IN_PROVIDER_PREFINALCOMMIT (Leave)
VSS_IN_PROVIDER_POSTFINALCOMMIT (Enter)
VSS_IN_PROVIDER_POSTFINALCOMMIT (Leave)
VSS_IN_PROVIDER_POSTSNAPSHOT (Enter)
VSS_IN_PROVIDER_POSTSNAPSHOT (Leave)
VSS_IN_PROVIDER_ABORTSNAPSHOTS (Enter)
VSS_IN_PROVIDER_ABORTSNAPSHOTS (Leave)
VSS_IN_DOSNAPSHOT (Enter)
VSS_IN_DOSNAPSHOT (Leave)
VSS_IN_OPEN_VOLUME_HANDLE (Enter)
VSS_IN_OPEN_VOLUME_HANDLE (Leave)
VSS_IN_IOCTL_FLUSH_AND_HOLD (Enter)
VSS_IN_IOCTL_FLUSH_AND_HOLD (Leave)
VSS_IN_IOCTL_RELEASE (Enter)
VSS_IN_IOCTL_RELEASE (Leave)
VSS_IN_IOCTL_NOTIFY_FLUSH_COMPLETE (Enter)
VSS_IN_IOCTL_NOTIFY_FLUSH_COMPLETE (Leave)
VSS_WS_UNKNOWN (SetCurrentState)
VSS_WS_STABLE (SetCurrentState)
VSS_WS_WAITING_FOR_FREEZE (SetCurrentState)
VSS_WS_WAITING_FOR_THAW (SetCurrentState)
VSS_WS_WAITING_FOR_POST_SNAPSHOT (SetCurrentState)
VSS_WS_WAITING_FOR_BACKUP_COMPLETE (SetCurrentState)
VSS_WS_FAILED_AT_IDENTIFY (SetCurrentState)
VSS_WS_FAILED_AT_PREPARE_BACKUP (SetCurrentState)
VSS_WS_FAILED_AT_PREPARE_SNAPSHOT (SetCurrentState)
VSS_WS_FAILED_AT_FREEZE (SetCurrentState)
VSS_WS_FAILED_AT_THAW (SetCurrentState)
VSS_WS_FAILED_AT_POST_SNAPSHOT (SetCurrentState)
VSS_WS_FAILED_AT_BACKUP_COMPLETE (SetCurrentState)
VSS_WS_FAILED_AT_PRE_RESTORE (SetCurrentState)
VSS_WS_FAILED_AT_POST_RESTORE (SetCurrentState)
VSS_WS_FAILED_AT_BACKUPSHUTDOWN (SetCurrentState)
VSS_S_OK (SetCurrentFailure)
((HRESULT)0x800423F0L) (SetCurrentFailure)
((HRESULT)0x800423F1L) (SetCurrentFailure)
((HRESULT)0x800423F2L) (SetCurrentFailure)
((HRESULT)0x800423F3L) (SetCurrentFailure)
((HRESULT)0x800423F4L) (SetCurrentFailure)
((HRESULT)0x800423F5L) (SetCurrentFailure)
((HRESULT)0x80042319L) (SetCurrentFailure)
(Enter)
(Leave)
UNKNOWN_EVENT[0x%08lx] %s
CVssMachineInformation::IsDuringDsrmSafeMode
DSREPAIR
Not DSREPAIR
SafeBoot option 0x%08lx, %s
Fail to find safeboot registry key
CVssMachineInformation::IsDCwithADinDSRM
Returning dc = %s, ad = %s, dsrm = %s
CVssMachineInformation::IsDomainController
Fail to find Product Options registry key
Product type is LanManNt - It is a DC
Product type is not LanManNt - It is not a DC
CVssMachineInformation::IsDCwithAD
Cannot determine whether machine is DC
Failure to use DsRoleGetPrimaryDomainInformation for DC
DsRoleGetPrimaryDomainInformation succeeded but DSROLE_PRIMARY_DOMAIN_INFO_BASIC buffer is NULL
Re-throwing after cleanup
LanManNt
SYSTEM\CurrentControlSet\Control\ProductOptions
Disabled
CVssIJetWriter::ProcessJetInstance
JetGetSystemParameter(JET_paramLogFilePath)
Succeeded
FAILED
CVssIJetWriter::ProcessJetInstance - %s calling JetGetSystemParameter() with instance Log file path '%s' (from ESE) or '%s' full name
JetGetSystemParameter(JET_paramSystemPath)
CVssIJetWriter::ProcessJetInstance - %s calling JetGetSystemParameter() with JET_paramSystemPath / checkpoint file path '%s' (from ESE) or '%s' full name
JetGetSystemParameter(JET_paramBaseName)
JetGetSystemParameter(JET_paramLegacyFileNames)
CVssIJetWriter::ProcessJetInstance - %s calling JetGetSystemParameter() for base name '%s' (from ESE) to form LogFileName '%s' and CheckpointFileName '%s'
CVssIJetWriter::ProcessJetInstance - %s adding component '%s\%s' for jet instance '%s' database '%s' with display name '%s'
CVssIJetWriter::ProcessJetInstance - %s adding database files for instance '%s', database '%s', database file '%s\%s'
CVssIJetWriter::ProcessJetInstance - %s adding log file for instance '%s', database '%s', log file '%s\%s'
CVssIJetWriter::ProcessJetInstance - %s adding checkpoint file for instance '%s', database '%s', checkpoint file '%s\%s'
CVssIJetWriter::OnIdentify
Jet Writer
JetGetInstanceInfo
CVssIJetWriter::OnPrepareBackup
CVssIJetWriter::OnBackupComplete
CVssIJetWriter::OnPrepareSnapshot
CVssIJetWriter::OnFreeze
CVssIJetWriter::OnThaw
CVssIJetWriter::OnPostSnapshot
CVssIJetWriter::OnAbort
CVssIJetWriter::OnPreRestore
CVssIJetWriter::OnPostRestore
CVssIJetWriter::Initialize
Bad FilesToInclude list.
Bad FilesToExclude list.
FAILED creating CVssIJetWriter object due to allocation failure.
FAILED during internal initialisation of CVssIJetWriter object
CVssIJetWriter::Uninitialize
CVssWriterPublisherFilter::SetupIdArrays
FLTRC
base\stor\vss\modules\filter\filter.cxx
Cannot allocate writer class id array
Cannot allocate instance id include array
CVssWriterPublisherFilter::SetupGenericSids
CVssWriterPublisherFilter::PrepareToFire
IMultiInterfaceEventControl::GetSubscriptions
IEventObjectCollection::get_NewEnum
IEnumEventObject::Next
IUnknown::QueryInterface
IEventSubscription::get_OwnerSID
Subscriber with SID (%s) is not allowed to fire
Firing subscriber SID (%s) for method (%s)
FireSubscription
Subscriber with SID (%s) for method (%s) was not fired.
SetupPublisherFilter
Error querying for IMultiInterfaceEventControl interface.  hr = 0x%08lx
IMultiInterfaceEventControl::SetMultiInterfacePublisherFilter
IMultiInterfaceEventControl::put_FireInParallel
ClearPublisherFilter
ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/
GetRestoreOptionDataValuePair
pwszOptionString
ppwszDataStringOut
ppwszValueStringOut
ppwszEndOfPairOut
ERROR_NO_MORE_ITEMS
pwszDataString
pwszValueString
TraceBackupDocument
pwszBackupDoc
StringCchCopyN( wszTraceBuffer, ARRAYSIZE(wszTraceBuffer), pwszStart, CHAR_PER_LINE )
ppVssAsrRestore
CComObject<CVssAsrAPIRestore>::CreateInstance( &pVssAsrApi )
spUnk->QueryInterface( riid, (VOID**)ppVssAsrRestore )
CVssAsrAPIRestore::_ParseRestoreOption
ppdwExcludeDisks
pcExcludeDisks
ppdwIncludeDisks
pcIncludeDisks
pcIncludeAllCritical
pdwRestoreFlags
pwszSystemVolumeName
pwszBootVolumeName
BootVolumeName
*pwszBootVolumeName
SystemVolumeName
*pwszSystemVolumeName
SkipDiskRecreation
CheckAllCritical
ExcludeDisk
IncludeDisk
pListCur
SkipRecreateVHD
InjectDrivers
pdwExcludeArray
pdwIncludeArray
CVssAsrAPIRestore::PreRestore
m_pAsrSys
m_pAsrFmt
m_pAsrLdm
_ParseRestoreOption( &pdwIncludeDisks, &cIncludeDisks, &pdwExcludeDisks, &cExcludeDisks, &cIncludeAllCritical, &dwRestoreFlags, &wszSystemVolumeName, &wszBootVolumeName )
_AsrPerformPreRestore((WCHAR *)pwszMetadata, pdwIncludeDisks, cIncludeDisks, pdwExcludeDisks, cExcludeDisks, dwRestoreFlags, wszSystemVolumeName, wszBootVolumeName )
CVssAsrAPIRestore::PostRestore
m_pAsrSys != NULL
m_pAsrLdm != NULL
m_pAsrFmt != NULL
m_pAsrSys->PerformPostRestore()
m_pAsrLdm->PerformPostRestore(m_pAsrSys)
SOFTWARE
m_pAsrSys->GetRestoredOfflinedHivePath( L"SOFTWARE", &pwszOfflineSoftwareHiveFilePath )
CVssAsrAPIRestore::SetRestoreOptions
pwszRestoreOptions
ERROR_ALREADY_ASSIGNED
CVssAsrAPIRestore::_AsrPerformPreRestore
pwszXmlBuffer
GetLastError()
m_pAsrSys->InitializeForRestore((WCHAR *) pwszXmlBuffer, dwRestoreFlags)
m_pAsrFmt->InitializeForRestore((WCHAR *) pwszXmlBuffer)
m_pAsrLdm->InitializeForRestore((WCHAR *) pwszXmlBuffer)
m_pAsrLdm->InitializePhysicalPackListForRestore()
m_pAsrSys->PerformPreRestore( m_pAsrLdm, pdwIncludeDisks, cIncludeDisks, pdwExcludeDisks, cExcludeDisks )
m_pAsrLdm->PerformPreRestore(m_pAsrSys)
m_pAsrSys->MarkActiveBitOnSystemPartition()
m_pAsrFmt->PerformPreRestore(m_pAsrSys)
wszSystemVolumeName
wszBootVolumeName
m_pAsrSys->SetBootAndSystemVolumeName( wszSystemVolumeName, wszBootVolumeName )
CVssXmlRwDocument::CVssXmlRwDocument
XMLRWC
base\stor\vss\modules\xmlrw\xmlrw.cpp
CVssXmlRwDocument::InitializeFromString
XML size is %ld
CreateStreamOnHGlobal(m_ptrBuffer.GetHGLOBAL(), FALSE, &pStream)
CreateXmlReader( __uuidof(IXmlReader), (LPVOID*) &m_pReader, NULL)
CreateXmlReaderInputWithEncodingName(pStream, NULL, L"UTF-16", FALSE, NULL, &pReaderInput)
m_pReader->SetInput(pReaderInput)
CVssXmlRwDocument::SelectElementIfExists
Current level %d
Selecting element %s on level %d
Target level if found = %d
Target level if not found = %d
m_pReader->Read(&xmlNodeType)
- ERROR: Call %S not succeeded. 
  Error Code = 0x%08lx. Error description = %s
m_pReader->Read(&xmlNodeType)
m_pReader->GetQualifiedName(XML_STR_PARAM(qualifiedName))
m_pReader->GetQualifiedName(qualifiedName.GetBufferAddr(), qualifiedName.GetLengthAddr())
m_pReader->GetNamespaceUri(XML_STR_PARAM(namespaceUri))
m_pReader->GetNamespaceUri(namespaceUri.GetBufferAddr(), namespaceUri.GetLengthAddr())
m_pReader->GetLocalName(XML_STR_PARAM(localName))
m_pReader->GetLocalName(localName.GetBufferAddr(), localName.GetLengthAddr())
* ELEMENT = %s [ns:%s, local:%s], level = %d
* END = %s
CVssXmlRwDocument::SelectAttributeIfExists
Selecting attribute %s
m_pReader->MoveToNextAttribute()
m_pReader->MoveToNextAttribute()
*    ATTRIBUTE = %s [ns:%s, local:%s]
CVssXmlRwDocument::SelectElement
Element '%s' not found
CVssXmlRwDocument::SelectAttribute
Attribute '%s' not found
CVssXmlRwDocument::GetAttributeValue
m_pReader->GetValue(XML_STR_PARAM(attributeValue))
m_pReader->GetValue(attributeValue.GetBufferAddr(), attributeValue.GetLengthAddr())
*       VALUE = '%s'
MX_E_INPUTEND - unexpected end of input
MX_E_ENCODING - unrecognized encoding
MX_E_ENCODINGSWITCH - unable to switch the encoding
MX_E_ENCODINGSIGNATURE - unrecognized input signature
WC_E_WHITESPACE - whitespace expected
WC_E_SEMICOLON - semicolon expected
WC_E_GREATERTHAN - '>' expected
WC_E_QUOTE - quote expected
WC_E_EQUAL - equal expected
WC_E_LESSTHAN - wfc: no '<' in attribute value
WC_E_HEXDIGIT - hexadecimal digit expected
WC_E_DIGIT - decimal digit expected
WC_E_LEFTBRACKET - '[' expected
WC_E_LEFTPAREN - '(' expected
WC_E_XMLCHARACTER - illegal xml character
WC_E_NAMECHARACTER - illegal name character
WC_E_SYNTAX - incorrect document syntax
WC_E_CDSECT - incorrect CDATA section syntax
WC_E_COMMENT - incorrect comment syntax
WC_E_CONDSECT - incorrect conditional section syntax
WC_E_DECLATTLIST - incorrect ATTLIST declaration syntax
WC_E_DECLDOCTYPE - incorrect DOCTYPE declaration syntax
WC_E_DECLELEMENT - incorrect ELEMENT declaration syntax
WC_E_DECLENTITY - incorrect ENTITY declaration syntax
WC_E_DECLNOTATION - incorrect NOTATION declaration syntax
WC_E_NDATA - NDATA expected
WC_E_PUBLIC - PUBLIC expected
WC_E_SYSTEM - SYSTEM expected
WC_E_NAME - name expected
WC_E_ROOTELEMENT - one root element 
WC_E_ELEMENTMATCH - wfc: element type match
WC_E_UNIQUEATTRIBUTE - wfc: unique attribute spec
WC_E_TEXTXMLDECL - text/xmldecl not at the beginning of input
WC_E_LEADINGXML - leading "xml"
WC_E_TEXTDECL - incorrect text declaration syntax
WC_E_XMLDECL - incorrect xml declaration syntax
WC_E_ENCNAME - incorrect encoding name syntax
WC_E_PUBLICID - incorrect public identifier syntax
WC_E_PESINTERNALSUBSET - wfc: pes in internal subset
WC_E_PESBETWEENDECLS - wfc: pes between declarations
WC_E_NORECURSION - wfc: no recursion
WC_E_ENTITYCONTENT - entity content not well formed
WC_E_UNDECLAREDENTITY - wfc: undeclared entity 
WC_E_PARSEDENTITY - wfc: parsed entity
WC_E_NOEXTERNALENTITYREF - wfc: no external entity references
WC_E_PI - incorrect processing instruction syntax
WC_E_SYSTEMID - incorrect system identifier syntax
WC_E_QUESTIONMARK - '?' expected
WC_E_CDSECTEND - no ']]>' in element content
WC_E_MOREDATA - not all chunks of value have been read
NC_E_QNAMECHARACTER - illegal qualified name character
NC_E_QNAMECOLON - multiple colons in qualified name
NC_E_NAMECOLON - colon in name
NC_E_DECLAREDPREFIX - declared prefix
NC_E_UNDECLAREDPREFIX - undeclared prefix
NC_E_EMPTYURI - non default namespace with empty uri
NC_E_XMLPREFIXRESERVED 'xml' prefix is reserved and must have the http://www.w3.org/XML/1998/namespace URI
NC_E_XMLNSPREFIXRESERVED 'xmlns' prefix is reserved for use by XML
NC_E_XMLURIRESERVED xml namespace URI (http://www.w3.org/XML/1998/namespace) must be assigned only to prefix 'xml'
NC_E_XMLNSURIRESERVED xmlns namespace URI (http://www.w3.org/2000/xmlns/) is reserved and must not be used
\Device\DfsClient
CVssUNCPath::SetUNCPath
FSSSHRMC
base\stor\vss\modules\remotevss\util\share\sharemgt.cxx
pwszUNCPath is NULL
Don't support SetUNCPath more than once
UNC path not initialized
UNC Path starts with invalid prefix
CVssUNCPath::GetScopeName
Output ppwszScopeName is NULL
UNC Path has no share scope name component in it
Cannot allocate share scope name
UNC Path has no share name component in it
Cannot allocate share name
CVssUNCPath::GetShareName
Output ppwszShareName is NULL
UNC Path has no scope name component in it
CVssUNCPath::IsUNCPrefixInternal
ReverseDnsLookup
Unable to translate server name in IP address format to host name. Please make sure your DNS servers have IPv4 and IPv6 reverse lookup zones (ip6.arpa and ip.arpa) configured.
ExpandMappedSharePathToUNC
Invalid pwszMappedPath=%s
Input path does not start with a drive letter
Input path is not a locally mapped share
.ipv6-literal.net
CVssCreateExpressWriterMetadata::Initialize
BUEXWXML
base\stor\vss\modules\backupext\vsxml\vs_xwmxml.cxx
Requested usage type is not supported
Failed creating CVssCreateWriterMetadata
CVssCreateExpressWriterMetadata::AddExcludeFiles
CVssCreateExpressWriterMetadata::AddComponent
AddComponent called on Express Writer with notify on backup complete request
AddComponent called on Express Writer with component flags %08x
CVssCreateExpressWriterMetadata::AddFilesToFileGroup
AddFilesToFileGroup called on Express Writer metadata with %08x
AddFilesToFileGroup called on Express Writer with alternate location
CVssCreateExpressWriterMetadata::SetRestoreMethod
SetRestoreMethod called on Express Writer with incorrect writer restore
SetRestoreMethod called on Express Writer with method %d
CVssCreateExpressWriterMetadata::AddComponentDependency
CVssCreateExpressWriterMetadata::SetBackupSchema
SetBackupSchema called on Express Writer metadata with %08x
CVssCreateExpressWriterMetadata::SaveAsXML
pwszFsName
pFsType
FAT32
exFAT
StringCchCopy( pwszFsName, cchFsName, L"FAT" )
StringCchCopy( pwszFsName, cchFsName, L"NTFS" )
StringCchCopy( pwszFsName, cchFsName, L"ReFS" )
StringCchCopy( pwszFsName, cchFsName, L"FAT32" )
StringCchCopy( pwszFsName, cchFsName, L"CDFS" )
StringCchCopy( pwszFsName, cchFsName, L"UDF" )
StringCchCopy( pwszFsName, cchFsName, L"exFAT" )
AsrFmt::InitializeForRestore
pwszXmlDoc
E_OUTOFMEMORY
pStateInfo
FixedVolumes
ERROR_INVALID_NAME
RemovableMedia
pXmlDoc
NumVolumeNames
AsrFmt::_ExtractFixedVolumesFromXml
ppVolume
pNextVolume
VolumeName
NumRemMedia
AsrFmt::_ExtractRemovableMediaFromXml
ppRemMedia
pNextRemMedia
Media
pVolume
VolumeGuid
DosPath
FsName
Label
ClusterSize
AsrFmt::_ExtractVolumeFromXml
pwszGuid
pwszDosPath
pwszLabel
ERROR_INSUFFICIENT_BUFFER
DevicePath
AsrFmt::_ExtractMediaFromXml
pRemMedia
ERROR_INVALID_PARAMETER
AsrFmt::_IsVolumeOnIncludedDisks
pAsrSys
pwszVolumeName
pfIsOnIncludedDisksOut
hVolume
::GetLastError()
FormatInitialise()
AsrFmt::_RestoreVolumeInformation
::StringCchCopy(ARRAY_COUNT_PARAM(wszVolumeRootPath), pVolume->szGuid)
::StringCchCat(ARRAY_COUNT_PARAM(wszVolumeRootPath), L"\\")
::StringCchCopy( ARRAY_COUNT_PARAM(FormatVolInfo.wszVolumePath), pVolume->szGuid )
::StringCchCopy( ARRAY_COUNT_PARAM(FormatVolInfo.wszFsName), pVolume->szFsName)
::StringCchCopy( ARRAY_COUNT_PARAM(FormatVolInfo.wszLabel), pVolume->szLabel)
IsDynamicVolume( pVolume->szGuid, &fDynamicVolume )
GetPartitionInfo( pVolume->szGuid, &PartInfo )
SetMBRPartitionInfo( pVolume->szGuid, &PartInfo )
_RestoreVolumeInformation( pVolume, pfnFveEraseDrive, pfnFveOpenVolume, pfnFveCloseVolume )
AsrFmt::_RestoreEspVolumeInformation
ERROR_NOT_FOUND
DiskGetDriveLayout( pCurSifDisk->AssignedTo->DeviceNumber, &pPhyDriveLayoutEx, &cbDrivelayout )
GetFileSytemName( pCurSifDisk->PartitionInfoTable[iSifPartition].FileSystemType, ARRAY_COUNT_PARAM(FormatVolInfo.wszFsName))
DiskBuildDevicePartitionPath( pCurSifDisk->AssignedTo->DeviceNumber, dwPhyPartNumber, TRUE, ARRAY_COUNT_PARAM(FormatVolInfo.wszVolumePath) )
AsrFmt::PerformPreRestore
_RestoreEspVolumeInformation(pAsrSys)
\??\Volume{
\\.\MountPointManager
hMountMgr
FormatInitialise
fmifs.dll
g_hIfsDll
FormatEx2
FormatRoutineEx2 != NULL
g_dwFormatTlsIndex != TLS_OUT_OF_INDEXES
FormatVolume
hThread
s_FormatVolumeThread
pFormatContext
Quick
fResult
%ws\*
IsVolumeIntact
pwszVolumeRootPath
pwszLabelName
pfIsIntactOut
AsrLdm::IsSifDiskDynamic
pbIsDynamic
pSifDisk
pCurPack->IsDiskInPack( pSifDisk->DeviceNumber, &fInPack )
AsrLdm::OfflineAllPacks
pPackIdNotToOffline
DoVdsIoctlCall(hVdsDriver, IOCTL_VOLMGR_QUERY_PACK_INFO, &QueryPackInBuffer, sizeof(QueryPackInBuffer), (void **)&pQueryPackOutBuffer)
DoVdsIoctlCall(hVdsDriver, IOCTL_VOLMGR_EXPORT_PACK, &ExportPackInBuffer, sizeof(ExportPackInBuffer), NULL)
AsrLdm::OnlinePack
pPackId
DoVdsIoctlCall(hVdsDriver, IOCTL_VOLMGR_IMPORT_PACK, &ImportPackInBuffer, sizeof(ImportPackInBuffer), NULL)
DevicePathToWin32Path(DD_VOLMGR_CONTROL_DEVICE_NAME, ARRAY_COUNT_PARAM(wszVolMgmtCtlPath))
DoVdsIoctlCall(hVdsDriver, IOCTL_VOLMGR_ENUM_PACKS, NULL, 0, (void **)&pOutBuffer)
pPackList
AsrLdm::InitializePhysicalPackListForRestore
AsrLdm::InitializeForRestore
AsrLdm::InitializeFromXMLDoc
NumPacks
AsrLdm
m_pPackList
DynPack
AsrLdm::PropagateDiskNotIntactByPack
pSifDiskList
pSifPack->GetPackId( &guidPackId )
pSifPack->IsDiskInPack( pCurSifDisk->DeviceNumber, &fInPack )
AsrLdm::CheckPackIntactByDisk
pPhyDisk
pfBasicDisks
pfIntact
pCurPack->IsDiskInPack( pPhyDisk->DeviceNumber, &fInPack )
IsBasicDiskEmpty(pSifDisk, &fDiskEmpty)
pPhyPack->GetPackId( &guidPackId )
pPhyPack->CheckPackDiskIntact( pSifDiskList, pfIntact )
pSifPack->IsPackIntact( pSifDiskList, pPhyPack, pfIntact )
AsrLdm::PerformPreRestore
pAsrSystem
hVdsDriver != INVALID_HANDLE_VALUE
pCurSifPack->GetRestoredPackId(&guidRestoredPackId)
AsrLdm::OfflineAllPacks( hVdsDriver, &guidRestoredPackId )
AsrLdm::OnlinePack( hVdsDriver, &guidRestoredPackId)
pCurSifPack->ClearBootSectorForCriticalVolumes(hVdsDriver, &guidRestoredPackId)
pCurSifPack->SetVolumeGuids( hVdsDriver )
pCurSifPack->AreAllSifDisksAssigned( pAsrSystem, &fAssigned )
AsrLdm::PerformPostRestore
pAsrSystem->GetRestoredOfflinedHivePath(L"System", &pwszOfflineSystemHiveFilePath)
::UuidCreate( &guidOfflineHive ) == RPC_S_OK
SafeStrConvertGuidString(&guidOfflineHive, ARRAY_COUNT_PARAM(wszOfflineHive))
::RegLoadKey(HKEY_LOCAL_MACHINE, wszOfflineHive, pwszOfflineSystemHiveFilePath)
AsrRegpOpenHandle(wszOfflineHive, TRUE, &hkeyOfflineSystemHive)
AsrRegpGetDefaultCurrentControlSet(hkeyOfflineSystemHive, &hkeyOfflineDefaultCCS)
m_pPackList[0].PerformPostRestore(hkeyOfflineDefaultCCS)
pInPackId
pDynDiskList
pDynVolList
DynPack::InitializePhysicalPackForRestore
DoVdsIoctlCall(hVdsDriver, IOCTL_VOLMGR_QUERY_PACK_INFO, &PackInBuffer, sizeof(PackInBuffer), (void **)&pPackOutBuffer)
DoVdsIoctlCall(hVdsDriver, IOCTL_VOLMGR_ENUM_DISKS, &DiskInfoInBuffer, sizeof(DiskInfoInBuffer), (void **)&pDiskInfoOutBuffer)
pDynDiskList[ulDiskIndex].Initialize(hVdsDriver, pInPackId, &pDiskInfoOutBuffer->DiskIds[ulDiskIndex])
DoVdsIoctlCall(hVdsDriver, IOCTL_VOLMGR_ENUM_VOLUMES, &VolInfoInBuffer, sizeof(VolInfoInBuffer), (void **)&pVolInfoOutBuffer)
pDynVolList[ulVolumeIndex].InitializePhysicalVolForRestore(hVdsDriver, pInPackId, &pVolInfoOutBuffer->VolumeIds[ulVolumeIndex])
DynPack::InitializeFromXMLDoc
PackId
PackName
IsOnline
NumDynDisks
NumDynVols
IsCritical
pDiskList
DynDisk
pVolumeList
DynVolume
DynPack::AreAllSifDisksAssigned
pfAssigned
DynPack::CreateDisks
::StringCchCopy(ARRAY_COUNT_PARAM(CreateDiskInputBuffer.NewPackName), m_PackInfo.Name)
SafeStrConvertGuidString(&guidCreatedPack, ARRAY_COUNT_PARAM(wszGuidString))
SafeStrConvertGuidString(&pCurrentSifDynDisk->m_DiskId, ARRAY_COUNT_PARAM(wszGuidString))
SafeStrConvertGuidString(&pCreateDiskOutputBuffer->DiskId, ARRAY_COUNT_PARAM(wszGuidString))
SafeStrConvertGuidString(&m_PackId, ARRAY_COUNT_PARAM(wszGuidString))
DynPack::CreateVolumes
pNewPackId
DynPack::RestoreBootVolumePartitionId
pAsrSys->GetSifDiskBySifDevNum( pCurrentSifDynDisk->GetDeviceNumber(), &pSifDisk )
DiskGetDriveLayout( pSifDisk->AssignedTo->DeviceNumber, &pPhyDrivelayoutEx, &cbDrivelayout )
DiskSetDriveLayout(pSifDisk->AssignedTo->DeviceNumber, pPhyDrivelayoutEx, cbDrivelayout)
DynPack::PerformPreRestore
CreateDisks( hVdsDriver, pAsrSys, &guidNewPackId )
CreateVolumes(hVdsDriver, &guidNewPackId)
RestoreBootVolumePartitionId( pAsrSys )
DynPack::PerformPostRestore
SafeStrConvertGuidToStringWithBraces(&m_RestoredPackId, ARRAY_COUNT_PARAM(wszGuidString))
PrimaryPackId
Services\VolMgrx
DynPack::IsDiskInPack
pfInPack
DynPack::IsPackIntact
pPhyPack
pfPackIntact
pCurSifVolume->IsVolumeIntact( pSifDiskList, pCurPhyVolume, &fVolIntact )
DynPack::SetVolumeGuids
pSifDynVol->SetVolumeGuidName( hVdsDriver, &m_RestoredPackId )
DynPack::GetRestoredPackId
pguidRestoredPackId
DynPack::GetPackId
pguidPackId
DynPack::ClearBootSectorForCriticalVolumes
pSifDynVol->ClearCriticalVolumeBootSector( hVdsDriver, pguidRestoredPackId )
DynPack::CheckPackDiskIntact
TraceVmVolumeLayout
pVolumeLayout
SafeStrConvertGuidString(&pNextExtentLayout->DiskId, ARRAY_COUNT_PARAM(wszGuidString))
TraceCreateVolumeInputBuffer
pCreateVolumeInputBuffer
pOrigVolGuid
SafeStrConvertGuidString(pOrigVolGuid, ARRAY_COUNT_PARAM(wszGuidString))
SafeStrConvertGuidString(&pCreateVolumeInputBuffer->PackId, ARRAY_COUNT_PARAM(wszGuidString))
SafeStrConvertGuidString(&pCreateVolumeInputBuffer->VolumeId, ARRAY_COUNT_PARAM(wszGuidString))
TraceQueryVolumeInfoBuffer
pQueryVolumeInfoBuffer
pVolGuid
SafeStrConvertGuidString(pVolGuid, ARRAY_COUNT_PARAM(wszGuidString))
pVolId
pDynPlexList
DynVolume::InitializePhysicalVolForRestore
pDynPlexList[ulPlexIndex].Initialize(hVdsDriver, pPackId, pNextPlexLayout)
DynVolume::IsVolumeIntact
pDynPhyVol
pfVolIntact
pCurSifPlex->IsPlexIntact( pSifDiskList, pCurPhyPlex, &fPlexIntact )
DynVolume::InitializeFromXMLDoc
NumPlexes
HasPartitions
IsBoot
IsSystem
NumSymbolicNames
VolumeLength
pPlexList
DynPlex
DynVolume::PackVolmgmtCreateVolumeBuffer
pcbVolumeInputBuffer
pSifDynDisks
pCreateVolInputBuffer
ERROR_DEVICE_NOT_CONNECTED
DynVolume::CreateVolume
ERROR_INVALID_DATA
SetVolumeGuidName(hVdsDriver, pNewPackId)
DynVolume::SetVolumeGuidName
DoVdsIoctlCall(hVdsDriver, IOCTL_VOLMGR_QUERY_VOLUME_INFO, &VolInfoInBuffer, sizeof(VolInfoInBuffer), (void **)&pVolInfoOutBuffer)
AsrSystem::RestoreVolumeGuids( pwszDeviceName, m_pmwszVolumeNames )
DynVolume::ClearCriticalVolumeBootSector
::StringCchPrintf(wszDevicePath, ARRAYSIZE(wszDevicePath), L"\\\\?\\GLOBALROOT%s", pwszDeviceName )
AsrpClearVolumeBootSector( wszDevicePath )
DynDisk::PutRestoredDiskInfo
DynDisk::Initialize
DynDisk::InitializeFromXMLDoc
IsMissing
PublicOffset
PublicLength
DeviceNumber
DynDisk::TraceQueryDiskInfoBuffer
pQueryDiskInfoBuffer
SafeStrConvertGuidString(&pQueryDiskInfoBuffer->GptDiskId, ARRAY_COUNT_PARAM(wszGuidString))
;&fMt
DynPlex::Initialize
pPlexLayout
pDynMemberList
DynPlex::IsPlexIntact
pPhyPlex
pfPlexIntact
pCurSifMember->IsMemberIntact( pSifDiskList, pCurPhyMember, &fMemberIntact )
DynPlex::InitializeFromXMLDoc
NumMembers
InterleaveLength
Status
Percentage
IsCurrentBoot
IsCurrentSystem
pDynMember
DynMember
DynMember::Initialize
pMemberLayout
pDynExtentList
DynMember::IsMemberIntact
pPhyMember
pfMemberIntact
pCurSifExtent->IsExtentIntact( pSifDiskList, pCurPhyExtent, &fExtentIntact )
DynMember::InitializeFromXMLDoc
NumExtents
pExtentList
DynExtent
DynExtent::Initialize
pExtentLayout
DynExtent::InitializeFromXMLDoc
DiskId
Offset
Length
DynExtent::IsExtentIntact
pPhyDiskExtent
pfExtentIntact
AsrSystem::GetBootVolumeName
ppwszVolumeGuidNameOut
*ppwszVolumeGuidNameOut
pwszVolumeGuidName
TracePhysicalDiskInfo
DiskListMarkOfflineDisks
DeviceIoControl( hDisk, IOCTL_DISK_GET_DISK_ATTRIBUTES, NULL, 0, &DiskAttributes, sizeof(DiskAttributes), &dwBytesReturned, NULL)
AsrSystem::InitializeForRestore
dwRestoreFlags < ASR_ROF_INVALID
Version
DiskBuses
Disks
AsrVhd
_TransferNodesFromList( &m_pDiskListHead, &AsrSystem::_IsVirtual, &pVirtualDiskList )
_JoinLists( &pVirtualDiskList, m_pDiskListHead )
AsrVersion
AsrSystem::_ExtractVersionFromXml
%d.%d
MachineName
Platform
FirmwareType
OSVersion
BootWinDirectory
BootSysDirectory
AutoExtend
AsrSystem::_ExtractSystemFromXml
BusType
NumBusType
AsrSystem::_ExtractDiskBusesFromXml
pdwSifBusType
NumMbrDisks
NumGptDisks
AsrSystem::_ExtractDisksFromXml
MbrDisk
GptDisk
pCurrentDisk
NumPartitions
PartitionTableSize
BusKey
MbrSignature
BytesPerSector
SectorsPerTrack
TracksPerCylinder
NumCylinders
MediaType
DiskSize
IsExcluded
IsShared
AsrSystem::_ExtractMbrDiskFromXml
ppCurrentDisk
pTempDiskInfo
GetDriveLayoutExSize( cEntriesInPartitionTable, &dwCurDriveLayoutExSize )
pTempDiskInfo->pDriveLayoutEx
pTempDiskInfo->pDiskGeometry
pTempDiskInfo->pPartition0Ex
::DWordMult(sizeof(ASR_PTN_INFO), cEntriesInPartitionTable, &cbAsrPartitionInfoTable)
pTempDiskInfo->PartitionInfoTable
MbrPartition
GptGuid
MaxPartition
AsrSystem::_ExtractGptDiskFromXml
tempDiskInfo
GetDriveLayoutExSize( cPartitions, &cbDriveLayoutEx )
tempDiskInfo->pDriveLayoutEx
tempDiskInfo->pDiskGeometry
tempDiskInfo->pPartition0Ex
tempDiskInfo->PartitionInfoTable
GptPartition
PartitionIndex
PartitionFlag
BootFlag
PartitionType
FileSystemType
PartitionOffset
PartitionLength
AsrSystem::_ExtractMbrPartitionFromXml
pPartInfo
pAsrExPartInfo
pulPartitionIndex
PartitionID
GptAttributes
GptName
VhdFileInfo
RelativeFilePath
BlockSize
Flags
Sequence
VirtualDisk
NumFiles
NumDisks
AsrSystem::_ExtractVhdFileInfoFromXml
pVhdFileInfo
AsrSystem::_ExtractVirtualDiskFromXml
ppVirtualDiskInfo
pVirtualDiskInfo
rgVhdFileInfo
AsrSystem::_ExtractAsrVhdFromXml
GetSifDiskBySifDevNum( pVirtualDiskInfo->m_dwDeviceNumber, &pDiskInfo )
VSS_E_INVALID_XML_DOCUMENT
AsrSystem::_ExtractGptPartitionFromXml
AsrSystem::_RestoreDisks
(DWORD) VSS_E_ASRERROR_NO_PHYSICAL_DISK_AVAILABLE
DiskListFreeNonFixedMedia(&pPhysicalDiskList)
DiskListMarkOfflineDisks( pPhysicalDiskList )
_TransferNodesFromList( &pPhysicalDiskList, &AsrSystem::_IsVirtual, &pVirtualDiskList )
(DWORD) VSS_E_ASRERROR_FIXED_PHYSICAL_DISK_AVAILABLE_AFTER_DISK_EXCLUSION
AsrpDisksAssignment(pPhysicalSifDiskList, pPhysicalDiskList, pAsrLdm )
AsrpCheckDiskIntact( pAsrLdm, pPhysicalSifDiskList)
(DWORD) VSS_E_ASRERROR_DISK_RECREATION_FAILED
AsrSystem::_RecoverBcdStore
!( m_dwRestoreFlags & ASR_ROF_SKIP_DISK_RECREATION ) || ( ( wcslen( m_wszSystemVolumeName ) > ::wcslen(L"\\\\?\\") ) && ( _wcsnicmp( m_wszSystemVolumeName, L"\\\\?\\", wcslen(L"\\\\?\\" ) ) == 0 ) )
::StringCchCopy( ARRAY_COUNT_PARAM(wszGlobalPathOfBcdToRestore), m_wszSystemVolumeName )
GetSystemPlex( m_pDiskListHead, TRUE, &pSystemDisk, &dwSifSystemPartitionIndex )
pSystemDisk->AssignedTo
pSystemDisk->pDriveLayoutEx
pSystemDisk->pDriveLayoutEx->PartitionStyle == PARTITION_STYLE_GPT
FindPhysicalPartition( &pSystemDisk->pDriveLayoutEx->PartitionEntry[dwSifSystemPartitionIndex], pSystemDisk->AssignedTo, &dwPhySystemPartNumber )
DiskBuildDevicePartitionPath(dwPhySysDiskNumber, dwPhySystemPartNumber, TRUE, ARRAY_COUNT_PARAM(wszGlobalPathOfBcdToRestore))
\efi\microsoft\Boot\BCD
::StringCchCat(ARRAY_COUNT_PARAM(wszGlobalPathOfBcdToRestore), BCD_STORE_FILEPATH)
::CoCreateGuid( &guidBcdkBkp )
SafeStrConvertGuidString(&guidBcdkBkp, ARRAY_COUNT_PARAM(wszBcdTemp))
::StringCchCopy( ARRAY_COUNT_PARAM(wszGlobalPathOfBcdTemp), wszGlobalPathOfBcdToRestore )
::StringCchCat( ARRAY_COUNT_PARAM(wszGlobalPathOfBcdTemp), wszBcdTemp )
::CopyFileEx( wszGlobalPathOfBcdToRestore, wszGlobalPathOfBcdTemp, NULL, NULL, NULL, 0 )
::StringCchCopy( ARRAY_COUNT_PARAM(wszNtSystemPartition), m_wszSystemVolumeName )
DiskBuildDevicePartitionPath(dwPhySysDiskNumber, dwPhySystemPartNumber, FALSE, ARRAY_COUNT_PARAM(wszNtSystemPartition))
ntStatus
AsrSystem::_UpdateRestoredRegistryMap
AsrSystem::_ClearSystemBootBits
m_SystemInfo.BootWinDirectory
BootStat.dat
AsrSystem::_IsSupportedVersion
ERROR_OLD_WIN_VERSION
AsrSystem::_JoinLists
ppDiskListA
AsrSystem::_TransferNodesFromList
ppDiskList
ppTransferList
!*ppTransferList
AsrSystem::_MarkActiveBitOnSystemPartitionHelper
pSifSystemDisk
pSifSystemDisk->pDriveLayoutEx
pSifSystemDisk->pDriveLayoutEx->PartitionStyle == PARTITION_STYLE_MBR || pSifSystemDisk->pDriveLayoutEx->PartitionStyle == PARTITION_STYLE_GPT
pSifSystemDisk->pDriveLayoutEx->PartitionCount > dwSifSystemPartIndex
DiskGetDriveLayout( dwPhySystemDiskNumber, &pPhySystemDiskDriveLayout, &cbPhySystemDiskDriveLayout)
pSifSystemDisk->pDriveLayoutEx->PartitionStyle == pPhySystemDiskDriveLayout->PartitionStyle
DiskSetDriveLayout( dwPhySystemDiskNumber, pPhySystemDiskDriveLayout, cbPhySystemDiskDriveLayout )
AsrSystem::ExtractAllVolumeNames
ppwszOutVolumeName
pmwszAllVolumeNames
VolumeMountPoint
pbTempBufferVolNames
SymbolicName
AsrSystem::ExtractVolumeSymbolicNameXmlNode
AsrSystem::GetSifDiskAssignTo
pulAssignedToPhyDisk
AsrSystem::GetSifDiskBySifDevNum
ppSifDisk
AsrSystem::RestoreVolumeGuids
pwszDeviceName
pmwszVolumeNames
AsrSystem::PerformPreRestore
ERROR_UNSUPPORTED_TYPE
_RestoreDisks( pAsrLdm, pdwIncludeDisks, cIncludeDisks, pdwExcludeDisks, cExcludeDisks )
AsrSystem::PerformPostRestore
_RecoverBcdStore()
AsrSystem::MarkActiveBitOnSystemPartition
GetSystemPlex(m_pDiskListHead, TRUE, &pSifSystemDisk, &dwSifSystemPartIndex)
_MarkActiveBitOnSystemPartitionHelper( pSifSystemDisk, dwSifSystemPartIndex, pPhySystemDisk->DeviceNumber )
AsrSystem::GetRestoredOfflinedHivePath
pwszHiveFilename
ppwszHivePathnameOut
\config\
ERROR_FILE_NOT_FOUND
AsrSystem::SetBootAndSystemVolumeName
GetSystemPlex
pdwPartitionTableIndex
ppSystemDiskOut
AsrpAssignPartitionsForDisk
GetBootPartition
GetDriveLayoutExSize( pSifDisk->pDriveLayoutEx->PartitionCount, &cbNewDriveLayoutEx )
pSifDisk->AssignedTo
AsrpAssignPartitions
pAssignedTo->pDriveLayoutEx
AsrpAssignVolumeGuids
AsrpAssignPartitionsForDisk( pSifDisk )
DiskBuildDevicePartitionPath( pPhysicalDisk->DeviceNumber, pDriveLayoutEx_Physical->PartitionEntry[dwIndex].PartitionNumber, FALSE, ARRAY_COUNT_PARAM(wszDeviceName) )
pPhysicalDisk
PutBootCodeOnDisk
ERROR_BAD_DEVICE
hPhyDisk
ulBytesPerSector != 0
dwSetFileErrorCode
pbIoBuffer
EraseBitlockedDrive( wszVolumeName, pfnFveEraseDrive, pfnOpenVolume, pfnCloseVolume )
AsrpEraseBitlockedVolume
pbSectorBuffer
AsrpClearBootSector
pDriveLayoutEx
AsrpClearAllBootSectors
pSifPartInfo
FindPhysicalPartition
DiskGetDriveLayout( pPhyDisk->DeviceNumber, &pPhyDriveLayoutEx, &cbDriveLayout)
pdwPartitionNum
pSifPartInfo->PartitionStyle == PARTITION_STYLE_GPT
pSifPartInfo->PartitionStyle == PARTITION_STYLE_MBR
pSifDisk->IsIntact
AsrpClearBootSectorsCriticalVolumeOnly
DiskBuildDevicePartitionPath(dwDeviceNumber, dwPhysicalPartitionNum, TRUE, ARRAY_COUNT_PARAM(wszPartitionDevicePath))
FindPhysicalPartition( pPartionInfoEx, pSifDisk->AssignedTo, &dwPhysicalPartitionNum )
AsrpClearVolumeBootSector(wszPartitionDevicePath)
IsDynamicVolume( wszPartitionDevicePath, &fDynamicVolume )
pwszVolume
AsrpClearVolumeBootSector
DeviceIoControl( hVolume, FSCTL_DISMOUNT_VOLUME, NULL, 0, NULL, 0, &dwBytesReturned, NULL )
hVolume != INVALID_HANDLE_VALUE
::SetFilePointerEx( hVolume, liPositionToSeekTo, NULL, FILE_BEGIN )
DoDiskIoctlCall( hVolume, IOCTL_DISK_GET_DRIVE_GEOMETRY, NULL, 0, (void **)&pDiskGeometry, &cbDiskGeometry)
AsrpRecreateSifDisk
::WriteFile( hVolume, pbSectorBuffer, pDiskGeometry->BytesPerSector, &dwBytesReturned, NULL )
pSifDisk->Style==PARTITION_STYLE_MBR || pSifDisk->Style==PARTITION_STYLE_GPT
pSifDisk != NULL
AsrpClearAllBootSectors( hDisk, pAssignTo->pDriveLayoutEx, pAssignTo->pDiskGeometry->BytesPerSector, pAssignTo->DeviceNumber)
AsrpClearBootSectorsCriticalVolumeOnly(pSifDisk, pAssignTo->DeviceNumber)
AsrpAssignVolumeGuids( pAssignTo, hDisk, pSifDisk )
GetDriveLayoutExSize( pAssignTo->pDriveLayoutEx->PartitionCount, &cbDriveLayoutEx )
AsrpRecreateDisks
\J/IPlA
srVhd::GetDeviceDependencyInformation
wszDevicepath
hDevice != INVALID_HANDLE_VALUE
ppDependencyInfo
pVhdInfo
dwError
AsrVhd::TraceVirtualDiskInfo
\\.\PhysicalDrive%lu
?pDisk
IsBasicDiskEmpty
pDisk->Style == PARTITION_STYLE_MBR || pDisk->Style == PARTITION_STYLE_GPT
pfDiskEmpty
pAsrLdm->IsSifDiskDynamic( pSifDisk, &bDynamicDisk )
AsrpExcludeEmptyBasicSifDisks
!pSifDisk->AssignedTo
IsBasicDiskEmpty( pSifDisk, &bEmpty )
AsrpCheckDiskIntact
!pSifDisk->IsCritical
pAsrLdm
pAsrLdm->CheckPackIntactByDisk( pSifDiskList, pCurSifDisk, pCurPhyDisk, &fBothBasic, &fIntact )
pAsrLdm->PropagateDiskNotIntactByPack( pSifDiskList, pCurSifDisk )
AsrpAssignDiskToRdisk
pAsrLdm->PropagateDiskNotIntactByPack ( pSifDiskList, pCurSifDisk )
VSS_E_ASRERROR_DATADISK_RDISK0
pPhysicalDiskList
ERROR_NO_MATCH
VSS_E_ASRERROR_RDISK0_TOOSMALL
AsrpAssignSystemDisk
AsrpAssignDiskToAnyRDisk
pSifBootDisk
AsrpAssignBootDisk
AsrpBasicDiskAssignmentPass
AsrpAssignBySignature
pfConverted
AsrpConvertRawDisks
ppLastUsedPartition
AsrpFindLastUsedPartition
pbIsDiskResized
AsrpAdjustDiskSizeToUsedPartitionSize
AsrpAdjustDiskSizes
AsrpFindLastUsedPartition(pSifDisk, &pLastUsedPartition )
AsrpAdjustDiskSizeToUsedPartitionSize( pSifDisk, &bDiskResized )
pbAreDisksResized
pbCriticalDiskNoARC
AsrpPerformDisksAssignment
AsrpDisksAssignment
AsrpAssignSifDisksToPhysicalDisks( pSifDiskList, pPhysicalDiskList, pbCriticalDiskNoARC )
AsrpAssignSifDisksToPhysicalDisks
VSS_E_ASRERROR_NO_ARCPATH
GetSystemPlex( pSifDiskList, TRUE, &pSifSystemDisk, &dwSifSystemParIndex )
pfCriticalDiskNoARC
VSS_E_ASRERROR_CRITICAL_DISKS_TOO_SMALL
VSS_E_ASRERROR_RDISK_FOR_SYSTEM_DISK_NOT_FOUND
SYSTEM\CurrentControlSet\Control\MiniNT
pdwDeviceNumber
GetRdisk0DeviceNumber
DoStorageIoctlCall(hDisk, IOCTL_STORAGE_GET_DEVICE_NUMBER, NULL, 0, (void **)&pStorageDeviceNumber)
\\?\GLOBALROOT\arcname\multi(0)disk(0)rdisk(0)
AsrGetSystemVolumeGlobalRootPath
StringCchPrintf( pwszVolume, cchVolume, L"\\\\?\\GLOBALROOT%s", wszDevicePath )
AsrGetSystemVolumeDevPath(wszDevicePath, ARRAYSIZE(wszDevicePath) )
AsrGetSystemVolumeDevPath
NtQuerySystemInformation( SystemSystemPartitionInformation, pSysInfo, cbRequiredSize, &cbRequiredSize)
pSysInfo
AsrpGetMorePartitionInfo
::StringCchCopyN( pwszVolume, cchVolume, pSysInfo->SystemPartition.Buffer, (pSysInfo->SystemPartition.Length)/sizeof(WCHAR) )
GetRdisk0DeviceNumber(&dwRDisk0DevNumber)
ppPartitionTable
hSystemVolume
AsrGetSystemVolumeGlobalRootPath( wszSysVolPath, ARRAYSIZE(wszSysVolPath) )
GetBootVolumeGuidName(&pwszBootVolGuidName)
DoVolumeIoctlCall(hSystemVolume, IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS, NULL, 0, (void **)&pSystemVolExtents, NULL)
DoVolumeIoctlCall(hBootVolume, IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS, NULL, 0, (void **)&pBootVolExtents, NULL)
hBootVolume
DiskBuildDevicePartitionPath( dwDeviceNumber, pCurPtnEx->PartitionNumber, FALSE, ARRAY_COUNT_PARAM(wszDevicePath) )
pPartitionTable
%s\Device\Harddisk%d\Partition%d\
\\?\GLOBALROOT
GetFileSytemType( wszFsName, &pPartitionTable[dwIndex].FileSystemType )
::StringCchPrintf( wszDevicePath, ARRAYSIZE(wszDevicePath), L"%s\\Device\\Harddisk%d\\Partition%d\\", L"\\\\?\\GLOBALROOT", dwDeviceNumber, pCurPtnEx->PartitionNumber )
AsrpGetMorePartitionInfo( pStorageDeviceNumber->DeviceNumber, pDriveLayoutEx, &pPartitionTable )
AsrpGetDiskLayout
ERROR_BAD_ENVIRONMENT
DiskListPopulateLayoutInfo
::StringCchPrintf(ARRAY_COUNT_PARAM(wszDeviceNumber), L"%d", pStorageDeviceNumber->DeviceNumber)
::StringCchPrintf(ARRAY_COUNT_PARAM(wszErrorCodeString), L"0x%x", dwError)
hdevInfo
DiskListInitialize
pDiDetail
ERROR_IO_DEVICE
pNewDisk->DevicePath
pNewDisk
::StringCchCopy(pNewDisk->DevicePath, cchDevicePath, pDiDetail->DevicePath)
DiskListFreeExcludedDisks
MapExcludedDisks
MarkDisksToExcludeFromBitmap
UpdateExcludedSifDisksAsIncluded
pExcludeDisksBmp
UpdateExcludedSifDisksAsIncluded(pPhysicalDiskList, pSifDiskList, pdwRestoreOptIncludeDisks, cRestoreOptIncludeDisks)
AsrpMarkExclusionDisksForRestore
bmpPhysicalDisksToExclude.Set(dwSystemDiskDeviceNumber)
bmpPhysicalDisksToExclude.Initialize(dwPhysicalDeviceNumber+1)
MapExcludedDisks(pSifDiskList, pPhysicalDiskList)
MarkDisksToExcludeFromBitmap(pPhysicalDiskList, &bmpPhysicalDisksToExclude)
MapExcludedDisks(pPhysicalDiskList, pSifDiskList)
MarkUnaccessableDisksAsExcluded( pPhysicalDiskList )
(DWORD)VSS_E_ASRERROR_CRITICAL_DISK_CANNOT_BE_EXCLUDED
pfHasPRKeys
ReadReservationKeys
pList
DeviceIoControl(hDisk, IOCTL_STORAGE_PERSISTENT_RESERVE_IN, &Param, Param.Size, pList, sizeof(PRI_RESERVATION_LIST), &cbReturned, NULL)
CheckDiskWritable
DeviceIoControl( hDisk, IOCTL_STORAGE_PERSISTENT_RESERVE_IN, &Param, Param.Size, pList, ulLen, &cbReturned, NULL)
::SetFilePointerEx( hDisk, liOffset, NULL, FILE_BEGIN )
pBuffer
ERROR_READ_FAULT
::ReadFile( hDisk, pBuffer, ulBytesPerSector, &cbRead, NULL )
ERROR_WRITE_FAULT
::WriteFile( hDisk, pBuffer, ulBytesPerSector, &cbWritten, NULL )
MarkUnaccessableDisksAsExcluded
AsrRegGetDword
pwszValueName
AsrRegGetBool
pdwOutRestoreInstanceCount
QuickFormat
pfOutValue
AsrRegSetRestoreInstanceCount
AsrRegIncrRestoreInstanceCount
SOFTWARE\MICROSOFT\WINDOWS NT\CurrentVersion\ASR\BackupSession
DeviceNumber{%d}
AsrRegSetRestoreMapForDeviceNumber
AsrRegClearExitCode
SOFTWARE\MICROSOFT\WINDOWS NT\CurrentVersion\ASR\RestoreSession\RestorationMap
PreRestoreExitCode
lDeleteValueResult
PostRestoreExitCode
AsrRegAddLastInstanceGuid
AsrRegSetExitCode
SafeStrConvertGuidString(&guidAsrInstanceGuid, ARRAY_COUNT_PARAM(wszAsrInstanceString))
hkeyRestoreSession
::StringCchPrintf( ARRAY_COUNT_PARAM(wszAsrInstanceString), L"%d/%02d/%02d-%02d:%02d:%02d", SystemTime.wYear, SystemTime.wMonth, SystemTime.wDay, SystemTime.wHour, SystemTime.wMinute, SystemTime.wSecond )
%d/%02d/%02d-%02d:%02d:%02d
AsrRegUpdateOfflineSoftwareHive
LastInstance
::RegLoadKey(HKEY_LOCAL_MACHINE, wszOfflineHive, pwszOfflineHiveFilePaths)
pwszOfflineHiveFilePaths
hkeyOfflineSoftwareHive
AsrRegDeleteLastAliveStamp
lResult
Microsoft\Windows\CurrentVersion\Reliability
GetMultiStringFromVolumeList
LastAliveStamp
pbMultiStr
pVolList
pwszMultiVolumeList
ppbMultiStr
AsrRegUpdateReformattedVolume
::StringCchCopy( pwszListCurrentStart, cFreeBuffer, pCurrentVol->szGuid )
GetMultiStringFromVolumeList( pVolList, &cbMultiStr, &pbMultiStr )
hkeyOfflineRestoreSession
::RegSetValueEx( hkeyOfflineRestoreSession, ASR_REG_RESTORED_VOLUME, 0, REG_MULTI_SZ, pbMultiStr, cbMultiStr )
RestoredVolumes
MICROSOFT\WINDOWS NT\CurrentVersion\ASR\RestoreSession
AsrRegUpdateRestoreSession
AsrRegAddLastInstanceGuid( hkeyOfflineAsrRestoreSession )
RegCreateKeyEx( hkeyOfflineSoftwareHive, ASR_REG_PATH_OFFLINE_SOFTWARE_RESTORE_SESSION, 0, NULL, NULL, KEY_ALL_ACCESS, NULL, &hkeyOfflineAsrRestoreSession, &dwDisposition)
AsrRegUpdateReformattedVolume( hkeyOfflineAsrRestoreSession, pVolList )
SafeStrJoinN
::StringCchCat(pwszNewString, cchNewString, pwszCurString)
pwszNewString
pguidToConvert && pwszGuidStringOut
%.8x-%.4x-%.4x-%.2x%.2x-%.2x%.2x%.2x%.2x%.2x%.2x
pwszVersionString
SafeStrExtractVersionNumber
pdwMinorVersion
pdwMajorVersion
pbBitmap
::DWordAdd((cElements/8), 1, &cbNeeded)
EnablePrivilege
LogEvent
pValue
ERROR_DATATYPE_MISMATCH
hSystemKey
AsrRegpGetDefaultCurrentControlSet
Current
phDefaultCCSKey
ControlSet%03d
Select
::StringCchPrintf( ARRAY_COUNT_PARAM(wszDefaultCCSKeyName), L"ControlSet%03d", dwDefaultCCSId )
DiskOpen
pIoctlOutputBuffer
phOutDiskHandle
DiskGetDriveLayout
dwLastError
DiskSetDriveLayout
ppOutDriveLayout
DiskTraceDriveLayout
pDriveLayout
SafeStrConvertGuidString(&pPartitionInfo->Gpt.PartitionId, ARRAY_COUNT_PARAM(wszGuidString))
SafeStrConvertGuidString(&pDriveLayoutEx->Gpt.DiskId, ARRAY_COUNT_PARAM(wszGuidString))
pdwRdiskNumberOut
DiskBuildDevicePartitionPath
multi(0)disk(0)rdisk(
%s\Device\Harddisk%d\Partition%d
pwszDevicePathOut
DiskForceDriversSync
ppwszNtPath
pwszlpcszArcName
pwszFullArcPath
\Arcname\
pwszNtPath
pwszNTName
\Arcname
ppwszArcPathOut
SYMBOLICLINK
pbDirInfo
pwszArcPath
pcbDriveLayoutEx
::DWordMult(cbDriveLayoutEx, sizeof(PARTITION_INFORMATION_EX), &cbDriveLayoutEx)
::DWordSub( cPartition, 1, &cbDriveLayoutEx)
::DWordAdd(cbDriveLayoutEx, sizeof(DRIVE_LAYOUT_INFORMATION_EX), &cbDriveLayoutEx)
ppwszVolumeGuidOut
wszVolumeName
FveApi.dll
FveOpenVolumeW
FveEraseDrive
IsDynamicVolume
FveCloseVolume
DeviceIoControl( hVolume, IOCTL_VOLUME_IS_DYNAMIC, NULL, 0, &fDynamic, sizeof(fDynamic), &dwBytesReturned, NULL )
pfDynamicVolume
pwszVolumePath
GetPartitionInfo
SetMBRPartitionInfo
pPartInfo->PartitionStyle == PARTITION_STYLE_MBR
EraseBitlockedDrive
hrFve
pwszNameToQuery
ppOutQueryPointOutput
dwIoctlLastError
pQueryPointInput
pQueryPointOutput
MtMgrDeletePoint
pCreatePointInput
pDeletePointInput
pwszNameToDelete
symbolic link
device name
pwszSymbolicName
MtMgrGetSymbolicNames
pmwszSymbolicNames
ppmwszOutSymbolicNames
pwszNametoGetMtPointsOn
MtMgrGetMountPoints
pwszFormattedName
ppMountPointsOut
hMountMgrOut != NULL
MtMgrOpen
MtMgrCreateMountPoint
pwszDevicePath
ERROR_TIMEOUT
COfflineDriverInjection::InitializeOfflineDriverInject
%PROCESSOR_ARCHITECTURE%
amd64
OfflineDriverInjectionExtension
COfflineDriverInjection::InjectDriversInOfflineOS
COfflineDriverInjection::MountAndSetWinDirPathForOfflineOSVolume
_GetExtensionProcAddress<PDRIVERSTOREOFFLINEADDDRIVERPACKAGE> ( ASR_OFFLINE_DRIVER_INJECTION_EXTENSION_NAME, &hDrvStoreDll, &pfnDriverStoreOfflineAddDriverPackage )
wszMountPoint
INBOX
s_pwszWindowsDirectoryPathForOfflineOS
COfflineDriverInjection::EnumerateAndInjectFromDriverStore
3rd Party
wszLocalInfName
COfflineDriverInjection::InjectDriverPackageInOfflineOS
SOFTWARE\Microsoft\Windows NT\CurrentVersion\ASR
COfflineDriverInjection::_GetExtensionProcAddress
AsrRegpQueryValueSz(hkeyOpenKey, wszExtensionName, &wszExtensionValue)
AsrRegpOpenHandle(ASR_KEY_PATH, FALSE, &hkeyOpenKey)
dwByteCount > 0
pFnLocal != NULL
szFunctionName
~pdwDeviceNumberOut
BootIsSystemStartFromFixedDisk
SYSTEM\CurrentControlSet\Control
pfIsSystemDiskFixed
SystemStartOptions
AsrRegpOpenHandle(BOOT_REGPATH_SYSTEM_START_OPTION, FALSE, &hkeyOpenKey)
RDPATH=
AsrRegpQueryValueSz(hkeyOpenKey, BOOT_REGVALUE_SYSTEM_START_OPTION, &pwszSystemStartOption)
::StringCchPrintf(ARRAY_COUNT_PARAM(wszWin32VolumeName), L"\\\\?\\GLOBALROOT\\Arcname\\%s", pwszArcNameStart)
\\?\GLOBALROOT\Arcname\%s
SetLastShutdownGood
hSystemPartition
hBootStatusData
pwszBootStatusPathname
::RtlGetSetBootStatusData( hBootStatusData, TRUE, RtlBsdPowerTransition, &bsdPowerTransition, sizeof(bsdPowerTransition),NULL)
::RtlGetSetBootStatusData( hBootStatusData, FALSE, RtlBsdItemBootShutdown, &fLastShutdownGood, sizeof(fLastShutdownGood),NULL)
::RtlGetSetBootStatusData( hBootStatusData, FALSE, RtlBsdPowerTransition, &bsdPowerTransition, sizeof(bsdPowerTransition),NULL)
vssapi.pdb
.rdata$brc
.rdata$zz$brc
.CRT$XCA
.CRT$XCU
.CRT$XCZ
.CRT$XIA
.CRT$XIAA
.CRT$XIZ
.gfids
.giats
.rdata
.rdata$00
.rdata$sxdata
.rdata$voltmd
.rdata$zETW0
.rdata$zETW1
.rdata$zETW2
.rdata$zETW9
.rdata$zz
.rdata$zzzdbg
.text$di
.text$lp00vssapi.dll!30_clientonly
.text$lp01vssapi.dll!30_clientonly
.text$lp05vssapi.dll!50_coldboot
.text$mn
.text$np
.text$x
.text$yd
.text$zs
.text$zy
.text$zz
.xdata$x
.didat$2
.didat$3
.didat$4
.didat$6
.didat$7
.edata
.data$brc
.data$01$brc
.data$dk00$brc
.data$r$brc
.data$zz$brc
.data
.data$00
.data$dk00
.data$zz
.bss$00
.bss$dk00
.bss$dk01
.bss$pr00
.bss$zz
.idata$5
.00cfg
.idata$2
.idata$3
.idata$4
.idata$6
.didat$5
.rsrc$01
.rsrc$02
PQQQQQQVj j
VWhPA
VWhPA
t9h0e
VWQSRh
VWQSRh
VWQSRh
VWQSRh
VWQSRh
@,VRQP
@<VRQP
QVh 7
VWQSRh
@<RQP
@<RQP
VWQSRh
VWQSRh
uNhp:
VWQSRh
VWQSRh
VWQSRh
VWQSRh
VWQSRh
<6WQP
MhQPh
<6WSP
<6WSP
VWQSRh
VWQSRh
jjjjj
VWQSRh
VWh0;
VWh0;
VWh0;
PQQSVW
Y__^[
Y__^[
QRPh8
QRPhX
QRPhx
QRPh8
QRPhX
QRPhx
QQSVW
t"VWj
PVhXW
9f;:u
y0hDt
QShLx
jchh?
t7QPSh
jrhh?
johh?
jQhh?
jkh<?
jph<?
u0h,m
PWh`r
QPVWh
PQhh}
VWhPA
VWhPA
;F,w(
f9F8t
~ 9~4t
QQSVWj
y5VRh
98u<h
awJtd
 SShd
QQQQQQQPQQQ
QQSVW3
SSSSPSSSSSS
t5SSSS
QQSVW
tnj'[f;
\t2ShH
j%YWf;
j{Xf;
j=Xf9
j=Xf9
j{Xf9
j{Xf9
j}Xf9
t'VWj'
?=u3W
!7_^[
VWhPA
VWhPA
PPPPh
WVhPA
QQh8T
QQh4T
t$hVQ
PVVh8T
t$hVQ
PVVh4T
&PWSV
PQQSVW
vThPS
v,ShlS
QQSVW3
97s/j
t!h0g
E,h U
j/VWh U
j;VWh U
QQVhxJ
t;SWj 
PQSVW
v8QhP
x VhxJ
EhPh$
u"WVh
SWRQP
SWRQP
SWRQP
SWRQP
SWRQP
SWRQP
SWRQP
SWRQP
SWRQP
SWRQP
9f;:u
1f;2u
1f;2u
1f;2u
1f;2u
1f;2u
1f;2u
1f;2u
1f;2u
1f;2u
C@9CHt
x@hxJ
^@9^Ht
9f;:u
9f;:u
uE;_Dr@3
uwVhx
uE;_Xr@3
uwVhx
1f;2u
1f;2u
1f;2u
1f;2u
1f;2u
1f;2u
1f;2u
1f;2u
u2Shp
u2Shp
t#ShT
G8HuL
GLHuT
0f;2u
0f;2u
0f;2u
0f;2u
0f;2u
1f;2u
1f;7u
1f;2u
1f;2u
9f;:u
9f;:u
9f;:u
9f;:u
1f;2u
1f;2u
1f;2u
1f;2u
1f;2u
1f;2u
1f;2u
0f;2u
0f;2u
0f;2u
1f;2u
1f;2u
9f;:u
9f;:u
1f;2u
1f;2u
1f;2u
1f;2u
1f;2u
1f;2u
1f;2u
1f;2u
1f;2u
1f;2u
1f;2u
1f;2u
1f;2u
1f;2u
1f;2u
1f;2u
1f;2u
1f;2u
1f;2u
0f;2u
0f;2u
0f;2u
1f;2u
1f;2u
\SVWQj
\SVWQj
t2RhL
t2RhL
t2Rh 
SSSSj
PPSVj
PPPPj
PPSVj
SWVRQP
u$h &
u5VhL;
y,h<-
tKhxJ
D$LWP
D$TWP
D$\WP
L$,^3
QQSVW
!w$Y!w(
t0hLp
t)PhhE
t7hLp
VWhXX
WShXX
WShXX
WShXX
WShXX
9u$u3h
WVhXX
VWhXX
WVhXX
WVhXX
WVRQP
9u u3h0
t3h l
9~`uGh
t/hLp
t/hLp
u4hLu
u(hLu
u4hLu
VWhXX
t,hLp
VWhXX
VWhXX
9f;:u
tWhxJ
u7hht
SWhXX
u0hht
t/hLp
SWVRQP
SWVRQP
SWVRQP
SWVRQP
t3h`w
D$(SVW
u0hht
PSWh`e
WShXX
WShXX
SVhL=
SVhL=
VShXX
u,hht
VShXX
WVRQP
[Sh]'
QShc'
QShi'
QShl'
VShXX
VShXX
t0hLp
v6QPh
t4hLp
WVhXX
WVhXX
WVhXX
WVhXX
WVhXX
y0PhxD
u3htn
WVhXX
u0htn
VWhXX
VWhXX
WVhXX
WVhXX
WVhXX
WVhXX
WVhXX
WVhXX
WVhXX
WVhXX
u!h0{
VWhXX
VWhXX
VWhXX
VWhXX
VWhXX
VWhXX
u!h0{
VWhXX
VWhXX
VWhXX
VWhXX
VWhXX
VWhXX
u!h0{
t1Phhz
VWhXX
VWhXX
u _Wh
SWVRQP
SVhXX
SVhXX
VWhXX
VWhXX
VWhXX
D$LWP
@Ph$I
VWhXX
VWhXX
t4Ph8
t/hLp
t1Phh
y0hXZ
VWhXX
VWhXX
VWhXX
VWhXX
WShXX
WShXX
[ShL!
QSh]!
QShd!
QShg!
QShm!
SVhXX
SVhXX
SWVRQP
SWVRQP
VShXX
t,hLp
VShXX
VShXX
VShXX
@_^[]
QQSVW
QQSVW
^Vh^*
QVhc*
QVhf*
QVhi*
QVhl*
QVhq*
WShXX
QVhr*
WShXX
SWVRQP
WShXX
WShXX
VWhXX
VWhXX
t,hLp
VWhXX
SVhXX
SVhXX
VWhXX
t,hLp
VWhXX
u4hPO
u4hht
 tL9= 
VShXX
VWhXX
u4h@V
SVhXX
SVhXX
SVhXX
SVhXX
SVhXX
SVhXX
SVhXX
SVhXX
t,h _
VWhXX
VWhXX
;u(s+Wh
VWhXX
VWhXX
WShXX
t,hLp
WShXX
t0hh\
WVhXX
VWhXX
VWhXX
L$T_^3
VWhXX
VWhXX
VWhXX
VWhXX
VWhXX
VWhXX
VWhXX
D$tWP
D$0PQ
rlhxJ
_Wh3*
QWh8*
QWh;*
QWh>*
QWhA*
QWhF*
QWhG*
u3hxm
u$WSQ
9>u4h
9w\u_
jkWSh
WSh([
t+Qhd[
WSh([
SVhL=
SVhL=
j~jFjgh
1j~jFjgh
9GXuZ
y9Ph0
y9Php
taPh(
VWh([
VWh([
VWh([
9w\uU
9O`tL
G`Ph\
G`Ph\
9p\uZ
PQSVW
D$ SVW
L$,_^[3
8_^[]
yUVhX
u$Ph<5
D$tQj
L$tQP
y9Ph|
8Y@u18YAu,h
D$`SVW
D$\h(K
D$,u)
D$7P%:
`Vh,M
O,SjdQV
v(h`<
p8h`<
@<VRQP
sTh@5
}<h(K
jjjjj
v(h`<
p8h`<
v(hXM
@<VRQP
sTh@5
tAh0T
C;Y$r
|$dQj
v(h`<
p8h`<
@<VRQP
sTh@5
@<VRQP
sThH5
v(h`<
p8h`<
@<VRQP
u:h8%
9wx~S
F;wx|
wxu(f
t A;O$r
QQSVW
B;W$r
9~$v+
9^xu3h
G;~x|
F|G;~x
u,hP!
PWhLd
hPWhhd
SVWj@[S3
Vj _WP
v(h`<
p8h`<
@<VRQP
sTh@5
u:h@R
v(h`<
@<RQP
p8h`<
@<VRQP
Cp t(
v(h`<
p8h`<
@<VRQP
sTh@5
uAhxP
v(h`<
p8h`<
@<VRQP
}ehX?
v(h`<
@<RQP
p8h`<
@<VRQP
u.hd9
WVRQP
@<WVRQP
@,RQP
y8Php<
vHhX=
u4hX@
B;V$r
5VhP'
v(h`<
p8h`<
@<VRQP
sTh@5
v(h`<
p8h`<
@<VRQP
sTh@5
[t\8]
u;hX\
u4hh]
9_$v(
F;w$r
[Sj<h
QSj=h
QSjuh
WSh@9
WSh@9
WVh@9
QWWWP
RQPhH
D$dSP
VWh0;
VWh0;
VWh0;
WVPShLm
t!f9\F
j;[f;
t j/[f;
j [f9E
t:j;Yf;
t2j\Yf;
 j/Yf;
YjsYf;
VWhhn
VWhhn
v)hxJ
j*Xf;
t/j?Yf;
j*Yf;
VWhhn
VWhhn
VWhhn
VWhhn
VShhn
VShhn
y2QQhQ
VWhhn
SVhhn
SVhhn
VWhhn
VWhhn
VWhhn
VWhhn
VWhhn
VWhhn
VWhhn
VShhn
VShhn
VWhhn
VWhhn
QQSVW
RRRRRRP
j\X^f;DQ
SVWPj
j"Yf9
j"[f9\H
j"Xf9DJ
tgh|o
PQSVW
u3jW^
u*jW^
u*jW^
u8jW^
t%jU^
jPWjQZ
jPWjQZ
f97tT
9u u/jW
9u$u,jW
_t|@;E
PQRj+
PQRj+
QQSVW
VWQRj
WSQVj
PQRj+
PVWQRj+
PVWQRj+
VRQRh
SVPh8
Zf9TC
t j\Zf
j\Xf9C
j._f;
wjWVhH
PShPN
u4t.h
jAVWh
jNVWh
jZVWh
u-jW3
PVWQRj
E PVWj
PWVSR
VWQRj+
uvVVh(
u3j-Xf;C&u*f;C0u$f;C:u
f;CDu
j}Xf;C^u
PVVVh
t9j?Xf
u;jW[
8XAtK
u&9^t
t*9^4u%9^0t 
PQRj+
9xdvA
t"h F
QQSVW
9Alv3
9wlvq
PQRj+
u[jW[
PQRj+
QQSVW
;PPt,
;BPsL
t@hL 
9Q8v,
;Q8sq
QQSVW
9C t7
tghl!
t@h\!
t@hL<
u@jW3
u'jW3
t|hL<
QQSVW
f97tqj-[
u!f;_&u
f;_0u
f;_:u
f;_Du
j}Xf;G^t
9H t=
9H t+
9C t&
tihl>
j-Xf;G&
j}Xf;G^u{
Vj PjZ
QQSVW
0SVW3
t_h<*
t;h\(
tchl(
t>h\(
u=jW3
u,jW3
t!h\#
,SVW3
t`h4.
t<h .
8u:9T
91t2jW
tNh41
tbhP9
t?h@9
PWVSRj
] VW3
{9~0ut9~
9~,tB
9s0u2jW
t@h`B
PVVVVh 
VVVVS
u69w,u>
9YHt/9qHt*jW
9XHuk
VWSQP
,91u(
VWSQP
t:h`B
XPG9s
E PRVj
PQh0L
PjXh0L
Pj\h0L
Pj(hPM
CD;FDu
tBjU3
!X0!_0
tAh$P
t2jU3
!x0!~0
t@h$P
th9w4uc
t 9w4u
9w0t{
9XHuo
tAhdQ
uq9w,u:
9_Hu1
CH;GHt
t/9GHt*
PVVjb
PSSSSS
QQSVW
Q9~4tE
QVWVP
PVVVVh
@QPhXK
9s8t+
t@h$P
QQSVW
VVVVS
VVVVS
QQSVW
t+hXj
QQSVW
QQSVW
D$xSVW
D$4Ph
D$4Ph
D$0Ph
u=jW3
QQQh m
QQQh m
t+hXj
j\Yf9
t@hhk
tMh p
tMh p
8.t>j
f90t(j
tPSh|o
2@^_]
j0Xf;
jxYf;
jXYf;
QQSVW
u:jW3
PPPQh
QSVW3
u2jW3
tQh,u
tVVVVV
tghxu
tThLu
t-h u
WVQRj
QQSVW
t5hTx
u=jW3
v*jz3
QSShH
93t/jW
PVVjx
PQh\x
tqhdy
tJf92tE
tyh8z
ttf93to3
VVVVj
WPhH{
Wj Pj
CoTaskMemAlloc
OpenServiceW
CoCreateInstance
CoTaskMemFree
CoTaskMemRealloc
OpenSCManagerW
CloseServiceHandle
CLSIDFromString
QueryServiceStatus
CoUninitialize
CoInitializeEx
LookupAccountSidLocalW
ReportEventW
RegisterEventSourceW
ConvertSidToStringSidW
DeregisterEventSource
CoGetClassObject
WNetGetUniversalNameW
UuidFromStringW
StringFromCLSID
CoCreateGuid
CoDisconnectObject
UuidToStringW
RpcStringFreeW
CoWaitForMultipleHandles
CreateStreamOnHGlobal
CreateXmlReader
CreateXmlReaderInputWithEncodingName
ConvertStringSecurityDescriptorToSecurityDescriptorW
CoSetProxyBlanket
CoDisconnectContext
CoImpersonateClient
CoRevertToSelf
ConvertStringSidToSidW
LookupAccountNameLocalW
NetLocalGroupGetMembers
NetApiBufferFree
DsRoleGetPrimaryDomainInformation
DsRoleFreeMemory
JetGetSystemParameterW
JetGetInstanceInfoW
JetFreeBuffer
JetOSSnapshotPrepare
JetOSSnapshotFreezeW
JetOSSnapshotThaw
JetOSSnapshotAbort
InetPtonW
GetNameInfoW
UuidCreate
CM_Get_Parent
GetStorageDependencyInformation
SetupDiDestroyDeviceInfoList
SetupDiEnumDeviceInterfaces
SetupDiGetClassDevsW
SetupDiGetDeviceInterfaceDetailW
SetupEnumPublishedInfW
SetupGetInfDriverStoreLocationW
pSetupGetFileTitle
BcdSetSystemStoreDevice
BcdImportStoreWithFlags
 !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNO
VSSAPI.DLL
??0CVssJetWriter@@QAE@XZ
??0CVssWriter@@QAE@XZ
??1CVssJetWriter@@UAE@XZ
??1CVssWriter@@UAE@XZ
?AreComponentsSelected@CVssJetWriter@@IBG_NXZ
?AreComponentsSelected@CVssWriter@@IBG_NXZ
?CreateVssBackupComponents@@YGJPAPAVIVssBackupComponents@@@Z
?CreateVssExamineWriterMetadata@@YGJPAGPAPAVIVssExamineWriterMetadata@@@Z
?GetBackupType@CVssJetWriter@@IBG?AW4_VSS_BACKUP_TYPE@@XZ
?GetBackupType@CVssWriter@@IBG?AW4_VSS_BACKUP_TYPE@@XZ
?GetContext@CVssJetWriter@@IBGJXZ
?GetContext@CVssWriter@@IBGJXZ
?GetCurrentLevel@CVssJetWriter@@IBG?AW4_VSS_APPLICATION_LEVEL@@XZ
?GetCurrentLevel@CVssWriter@@IBG?AW4_VSS_APPLICATION_LEVEL@@XZ
?GetCurrentSnapshotSetId@CVssJetWriter@@IBG?AU_GUID@@XZ
?GetCurrentSnapshotSetId@CVssWriter@@IBG?AU_GUID@@XZ
?GetCurrentVolumeArray@CVssJetWriter@@IBGPAPBGXZ
?GetCurrentVolumeArray@CVssWriter@@IBGPAPBGXZ
?GetCurrentVolumeCount@CVssJetWriter@@IBGIXZ
?GetCurrentVolumeCount@CVssWriter@@IBGIXZ
?GetRestoreType@CVssJetWriter@@IBG?AW4_VSS_RESTORE_TYPE@@XZ
?GetRestoreType@CVssWriter@@IBG?AW4_VSS_RESTORE_TYPE@@XZ
?GetSnapshotDeviceName@CVssJetWriter@@IBGJPBGPAPBG@Z
?GetSnapshotDeviceName@CVssWriter@@IBGJPBGPAPBG@Z
?Initialize@CVssJetWriter@@QAGJU_GUID@@PBG_N211K@Z
?Initialize@CVssWriter@@QAGJU_GUID@@PBGW4VSS_USAGE_TYPE@@W4VSS_SOURCE_TYPE@@W4_VSS_APPLICATION_LEVEL@@KW4VSS_ALTERNATE_WRITER_STATE@@_N1@Z
?InstallAlternateWriter@CVssWriter@@QAGJU_GUID@@0@Z
?IsBootableSystemStateBackedUp@CVssJetWriter@@IBG_NXZ
?IsBootableSystemStateBackedUp@CVssWriter@@IBG_NXZ
?IsPartialFileSupportEnabled@CVssJetWriter@@IBG_NXZ
?IsPartialFileSupportEnabled@CVssWriter@@IBG_NXZ
?IsPathAffected@CVssJetWriter@@IBG_NPBG@Z
?IsPathAffected@CVssWriter@@IBG_NPBG@Z
?OnAbortBegin@CVssJetWriter@@UAGXXZ
?OnAbortEnd@CVssJetWriter@@UAGXXZ
?OnBackOffIOOnVolume@CVssWriter@@UAG_NPAGU_GUID@@1@Z
?OnBackupComplete@CVssWriter@@UAG_NPAVIVssWriterComponents@@@Z
?OnBackupCompleteBegin@CVssJetWriter@@UAG_NPAVIVssWriterComponents@@@Z
?OnBackupCompleteEnd@CVssJetWriter@@UAG_NPAVIVssWriterComponents@@_N@Z
?OnBackupShutdown@CVssWriter@@UAG_NU_GUID@@@Z
?OnContinueIOOnVolume@CVssWriter@@UAG_NPAGU_GUID@@1@Z
?OnFreezeBegin@CVssJetWriter@@UAG_NXZ
?OnFreezeEnd@CVssJetWriter@@UAG_N_N@Z
?OnIdentify@CVssJetWriter@@UAG_NPAVIVssCreateWriterMetadata@@@Z
?OnIdentify@CVssWriter@@UAG_NPAVIVssCreateWriterMetadata@@@Z
?OnPostRestore@CVssWriter@@UAG_NPAVIVssWriterComponents@@@Z
?OnPostRestoreBegin@CVssJetWriter@@UAG_NPAVIVssWriterComponents@@@Z
?OnPostRestoreEnd@CVssJetWriter@@UAG_NPAVIVssWriterComponents@@_N@Z
?OnPostSnapshot@CVssJetWriter@@UAG_NPAVIVssWriterComponents@@@Z
?OnPostSnapshot@CVssWriter@@UAG_NPAVIVssWriterComponents@@@Z
?OnPreRestore@CVssWriter@@UAG_NPAVIVssWriterComponents@@@Z
?OnPreRestoreBegin@CVssJetWriter@@UAG_NPAVIVssWriterComponents@@@Z
?OnPreRestoreEnd@CVssJetWriter@@UAG_NPAVIVssWriterComponents@@_N@Z
?OnPrepareBackup@CVssWriter@@UAG_NPAVIVssWriterComponents@@@Z
?OnPrepareBackupBegin@CVssJetWriter@@UAG_NPAVIVssWriterComponents@@@Z
?OnPrepareBackupEnd@CVssJetWriter@@UAG_NPAVIVssWriterComponents@@_N@Z
?OnPrepareSnapshotBegin@CVssJetWriter@@UAG_NXZ
?OnPrepareSnapshotEnd@CVssJetWriter@@UAG_N_N@Z
?OnThawBegin@CVssJetWriter@@UAG_NXZ
?OnThawEnd@CVssJetWriter@@UAG_N_N@Z
?OnVSSApplicationStartup@CVssWriter@@UAG_NXZ
?OnVSSShutdown@CVssWriter@@UAG_NXZ
?SetWriterFailure@CVssJetWriter@@IAGJJ@Z
?SetWriterFailure@CVssWriter@@IAGJJ@Z
?Subscribe@CVssWriter@@QAGJK@Z
?Uninitialize@CVssJetWriter@@QAGXXZ
?Unsubscribe@CVssWriter@@QAGJXZ
CreateVssBackupComponentsInternal
CreateVssExamineWriterMetadataInternal
CreateVssExpressWriterInternal
CreateVssSnapshotSetDescription
CreateWriter
CreateWriterEx
DllCanUnloadNow
DllGetClassObject
GetProviderMgmtInterface
GetProviderMgmtInterfaceInternal
IsVolumeSnapshotted
IsVolumeSnapshottedInternal
LoadVssSnapshotSetDescription
ShouldBlockRevert
ShouldBlockRevertInternal
VssFreeSnapshotProperties
VssFreeSnapshotPropertiesInternal
.?AVlogic_error@std@@
.?AVlength_error@std@@
.?AVout_of_range@std@@
.?AVbad_alloc@std@@
.?AVexception@@
.?AV_com_error@@
.?AVResultException@wil@@
TCPAu2
fSfSfUfh
Invalid partition table
Error loading operating system
Missing operating system
__CxxFrameHandler3
_vsnwprintf
_wcsicmp
realloc
wcscat_s
_purecall
_wcsnicmp
towupper
malloc
memcpy_s
??1exception@@UAE@XZ
??0exception@@QAE@XZ
??0exception@@QAE@ABV0@@Z
_vsnprintf_s
_callnewh
?what@exception@@UBEPBDXZ
_CxxThrowException
??0exception@@QAE@ABQBD@Z
memcpy
memmove
_XcptFilter
_amsg_exit
_initterm
msvcrt.dll
_except_handler4_common
?terminate@@YAXXZ
_lock
_unlock
__dllonexit
_onexit
??1type_info@@UAE@XZ
EtwRegisterTraceGuidsW
EtwGetTraceEnableLevel
SizeofResource
VirtualProtect
RegEnumValueW
EnterCriticalSection
EtwGetTraceLoggerHandle
lstrcpynW
RegDeleteValueW
DeviceIoControl
VirtualAlloc
GetModuleFileNameW
RegOpenKeyExW
LeaveCriticalSection
InitializeCriticalSection
GetVolumePathNameW
CreateFileW
CharNextW
RegSetValueExW
RegEnumKeyExW
EtwGetTraceEnableFlags
GetVolumeNameForVolumeMountPointW
CreateEventW
MultiByteToWideChar
GetLastError
RegCreateKeyExW
CharPrevW
CloseHandle
EtwUnregisterTraceGuids
GetSystemInfo
FindResourceExW
ResetEvent
LoadResource
HeapDestroy
GetProcAddress
LocalFree
DeleteCriticalSection
GetModuleHandleW
FreeLibrary
RegQueryInfoKeyW
RegCloseKey
lstrcmpiW
VirtualQuery
GetDriveTypeW
LoadLibraryExW
GetModuleFileNameA
CreateSemaphoreExW
HeapFree
SetLastError
ReleaseSemaphore
GetModuleHandleExW
InitializeCriticalSectionAndSpinCount
WaitForSingleObject
GetCurrentThreadId
ReleaseMutex
Sleep
FormatMessageW
OutputDebugStringW
WaitForSingleObjectEx
OpenSemaphoreW
HeapAlloc
CreateMutexExW
GetCurrentProcessId
GetProcessHeap
DebugBreak
IsDebuggerPresent
CreateThread
UnhandledExceptionFilter
SetUnhandledExceptionFilter
GetCurrentProcess
TerminateProcess
QueryPerformanceCounter
GetSystemTimeAsFileTime
GetTickCount
ntdll.dll
api-ms-win-core-libraryloader-l1-2-0.dll
api-ms-win-core-memory-l1-1-0.dll
api-ms-win-core-registry-l1-1-0.dll
api-ms-win-core-synch-l1-1-0.dll
api-ms-win-core-string-obsolete-l1-1-0.dll
api-ms-win-core-io-l1-1-0.dll
api-ms-win-core-file-l1-1-0.dll
api-ms-win-core-string-l2-1-0.dll
api-ms-win-core-file-l1-2-0.dll
api-ms-win-core-string-l1-1-0.dll
api-ms-win-core-errorhandling-l1-1-0.dll
api-ms-win-core-handle-l1-1-0.dll
api-ms-win-core-sysinfo-l1-1-0.dll
api-ms-win-core-heap-l1-1-0.dll
api-ms-win-core-heap-l2-1-0.dll
api-ms-win-core-processthreads-l1-1-0.dll
api-ms-win-core-synch-l1-2-0.dll
api-ms-win-core-localization-l1-2-0.dll
api-ms-win-core-debug-l1-1-0.dll
api-ms-win-core-profile-l1-1-0.dll
VssTrace.DLL
_vsnprintf
iswdigit
wcstoul
_wtoi
_wtoi64
towlower
_errno
_beginthreadex
wcschr
_wcsdup
wcsncmp
wcsrchr
wcspbrk
tolower
wcstok
GetTokenInformation
GetCommandLineW
OpenThreadToken
OpenProcessToken
GetCurrentThread
LoadStringW
GetVersionExW
LocalAlloc
WideCharToMultiByte
LockResource
FreeResource
EventUnregister
EventRegister
EventSetInformation
EventWriteTransfer
SetEvent
AcquireSRWLockExclusive
EventActivityIdControl
SetThreadToken
EqualSid
IsValidSid
RevertToSelf
DuplicateToken
ReadFile
GetWindowsDirectoryW
FindFirstFileW
FindNextFileW
RaiseException
InitOnceBeginInitialize
InitOnceComplete
FindClose
ReleaseSRWLockExclusive
ResumeThread
GlobalAlloc
GlobalLock
GlobalFree
GlobalUnlock
DeleteFileW
GetSystemWindowsDirectoryW
WriteFile
GetFileAttributesW
CreateDirectoryW
CreateMutexW
GetTickCount64
AllocateAndInitializeSid
CheckTokenMembership
FreeSid
PrivilegeCheck
CreateWellKnownSid
InitializeSecurityDescriptor
SetSecurityDescriptorOwner
GetLengthSid
CopySid
SetSecurityDescriptorGroup
SetSecurityDescriptorDacl
GetAclInformation
GetAce
AddAce
InitializeAcl
AddAccessDeniedAceEx
AddAccessAllowedAceEx
GetSidSubAuthorityCount
EqualDomainSid
RegQueryValueExW
GetFullPathNameW
ExpandEnvironmentStringsW
EtwTraceMessage
RtlInitUnicodeString
NtClose
NtFsControlFile
NtQueryInformationFile
RtlNtStatusToDosError
NtCreateFile
NtQueryVolumeInformationFile
GetComputerNameExW
RtlIpv6StringToAddressW
RtlIpv4StringToAddressW
ResolveDelayLoadedAPI
DelayLoadFailureHook
api-ms-win-security-base-l1-1-0.dll
api-ms-win-core-processenvironment-l1-1-0.dll
api-ms-win-eventing-provider-l1-1-0.dll
api-ms-win-core-heap-obsolete-l1-1-0.dll
api-ms-win-core-file-l2-1-0.dll
api-ms-win-core-kernel32-legacy-l1-1-1.dll
api-ms-win-core-delayload-l1-1-1.dll
api-ms-win-core-delayload-l1-1-0.dll
swscanf
qsort
wcsstr
GetVolumeInformationW
SetErrorMode
TlsSetValue
EncodePointer
TlsAlloc
DecodePointer
TlsGetValue
RegLoadKeyW
RegUnLoadKeyW
NtQuerySystemInformation
CopyFileExW
SetFilePointer
SetFilePointerEx
GetSystemTime
RtlAdjustPrivilege
NtOpenSymbolicLinkObject
NtQuerySymbolicLinkObject
NtOpenDirectoryObject
NtQueryDirectoryObject
GetLogicalDrives
SetVolumeMountPointW
GetVolumePathNamesForVolumeNameW
RtlUnlockBootStatusData
RtlGetSetBootStatusData
api-ms-win-core-util-l1-1-0.dll
memcmp
memset
VS_VERSION_INFO
StringFileInfo
040904B0
CompanyName
Microsoft Corporation
FileDescription
Microsoft
 Volume Shadow Copy Requestor/Writer Services API DLL
FileVersion
10.0.22621.1 (WinBuild.160101.0800)
InternalName
VSSAPI.DLL
LegalCopyright
 Microsoft Corporation. All rights reserved.
OriginalFilename
VSSAPI.DLL
ProductName
Microsoft
 Windows
 Operating System
ProductVersion
10.0.22621.1
VarFileInfo
Translation
<Schema name="VssComponentMetadata"
        xmlns="urn:schemas-microsoft-com:xml-data"
        xmlns:dt="urn:schemas-microsoft-com:datatypes">
<AttributeType name="filespec" dt:type="string" required="yes">
   <description>
   File specification.  Can include wildcard characters ? and *
   </description>
</AttributeType>
<AttributeType name="path" dt:type="string" required="yes">
   <description>
   Path to a file.  The path can include environment variables or
   values extracted from registry keys.
   </description>
</AttributeType>
<AttributeType name="recursive" dt:type="enumeration"
               dt:values="yes no" default="no">
   <description>
   Is path specified recursive or limited to the directory that is specified.
   </description>
</AttributeType>
<AttributeType name="alternatePath" dt:type="string" required="no">
   <description>
   Alternate path in which to find the file.  Files in a file group may
   have been copied to an alternative location by the writer.  Backup should
   pick up the files from the alternative location instead of the original
   location but should restore the files to their original location
   </description>
</AttributeType>
<AttributeType name="logicalPath" dt:type="string" required="no">
   <description>
   Logical path for a database or file group.  This logical name uses backslash
   as separators to form a logical namespace hierarchy
   </description>
</AttributeType>
<AttributeType name="componentName" dt:type="string" required="yes">
   <description>
   Name used to identify a database or file group.  May be qualified by a
   logical path.
   </description>
</AttributeType>
<AttributeType name="version" dt:type="enumeration" dt:values="1.0 1.1 1.2 1.3" required="yes">
   <description>
   Version of a specific document
   </description>
</AttributeType>
<AttributeType name="writerId" dt:type="uuid" required="yes">
   <description>
   Unique id to identify the writer.  Note that this identifies the
   writer class rather than a specific instance of the writer.
   </description>
</AttributeType>
<AttributeType name="instanceId" dt:type="uuid" required="no">
   <description>
   Unique id identifying the instance of a writer during backup.  It
   has no meaning during restore.
   </description>
</AttributeType>
<AttributeType name="instanceName" dt:type="string" required="no">
   <description>
   Unique generated by the writer that identifies the instance of a writer
   both during backup and restore.  This id is used to map writers at backup
   time to writers at restore time.
   </description>
</AttributeType>
<AttributeType name="backupSchema" dt:type="number" required="no">
   <description>
Describes the writer capabilities and how different types of backup are performed.
   </description>
</AttributeType>
<ElementType name="BACKUP_COMPONENTS" content="eltOnly" model="closed" order="many">
   <description>
   Components that are backed up or restored.
   Used to communicate between the writer and the backup application during
   backup and restore.
   </description>
   <AttributeType name="selectComponents" dt:type="enumeration"
                       dt:values="yes no" default="no">
      <description>
      Does the backup application select individual components or
      does it backup entire volumes
      </description>
   </AttributeType>
   <AttributeType name="bootableSystemStateBackup" dt:type="enumeration"
                  dt:values = "yes no" default="no" >
      <description>
      Is backup saving the bootable state of the system.
      </description>
   </AttributeType>
   <AttributeType name="backupType" dt:type="enumeration"
                  dt:values="full differential incremental log copy other"
                  default="full">
      <description>
      Type of backup being performed.
      </description>
   </AttributeType>
   <AttributeType name="restoreType" dt:type="enumeration"
dt:values="byCopy import other"
default="byCopy">
   <description>
   Type of restore being performed.
   </description>
   </AttributeType>
   <AttributeType name="partialFileSupport" dt:type="enumeration"
                  dt:values= "yes no" default="no" >
       <description>
       Indicates whether the requestor is capable of backing up and restoring
       portions of files.  If no, then the writer should never generate
       PARTIAL_FILE or DIRECTED_RESTORE elements.
       Only entire files can be backed up or restored.
       </description>
   </AttributeType>
   <AttributeType name="snapshotSetId" dt:type="uuid" required="no">
       <description>
       this is the unique identifier for the snapshot set
       </description>
   </AttributeType>
   <attribute type="version" />
   <attribute type="selectComponents" />
   <attribute type="bootableSystemStateBackup" />
   <attribute type="backupType" />
   <attribute type="restoreType" />
   <attribute type="partialFileSupport" />
   <attribute type="snapshotSetId" />
   <element type= "WRITER_COMPONENTS" />
   <element type= "SNAPSHOT_SET_DESCRIPTION" minOccurs="0" maxOccurs="*" />
</ElementType>
<ElementType name="WRITER_COMPONENTS" content="eltOnly" model="closed"
             order="many">
   <description>
   Components that are backed up and restored that are associated with a
   specific writer instance
   </description>
   <attribute type="writerId" />
   <attribute type="instanceId" />
   <attribute type="instanceName" />
   <attribute type="backupSchema" />
   <element type="COMPONENT" />
</ElementType>
<ElementType name="COMPONENT" content="eltOnly" model="open" order="many">
   <AttributeType name="backupSucceeded" dt:type="enumeration"
                  dt:values="yes no" default="no">
      <description>
      Indication of whether the component was backed up successfully
      or not.  This should be set during the BackupComplete notification
      </description>
   </AttributeType>
   <AttributeType name="componentType" dt:type="enumeration"
                  dt:values="database filegroup">
       <description>
       Indication of whether component is database or file group
       </description>
   </AttributeType>
   <AttributeType name="backupStamp" dt:type="string" required="no">
       <description>
       This string attribute contains the identifier assigned to the
       backup by the writer.  The attribute is set by the writer either
       during the PrepareBackup or PostSnapshot event.
       </description>
    </AttributeType>
   <AttributeType name="previousBackupStamp" dt:type="string" required="no">
       <description>
       In the case of an incremental or differential backup, this identifies
       the backup from which differences are compouted.  This attribute is
       set by the requestor prior to the PrepareBackup event.
       </description>
   </AttributeType>
   <AttributeType name="selectedForRestore" dt:type="enumeration"
                  dt:values="yes no"  default="no" >
       <description>
       This yes/no attribute is set by the request prior to calling
       PreRestore and indicates whether the component is being restored
       or not.
       </description>
   </AttributeType>
   <AttributeType name="additionalRestores" dt:type="enumeration"
                  dt:values="yes no" default="no" >
       <description>
       This yes/no attribute is set by the requestor prior to calling
       PreRestore and indicates whether additional restores of the
       component will follow (i.e., ull restore followed by log restores
       </description>
   </AttributeType>
   <AttributeType name="restoreTarget" dt:type="enumeration"
                  dt:values="original alternate directed originalLocation"
                  default="original" >
       <description>
       This enumerated attribute is set by the writer during PreRestore
       and indicates whether the files for the component should be restored
       to their original location, alternate location (as expressed by
       ALTERNATE_LOCATION_MAPPING elements in the metadata), new location
       (as expressed by RESTORE_TARGET elements created by the writer) or
       should be partially restored (as expressed by the DIRECTED_TARGET
       element created by the writer.
       </description>
   </AttributeType>
   <AttributeType name="preRestoreFailureMsg" dt:type="string" required="no">
       <description>
       This attirbute is set by the writer during the PreRestore event if
       the preRestore operation failed for some reason.  It gives a textual
       description of why the preRestore failed.
       </description>
   </AttributeType>
   <AttributeType name="filesRestored" dt:type="enumeration"
                  dt:values= "none all failed" default="all" >
       <description>
       This attribute is set by the requestor after restoring files
       for the component (i.e., between the PreRestore and PostRestore
       events).  Yes indicates that the files were restored successfully;
       no indicates that the files were not restored and the original files
       are intact; failed indicates that the original files were partially
       overwritten and are therefore corrupt.  Note that the failed status
       can only occur in the situation of a restore of a file where only
       part of the data is restored (DIRECTED_RESTORE) or where only part
       of a file is backed up and restored (e.g., as part of a differential
       backup).  In these cases a failed restore occurs if some of the data
       to be restored is written to the file but not all.  In this case,
       the original copy of the file no long exists and the copy on tape is
       not complete and therefore cannot be used to create a consistent
       copy.  The only option is to use a previous full backup to restore
       the data.  Note that the "failed" indication can be used to indicate
       that some, but no all of the files of a component were restored.  The
       requestore is required to either restore all the files of a component
       or none of the files.  However, there are situations where this is
       not possible, and the restoration of a component has failed, but
       cannot be completely undone.
       </description>
   </AttributeType>
   <AttributeType name="postRestoreFailureMsg" dt:type="string" required="no">
       <description>
       This string attribute is set by the writer during the PostRestore
       event.  It is a text message indicating why the restore failed.
       </description>
   </AttributeType>
   <AttributeType name="backupOptions" dt:type="string" required="no">
       <description>
       This is a private string passed between the requestor and the writer
       to control the backup of the component.  It should be set by the
       requestor prior to the PrepareBackup event.
       </description>
   </AttributeType>
   <AttributeType name="restoreOptions" dt:type="string" required = "no">
       <description>
       This is a private string passsed between to requestor and the writer
       to control the restore of a component.  It should be set by the
       requestor prior to the PreRestore event.
       </description>
   </AttributeType>
   <AttributeType name="restoreInstanceId" dt:type="uuid" required = "no">
       <description>
       This is an attribute that allows a writers component to be restored by a specific
       instance of the writer at restore time.  
       </description>
   </AttributeType>
    <AttributeType name="authRestore" dt:type="enumeration"
               dt:values="yes no" default="no">
      <description>
        This attributes determines whether restore of this component should be authoritative
        or not.
      </description>
    </AttributeType>
    <AttributeType name="rollForwardType" dt:type="enumeration" required = "no"
               dt:values="none all partial">
      <description>
        This attributes determines how far a writer should roll forward restored data
        or not.
      </description>
    </AttributeType>
    <AttributeType name="rollForwardPoint" dt:type="string" required = "no">
      <description>
        This attributes determines how far a writer should roll forward restored data
        or not.
      </description>
    </AttributeType>
    <AttributeType name="restoreName" dt:type="string" required = "no">
      <description>
      This attribute allows a requestor to rename a component at restore time.
      </description>
    </AttributeType>
   <AttributeType name="prepareForBackupFailureMsg" dt:type="string" required="no">
       <description>
       This attirbute is set by the writer during the PrepareForBackup event if
       the PrepareForBackup operation failed for some reason.  It gives a textual
       description of why the PrepareForBackup failed.
       </description>
   </AttributeType>
   <AttributeType name="PostSnapshotFailureMsg" dt:type="string" required="no">
       <description>
       This attirbute is set by the writer during the PostSnapshotFailureMsg event if
       the PostSnapshotFailureMsg operation failed for some reason.  It gives a textual
       description of why the PostSnapshotFailureMsg failed.
       </description>
   </AttributeType>
   <AttributeType name="FailureMsg" dt:type="string" required="no">
       <description>
       This attribute allows writer to set event-independent, per-component error message
       in case of a partial failure.
       </description>
   </AttributeType>
   <AttributeType name="ErrorCode" dt:type="number" required="no">
       <description>
       This attribute allows writer to set basic HRESULT error code on the component
       in case of a partial failure.
       </description>
   </AttributeType>
   <AttributeType name="ApplicationErrorCode" dt:type="number" required="no">
       <description>
       This attribute allows writer to set extended error code information on the component
       in case of a partial failure.
       </description>
   </AttributeType>
   <attribute type="componentType" />
   <attribute type="logicalPath" />
   <attribute type="componentName" />
   <attribute type="restoreInstanceId" />
   <attribute type="backupSucceeded" />
   <attribute type="backupOptions" />
   <attribute type="restoreOptions" />
   <attribute type="backupStamp" />
   <attribute type="previousBackupStamp" />
   <attribute type="selectedForRestore" />
   <attribute type="additionalRestores" />
   <attribute type="restoreTarget" />
   <attribute type="preRestoreFailureMsg" />
   <attribute type="filesRestored" />
   <attribute type="postRestoreFailureMsg" />
   <attribute type="authRestore" />
   <attribute type="rollForwardType" />
   <attribute type="rollForwardPoint" />
   <attribute type="restoreName" />
   <attribute type="prepareForBackupFailureMsg" />
   <attribute type="PostSnapshotFailureMsg" />
   <attribute type="FailureMsg" />
   <attribute type="ErrorCode" />
   <attribute type="ApplicationErrorCode" />
   <element type="ALTERNATE_LOCATION_MAPPING" minOccurs="0" maxOccurs="*" />
   <element type="BACKUP_METADATA" minOccurs="0" maxOccurs="1" />
   <element type="RESTORE_METADATA" minOccurs="0" maxOccurs="1" />
   <element type="RESTORE_TARGET" minOccurs="0" maxOccurs="*" />
   <element type="DIRECTED_TARGET" minOccurs="0" maxOccurs="*" />
   <element type="PARTIAL_FILE" minOccurs="0" maxOccurs="*" />
   <element type="RESTORE_SUBCOMPONENT" minOccurs="0" maxOccurs="*" />
   <element type="DIFFERENCED_FILE" minOccurs="0" maxOccurs="*" />
</ElementType>
<ElementType name="ALTERNATE_LOCATION_MAPPING" content="empty" model="closed">
  <description>
     Mapping from a location that was backed up to a location to restore to.
  </description>
   <attribute type="path" />
   <attribute type="filespec" />
   <attribute type="recursive" />
   <attribute type="alternatePath" />
</ElementType>
<ElementType name="BACKUP_METADATA" content="empty" model="closed">
   <description>
   Default metadata element for backup.  Content is a binary hex string.
   Note that the writer can store whatever he wants in the component.  This
   is just a simple default mechanism.
   </description>
   <AttributeType name="metadata" dt:type="string" required="yes">
      <description>
      Metadata to be passed on restore
      </description>
   </AttributeType>
   <attribute type="metadata" />
</ElementType>
<ElementType name="RESTORE_METADATA" content="empty" model="closed">
   <description>
   Default metadata element for passing information from the writer's
   PreRestore event to the writer's PostRestore event.  The data is
   opaque to the requestor.
   </description>
   <AttributeType name="metadata" dt:type="string" required="yes">
      <description>
      Metadata to be passed from PreRestore to PostRestore.
      </description>
   </AttributeType>
   <attribute type="metadata" />
</ElementType>
<ElementType name="RESTORE_TARGET" content="empty" model="closed">
   <description>
   This element in a COMPONENT should be supplied if the value of the
   restoreTarget attribute of the COMPONENT is "new".  It supplies a
   mapping from a the original location of the file to the location where
   the file should be restored.  There may be multiple RESTORE_TARGET
   elements within a component.
   </description>
   <attribute type="path" />
   <attribute type="filespec" />
   <attribute type="recursive" />
   <attribute type="alternatePath" />
</ElementType>
<ElementType name="DIRECTED_TARGET" content="empty" model="closed">
   <description>
   This element in a COMPONENT should be should be supplied if the value
   of the restoreTarget attribute of the COMPONENT is "directed".  It
   is intended to support partial restoration of files or potentially
   how files should be reorganized upon restore.  There may be multiple
   DIRECTED_TARGET elements within a component.
   </description>
   <AttributeType name="targetPath" dt:type="string" required="no">
       <description>
       This is the target location of the file that is to be written
       by the requestor.  If this attribute is not specified then
       the targetPath is assumed to be the same as the original path.
       </description>
   </AttributeType>
   <AttributeType name="targetFilespec" dt:type="string" required="no">
       <description>
       This is the name of the file that is to be written
       by the requestor.  If this is not specified then the target filename
       is assumed to be the same as the original file name.  Note that if
       both the targetPath and targetFilespec are not specified then the
       original file is overwritten.
       </description>
   </AttributeType>
   <AttributeType name="sourceRanges" dt:type="string" required ="yes">
       <description>
       This is a string of the form (offset:cb ...) where each offset
       is the byte offset to start reading data and cb is the length
       of the data to be read (each is a 64 bit integer).  The ranges
       may not overlap and must be monotonically increasing.
       </description>
   </AttributeType>
   <AttributeType name="targetRanges" dt:type="string" required="yes">
       <description>
       This is a string of the form (offset:cb ...) where each offset
       is the byte offset to start wrting data and cb is the length of
       the data to be written (each is a 64 bit integer).  The ranges
       may not overlap and must be monotonically increasing.
       </description>
   </AttributeType>
   <attribute type="path" />
   <attribute type="filespec" />
   <attribute type="targetPath" />
   <attribute type="targetFilespec" />
   <attribute type="sourceRanges" />
   <attribute type="targetRanges" />
</ElementType>
<ElementType name="PARTIAL_FILE" content="empty" model="closed">
   <description>
   This element in a COMPONENT is supplied by the writer during the
   PostRestore event.  It indicates that only a portion of the file
   should be backed up.  There may be multiple PARTIAL_FILE elements
   within a single COMPONENT.
   </description>
   <AttributeType name="ranges" dt:type="string" required="no">
       <description>
       This range list has the form (offset:length ...) where offset is
       the byte offset in the file to be backed up and length is the length
       of the data to be backed up.  Both are 64 bit integers.  The ranges
       must be monotonically increasing and must not overlap.  If the
       rangelist is not specified then the entire file should be backed up.
       </description>
   </AttributeType>
   <AttributeType name="metadata" dt:type="string" required="no">
       <description>
       This is metadata used by the writer for restoring the partial
       backup.  It might for example, include the total size of the
       file to be restored.
       </description>
   </AttributeType>
   <attribute type="path" />
   <attribute type="filespec" />
   <attribute type="ranges" />
   <attribute type="metadata" />
</ElementType>
<ElementType name="RESTORE_SUBCOMPONENT" content="empty" model="closed">
   <description>
   This element in a COMPONENT is added by the requestore prior to the
   PreRestore event.  It allows a subcomponent of a backed up component to
   be restored.
   </description>
   <AttributeType name="repair" dt:type="enumeration"
                  dt:values="yes no" default="no">
       <description>
       This indicates that the purpose of the restore is to repair one or more files
       of the component.  The writer is responsible for identifying what
       is to be restored using a DIRECTED_TARGET element.
       </description>
   </AttributeType>
   <attribute type="logicalPath" />
   <attribute type="componentName" />
   <attribute type="repair" />
</ElementType>
<ElementType name="SNAPSHOT_SET_DESCRIPTION" content="eltOnly" model="closed">
   <description>
   This describes a snapshot, including the snapshot set id as well as
   the volume information for the snapshotted volumes
   </description>
   <AttributeType name="snapshotSetId" dt:type="uuid" required="yes">
       <description>
       this is the unique identifier for the snapshot
       </description>
   </AttributeType>
   <AttributeType name="context" dt:type="ui4" required="yes">
       <description>
       this is the context used to create the snapshot
       </description>
   </AttributeType>
   <AttributeType name="metadata" dt:type="string" required="no">
       <description>
       this is private metadata about the snapshot set
       </description>
   </AttributeType>
   <AttributeType name="description" dt:type="string" required="no">
       <description>
       this is a user description of the snapshot
       </description>
   </AttributeType>
   <AttributeType name="originalCount" dt:type="ui4" required="yes">
       <description>
       this is the original count of snapshots in the snapshot set
       </description>
   </AttributeType>
   <attribute type="snapshotSetId" />
   <attribute type="context" />
   <attribute type="description" />
   <attribute type="metadata" />
   <attribute type="originalCount" />
   <element type="SNAPSHOT_DESCRIPTION" minOccurs="0" maxOccurs="*" />
</ElementType>
<ElementType name="SNAPSHOT_DESCRIPTION" content="eltOnly" model="closed">
   <description>
   This is the description of a snapshotted volume
   </description>
   <AttributeType name="snapshotId" dt:type="uuid" required="yes" >
       <description>
       This is the unique id of the snapshotted volume
       </description>
   </AttributeType>
   <AttributeType name="originatingMachine" dt:type="string" required="yes" >
       <description>
       This is the machine where the original volume was snapshotted
       </description>
   </AttributeType>
   <AttributeType name="serviceMachine" dt:type="string" required="yes" >
       <description>
       This is the Application Server machine (i.e. where the writers were notified)
       </description>
   </AttributeType>
   <AttributeType name="originalVolumeName" dt:type="string" required ="yes">
       <description>
       This is the original name of the volume.
       </description>
   </AttributeType>
   <AttributeType name="snapshotAttributes" dt:type="ui4" required="yes">
       <description>
       this describes the actual snapshot attributes (as defined in
       VSS_VOLUME_SNAPSHOT_ATTRIBUTES)
       </description>
   </AttributeType>
   <AttributeType name="deviceName" dt:type="string" required="no" >
        <description>
        This is the internal device name for the snapshotted volume.  This
        can be used if the snapshot is not exposed.
        </description>
   </AttributeType>
   <AttributeType name="exposedName" dt:type="string" required="no" >
       <description>
       This is the exposed name of the snapshot volume
       </description>
   </AttributeType>
   <AttributeType name="exposedPath" dt:type="string" required="no">
       <description>
       If only a subdirectory is exposed, this is the path to that
       subdirectory.
       </description>
   </AttributeType>
   <AttributeType name="providerId" dt:type="uuid" required="yes">
       <description>
       This is the provider that surfaced the snapshot
       </description>
   </AttributeType>
   <AttributeType name="timestamp" dt:type="ui8" required="yes">
       <description>
       this is when the snapshot set was created.
       </description>
   </AttributeType>
    <AttributeType name="isDynamicVolume" dt:type="enumeration"
                   dt:values="yes no" required="yes" >
        <description>
        Is the original volume for the snapshot dynamic or basic
        </description>
    </AttributeType>
   <AttributeType name="mappedSnapshotId" dt:type="uuid" required="no">
       <description>
       This is the id of the mapped local snapshot in case that this 
        object stands for a remote virtual snapshot
       </description>
   </AttributeType>
   <AttributeType name="mappedVolumeName" dt:type="string" required ="no">
       <description>
       This is the name of the volume that maps to the original share 
        in case that this object stands for a remote snapshot
       </description>
   </AttributeType>
   <AttributeType name="mappedPathFromRoot" dt:type="string" required ="no">
       <description>
       This is the path of the original share from the volume root. 
        Relevant only if that this object stands for a remote snapshot
       </description>
   </AttributeType>
   <attribute type="snapshotId" />
   <attribute type="providerId" />
   <attribute type="snapshotAttributes" />
   <attribute type="originatingMachine" />
   <attribute type="serviceMachine" />
   <attribute type="originalVolumeName" />
   <attribute type="timestamp" />
   <attribute type="deviceName" />
   <attribute type="exposedPath" />
   <attribute type="exposedName" />
   <attribute type="isDynamicVolume" />
   <attribute type="mappedSnapshotId" />
   <attribute type="mappedVolumeName" />
   <attribute type="mappedPathFromRoot" />
   <element type="LUN_MAPPING" minOccurs="0" maxOccurs="*"/>
</ElementType>
<ElementType name="LUN_MAPPING" content="eltOnly" model="closed">
    <description>
    Actual mapping of source lun to a destination lun
    </description>
    <AttributeType name="sourceDevice" dt:type="string" required="yes" >
        <description>
        This is the device name of the source device on the originating
        machine.  Note that this is only used during snapshot creation
        </description>
    </AttributeType>
    <AttributeType name="lunID" dt:type="uuid" required="no" >
        <description>
        Longhorn Server.
        This GUID is written on all source LUNs at creation time.
        It is needed to match LUNs at import time.
        </description>
    </AttributeType>
    <element type="SOURCE_LUN" minOccurs="1" maxOccurs="1" />
    <element type="DESTINATION_LUN" minOccurs="1" maxOccurs="1" />
    <element type="DISK_EXTENT" minOccurs="1" maxOccurs="*" />
    <attribute type="sourceDevice" />
    <attribute type="lunID" />
</ElementType>
<ElementType name="DISK_EXTENT" content="empty" model="closed">
    <description>
    A particular disk extent on a LUN
    </description>
    <AttributeType name="startingOffset" dt:type="ui8" required="yes">
        <description>
        starting offset of the extent in sectors
        </description>
    </AttributeType>
    <AttributeType name="extentLength" dt:type="ui8" required="yes">
        <description>
        length of the extent in sectors
        </description>
    </AttributeType>
    <attribute type="startingOffset" />
    <attribute type="extentLength" />
</ElementType>
<ElementType name="SOURCE_LUN" content="eltOnly" model="closed">
   <description>
   The information for the lun on the originating volume
   </description>
   <element type="LUN_INFORMATION" />
</ElementType>
<ElementType name="DESTINATION_LUN" content="eltOnly" model="closed">
   <description>
   The information for the lun on the snapshotted volume
   </description>
   <element type="LUN_INFORMATION" />
</ElementType>
<ElementType name="INTERCONNECT_DESCRIPTION" content="empty" model="closed">
   <description>
   An interconnect address including the address type
   </description>
   <AttributeType name="interconnectAddressType" dt:type="enumeration"
                  dt:values="FCFS FCPH FCPH3 MAC Scsi" required="yes" >
       <description>
       interconnect address type.  Describes type of the interconnect
       address stored in the interconnectAddress attribute
       </description>
   </AttributeType>
   <AttributeType name="port" dt:type="string" required="no">
      <description>
      Port through which the interconnect address is referred to.  Note
      that the same device may have different interconnect addresses through
      different ports.
      </description>
   </AttributeType>
   <AttributeType name="interconnectAddress" dt:type="string" required="yes">
       <description>
       World Wide name or other interconnect address of the device
       </description>
   </AttributeType>
   <attribute type="interconnectAddressType" />
   <attribute type="port" />
   <attribute type="interconnectAddress" />
</ElementType>
<ElementType name="LUN_INFORMATION" content="eltOnly" model="closed">
    <description>
    enough of the location and name of the lun to transport it. TBD
    </description>
   <AttributeType name="busType" dt:type="enumeration"
              dt:values="Scsi Atapi Ata 1394 Ssa Fibre Usb RAID iScsi Sas Sata"
              required="yes" >
       <description>
       Type of bus that the LUN is attached to
       </description>
   </AttributeType>
   <AttributeType name="deviceType" dt:type="ui1" required="yes" >
       <description>
       SCSI-2 device type
       </description>
   </AttributeType>
   <AttributeType name="deviceTypeModifier" dt:type="ui1" required="yes">
       <description>
       SCSI-2 device type modifier (if any) - this may be 0
       </description>
   </AttributeType>
   <AttributeType name="commandQueueing" dt:type="enumeration"
                  dt:values="yes no" default="no" >
       <description>
       Flag indicating whether the device can support mulitple outstanding
       commands.  The actual synchronization in this case is the
       responsibility of the port driver.
       </description>
   </AttributeType>
   <AttributeType name="vendorId" dt:type="string" required="no" >
       <description>
       Optional string identifying the vendor
       </description>
   </AttributeType>
   <AttributeType name="productId" dt:type="string" required="no" >
       <description>
       Optional string identifying the product
       </description>
   </AttributeType>
   <AttributeType name="productRevision" dt:type="string" required="no" >
       <description>
       Optional product revision information
       </description>
   </AttributeType>
   <AttributeType name="serialNumber" dt:type="string" required="no" >
       <description>
       Optional serial number of the device
       </description>
   </AttributeType>
   <AttributeType name="diskSignature" dt:type="uuid" required="yes">
       <description>
       Disk signature or GUID.  If a signature than all but the lower
       32 bits of the GUID are 0.
       </description>
   </AttributeType>
   <AttributeType name="deviceIdentification" dt:type="string" required="yes" >
       <description>
       UUENCODED binary for the device identification page as
       defined by the STORAGE_DEVICE_ID_DESCRIPTOR structure.  This contains
       the vendor id, EUI-64 id, FC-PH name, and vendor specific data.
       </description>
   </AttributeType>
   <element type="INTERCONNECT_DESCRIPTION" minOccurs="0" maxOccurs="*"/>
   <attribute type="deviceType" />
   <attribute type="deviceTypeModifier" />
   <attribute type="commandQueueing" />
   <attribute type="busType" />
   <attribute type="vendorId" />
   <attribute type="productId" />
   <attribute type="productRevision" />
   <attribute type="serialNumber" />
   <attribute type="diskSignature" />
   <attribute type="deviceIdentification" />
</ElementType>
<ElementType name="DIFFERENCED_FILE" content="empty" model="closed">
<description>
The writer used these elements to indicate differenced files.
</description>
<AttributeType name="lastModifyLSN" dt:type="string" required="no" >
<description>
The LSN that indicates the point of the last backup.
</description>
</AttributeType>
<AttributeType name="lastModifyTimeLow" dt:type="number" default="0" >
<description>
The time that indicates the point of the last backup.
</description>
</AttributeType>
<AttributeType name="lastModifyTimeHigh" dt:type="number" default="0" >
<description>
The time that indicates the point of the last backup.
</description>
</AttributeType>
<attribute type="path" />
<attribute type="filespec"  />
<attribute type="recursive" />
<attribute type="lastModifyLSN" />
<attribute type="lastModifyTimeLow" />
<attribute type="lastModifyTimeHigh" />
</ElementType>
</Schema>
<Schema name="VssWriterMetadataInfo"
        xmlns="urn:schemas-microsoft-com:xml-data"
    xmlns:dt="urn:schemas-microsoft-com:datatypes">
<AttributeType name="filespec" dt:type="string" required="yes">
   <description>
   File specification.  Can include wildcard characters ? and *
   </description>
</AttributeType>
<AttributeType name="path" dt:type="string" required="yes">
   <description>
   Path to a file.  The path can include environment variables or
   values extracted from registry keys.
   </description>
</AttributeType>
<AttributeType name="recursive" dt:type="enumeration"
               dt:values="yes no" default="no">
   <description>
   Is path specified recursive or limited to the directory that is specified.
   </description>
</AttributeType>
<AttributeType name="alternatePath" dt:type="string" required="no">
   <description>
   Alternate path in which to find the file.  Files in a file group may
   have been copied to an alternative location by the writer.  Backup should
   pick up the files from the alternative location instead of the original
   location but should restore the files to their original location
   </description>
</AttributeType>
<AttributeType name="logicalPath" dt:type="string" required="no">
   <description>
   Logical path for a database or file group.  This logical name uses backslash
   as separators to form a logical namespace hierarchy
   </description>
</AttributeType>
<AttributeType name="componentName" dt:type="string" required="yes">
   <description>
   Name used to identify a database or file group.  May be qualified by a
   logical path.
   </description>
</AttributeType>
<AttributeType name="restoreMetadata" dt:type="enumeration"
               dt:values="yes no" default="no">
   <description>
   Restore metadata exists for this database or file group.  Backup
   application should capture the restore metadata and pass it to the
   writer on restore.
   </description>
</AttributeType>
<AttributeType name="notifyOnBackupComplete" dt:type="enumeration"
               dt:values="yes no" default="no">
   <description>
   Writer should be notified when backup is complete whether this
   database or file group was successfully backed up or not.
   </description>
</AttributeType>
<AttributeType name="caption" dt:type="string" required="no">
   <description>
   Textual Description of database or file group
   </description>
</AttributeType>
<AttributeType name="icon" dt:type="string" required="no">
   <description>
   Icon associated with database or file group
   </description>
</AttributeType>
<AttributeType name="selectable" dt:type="enumeration"
               dt:values="yes no" default="yes">
   <description>
   Is this component selectable for backup or is it always backed up.
   If no, then the component is always backed up if any other components of
   the application/service are backed up.  If yes, then the
   component may be selectively backed up.
   </description>
</AttributeType>
<AttributeType name="selectableForRestore" dt:type="enumeration"
               dt:values="yes no" default="no">
   <description>
   Is this component selectable for restore
   </description>
</AttributeType>
<AttributeType name="version" dt:type="enumeration" dt:values="1.0 1.1 1.2 1.3" required="yes">
   <description>
   Version of a specific document
   </description>
</AttributeType>
<AttributeType name="writerId" dt:type="uuid" required="yes">
   <description>
   Unique id to identify the writer.  Note that this identifies the
   writer class rather than a specific instance of the writer.
   </description>
</AttributeType>
<AttributeType name="instanceId" dt:type="uuid" required="no">
   <description>
   Unique id identifying the instance of a writer during backup.  It
   has no meaning during restore.
   </description>
</AttributeType>
<AttributeType name="instanceName" dt:type="string" required="no">
   <description>
   Unique id generated by the writer that identifies the instance of a writer
   both during backup and restore.  This id is used to map writers at backup
   time to writers at restore time.
   </description>
</AttributeType>
<AttributeType name="componentFlags" dt:type="number" default="0">
   <description>
   Contains extra flags that describe the component being backed up.   
   </description>
</AttributeType>
<AttributeType name="backupSchema" dt:type="number" default="0">
<description>
Describes the writer capabilities and how different types of backup are performed.
</description>
</AttributeType>
<AttributeType name="filespecBackupType" dt:type="number" default="0">
<description>
Describes how backup should be performed on a specific filespec.
</description>
</AttributeType>
<ElementType name="WRITER_METADATA" content="eltOnly" model="open" order="one">
   <description>
      Information used by Backup application to backup/restore data
   </description>
   <attribute type="version" />
   <attribute type="backupSchema" />
   <element type="IDENTIFICATION" />
   <element type="BACKUP_LOCATIONS" minOccurs="0" />
   <element type="RESTORE_METHOD" minOccurs="0" />
</ElementType>
<ElementType name="IDENTIFICATION" content="empty" model="closed">
   <description>
      Identification of a service/application backing up data
   </description>
   <AttributeType name="friendlyName" dt:type="string" required="yes">
      <description>
      Friendly name used to describe the service or application.
      </description>
   </AttributeType>
   <AttributeType name="usage" dt:type="enumeration"
           dt:values="USER_DATA BOOTABLE_SYSTEM_STATE SYSTEM_SERVICE OTHER"
           default="OTHER">
      <description>
      How the data associated with the writer is used.  For now we
      distinguish user data and system state.
      </description>
   </AttributeType>
   <AttributeType name="dataSource" dt:type="enumeration"
               dt:values="TRANSACTION_DB NONTRANSACTIONAL_DB OTHER"
           default="OTHER">
      <description>
      Description of the nature of the data manager.  Currently only
      databases are identified
      </description>
   </AttributeType>
   <AttributeType name="majorVersion" dt:type="number" default="1">
     <description>
       Major version number of the writer.
     </description>
   </AttributeType>
   <AttributeType name="minorVersion" dt:type="number" default="0">
     <description>
       Minor version number of the writer.
     </description>
   </AttributeType>
   <attribute type="instanceId" required="yes" />
   <attribute type="instanceName" />
   <attribute type="writerId" />
   <attribute type="friendlyName" />
   <attribute type="usage" />
   <attribute type="dataSource" />
   <attribute type="majorVersion" />
   <attribute type="minorVersion" />
</ElementType>
<ElementType name="BACKUP_LOCATIONS" content="eltOnly" model="closed" order="many">
   <description>
      Files to include and exclude from the backup
   </description>
   <element type="INCLUDE_FILES" minOccurs="0" />
   <element type="EXCLUDE_FILES" minOccurs="0" />
   <element type="EXCLUDE_FILES_FROM_SNAPSHOT" minOccurs="0" />   
   <element type="DATABASE" minOccurs="0"/>
   <element type="FILE_GROUP" minOccurs="0" />
</ElementType>
<ElementType name="INCLUDE_FILES" content="empty">
   <description>
      Files to include in the backup, essentially files to backup if you want
      to backup this application/service
   </description>
   <attribute type="path" />
   <attribute type="filespec" />
   <attribute type="recursive" />
   <attribute type="alternatePath" />
</ElementType>
<ElementType name="EXCLUDE_FILES" content="empty">
   <description>
      Files that should always be excluded from the backup
   </description>
   <attribute type="path" />
   <attribute type="filespec" />
   <attribute type="recursive" />
</ElementType>
<ElementType name="EXCLUDE_FILES_FROM_SNAPSHOT" content="empty">
   <description>
      Files that should always be excluded from the backup
   </description>
   <attribute type="path" />
   <attribute type="filespec" />
   <attribute type="recursive" />
</ElementType>
<ElementType name="DATABASE" content="eltOnly" model="closed" order="many">
   <description>
      List of databases of interest.  This is used to allow selective
      backup and restore of specific databases.
   </description>
   <attribute type= "logicalPath" />
   <attribute type="componentName" />
   <attribute type="caption" />
   <attribute type="icon" />
   <attribute type="restoreMetadata" />
   <attribute type="notifyOnBackupComplete" />
   <attribute type="selectable" />
   <attribute type="selectableForRestore" />
   <attribute type="componentFlags" />
   <element type="DATABASE_FILES" minOccurs="1" />
   <element type="DATABASE_LOGFILES" />
   <element type="DEPENDENCY" minOccurs="0" />
</ElementType>
<ElementType name="DATABASE_FILES" content="empty" model="closed">
   <description>
      Location of a set of database files.  Filespec can include wildcards
   </description>
   <attribute type="path" />
   <attribute type="filespec" />
   <attribute type="filespecBackupType" />
</ElementType>
<ElementType name="DATABASE_LOGFILES" content="empty" model="closed">
   <description>
      Location of a set of database log files.  Filespec can include
      wildcards.  Indication of whether database log files are truncated.
   </description>
   <attribute type="path" />
   <attribute type="filespec" />
   <attribute type="filespecBackupType" />
</ElementType>
<ElementType name="FILE_GROUP" content="eltOnly" model="closed" order="many">
   <description>
      A named group of files.  Used to group sets of files into a group
      that are backed up together
   </description>
   <attribute type="logicalPath" />
   <attribute type="componentName" />
   <attribute type="caption" />
   <attribute type="icon" />
   <attribute type="restoreMetadata" />
   <attribute type="notifyOnBackupComplete" />
   <attribute type="selectable" />
   <attribute type="selectableForRestore" />
   <attribute type="componentFlags" />
   <element type="FILE_LIST" />
   <element type="DEPENDENCY" minOccurs="0" />
</ElementType>
<ElementType name="FILE_LIST" content="empty" model="closed">
   <description>
      Location of a set of files in a FILE_GROUP.  Filespec can include
      wildcards.
   </description>
   <attribute type="path" />
   <attribute type="filespec" />
   <attribute type="recursive" />
   <attribute type="alternatePath" />
   <attribute type="filespecBackupType" />
</ElementType>
<ElementType name="DEPENDENCY" content="empty" model="closed">
    <description>
    A dependency from one component to another component in another writer.
    </description>
  <AttributeType name="onWriterId" dt:type="uuid" required="yes">
    <description>
    Id of writer that this component is dependent on.
    </description>
  </AttributeType>
  <AttributeType name="onLogicalPath" dt:type="string" required="no">
    <description>
    Logical path of component that this component is dependent on.
    </description>
  </AttributeType>
  <AttributeType name="onComponentName" dt:type="string" required="yes">
    <description>
    Name of component that this component is dependent on.
    </description>
  </AttributeType>
  <attribute type="onWriterId" />
  <attribute type="onLogicalPath" />
  <attribute type="onComponentName" />
</ElementType>
<ElementType name="RESTORE_METHOD" content="eltOnly" model="open" order="many">
  <description>
  How restore should be performed.  Includes specification of how files
  should be restored as well as special steps that should occur in order
  to complete the restore.
  </description>
  <AttributeType name="method" dt:type="enumeration"
             required="yes"
             dt:values="RESTORE_IF_NONE_THERE
                        RESTORE_IF_CAN_BE_REPLACED
                        STOP_RESTART_SERVICE
                        REPLACE_AT_REBOOT
                        REPLACE_AT_REBOOT_IF_CANNOT_REPLACE
                        RESTORE_TO_ALTERNATE_LOCATION
                        CUSTOM
                        RESTORE_STOP_START_SERVICE">
      <description>
       RESTORE_IF_NONE_THERE: i.e., can restore data if it is not at the
       location where it was backed up from.  This essentially allows
       data to be restored to a clean system
       RESTORE_IF_CAN_BE_REPLACED: Restore data if all of the files can
       be replaced in the orgiginal backup location.  Fails if any of
       the files are open.  If an alternate location is provided, files
       will be placed there if they cannot be restored to their original
       location.
       STOP_RESTART_SERVICE: stop service (service attribute must be
       specified). Restore files to original backup location.
       Restart service.  Fails if any of the files are open after the
       service is stopped.
       REPLACE_AT_REBOOT: Restore files to a temporary location.  Use
       MoveFileEx to replace the files at reboot.
       REPLACE_AT_REBOOT_IF_CANNOT_REPLACE:  Similiar to REPLACE_AT_REBOOT
       however files may be restored in place in they are not busy.  All files
       within a component must be either completely replaced in place or
       completely replaced at reboot, so if one component file is busy, all files
       in that component must be replaced at reboot.       
       RESTORE_TO_ALTERNATIVE_LOCATION: Restore files to an alternate
       location.  Typically writerRestore will indicate that the writer
       will participate in the restore process
       CUSTOM: restore process cannot be expressed using this specification
       RESTORE_STOP_START_SERVICE: Restore files to original location,
       then restart the specified service.
       </description>
   </AttributeType>
   <AttributeType name="service" dt:type="string" required="no">
      <description>
      Must be specified if method="STOP_RESTART_SERVICE" or method="RESTORE_STOP_START_SERVICE".
      </description>
   </AttributeType>
   <AttributeType name="writerRestore" dt:type="enumeration"
                  dt:values="always never ifReplaceFails" default="never">
      <description>
      Whether writer should be invoked after files are restored to
      disk.  Options are always, never, and ifReplaceFails.  The latter means
      that the files will be restored to their original location.  If one
      or more of the files cannot be replaced, then the files will be
      restored to an alternate location (must be specified via
      ALTERNATE_LOCATION_MAPPING.  After the files are restored, the writer
      is invoked.
      </description>
   </AttributeType>
  <AttributeType name="userProcedure" dt:type="uri" required="no">
     <description>
     Description of actions that the user should perform to restore the files.
     The format of this string has yet to be determined.
     </description>
  </AttributeType>
  <AttributeType name="rebootRequired" dt:type="enumeration"
                 dt:values="yes no" default="no" >
     <description>
     Should a reboot be performed after restoring the data for this
     writer
     </description>
  </AttributeType>
  <attribute type="method" />
  <attribute type="service" />
  <attribute type="writerRestore" />
  <attribute type="userProcedure" />
  <attribute type="rebootRequired" />
  <element type="ALTERNATE_LOCATION_MAPPING" minOccurs="0" maxOccurs="*" />
</ElementType>
<ElementType name="ALTERNATE_LOCATION_MAPPING" content="empty" model="closed">
  <description>
     Mapping from a location that was backed up to a location to restore to.
  </description>
   <attribute type="path" />
   <attribute type="filespec" />
   <attribute type="recursive" />
   <attribute type="alternatePath" />
</ElementType>
</Schema>
<Schema name="VssWriterMetadataInfo"
        xmlns="urn:schemas-microsoft-com:xml-data"
    xmlns:dt="urn:schemas-microsoft-com:datatypes">
<AttributeType name="filespec" dt:type="string" required="yes">
   <description>
   File specification.  Can include wildcard characters ? and *
   </description>
</AttributeType>
<AttributeType name="path" dt:type="string" required="yes">
   <description>
   Path to a file.  The path can include environment variables or
   values extracted from registry keys.
   </description>
</AttributeType>
<AttributeType name="recursive" dt:type="enumeration"
               dt:values="yes no" default="no">
   <description>
   Is path specified recursive or limited to the directory that is specified.
   </description>
</AttributeType>
<AttributeType name="alternatePath" dt:type="string" required="no">
   <description>
   Alternate path in which to find the file.  Files in a file group may
   have been copied to an alternative location by the writer.  Backup should
   pick up the files from the alternative location instead of the original
   location but should restore the files to their original location
   </description>
</AttributeType>
<AttributeType name="logicalPath" dt:type="string" required="no">
   <description>
   Logical path for a database or file group.  This logical name uses backslash
   as separators to form a logical namespace hierarchy
   </description>
</AttributeType>
<AttributeType name="componentName" dt:type="string" required="yes">
   <description>
   Name used to identify a database or file group.  May be qualified by a
   logical path.
   </description>
</AttributeType>
<AttributeType name="restoreMetadata" dt:type="enumeration"
               dt:values="yes no" default="no">
   <description>
   Restore metadata exists for this database or file group.  Backup
   application should capture the restore metadata and pass it to the
   writer on restore.
   </description>
</AttributeType>
<AttributeType name="notifyOnBackupComplete" dt:type="enumeration"
               dt:values="yes no" default="no">
   <description>
   Writer should be notified when backup is complete whether this
   database or file group was successfully backed up or not.
   </description>
</AttributeType>
<AttributeType name="caption" dt:type="string" required="no">
   <description>
   Textual Description of database or file group
   </description>
</AttributeType>
<AttributeType name="icon" dt:type="string" required="no">
   <description>
   Icon associated with database or file group
   </description>
</AttributeType>
<AttributeType name="selectable" dt:type="enumeration"
               dt:values="yes no" default="yes">
   <description>
   Is this component selectable for backup or is it always backed up.
   If no, then the component is always backed up if any other components of
   the application/service are backed up.  If yes, then the
   component may be selectively backed up.
   </description>
</AttributeType>
<AttributeType name="selectableForRestore" dt:type="enumeration"
               dt:values="yes no" default="no">
   <description>
   Is this component selectable for restore
   </description>
</AttributeType>
<AttributeType name="version" dt:type="enumeration" dt:values="1.0 1.1 1.2 1.3" required="yes">
   <description>
   Version of a specific document
   </description>
</AttributeType>
<AttributeType name="writerId" dt:type="uuid" required="yes">
   <description>
   Unique id to identify the writer.  Note that this identifies the
   writer class rather than a specific instance of the writer.
   </description>
</AttributeType>
<AttributeType name="instanceId" dt:type="uuid" required="no">
   <description>
   Unique id identifying the instance of a writer during backup.  It
   has no meaning during restore.
   </description>
</AttributeType>
<AttributeType name="instanceName" dt:type="string" required="no">
   <description>
   Unique id generated by the writer that identifies the instance of a writer
   both during backup and restore.  This id is used to map writers at backup
   time to writers at restore time.
   </description>
</AttributeType>
<AttributeType name="componentFlags" dt:type="number" default="0">
   <description>
   Contains extra flags that describe the component being backed up.   
   </description>
</AttributeType>
<AttributeType name="backupSchema" dt:type="number" default="0">
<description>
Describes the writer capabilities and how different types of backup are performed.
</description>
</AttributeType>
<AttributeType name="filespecBackupType" dt:type="number" default="0">
<description>
Describes how backup should be performed on a specific filespec.
</description>
</AttributeType>
<ElementType name="WRITER_METADATA" content="eltOnly" model="open" order="one">
   <description>
      Information used by Backup application to backup/restore data
   </description>
   <attribute type="version" />
   <attribute type="backupSchema" />
   <element type="IDENTIFICATION" />
   <element type="BACKUP_LOCATIONS" minOccurs="0" />
   <element type="RESTORE_METHOD" minOccurs="0" />
</ElementType>
<ElementType name="IDENTIFICATION" content="empty" model="closed">
   <description>
      Identification of a service/application backing up data
   </description>
   <AttributeType name="friendlyName" dt:type="string" required="yes">
      <description>
      Friendly name used to describe the service or application.
      </description>
   </AttributeType>
   <AttributeType name="usage" dt:type="enumeration"
           dt:values="USER_DATA BOOTABLE_SYSTEM_STATE SYSTEM_SERVICE OTHER"
           default="OTHER">
      <description>
      How the data associated with the writer is used.  For now we
      distinguish user data and system state.
      </description>
   </AttributeType>
   <AttributeType name="dataSource" dt:type="enumeration"
               dt:values="TRANSACTION_DB NONTRANSACTIONAL_DB OTHER"
           default="OTHER">
      <description>
      Description of the nature of the data manager.  Currently only
      databases are identified
      </description>
   </AttributeType>
   <AttributeType name="majorVersion" dt:type="number" default="1">
     <description>
       Major version number of the writer.
     </description>
   </AttributeType>
   <AttributeType name="minorVersion" dt:type="number" default="0">
     <description>
       Minor version number of the writer.
     </description>
   </AttributeType>
   <attribute type="instanceId" required="yes" />
   <attribute type="instanceName" />
   <attribute type="writerId" />
   <attribute type="friendlyName" />
   <attribute type="usage" />
   <attribute type="dataSource" />
   <attribute type="majorVersion" />
   <attribute type="minorVersion" />
</ElementType>
<ElementType name="BACKUP_LOCATIONS" content="eltOnly" model="closed" order="many">
   <description>
      Files to include and exclude from the backup
   </description>
   <element type="INCLUDE_FILES" minOccurs="0" />
   <element type="EXCLUDE_FILES" minOccurs="0" />
   <element type="EXCLUDE_FILES_FROM_SNAPSHOT" minOccurs="0" />   
   <element type="DATABASE" minOccurs="0"/>
   <element type="FILE_GROUP" minOccurs="0" />
</ElementType>
<ElementType name="INCLUDE_FILES" content="empty">
   <description>
      Files to include in the backup, essentially files to backup if you want
      to backup this application/service
   </description>
   <attribute type="path" />
   <attribute type="filespec" />
   <attribute type="recursive" />
   <attribute type="alternatePath" />
</ElementType>
<ElementType name="EXCLUDE_FILES" content="empty">
   <description>
      Files that should always be excluded from the backup
   </description>
   <attribute type="path" />
   <attribute type="filespec" />
   <attribute type="recursive" />
</ElementType>
<ElementType name="EXCLUDE_FILES_FROM_SNAPSHOT" content="empty">
   <description>
      Files that should always be excluded from the backup
   </description>
   <attribute type="path" />
   <attribute type="filespec" />
   <attribute type="recursive" />
</ElementType>
<ElementType name="DATABASE" content="eltOnly" model="closed" order="many">
   <description>
      List of databases of interest.  This is used to allow selective
      backup and restore of specific databases.
   </description>
   <attribute type= "logicalPath" />
   <attribute type="componentName" />
   <attribute type="caption" />
   <attribute type="icon" />
   <attribute type="restoreMetadata" />
   <attribute type="notifyOnBackupComplete" />
   <attribute type="selectable" />
   <attribute type="selectableForRestore" />
   <attribute type="componentFlags" />
   <element type="DATABASE_FILES" minOccurs="1" />
   <element type="DATABASE_LOGFILES" />
   <element type="DEPENDENCY" minOccurs="0" />
</ElementType>
<ElementType name="DATABASE_FILES" content="empty" model="closed">
   <description>
      Location of a set of database files.  Filespec can include wildcards
   </description>
   <attribute type="path" />
   <attribute type="filespec" />
   <attribute type="filespecBackupType" />
</ElementType>
<ElementType name="DATABASE_LOGFILES" content="empty" model="closed">
   <description>
      Location of a set of database log files.  Filespec can include
      wildcards.  Indication of whether database log files are truncated.
   </description>
   <attribute type="path" />
   <attribute type="filespec" />
   <attribute type="filespecBackupType" />
</ElementType>
<ElementType name="FILE_GROUP" content="eltOnly" model="closed" order="many">
   <description>
      A named group of files.  Used to group sets of files into a group
      that are backed up together
   </description>
   <attribute type="logicalPath" />
   <attribute type="componentName" />
   <attribute type="caption" />
   <attribute type="icon" />
   <attribute type="restoreMetadata" />
   <attribute type="notifyOnBackupComplete" />
   <attribute type="selectable" />
   <attribute type="selectableForRestore" />
   <attribute type="componentFlags" />
   <element type="FILE_LIST" />
   <element type="DEPENDENCY" minOccurs="0" />
</ElementType>
<ElementType name="FILE_LIST" content="empty" model="closed">
   <description>
      Location of a set of files in a FILE_GROUP.  Filespec can include
      wildcards.
   </description>
   <attribute type="path" />
   <attribute type="filespec" />
   <attribute type="recursive" />
   <attribute type="alternatePath" />
   <attribute type="filespecBackupType" />
</ElementType>
<ElementType name="DEPENDENCY" content="empty" model="closed">
    <description>
    A dependency from one component to another component in another writer.
    </description>
  <AttributeType name="onWriterId" dt:type="uuid" required="yes">
    <description>
    Id of writer that this component is dependent on.
    </description>
  </AttributeType>
  <AttributeType name="onLogicalPath" dt:type="string" required="no">
    <description>
    Logical path of component that this component is dependent on.
    </description>
  </AttributeType>
  <AttributeType name="onComponentName" dt:type="string" required="yes">
    <description>
    Name of component that this component is dependent on.
    </description>
  </AttributeType>
  <attribute type="onWriterId" />
  <attribute type="onLogicalPath" />
  <attribute type="onComponentName" />
</ElementType>
<ElementType name="RESTORE_METHOD" content="eltOnly" model="open" order="many">
  <description>
  How restore should be performed.  Includes specification of how files
  should be restored as well as special steps that should occur in order
  to complete the restore.
  </description>
  <AttributeType name="method" dt:type="enumeration"
             required="yes"
             dt:values="RESTORE_IF_NONE_THERE
                        RESTORE_IF_CAN_BE_REPLACED
                        STOP_RESTART_SERVICE
                        REPLACE_AT_REBOOT
                        REPLACE_AT_REBOOT_IF_CANNOT_REPLACE
                        RESTORE_TO_ALTERNATE_LOCATION
                        CUSTOM
                        RESTORE_STOP_START_SERVICE">
      <description>
       RESTORE_IF_NONE_THERE: i.e., can restore data if it is not at the
       location where it was backed up from.  This essentially allows
       data to be restored to a clean system
       RESTORE_IF_CAN_BE_REPLACED: Restore data if all of the files can
       be replaced in the orgiginal backup location.  Fails if any of
       the files are open.  If an alternate location is provided, files
       will be placed there if they cannot be restored to their original
       location.
       STOP_RESTART_SERVICE: stop service (service attribute must be
       specified). Restore files to original backup location.
       Restart service.  Fails if any of the files are open after the
       service is stopped.
       REPLACE_AT_REBOOT: Restore files to a temporary location.  Use
       MoveFileEx to replace the files at reboot.
       REPLACE_AT_REBOOT_IF_CANNOT_REPLACE:  Similiar to REPLACE_AT_REBOOT
       however files may be restored in place in they are not busy.  All files
       within a component must be either completely replaced in place or
       completely replaced at reboot, so if one component file is busy, all files
       in that component must be replaced at reboot.       
       RESTORE_TO_ALTERNATIVE_LOCATION: Restore files to an alternate
       location.  Typically writerRestore will indicate that the writer
       will participate in the restore process
       CUSTOM: restore process cannot be expressed using this specification
       RESTORE_STOP_START_SERVICE: Restore files to original location,
       then restart the specified service.
       </description>
   </AttributeType>
   <AttributeType name="service" dt:type="string" required="no">
      <description>
      Must be specified if method="STOP_RESTART_SERVICE" or method="RESTORE_STOP_START_SERVICE".
      </description>
   </AttributeType>
   <AttributeType name="writerRestore" dt:type="enumeration"
                  dt:values="always never ifReplaceFails" default="never">
      <description>
      Whether writer should be invoked after files are restored to
      disk.  Options are always, never, and ifReplaceFails.  The latter means
      that the files will be restored to their original location.  If one
      or more of the files cannot be replaced, then the files will be
      restored to an alternate location (must be specified via
      ALTERNATE_LOCATION_MAPPING.  After the files are restored, the writer
      is invoked.
      </description>
   </AttributeType>
  <AttributeType name="userProcedure" dt:type="uri" required="no">
     <description>
     Description of actions that the user should perform to restore the files.
     The format of this string has yet to be determined.
     </description>
  </AttributeType>
  <AttributeType name="rebootRequired" dt:type="enumeration"
                 dt:values="yes no" default="no" >
     <description>
     Should a reboot be performed after restoring the data for this
     writer
     </description>
  </AttributeType>
  <attribute type="method" />
  <attribute type="service" />
  <attribute type="writerRestore" />
  <attribute type="userProcedure" />
  <attribute type="rebootRequired" />
  <element type="ALTERNATE_LOCATION_MAPPING" minOccurs="0" maxOccurs="*" />
</ElementType>
<ElementType name="ALTERNATE_LOCATION_MAPPING" content="empty" model="closed">
  <description>
     Mapping from a location that was backed up to a location to restore to.
  </description>
   <attribute type="path" />
   <attribute type="filespec" />
   <attribute type="recursive" />
   <attribute type="alternatePath" />
</ElementType>
</Schema>
0 0$0(0,0004080<0@0D0H0L0P0T0X0\0`0d0h0l0p0t0x0|0
1 1$1(1,141<1D1L1T1\1d1l1t1|1
2$2,242<2D2L2T2\2d2l2t2|2
3$3,343<3D3L3T3\3d3l3t3|3
4$4,444<4D4L4T4\4d4l4t4|4
5$5,545<5D5L5T5\5d5l5t5|5
6 6$6(6,6064686<6@6D6H6L6P6T6X6\6`6d6h6l6p6t6x6|6
7 7$7(7,7074787<7@7D7H7L7P7T7X7\7`7d7h7l7p7t7x7|7
8 8$8(8,8084888<8@8D8H8L8P8T8X8\8`8d8h8l8p8t8x8|8
9 9$9(9,9094989<9@9D9H9L9P9T9X9\9`9d9h9l9p9t9x9|9
: :$:(:,:0:4:8:<:@:D:H:L:P:T:X:\:`:d:h:l:p:t:x:|:
;D;H;P;X;p;
< <$<(<,<D<H<L<P<T<X<\<`<d<h<l<p<t<x<|<
= =$=(=,=0=4=8=<=@=D=H=L=P=T=X=\=`=d=h=l=p=t=x=|=
> >$>(>,>0>4>8><>@>D>H>L>P>T>X>\>`>d>h>l>p>t>x>|>
? ?$?(?,?0?4?8?<?@?D?H?L?P?T?X?\?`?d?h?l?p?t?x?|?
0 0$0(0,0004080<0@0D0H0L0P0T0X0\0`0d0h0l0p0t0x0|0
1 1$1(1,1014181<1@1D1H1L1P1T1X1\1`1d1h1l1p1t1x1|1
2 2$2(2,2024282<2@2D2H2L2P2T2X2\2`2d2h2l2p2t2x2|2
3 3$3(3,3034383<3@3D3H3L3P3T3X3\3`3h3p3x3
4(444@4L4X4d4p4|4
5 5$5(5,50545@5
:1:Q:q:w:|:
;";1;Q;q;
<&<7<G<L<k<
=C=H=M=h=
>)>2>;>D>M>V>\>
?"?8?=?D?T?n?
182M2b2n2
2%373i3
424>4Q4`4
6'6,6?6X6l6
7;7M7
8'818;8
9(9d9o9
:):.:3:V:h:m:r:
;:;E;L;S;
<,<1<6<R<_<
= =/=
>b?k?}?
3"3*323:3B3J3|3
5+636?6G6W6c6v6
7,7b7
91:7:L:[:y:
; ;2;X;m;
<A<S<
<6=S=a=}=
=6>J>
?+?>?M?
1)272V2[2k2
2<3E3W3s3
3X4m4
5>5P5
6&6:6
7!7+7
829;9M9
9I:O:a:
<s<z<
<%=5=<=C=
0"0^0d0v0}0
1&1-141p1
2+2;2
313v3
3_4h4s4
5E5_5k5{5
6;7I7X7d7
9'989E9N9_9
9X:a:o:~:
:);7;F;R;
<>=I=R=[=d=
=5>A>V>
?e?s?
1.2T2^2
3;3M3W3
4%4g4q4
4<5Z5j5
5.686r6y6
7@7G7l7~7
8+8\8
:S:^:~:
:V;j;
<'=<=
>/>V>y>
>1?=?O?a?f?k?
101u1
1&2:2
595L5Q5V5q5
6,61666Q6d6i6n6
7(727
9&9:9
9(:::
:m;~;
;$<I<
<A=Y=^=c=
>,>@>G>N>T>f>k>p>
?7?<?N?S?X?q?v?
0I0`0e0j0
3#3q3|3
4-4a4h4
5k6u6
7b7o7
8#8*808@8c8y8
9!9I9v9
:):.:;:y:
<2=C=
>)>J>a>
?+?U?
03080=0M0k0
141K1P1U1k1
293M3R3W3u3z3
4+4B4G4L4b4y4~4
52585O5T5Y5p5
636x6
6/767=7Q7
7%8B8P8d8
829;9M9f9x9
;0;i;
<A<\<z<
=&=3=U=p=
>&>:>
?2?P?p?
(0=0\0q0
011=1O1Z1_1i1~1
2)2c2
3"373B3P3[3j3
4E5Z5
6.7;7R7
868I8`8
8"9H9]9w9
9.:@:v:
:f;o;
<"=p=
=9>N>
0>1E1S1g1n1{1
1"2+2=2h2}2
3N3`3
464J4
848|88:J:
;+?i?
6G6U6
777>7J7^7
858H8W8
849m9{9
:':7:F:Z:
;7;J;Y;
<b=k=}=
R0[0m0
1k1n2r2x2|2
3%3,32383>3D3U3c3
4)4>4Z4`4
7!7H7c7w7
;,;A;K;`;j;
<)<><J<
=P=z=
>%?+?W?\?a?
0*03090Z0b0i0o0u0
1(101C1O1W1
2-2Q3i3
3P4~4
52585>5D5J5P5W5^5e5l5s5z5
6 6)6@6F6L6R6X6^6e6l6s6z6
8,848J8R8v8
9*9<9M9t9
;9;u;
;h<m<
>2>u>
?'?7?G?W?g?w?
0,090M0]0j0~0
1 101@1P1`1p1
2!212>2R2_2s2
3%353B3V3f3v3
4)494I4V4j4
4*515:5J5R5_5c5i5m5
5.6<6P6Y6b6h6m6r6y6
727J7}7
9F:O:U:m:
;*;8;=;\;i;|;
=A=^=
6$7|7
94:t:
>$?G?
1D1g1
2W2}2
3)4i4
6-7Z7
7%8U8
8(9n9
=:=Z=
>:>j>
1<1d1|1
3/3G3o3
3/4o4
5E6}6
738k8
9I:y:
;/<i<
>/>i>
>1?a?
0)0I0q0
1I1i1
3)4a4
5A5y5
5!6Y6
7"8r8
<F=~=
=6>f>
0.1k1
2=2z2I3
425t5
5.6^6
848d8
8$9W9
:?:_:
;/<i<
=.=V=
>>>n>
1$2r2
2!3Q3
5)6a6
8 9h9
;:;j;
;"<b<
</=j=
>@>x>
?@?x?
0(1`1
4!5_5
657s7
;)<\<
=[=~=
0D1|1
515Y5
878g8
=+>s>
0A0q0
1,1\1
1'2W2
5M5p5
556p6
728}8
9%9]9m9}9
:I:Y:
;G;w;
<2<6<R<V<q<
=>=E=J=[=`=e=
?4?V?n?z?
0#000E0g0
1*1/141A1b1q1
1,2N2f2r2
3%3=3I3o3
4?4]4s4
545V5n5z5
6"6'6,6J6O6T6a6w6|6
7(7@7L7u7
9%9*9/9?9e9
9$:;:@:E:a:
:.;P;h;t;
<"<'<,<^<
=7=T=f=v=
>'>H>T>u>
?D?P?
0&0;0_0d0i0y0
151>1V1[1`1
2#2(2-2=2^2
3(3<3A3K3]3b3g3
3U4y4
5$565;5@5S5k5}5
6 6%6*6?6c6r6~6
6&797>7C7n7
8F8y8
9@9V9i9
:-:3:E:J:O:u:
;=;B;G;
<#<6<;<@<J<]<b<g<t<
=&=1=Y=
>%>/>k>
000G0L0Q0y0~0
1)1V1f1k1p1
192T2x2}2
3-32373P3W3`3o3t3y3
4,41464d4v4{4
5S5f5k5p5
526R6e6j6o6
6Q7i7
7'8g8
9$:4:9:>:S:
<D<V<[<`<x<
=/=4=9=c=
?#?M?o?
,0?0D0I0b0y0~0
1)1;1Q1d1i1n1
2E2]2b2g2t2
373<3c3{3
4&4G4z4
5'5M5
536C6e6k6p6w6
7)7F7R7d7j7q7x7
7&8B8G8L8d8o8
:":/:O:y:
;8;F;W;_;
<)<2<F<
=>=I=W=
=.>Q>u>
>"?-?o?}?
0 1I1c1t1
1X2_2
3 3'393o3
3>4I4^4e4
4W5n5s5x5
5J6P6c6n6
898V8w8
999P9U9Z9j9
9L:d:
: ;b;q;
<V<e<q<x<
=.=;=d=
>=>g>
?2?i?w?|?
1I1W1\1i1
2Z2_2d2t2
3R3d3i3n3
424K4{4
5$626@6E6
657:7
9$9)9u9
;/;k;
<5<M<u<
050;0D0K0W0]0f0m0
1?1D1I1
2%2*2/2b2
2 3*303B3G3L3z3
3.4_4i4v4$5I5V5
64696>6N6j6o6t6
7*747
8Y9i9
9.:7:P:
<4<K<P<U<m<
=o=|=
> >%>Q>f>
>&?=?B?G?w?|?
0?0Q0V0[0
061`1
4H4v4
515\5
7b8i8p8z8:9A9h9o9C:]:
=7= >[>e>r>
0;1E1
4%4R4
696Y6
6%7_7p7
=1=A=Q=
>U>r>w>|>
?2?8?H?X?i?|?
0"0`0p0
181Y1^1c1
2(2>2C2J2]2v2
3!3<3H3
3>4^4
5 5%5*5:5L5]5x5
5#6;6@6_6
6>7L7{7
8"8'818`8z8
9$92979A9r9w9
:8:G:O:_:d:
<.<D<
?,?=?K?W?|?
0"0>0C0H0X0q0v0{0
0"1.191
5X6i6p6
6 72797L7S7}7
8u9|9
90:C:R:i:z:
:j;~;
< <&<6<
<,=P=d=j=
?#?+?1?7?A?G?
0"0O0
1R1Y1`1g1n1
2;2I2r2
2&3/353:3V3
404K4
7*7>7V7c7j7w7~7
8&8I8_8v8
:E:S:i:
<3<l<
=-=?=
>!>5>=>D>J>n>w>
?"?2?8?f?y?
1Z1r1|1
1J4i4
5/6p6
7:7H7x7
8 8.8=8S8\8j8
8[9v9
:&:O:X:d:q:
<!<><E<K<X<a<
=2>h>
?'?<?k?u?
H0O0w0
1A1M1
1(252G2P2Y2_2d2i2p2x2
2*343
5B6~8
='=P=~=
>.>F>K>i>
?-?2?7?D?K?
0@0j0
1*1=1B1G1T1g1l1q1{1
2!252:2?2b2o2v2
203`3
4F4Q4Y4i4n4
5B5W5{5
6'6J6
7,71767@7Y7^7c7p7~7
808i8
9'9,919;9N9S9X9e9l9
:C:Z:_:d:
:#;:;?;D;
<$<I<
=c=z=
?+?0?5?\?a?f?s?
0S0`0g0s0
1$111?1D1I1V1d1i1n1x1
292I2N2S2s2
3S3j3o3t3
3&4+404v4{4
5 5f5k5p5
6V6[6`6
7F7K7P7
768;8@8
8&9+909c9z9
:?:J:y:
<f<}<
=%=;=Z=x=
/0=0[0
2x2~2
2!3^3w3|3
484c4z4
5?5\5j5
7)707C7J7z7
7$8D8a8{8
=(=~=
>&>A>F>K>[>w>|>
>,?6?Y?
(020U0
0)181f1u1
2"232V2[2`2m2
3$3)3>3I3
4V4k4v4
4*545:5?5]5
5$6:6
:!:k:
='=R=
=!>?>N>X>{>&?|?
0"0M0W0z0)1
1%252K2e2
989V9
;";*;:;A;S;X;];y;
<+<0<5<
>c>v>
???I?[?g?n?
0S0v0
1)171c1p1w1
2'2,2T2i2
3'3P3U3Z3g3z3
4#4*4/4a4
6E6j6
8$8)8.8;8v8
819C9Z9j9
:S:`:
;B;X;k;
<0<]<b<g<t<
=<=P=U=}=
>3>@>G>L>
>J?T?
0C0P0W0\0
0Z1d1
2)2\2p2u2
2L3d3t3
4=4B4G4T4g4l4q4~4
5@5l5
656:6?6I6b6m6
7.73787I7N7
8B8T8Y8~8
9 9-9@9E9J9T9g9l9q9~9
:8:O:T:Y:
;&<m<
='=M=V=^=
>J>\>a>f>
?1?6?;?K?d?i?n?~?
2=2l2}2
3"3{3
3>4J4\4o4
5!515
6"656:6?6L6
687=7B7g7x7
8&8\8p8u8
959i9y9
:::i:
; ;-;<;B;R;
<<<L<c<l<|<
=/=D=Y=^=c=p=
>a>x>
>c?p?w?|?
0#0(0-0:0M0R0W0d0w0|0
0)1r1
2#2(252c2p2w2|2
3"3'3,393L3Q3V3`3s3x3}3
3*4H4M4R4_4r4w4|4
5#5(5N5f5k5
5&656:6G6m6
787P7
8A8X8]8b8
9(9;9@9E9R9e9p9{9
:?:V:[:`:
;+;\;
=)=B=G=L=Y=l=w=
>3>8>=>
?&?+?0?Y?
0!0&030F0K0P0Z0m0r0w0
1,1C1H1M1
262;2@2[2
3#303C3H3M3W3j3o3t3
4#4*494_4x4
4#52575D5j5
6*6>6R6f6z6
7<7n7}7
9'9?9D9I9Y9l9q9v9
9&:;:Q:V:}:
;`;h;|;
<+<C<o<~<
>5>:>?>I>b>g>l>|>
?&?j?o?t?
0(0\0p0u0
1(1\1p1u1
1'242E2J2a2f2k2
3?3^3c3h3u3
4c4z4
5&5+5G5j5y5
6$6)666I6N6S6]6p6u6z6
8"8/8S8`8g8l8
9!9.9A9F9K9U9h9m9r9
: :%:C:|:
;$;=;n;
<-<^<
<,=@=E=c=
>0>5>U>h>
>#?t?
0%0*070]0~0
1=1v1
2.23282E2X2]2b2l2
4a4o4
455?5V5[5`5
6!6.6W6
7,71767b7
8,81868C8V8[8`8m8
8%9S9j9o9t9
:*:L:
;!;&;+;8;K;P;U;_;r;w;|;
< <%<D<V<
=8=C=~=
>6>P>X>m>
?4?9?>?e?j?o?
0F0Y0x0
0(1S1o1
3#3(3-3=3V3[3`3j3
3J4Y4l4q4v4
5$575<5A5N5a5f5k5u5
5:6I6\6a6f6
7'7,717>7Q7V7[7e7x7}7
7,8<8A8
9$9D9V9
: :%:D:V:
; ;%;D;W;
>*>=>B>G>Q>d>i>n>{>
0'0/0A0I0[0c0
1(1-121Y1^1c1s1
232@2G2L2
2+30353B3U3Z3_3l3
3L4n4
5/54595C5V5[5`5m5
5*6/646T6g6
8.8>8N8^8
8,91969C9_9d9i9v9
:2;D;j;
<!<.<A<F<K<U<h<m<r<
<U=j=o=t=
=#>0>7><>h>
?.?3?8?B?U?Z?_?l?
0W0\0a0
0'1,111Y1m1~1
1$2d2
203;3I3T3Z3j3
3C4I4Y4
5B5W5\5a5n5
6 6'666X6q6
7 7%7/7B7G7L7Y7
888J8p8
9$9)939F9K9P9]9
:>:_:
<$<)<6<
<8=r=
=%>a>x>}>
?3?8?=?i?n?u?z?
0:0|0
121v1
1!2Z2q2v2{2
4C4}4
5=5w5
596s6
627l7
7.8h8
8*9d9
:9;t;
;%<`<
='=,=1=W=
>C>Z>_>d>
>$?^?
1%1*1/1<1c1
1%2M2V2m2r2w2
4 4%4*444G4L4Q4^4z4
445k5
656N6S6X6{6
7.73787E7X7]7b7o7
9'9C9k9
:(:-:2:?:R:W:\:i:|:
<)<<<A<F<S<s<
<a=t=
>K>P>U>
>!?8?=?
0$0+02090@0G0N0U0\0c0j0q0x0
10151:1N1U1`1g1
2 2%272>2E2L2S2u2z2
3,3C3H3M3]3d3k3r3
4$464=4D4k4
5D5[5`5e5u5|5
7;7a7v7
8 8F8
9D9Y9d9{9
:W:n:
: ;5;^;i;
;'<,<J<O<T<t<
<O=V=t=y=~=
?a?v?{?
030@0G0V0
151S1X1]1j1}1
2-22272p2
4$414G4L4Q4[4q4v4{4
5)5B5
6"6'646c6z6
8&8S8`8p8u8
9-9?9F9P9W9k9
: :%:*:4:G:L:Q:^:l:r:
:";6;};
<#<0<@<E<h<
=+=>=C=H=U=h=m=r=|=
>0>5>p>
?"?,???D?I?V?
0$0<0
202>2I2W2g2p2
3 3%3*343G3L3Q3^3
444G4s4
5-5K5P5U5b5u5z5
6$6^6q6
787f7y7
8 808j8o8t8
:5:M:Y:j:
;#;M;`;j;
<#<j<o<t<
=>=\=a=f=
>">=>g>y>
?+?0?5?B?U?Z?_?i?|?
0 0%0K0c0h0
1C1U1\1f1m1
2#262;2@2J2]2b2g2t2
3$363z3
4$474z4
5@5Q5h5w5
6)6<6A6F6S6
6#737D7O7]7d7
8-82878A8T8Y8^8k8
9 9'969Y9r9
:#:6:;:@:M:s:
;(;B;V;i;
<"<S<`<g<v<
=%=<=A=F=k=
>!>&>I>^>s>x>}>
040G0
1,1z1
2(2@2E2
3.33383B3U3Z3_3l3
4(4=4G4^4c4h4
5Z5_5d5
6?6S6X6]6u6
7U7[7k7
8[8a8q8
9U9j9o9t9
9#:::?:D:}:
;%;*;/;<;c;p;w;|;
<$<)<6<I<N<S<`<s<x<}<
<)=r=
>$>1>c>z>
?#?(?5?H?M?R?\?o?t?y?
0#0;0P0U0Z0g0z0
1*1/141L1W1x1
2#2(2-2:2c2z2
3)3>3S3^3x3
4C4Z4_4d4
5(5-525<5O5T5Y5f5
5"6:6O6T6Y6f6y6~6
7 7'7,7Y7
8#8(8-878J8O8T8a8
9$9)9.9;9N9S9X9e9x9}9
9):r:
;$;1;c;p;w;|;
<5<:<?<L<_<d<i<v<
=M=e=z=
>3>J>O>T>
?"?,???D?I?V?
0*0?0D0I0V0i0n0s0
2'2:2?2D2Q2
3/3D3I3N3[3n3s3x3
4$4`4x4
5O5_5
5#656[6
7$7)767
8+8<8V8e8
9+9\9g9{9
:X:u:
;v<P=
6T6^6
3W5|5
5R6:7
8%83888^8m8
899h9
9-:D:
;$;8;=;B;c;
</=A=K=f=m=
?&?;?
060O0`0p0
022B2G2
4)444D4T4_4j4
5D5q5
616<6G6
7p8x8
8!9*9:9j9
;';^;i;w;
=7=<=`=e=o=
?+?>?C?H?R?e?j?o?|?
0'040F0K0P0r0x0
3<3X3
4F5S5c5h5
6$646B6I6O6b6
757:7?7L7b7g7l7v7
7F9x9}9
:(:`:
;D;q;
<)<G<L<Q<a<}<
?)?7?>?D?W?g?}?
0$0m0r0w0
0#1:1?1D1
2!2S2`2g2x2
3.3;3@3J3_3
4X4b4
5B5n5s5x5
6.6`6y6~6
7Q7X7
8[8b8
8$9+9^9
:1:6:;:K:d:i:n:x:
;6;];q;
<,<9<N<
=!=5=:=V=d=
?9?D?x?
0E0J0O0_0{0
151}1
2?2W2\2~2
3&3-333F3
4'4=4B4G4T4
656i6
7@7E7J7W7j7o7t7
7&8+818
9M9V9s9
:d:|:
;6;;;@;M;`;e;j;w;
; <&<+<K<a<y<~<
=4=Y=}=
>(>->2>l>
?"?2?E?J?O?Y?l?q?v?
0/0D0[0k0
1*1D1
2*2@2E2J2T2j2o2t2
4R4w4
53585=5z5
5<6A6F6
61767;7E7f7o7
8+80858?8
9)9X9r9w9|9
:$:):r:
<'<6<;<H<q<
=7=_=~=
>A>y>H?T?]?i?
0E0r0w0|0
1"1_1
2#2*262G2}2
383M3m3
464?4H4O4V4`4
5 5%5*5:5c5
6&6+606O6X6o6t6y6
73787=7J7p7
7%8G8
:J:a:q:
;1;H;M;R;\;u;
<#<(<5<K<P<U<_<u<z<
>C>O>a>f>k>
?6?;?W?
090N0S0X0e0x0}0
1"1'1O1f1k1
2L2o2
3<3S3X3]3
3"4/4U4
5R5a5f5s5
5$6@6}6
7*7/747m7
9/94999F9l9
:1:;:A:S:X:]:
;A;P;p;y;
<S<b<
=d=s=
>V>i>n>
040>0U0Z0_0
0q1v1{1
2%2*2/2<2O2T2Y2f2y2~2
3<3S3Y3^3
4 4F4K4o4t4~4
5"5'545G5L5Q5^5q5v5{5
7(7-727?7c7
80898R8
9%9*9/9
: :7:<:A:T:{:
;3;V;[;`;
;2<7<<<^<c<h<r<
<.=8=S=z=
>?>H>U>
? ?7?<?A?`?
1 13181=1G1Z1_1d1t1
2$2_2v2{2
3F3K3P3]3p3u3z3
4)4Y4r4
4:5O5T5Y5f5y5~5
6$6?6_6
7/7W7p7
9+949X9d9j9
:3:J:O:T:n:
:(;t;
=?=D=I=Y={=
>3>@>P>U>{>
?>?C?H?n?s?x?
14191>1K1a1f1k1u1
3*3/343j3
3<4e4
5$575<5A5N5s5
72777<7V7|7
8-8?8D8I8
8!91969]9b9l9
9Q:r:
; ;%;*;:;c;p;
<N<S<X<z<
=#=J=O=T=a=t=y=~=
> >%>J>j>
?2?7?_?d?
U0q0v0{0
131@1R1W1
272|2
3/34393F3i3
3M4d4i4n4
5#5n5
5V6m6r6w6
8!8&8+8U8
:#:8:G:P:]:f:
<B<K<s<
=.>F>q>v>{>
?C?Z?_?d?
00050:0D0W0\0a0n0
0-1D1T1s1
2%2*2/2<2R2W2\2f2|2
484P4U4
5+50555B5U5Z5_5i5|5
6Z6_6d6
6:7?7D7l7
7*8/848T8f8
9 90959^9{9
9,:N:g:
;2;7;<;I;\;a;f;s;
<4<G<j<
=S=`=g=l=
>'>,>1>;>N>S>X>e>
?:?N?e?j?o?
0A0V0k0p0u0
1!1s1
2$212D2I2N2X2k2p2u2
3I3c3{3
4,41464C4
585P5U5
6*6=6B6G6Q6d6i6n6{6
7(7?7D7I7c7
8+80858?8]8b8g8
8%9X9]9b9o9
:D:^:o:
;+;0;5;I;R;{;
<$<7<<<A<N<a<f<k<u<
=!=&=+=5=
>C>Z>_>d>
?"?'?I?Y?y?
090C0j0o0t0
0:1?1D1\1
1V2f2}2
3*393Q3[3
4Z4_4d4|4
5?5Q5V5[5
6 656:6T6h6m6
7-72777A7T7Y7^7k7
8.8[8|8
9#9F9d9i9n9
:A:]:
; ;-;@;E;J;T;g;l;q;~;
<?<X<z<
=:=?=D=d=v=
?.?3?8?B?U?Z?_?l?
0$0<0s0
1$1;1@1E1a1o1
2!2.2A2F2K2X2k2p2u2
3Z3_3d3
4Z4_4d4
5Z5_5d5
5J6O6T6|6
737@7G7V7
7'8/8@8X8g8
9C9Z9_9d9
:,:L:]:k:
;(;-;2;<;O;T;Y;f;
< <%<J<b<g<
=+=>=C=H=U=h=m=r=|=
=8>E>T>b>g>
?#?(?-?7?J?O?T?a?
0#0(0-0H0j0z0
1 13181=1J1
1)2_2d2i2
4+40454E4X4]4b4r4
5.54595K5^5c5
6*6O6s6
7 70757[7s7x7
8$8)8.8M8`8|8
9*9/949A9T9Y9^9k9~9
93:@:R:W:z:
;7;O;p;
<C<f<k<p<
=5=e=|=
?%?*?/?M?R?W?d?w?|?
0 0%0G0]0u0z0
1 1-1s1
2'212H2M2R2p2u2z2
3K3P3U3
4*4B4d4
5'5,515;5N5S5X5e5
636R6
7B7G7L7
818F8P8w8|8
9'9g9l9q9
:U:y:~:
;C;P;`;e;
=#=6=@=h=m=r=
=&>3>:>K>r>
>)?M?W?
0#060;0@0M0^0c0q0
191r1
2X2s2|2
3)3O3k3p3u3
4B4o4
5!5]5f5r5{5
6*6?6D6I6s6
7,71767C7V7[7`7j7}7
8(8-8r8
9H9X9{9
9+:1:d:r:
< <%<*<:<S<X<]<g<
>R>j>o>
0(0/0=0X0p0
1)1<1A1F1V1
3#3Q3^3q3v3
4"4'4@4S4w4
4H5Z5d5
6:6[6`6j6
727B7
8?9v9
:#:(:-:=:S:X:]:g:}:
;$;);.;>;W;\;a;q;
< <T<a<u<
<<=E=
>C>\>~>
?"?'?Z?l?q?v?
0#0(020E0J0O0_0z0
1$1)191L1Q1V1`1s1x1}1
2.232Y2^2
41565;5E5
6/64696^6
7#7;7D7
8"8,8?8D8I8Y8
9,9S9w9
;$;H;M;R;_;r;w;|;
<9<L<Q<f<k<p<}<
<!=4=;=J=u=
>'?9?>?C?
0+0>0C0H0R0e0j0o0|0
12171<1I1\1a1f1p1
2%282=2c2h2
3$3S3
3<4A4K4
4?5D5I5V5i5n5s5
6-6@6U6Z6_6l6
7 7'767]7v7
8&8S8`8g8l8
9(9-929<9O9T9Y9f9
:.:F:x:}:
;&;T;b;h;
<5<^<
=#=6=;=@=J=]=b=g=w=
>Z>_>d>
???}?
0;0K0c0r0
4T4e5
7/74797F7V7f7
8 8%8*878J8O8T8^8q8v8{8
8(919M9V9t9
9&:^:9;`<e<x<
=2=7=<=q=
=!>(>A>`>
?7?F?V?
10:0L0Q0V0p0y0
2!2&2d2
3(3;3@3E3O3b3g3l3y3
354>4Q4V4m4v4
5.535Q5V5[5h5
6V6m6}6
797W7\7a7
738C8)989=9B9
;S;\;o;t;
;.<3<8<E<[<`<e<r<
<9=B=T=Y=^=u=~=
>#>(>->:>M>R>W>d>w>|>
?'?,?f?o?
02070<0I0\0a0f0p0
1"1'1J1a1f1
2H2M2R2_2r2w2|2
3"3'3O3f3k3
4L4o4
5C5X5i5n5
61666V6j6x6
63787=7J7]7b7g7t7
8>8V8[8
9W9n9s9x9
:#:(:-:::
<B<k<
=<=f=v=
>^>f>v>{>
?(?-?|?
0'0,010>0G0`0e0j0
1$111c1
2*2H2t2
393o3t3y3
3(4w4
5!5&535F5K5P5Z5m5r5w5
6"636U6
7+7L7r7
8"8/8B8G8L8Y8l8q8v8
9B9q9
:,:D:T:Y:t:
;C;Z;_;d;n;
<l<{<
=T>c>h>m>
-0I0`0e0j0
1"1D1c1
2/2g2
3!3.3
4O5s5
556V6
6#707D7
9c:|:
;C;l;r;w;
<A<Q<u<
=)=n=
>$>)>.>>>
? ?%?p?
0C0P0W0f0
1 1%1/1B1G1L1Y1
152J2O2T2a2t2y2~2
404E4J4O4\4o4t4y4
5!5S5`5g5l5
5D6O6U6
7'7j7o7t7
738L8h8
9"9L9Q9V9c9v9{9
:(:J:b:~:
;#;6;;;@;M;`;e;j;t;
<'<C<
=@=U=Z=_=l=
=&>O>T>Y>
>c?n?t?
0"050:0?0O0u0
0"151W1p1
1&2=2B2G2f2~2
3#3G3j3
4,4S4X4]4j4}4
5#53585h5x5
626\6a6f6
7&7+707
8#808F8K8P8Z8p8u8z8
;>;W;
</<4<9<C<V<[<`<m<
<+=D=
>)>.>3>=>P>U>Z>g>
0#000C0H0M0Z0m0r0w0
121N1e1r1
20252:2D2W2\2a2n2
3%323h3
4!4.4S4`4g4x4
4(5G5\5a5f5s5
6 6'686Z6r6
7!7&737F7K7P7]7p7u7z7
7C8\8
9"9/9B9G9L9Y9l9q9v9
9):]:v:
;#;B;Y;n;s;x;
<:<?<D<
>,>1>6>@>S>X>]>j>
0.03080E0X0]0b0o0
1.1G1c1
2 2%222E2J2O2\2o2t2y2
2'3?3D3]3
4$4.4A4F4K4X4
5'5:5R5
60656:6G6Z6_6d6n6
6(7`7e7x7
9'9}9
;/;4;9;u;~;
<`<r<w<|<
<0=9=b=
>3>K>T>y>
?&?E?J?O?_?
0B0[0y0
2 262;2@2J2`2e2j2w2
2R3l3z3
4$5*5f5s5z5
6A6\6s6
7/7D7I7N7z7
8#8)8;8@8E8{8
9&959?9E9W9\9a9
: :5:L:Q:a:
:(;8;=;d;i;s;
<k<|<
=:=R=W=\=l=
0#0*01080?0F0M0T0[0e0i0m0q0u0y0}0
2%2y2
5L5c5
6;6@6E6
7+70757m7
;(;-;2;B;
<%<;<K<l<
<?=c=x=}=
>=>T>Y>^>
?#?)?G?n?x?
1H2T2g2
393N3
3'4B4q4
5J5Y5f5k5u5
6)6B6G6L6
8$868;8h8
8Q9^9c9p9
:':B:G:L:
;3;K;P;p;
<)<.<;<a<
="=`=p=}=
>&>+>8>a>
?'?L?[?`?m?
0)0M0r0
1&1O1j1|1
2`2j2~2
3P3i3n3s3
4I4X4]4j4
6'6,6j6w6
7&7?7D7I7
7$8;8@8E8O8
8 909=9c9
:(:>:C:H:_:o:
;2;7;j;
<!<Q<a<w<|<
< =%=<=A=t=
>$>T>d>z>
>3?8?O?T?
0*0/040V0l0
1#1(1-1L1Z1v1{1
2$2)2.2H2
3$373@3T3Y3^3v3
34494P4U4Z4
5"5C5R5b5g5
6E6N6j6v6|6
7#7(727V7]7r7
8#8(8-8`8e8j8w8
9?9k9}9
:":':4:D:I:N:X:h:m:r:
;*;O;Z;
<2<V<[<`<
>->2>7>D>W>\>a>n>
>$?+?2?R?Y?g?
000C0K0o0x0
242Q2o2
3/34393C3V3[3`3p3v3{3
4?4N4U4d4
5#505A5F5K5U5f5k5p5}5
6*6f6z6
6'777M7S7X7k7~7
8J8]8b8g8
9C9R9b9g9
:":':,:9:L:Q:V:c:v:{:
;4;D;`;x;
<8<^<
=9=H=Y=^=c=
=,>b>
?I?N?S?`?s?x?}?
0 0o0v0}0
1#1(1/1C1h1
2B3V3
4 4%4W4o4t4
6-62676[6p6u6z6
7K7U7\7i7~7
8!8&8J8e8t8
9 9%9R9e9j9
:2:7:Q:X:r:
;7;<;A;t;
<*<B<f<v<
= =3=8===J=d=
h081K1
5.5=5`5h5
5Y6x6}6
7(7S7t7y7~7/8>8P8U8s8
9-9W9~9
9]:z:
;7;?;L;Q;^;
<:<`<o<t<
<,=;=@=M=
>I>|>
?'?^?
090X0
1&282=2B2w4
4M5Y5
6E9b9l9u9
:1:<:G:[:s:
;(;;;@;E;R;e;j;o;y;
;'<,<1<O<_<i<
=:>W>i>n>s>
>1?8?X?f?
0-0I0
1+1O1^1g1~1
2'2,212`2
3)3.333@3S3X3]3g3z3
484=4B4W4p4
4%5/5f5
6K6V6
7!7&7+7;7N7S7X7b7u7z7
728F8
9>9S9]9c9w9
:R:b:g:
;5;H;
;#<1<;<C<V<[<
>%><>N>S>X>
?J?Y?k?p?u?
0$0)0R0W0\0i0|0
0;1E1R1g1
222w2
2#30373<3e3
4*434E4J4O4p4
5A5k5p5u5
6<6i6n6u6
9#:F:b:
;E;+<2<=<B<I<P<q<
>">E>l>{>
?B?N?
000<0y0
1 1Q1l1
1C2v2
2 383=3Y3r3
5I5e5
929=9L9t9
<s<{<
=B>G>L>\>x>}>
?'?,?1?
0.0G0L0Q0[0t0y0~0
1l1y1
2$2.2G2L2Q2a2
3+30353E3s3
4$4)4.4P4i4
5"6{6
6j7r7}7
7W8k8s8
8E9J9O9_9{9
97:?:F:K:o:
;*;F;K;P;`;y;~;
<+<0<5<E<^<c<h<r<
=`=w=|=
=.>>>F>O>T>]>
?$?J?q?
0f0u0z0
11161;1
1(2<2N2S2X2
2T3h3z3
4*4P4b4v4
5!5J5z5
6G6k6z6
7#7(7d7q7
8E8T8Y8f8
8(9H9W9\9i9
9!:3:8:=:u:
;";?;I;Q;X;];
<+<1<:<t<
=(=C=c=m=
>!>&>R>
?,?>?C?H?y?
0-0=0D0S0k0
1 1%1*1U1e1l1{1
2$2q2
3+30353
4+4=4B4G4
5j5s5
5V6_6h6v6
7'7,7@7_7s7
8*8/848m8
9-92979l9
:#:(:8:T:Y:^:h:
;#;';+;/;3;7;U;x;};
<1=C=H=M=
?2?t?
0B0c0
1#1L1r1
3k3t3}3
656S6p6
6.7c7h7m7}7
8!8I8Q8w8
9>9D9Q9X9g9
:/:4:9:I:b:g:l:v:
:/;I;r;
<?<T<Y<^<
<(=H=f=y=
><>f>k>p>}>
?[?t?y?~?
*060;0v0{0
0$1]1
162D2I2p2z2
363H3Z3_3d3
4@5R5W5\5
506n6
727a7f7k7x7
94999>9
9r:{:
;#;(;5;T;i;n;s;
<.=A=F=K={=
=->U>
>#?L?q?
0[0k0
1.1y1~1
1"2'2,2K2r2
4%4*414T4k4
495@5E5o5
6/686v6}6
7+797N7s7
828E8J8q8
9-92979
:!:/:<:
:";>;C;H;a;~;
<-<N<g<
=#=(=-=I=P=b=g=l=
>#>)>1>@>`>l>
>I?W?\?d?l?t?|?
0&0,0C0W0k0v0
1&151P1V1m1
2I2P2V2q2
3'3r3
4R4w4
5W5z5
536V6
7*7~7
7U8r8
9 9?9l9q9
:1:_:
<&<,<@<
<4=H=n=
?#?3?c?u?z?
0 0%050N0S0X0h0~0
0'1B1G1L1\1u1z1
1#2\2
333K3P3
3K4T4f4
475@5R5m5
5\6d6o6
6[7m7r7w7
8&859:9?9O9k9p9u9
:G:x:
:%;*;/;?;[;`;e;u;
;C<y<
=%=;=@=f=}=
>#>z>
?f?o?x?
,070<0P0o0
0(1<1A1F1
2(292>2C2\2
2V3[3`3p3
3-4?4D4I4b4z4
5"525H5M5R5\5r5w5|5
6&6?6D6I6Y6o6t6y6
8Q8{8
9'9@9n9
;9;?;Q;V;r;
<N<u<
<W=\=a=q=
>#>5>:>?>k>
>!?&?+?;?W?\?a?q?
1 1O1t1
3k3t3
5"696D6]6
6P7U7Z7j7
8/8A8F8K8d8
91969;9K9g9l9q9
:,:X:t:y:~:
;F;\;a;f;
>X>v>
0P1b1g1n1
1P2^2m2
3#3)3<3{3
5!515F5W5\5a5z5
7+7W7\7a7q7
808I8\8
8$9b9
: :%:E:
:H;c;h;m;};
<+<9<J<\<g<t<z<
=+=0=5=N=
>A>l>
?X?v?}?
1Q2f2~2
3,3r3
4#4<4A4F4m4
4#5*515C5H5M5f5x5}5
7&7Q7_7e7w7|7
8"8'8,898I8m8|8
929=9C9V9[9s9
92:L:\:a:
;3;8;Q;h;m;
;&<W<
?1?H?R?b?
0!070<0A0K0a0f0k0{0
1R1m1r1w1
2E2_2
4q4z4
475B5G5[5z5
536E6J6O6
7"7'7Y7k7p7u7
7;8L8~8
8G9L9Q9t9
:9:J:O:T:
;,;=;B;G;a;n;
<7<<<A<`<p<
=3=9=K=b=g=l=
>@>\>m>
?!?0?:?Z?_?d?
0J0\0y0
0C1y1
2-2N2[2`2
3&3g3
3B4a4
4*5A5T5^5
6+636L6Q6V6o6
7I7p7}7
8"9)969Z9k9
:1:f:o:
;3<J<q<
= =@=J=a=u=
>H>P>
>K?c?|?
0.0I0N0S0m0
3$333C3H3
3%4U4r4
5*5=5B5G5Q5d5i5n5{5
687Q7V7[7
8(8-828
9+9?9S9g9{9
:(:8:B:R:\:l:v:
;";,;<;F;V;`;p;z;
<&<0<@<J<x<
=)=9=C=S=]=m=w=
>">G>N>V>]>v>
?!?%?)?-?1?5?9?=?A?E?I?M?Q?U?Y?]?a?e?r?
0!0&0+0I0m0r0w0
1-1;1k1
2"24292>2x2
3$3)3Z3a3l3
4*4Q4q4x4
6@6E6K6
6 72777<7e7w7
8$8)868R8W8\8l8
9^9m9}9
:$:2:7:`:|:
;X<y<
1)1.1H1W1j1
182E2J2a2
3'3,313;3N3S3X3e3
4o4|4
6#777
8c9p9w9|9
9B:G:_:e:
;2;7;<;I;\;a;f;p;
=.=N=|=
>C>P>W>\>
>4?A?H?W?
,0G0U0
1f1s1z1
1^2c2k2
2$3;3@3M3Z3
3$4;4P4U4Z4g4z4
5 5'5,5
6@6g6
7-72777D7
7b8g8
9.93989E9X9]9b9l9
;';V;r;w;|;
<C<P<W<f<
<)=@=E=L=w=
> >->@>E>J>T>g>l>q>~>
000t0
1&1S1`1g1l1
1:2Q2V2]2
353:3?3L3_3d3i3v3
7:7?7D7y7
8W8k8}8
9b9v9
90:B:G:T:d:s:x:
==>L>U>s>
?9?K?P?U?
0J1c1h1m1
2"252:2?2L2
2E3}3
334h4w4
5'5,515>5Q5V5[5e5x5}5
6'6F6]6b6g6~6
7D7l7{7
8*8P8u8
929Z9i9n9{9
9 :2:7:<:\:f:~:
;&;L;m;
<!<4<9<><H<[<`<e<u<
<6=O=T=Y=
>&>+>c>
? ?8?D?I?
0&0R0p0
12191E1^1m1
272B2\2
2J3l3
394b4x4
6F7f7
8>8Q8
889Q9X9
99:K:a:
; ;+;2;8;J;O;\;e;u;
;+<0<E<\<
<6=;=P=l=q=
?"?'?4?I?N?[?i?~?
0+000E0]0b0w0
1(191M1R1_1v1
2$2)2/242`2g2l2
33393S3b3i3n3
4&4h4z4
4*5]5
6"686=6C6X6]6j6
888{8
9!9&939Q9V9c9q9
9-:3:F:[:
;);2;B;N;
<2<c<h<z<
=7=>=V=[=a=|=
>3>8>>>f>m>
>"?)?A?F?L?
!0(0@0E0K0w0~0
1-141D1I1O1c1h1w1
3+3Z3_3t3
4-464[4`4{4
545G5P5y5~5
6'6,6D6I6g6l6
8(8B8G8]8f8
9,919F9^9c9x9
:*:?:D:Q:_:n:w:
:';];w;
=%=r=
>">1>=>B>G>r>
?/?l?~?
0#0-070A0K0U0_0i0s0}0
1'111;1E1n1u1z1
2"2)20272>2E2L2S2Z2a2h2
3F3J3N3R3V3Z3^3b3f3j3n3r3v3z3~3
4!4:4N4r4
5*5/5S5]5j5o5
6#6(6-6h6
7'7,7U7
8=9B9G9O9\9u9
::;R;W;
<-<2<Q<c<h<m<
<3=\=
=%>N>w>0?B?G?L?
0f0k0y0~0
1'1,1:1?1F1_1{1
2.2@2
293e3
424b4l4
6(6>6N6d6q6v6
6%7C7M7f7}7
8 8%828S8l8q8v8
8(959X9}9
:):D:I:N:m:
;,;W;|;
=O=X=z=
>!>(>g>
0N1b1
2!2f2z2
3H3q3
4B4I4N4t4
5I5N5S5
52696>6g6
6"7)757]7n7
7W8\8a8
879r9y9
:j:o:
;8;=;R;a;g;~;
<"<1<7<N<p<u<
=9=>=K=Z=`=m=z=
>&>9>@>P>W>g>n>~>
>J?O?d?y?
0!070<0S0X0}0
1'1,191B1R1m1r1
1$2;2@2U2o2v2{2
3"3*373B3H3O3U3a3
4 4-484D4s4
5!5/565<5B5G5b5g5t5}5
6'6<6]6g6{6
7!7&7,7j8o8|8
8-9P9
:n:u:z:
;#;A;F;[;i;
<"<,<6<N<S<h<v<
=!=6=W=\=q=
=\?a?n?s?
B0u0|0
1#1M1Y1^1k1
5-535F5
6/666;6Q6\6b6h6
747A7V7[7h7v7
7-828G8U8
9+919y9
9>:C:i:o:
;?;E;
<!<&<6<Z<a<f<|<
=*=0=u=|=
>'>\>b>r>
?%?R?f?m?r?
0;1]1
2!2Z2n2
3%31383=3K3P3V3g3l3r3z3
4<4A4V4_4t4y4
5)575O5T5
6;6@6U6h6m6~6
8[8k8q8
:(:::@:L:S:X:j:o:u:
;1;>;L;
<(<C=J=O=e=j=p=
>E>L>Q>g>l>r>
?H?O?T?j?o?u?
0 0%0:0P0U0b0x0}0
1(1-1B1P1
2(2-2:2C2S2n2s2
3-34393O3V3[3a3n3
5"5'545I5N5[5i5t5
6*606[6`6f6
7#71767<7A7f7~7
8G8L8
8:9A9F9\9g9m9s9
9c:j:o:}:
;);<;
=#=1=6=<=Q=V=c=q=
> >.>>>C>T>
?!?'?9?>?N?e?j?v?
0 0%010[0m0t0y0
12171=1\1j1o1
2 2@2G2L2Z2_2e2
3'3K3W3z3
3(4d4k4p4
4%5J5O5b5
6?6F6K6a6f6l6
6=7B7u7z7
8(8.848F8M8R8h8m8s8
9!9,989^9q9
:!:7:<:B:T:Y:i:
;#;8;=;J;`;e;r;
;$<w<
>">'>4>I>N>[>i>t>
>!?&?6?V?[?h?}?
-04090G0L0R0f0k0x0
1*2/2D2
3E3W3m3
4'4,424K4R4j4o4u4
5 585=5S5X5h5
6n6u6z6
7,717>7G7]7i7
7%8;8i8
9U9Z9o9t9
:L:}:
; ;';,;2;?;b;g;w;
<1<6<;<A<X<_<d<z<
=4=9=F=[=`=m={=
=3>:>?>U>Z>`>
0!0=0t0y0$1+101F1K1Q1e1j1w1
2$2J2
3P3U3f3
4D4I4[4
5%535>5J5g5~5
6^6e6u6z6
7,7:7d7k7p7
8"8>8J8y8
:d:k:p:
; ;';,;:;?;E;Z;_;l;z;
<(<-<3<8<K<W<
="=/=@=
?4?9?O?h?m?s?
0'0Q0s0
191c1i1|1
2%2*202B2G2L2
3(3<3N3c3
4Y4`4t4y4
515H5}5
676>6C6Y6^6c6i6n6
667;7
8 8&8+8C8J8O8]8d8i8o8t8
9+9_9d9u9
:1:C:S:
:X;_;d;z;
<(<4<\<
=4=F=
>3>8>>>M>R>y>~>
1?1D1U1
24292J2c2h2}2
2Q3l3
3<4C4H4V4[4a4f4
5#585A5v5
6%6:6\6c6h6~6
7"7'7-7?7D7T7{7
8:8L8`8f8v8
9&9+9A9F9L9_9d9z9
:#:8:K:`:r:
;";3;G;Y;p;
<'<=<Q<d<y<
=-=3=C=W=]=m=
>2>8>H>b>
?S?n?
0$0K0
1)10151K1P1U1[1
2?2_2d2q2z2
3'383>3N3d3j3z3
4!424G4R4j4
5*5?5E5Z5o5u5
6*6/6v6
797>7
7$8)868L8Q8^8t8y8
8G9N9U9\9c9j9~9
;!;.;C;H;U;c;n;z;
<k<p<
=!=.=C=H=U=j=o=|=
><>I>u>
>7???E?S?[?a?g?
0(0@0W0
1N1S1
2+22272=2B2d2i2v2
20353J3\3
40474<4R4W4]4o4
595[5
5&6+606@6F6[6~6
7,7C7\7a7v7
8/8;8j8
9$959I9O9_9s9
:,:1:>:L:W:c:
;?;E;U;s;
<-<2<8<=<U<\<a<n<v<
=j=o=
=a>j>
?(?-?6?P?U?b?t?y?
0"010L0Q0b0s0
1\1a1v1
2=2D2
3>3q3v3
4<4C4H4V4[4a4f4
5!5.5@5E5R5a5r5y5~5
6 6-666H6T6r6
7,7Q7V7k7y7
8(8J8Q8V8l8r8w8|8
9 9%9*9?9U9Z9q9v9
:<:C:H:^:d:i:n:
;3;:;R;X;];
<.<3<@<I<Y<t<y<
<*=1=6=L=Q=i=n=~=
>8>?>D>Z>_>t>y>
?"?A?I?O?e?j?u?z?
0&0+090>0j0p0
10151B1l1s1x1
2&2+292>2D2I2|2
3A3H3
334:4?4U4[4n4u4z4
5.535?5^5
5,656K6^6p6w6
7#7G7W7v7
8!8/858;8@8U8Z8k8
90999[9k9p9
:/:=:a:h:m:{:
; ;G;N;S;h;m;w;};
; <%<d<
="=(=:=A=F=T=k=p=
>0>G>N>S>`>e>j>p>u>
?.?5?:?H?N?S?Y?f?x?}?
040W0a0
1j1o1
2'2-2D2I2W2
3"323>3]3
4'4,41474<4
405=5V5
6-64696O6Y6^6d6i6
8&8+8@8Q8V8c8t8y8
9+909=9L9Q9^9k9x9
:2:?:`:e:z:
:E;Y;g;u;
< <-<b<i<n<|<
<n=z=
=9>I>h>o>t>
?+?0?6?
0#0*080?0F0M0W0e0o0v0
2*2@2E2`2g2m2
3$3)363J3O3\3o3t3
4$4)464D4O4[4
5*5/5D5]5b5w5
6#616L6S6X6n6s6x6~6
64797E7n7
8E8O8V8`8j8t8{8
82979L9Q9l9u9
:0:I:N:[:`:n:}:
;.;7;Q;l;s;x;
<"<:<L<
=#=(=.=3=v=
= >'>,>A>F>P>V>[>
?(?-?C?H?_?d?m?
0/0a0h0m0
1(12171H1T1
2-2p2v2
3#3(363;3A3F3
3,424C4^4
545:5G5a5g5t5
6E7K7o7x7}7
7/868;8Q8V8\8
9H9O9T9j9o9u9
:.:3:\:c:h:~:
;";H;W;\;o;
; <%<O<U<}<
=%=*=0=5=b=g=|=
>%>7>^>m>{>
?%?+?6?W?^?c?y?~?
0 0&0;0]0d0i0
1 1/141D1e1l1q1
2#2(2>2C2f2k2
303;3K3l3s3
4)4.4P4W4\4r4
5.5Y5e5
5,626B6`6o6
6/757\7k7
9'9?9K9[9
9&:P:g:u:
:&;Q;r;
<;<H<M<e<u<
=%=*===I=n=
=$>H>h>o>t>
>9?E?d?
0'000R1e1
2(2I2o2v2{2
3)373I3N3Z3
4"4'454=4C4I4c4h4u4~4
5`5e5s5
6,61676I6N6a6
7!7/747:7G7T7Y7e7
7.8b8}8
959r9y9~9
:#:8:?:D:R:W:]:q:v:
;3;A;\;a;o;u;z;
<,<1<7<f<m<r<
= =?=K=R=W=e=j=p=}=
>$>*>P>W>\>j>o>u>
?#?)?.?A?Q?X?]?k?p?v?
0/040S0X0
1&1,1<1d1i1w1}1
2#242\2a2o2{2
3.383V3
4!4&4,4F4K4[4
50555E5g5n5s5
6"686D6h6
8/8L8R8g8|8
9+9k9p9}9
;3;8;E;Z;_;l;
<!</<_<d<z<
='=4=<=B=X=]=c=p=
>@>G>L>Z>_>e>}>
?,?q?
0+090}0
1'1J1
2'2?2D2Y2m2s2
3(3-3:3O3T3a3o3|3
4 404E4P4q4
5,5:5c5
6=7C7
8\8a8q8
92979D9Y9^9k9
:9:>:N:
;X<]<m<
<?=D=
>h>n>
?!?.?D?I?V?d?u?z?
2070O0T0n0t0
1o1t1
2#282=2J2X2f2k2w2
4/444:4`4w4
5!5&5<5A5G5i5x5
636:6?6U6Z6`6
7@7E7Z7~7
8%808<8e8~8
9-9]9b9s9
:":4:X:_:o:t:z:
;&;+;1;W;^;c;q;v;|;
<S<Y<f<o<
=!=.=8=
>(>->3>G>L>Y>n>s>
>)?A?
0%0-0H0M0Z0p0u0
1'1L1S1X1n1s1y1
2'2]2b2r2
333I3P3U3k3p3v3
5&515=5
686H6
6l7q7
9E9g9l9
:':M:d:i:~:
;M;T;Y;g;l;r;
;&<+<@<i<o<
=9=L=x=~=
>'>3>Z>h>
?2?@?g?u?
000A0F0[0y0
1%1=1B1O1]1j1o1{1
212W2\2p2
3!3-393R3f3
4*40454e4l4q4
4%5/545D5X5e5l5q5
6#61666<6A6
8*8N8
969;9H9V9e9q9}9
:A:H:M:c:h:n:
:";);.;D;I;O;
>.>V>
?$?3?s?z?
S0Z0_0u0z0
1"1(151M1R1_1h1
2.232H2
303N3s3x3
4A4F4V4
5.5<5N5
6B6N6l6q6
6`7h7n7
8'8,828?8g8{8
9'999>9S9f9m9r9
: :%:::P:W:\:i:q:
;-;W;];
<!<1<D<m<
=7=<=I=R=f=k=w=
>">'>L>S>X>e>m>
?>?K?Y?
0B0V0
1!1&1,1X1]1m1
2#232W2^2c2y2~2
30373<3R3W3]3
3&4+484M4R4_4t4y4
595F5h5
6"6'696>6D6m6
6;7H7n7
8 8<8H8O8T8j8o8u8
9'9,929Y9^9k9
:5:::J:h:
;8;=;W;\;j;s;x;
<_<d<y<
=M=R=g=
>+>7>\>n>
?/?Q?V?
00050B0J0Z0f0
1%1+181F1[1`1l1
20262D2Y2^2k2s2
353:3K3T3y3
3"4'4<4U4d4u4|4
5,585=5J5X5c5o5
6(6-636R6Y6^6l6q6w6
7)7K7R7W7e7j7p7}7
8!898X8_8d8r8z8
8*909E9S9o9
:j:q:v:
;\;u;z;
<#<(<I<N<T<
<$=)=7===B=^=c=p=y=
=*>/>D>R>w>~>
?!?&?3?;?M?R?^?
0<0C0H0N0`0i0}0
1'1,121V1]1b1p1u1{1
43484E4Z4_4l4z4
4=5C5_5h5|5
666T6[6
697[7a7n7w7
8@8F8S8\8t8z8
9)9.9C9^9w9|9
:,:7:C:
<)<.<:<
>6>K>`>f>
?>?C?Y?b?
0/0H0M0^0
1$121K1P1e1
2/242O2_2d2j2
2 3%3:3H3s3
3%4I4`4e4z4
5g5n5s5
6n6u6z6
7S7b7g7t7
8!80858B8U8m8u8{8
9$9+9:9?9L9_9w9
9F:K:`:u:
;(;.;C;Q;
<8<=<J<X<j<
=?=E=R=^=k=w=
>/>;>W>{>
?4???k?
0+030K0[0`0l0
1 1%1;1@1F1m1t1y1
252:2G2d2k2
3%3;3@3U3^3
4!4'4-4J4V4
5D5K5P5^5c5i5v5
6"6(686L6X6
70767F7]7c7{7
8$8*8:8N8T8e8z8
9/9R9
:$:Z:z:
;.;3;9;Q;V;c;q;|;
<,<=<P<a<
=D=I=V=d=q=x=
>U>[>
?$?>?U?
0!0&0
1$1,1@1E1Q1
2"222n2
3/343I3e3j3w3
5-525C5j5q5
61666O6f6m6
6&7+787A7]7m7s7
808I8N8^8r8
83989F9O9a9f9v9
:%:3:Y:j:o:
;+;1;B;];b;o;
<)<F<R<Z<`<v<{<
=(=/=`=|=
>*>6>=>B>P>U>[>`>x>
?$?2?K?P?e?
080=0I0r0y0
1,131B1I1N1\1a1h1w1~1
2-222G2U2n2s2
3 3'3,3:3?3E3J3b3i3n3{3
4g5n5s5
6'6/6A6F6R6y6
6k7r7w7
8.838?8c8
989@9F9T9Y9_9d9
:e:l:q:
:Q;V;c;y;~;
;#<*</<=<B<H<\<a<n<|<
=,=1=7=D=O=[=
>#>1>C>H>U>]>q>x>
?-?2???
0)0F0K0`0
0C1p1z1
2-2N2S2b2j2
313<3C3L3Q3]3x3
4"4/444D4J4O4c4j4
5*5I5S5Z5_5u5z5
6D6R6X6b6g6l6
7(7-7B7P7
8#8,8C8~8
9'939g9s9
:.:v:
;4;T;b;h;y;
<O<^<e<p<x<~<
=K=b=z=
=+>B>f>k>p>
!?(?G?P?U?|?
070B0O0p0u0
0#1-1V1[1p1
2'252
253U3_3
4!414<4J4T4Y4f4t4
5'575F5K5[5k5{5
6+616B6T6Y6j6
7,7n7s7
8$818N8_8f8k8y8~8
9&9+979T9d9i9~9
9*:_:f:k:
;o;v;{;
<5<G<L<m<r<x<
=#=>=C=I=\=c=h=u=}=
><>D>L>T>\>d>l>t>|>
?8?D?d?|?
0$0,040@0`0h0p0x0
1 1(1@1P1X1`1|1
2(202L2\2d2l2t2|2
3$343<3X3l3t3|3
4$4,444<4D4L4T4\4d4p4
5,545<5D5L5T5\5d5p5
6$6,646<6D6L6T6\6d6p6
7$787X7d7
848<8L8T8\8d8l8t8|8
9 909@9L9l9t9|9
: :(:@:H:l:t:|:
;$;,;4;<;D;L;T;\;h;
<$<8<@<H<P<T<X<`<t<|<
= =$=,=0=L=P=p=
>$>(>0>D>L>`>h>p>x>
?,?<?H?P?h?
0<0D0L0T0\0d0l0t0|0
1$1,141<1D1L1T1\1h1p1
2$2,282@2d2l2|2
343<3H3h3p3x3
4 4,4L4X4x4
5(505H5X5t5|5
6$6,646<6L6T6\6d6l6t6|6
7$707P7\7|7
8(8L8T8\8d8l8t8|8
9$9,949<9D9L9X9`9x9
:4:<:H:h:p:x:
; ;@;H;T;\;t;
< <(<0<8<@<H<T<\<t<
= =(=0=<=\=d=p=
>$>,>4>@>H>|>
?$?,?4?@?H?`?
0$0,040<0D0L0T0\0h0p0
1,141D1L1T1\1d1l1t1
2$2,242<2D2L2T2`2h2
2,343<3D3L3T3\3d3l3x3
4$4,444<4D4L4T4\4h4p4
5 5D5L5T5\5d5l5t5|5
6$6,686@6d6l6|6
7(70787@7\7d7l7t7|7
8$8,848<8D8L8T8`8h8
9 9D9L9\9d9l9t9|9
: :(:@:P:X:`:|:
;$;,;4;<;D;L;T;\;d;p;x;
< <D<L<\<d<l<t<|<
=$=,=4=<=D=L=T=\=d=p=x=
>0>@>H>d>l>t>|>
?$?,?4?D?L?T?\?d?l?t?|?
0 0@0H0T0t0|0
141<1D1L1T1\1d1l1t1
2 282H2d2l2t2|2
3$3,343<3D3P3X3|3
4(484@4H4P4l4t4|4
5,545<5D5L5T5\5d5p5x5
6<6D6T6\6d6l6t6
7$7,747<7D7L7T7`7h7
8<8D8L8T8\8d8l8t8|8
9 9(9@9P9l9t9|9
:$:,:4:<:D:L:T:`:h:
;<;D;T;\;d;l;t;|;
<$<,<4<D<L<T<\<d<l<t<|<
=(=0=H=X=`=h=
>(>0>H>X>t>|>
?(?H?P?\?|?
0(0H0P0`0h0
1 1(1D1L1T1\1d1l1t1|1
2 2(2H2d2l2t2|2
3 3@3H3P3l3t3|3
4$4,444<4D4L4X4`4
5 5<5D5L5T5\5d5l5t5|5
6(606H6X6t6|6
7$7,747<7D7L7X7`7x7
8(8D8L8T8\8d8l8t8|8
9(909H9X9t9|9
:$:,:4:<:D:L:T:`:h:
;(;8;@;\;d;l;t;|;
<$<,<4<<<H<P<t<|<
=(=8=T=\=d=l=t=|=
>$>,>8>@>X>h>
?$?,?4?<?D?L?T?\?h?p?
0(0D0L0T0\0d0l0t0|0
1(101H1l1t1|1
2$2,242<2D2P2X2p2
3,343<3D3L3T3\3d3l3x3
404@4H4d4l4t4|4
5$5,545<5H5P5h5x5
646<6D6L6T6\6d6l6t6
7,747<7D7L7T7\7d7p7x7
808@8H8d8l8t8|8
9$9,949<9D9P9X9p9
: :(:D:L:T:\:d:l:t:|:
; ;(;@;P;X;t;|;
<$<,<4<<<D<L<X<`<x<
= =<=D=L=T=\=d=l=t=|=
> >@>H>P>X>`>p>x>
?(?4?T?\?h?
0(0L0T0\0d0l0t0|0
1$1,181\1d1l1t1|1
2$242<2D2L2T2\2d2t2|2
3$3,343<3D3L3T3\3h3
4(404T4\4l4t4|4
5 5<5D5L5T5\5d5l5t5|5
6(606T6\6d6t6|6
7$7,787@7X7`7h7
8$8,8X8l8t8|8
9$9,949<9D9\9d9l9t9|9
:$:,:4:<:D:L:T:`:h:
; ;(;4;T;\;d;p;x;
<$<,<<<D<L<T<\<d<l<t<
=,=4=<=D=L=T=\=d=l=x=
>$>,>4><>D>L>T>\>d>l>t>|>
? ?(?D?T?\?d?
0$000P0X0h0p0
1$1,141<1D1L1T1\1d1l1t1|1
2$2,2X2l2t2|2
3(30383T3\3d3l3t3|3
4$4,444<4D4L4T4\4h4p4
5 5(505@5d5l5t5|5
6$6,646<6H6P6l6|6
7$7,747<7D7L7T7\7h7
8,848<8H8h8p8x8
9$9,949<9D9L9T9\9d9p9x9
: :D:L:T:\:d:l:t:|:
; ;(;@;d;l;t;|;
<$<,<4<<<H<P<h<
=,=4=<=D=L=T=\=d=l=x=
>0>@>\>d>l>t>|>
?$?,?8?@?X?`?h?
0$0,040<0D0L0T0\0d0p0x0
1(181T1\1d1l1t1|1
2$2,282X2`2p2x2
3(3L3T3\3d3l3t3|3
4(404H4X4t4|4
5$5,545<5D5L5X5`5x5
6 6<6D6L6T6\6d6l6t6|6
7(707H7X7t7|7
8$8,848<8D8L8T8`8h8
9 90989T9\9d9l9t9|9
:$:,:4:<:D:P:X:p:
;4;<;D;L;T;\;d;l;t;
< <8<H<P<l<t<|<
=$=,=4=<=D=L=X=x=
>$>,>4>@>`>h>p>
?0?@?H?P?l?t?|?
0$0,040<0D0L0T0`0h0
1(181@1H1d1l1t1|1
2$2,242@2H2`2p2
3$3,343<3D3L3T3\3d3p3x3
4 484H4P4l4t4|4
5$5,545<5H5P5h5x5
646<6D6L6T6\6d6l6t6
7(707H7l7t7|7
8$8,848<8D8P8X8p8
9 9<9D9L9T9\9d9l9t9|9
: :8:H:d:l:t:|:
;$;,;4;<;D;P;X;p;
< <(<0<8<T<\<d<l<t<|<
=$=,=4=<=H=P=h=x=
> >(>D>L>T>\>d>l>t>|>
?(?0?H?X?`?h?p?
0 0<0D0L0T0\0d0l0t0|0
1 141<1D1L1T1\1d1l1t1|1
2$2,242<2D2L2T2\2h2p2
303@3H3P3l3t3|3
4$4,444<4D4L4T4`4h4
5(585@5H5d5l5t5|5
6$6,646<6D6L6X6`6x6
7(7D7L7T7\7d7l7t7|7
8$8,888@8X8h8p8
9,949<9D9L9T9\9d9l9x9
: :8:H:P:l:t:|:
;$;,;4;<;D;L;X;`;x;
<$<,<<<D<L<T<\<l<t<|<
=$=,=4=<=D=P=X=p=
>4><>D>L>T>\>d>l>t>
? ?(?@?d?l?t?|?
0$0,040<0D0P0X0p0
1,141D1L1T1\1d1t1|1
2$2,242<2D2L2X2`2x2
3(383@3H3d3l3t3|3
4$444<4D4L4T4\4d4l4x4
5 585H5P5l5t5|5
6$6,646<6H6P6h6x6
747<7D7L7T7\7d7l7t7
8(808H8X8`8h8
9$9,949<9D9L9T9\9d9t9|9
:$:,:4:<:D:L:X:`:x:
;$;D;L;T;`;
<4<<<H<h<p<x<
=,=4=<=D=L=X=x=
>$>,>8>X>`>h>p>|>
?4?<?D?L?X?|?
0 00080P0`0h0
1$1,141<1D1L1T1`1h1
2 2@2H2`2p2x2
3$3,343<3D3L3T3\3d3p3x3
4$4,484@4d4l4t4|4
5(505H5l5t5|5
6$6,646<6D6L6T6\6h6p6
787@7P7t7|7
8$8D8P8p8x8
9,949<9H9P9h9
:$:,:4:<:D:L:T:\:d:p:x:
; ;8;H;P;l;t;|;
<$<,<4<<<H<h<p<x<
= =(=@=d=l=t=|=
>8>@>L>l>x>
?4?8?T?X?t?x?
04080T0X0h0p0
1 1(1@1P1X1`1h1
2$2,282\2d2l2t2|2
3$3,343<3D3L3X3`3
4$4,444<4D4L4T4\4d4l4t4|4
5$585L5T5d5l5t5
6$6,646<6D6L6T6\6d6l6
7$7,747<7T7X7h7p7
8$8,848<8D8L8T8\8d8l8t8|8
949<9T9\9t9
:$:,:4:<:D:L:T:\:d:l:t:|:
;$;,;<;D;L;T;\;t;
<$<,<D<H<X<`<|<
=$=,=4=<=D=L=T=\=d=l=
> >4><>D>L>T>\>d>l>t>|>
?$?,?4?<?T?d?x?
0$0(040T0\0d0p0x0
1$1,141<1D1L1T1\1d1l1t1|1
2$242L2T2\2d2t2|2
3$3,343<3D3L3T3\3t3x3
4$4,444<4D4\4`4p4x4
585D5d5l5t5|5
6$6,646@6`6h6p6x6
7(7H7X7`7x7
8(808<8\8d8l8t8|8
9<9D9L9T9\9d9l9t9|9
: :8:\:d:l:t:|:
;$;,;4;<;D;L;T;\;d;p;x;
< <D<L<T<\<d<l<t<|<
= =(=@=d=l=t=|=
>$>,>4>@>H>`>
?$?,?4?<?D?L?T?`?h?
0 0<0D0L0T0\0d0l0t0|0
1,141<1D1L1T1\1d1l1x1
20282H2P2t2|2
3$3,383X3`3l3
4$4,444<4D4L4X4x4
5,545<5D5L5T5`5
6 6@6H6X6`6x6
747<7D7P7X7p7
8,888X8d8l8
90989D9d9l9x9
:(:H:T:\:t:
;<;D;L;X;`;
0 0$0(0P0T0l0p0t0x0
141@1\1
0 0$0,04080<0@0D0H0L0P0T0X0`0d0h0l0t0x0|0
1$1(1,14181<1D1L1P1X1`1
