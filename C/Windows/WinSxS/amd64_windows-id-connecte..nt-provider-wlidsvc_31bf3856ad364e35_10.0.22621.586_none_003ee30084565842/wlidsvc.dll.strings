!This program cannot be run in DOS mode.
RRich
.text
`.rdata
@.data
.pdata
@.didat
.rsrc
@.reloc
D$PE3
D$(E3
D$PE3
L$`H3
D$0E3
L$PH3
D$(E3
L$ E3
L$pH3
L$pH3
\$ UVWAVAWH
f94Bu
fA94@u
fA94@u
A_A^_^]
\$ UH
\$ UVWAVAWH
f94Bu
fA94@u
fA94@u
A_A^_^]
D$(E3
L$`H3
D$PE3
D$(E3
L$pH3
D$(E3
D$(E3
L$pH3
D$(E3
\$ UVWAVAWH
f94Au
fA94@u
fA94@u
A_A^_^]
D$(E3
D$(E3
D$(E3
@USVWAUAVAWH
f94Bu
fA94@u
fA94@u
fA94@u
A_A^A]_^[]
\$ UH
@USWH
D$(E3
D$(E3
USVWAVH
A^_^[]
qK]0T7
ATAVAWH
t$(!t$,3
A_A^A\
@USWAVAWH
A_A^_[]
@USVWAVH
D9uXt
A^_^[]
UATAUAVAWH
\$`D8
D9d$ht
A_A^A]A\]
pY^Tc6
D$pH;
SVWATAUAWH
A_A]A\_^[
USVWATAUAVAWH
A_A^A]A\_^[]
UVWATAVH
A^A\_^]
UVWATAUAVAWH
A_A^A]A\_^]
T$xHcB
|$hH=
UVWATAUAVAWH
A_A^A]A\_^]
UWATAVAWH
p[]:`
d$ E3
A_A^A\_]
UWAVH
pA^_]
T$0E3
WATAUAVAWH
H!D$XE3
A_A^A]A\_
L$ E3
UATAUAVAWH
fE9,$
fE9,Fu
A_A^A]A\]
UAVAWH
A_A^]
UVWAUAVH
pA^A]_^]
UWATAVAWH
A_A^A\_]
VUUUUUUUI
qaY4b?d
H UATAUAVAWH
A_A^A]A\]
UWAUAVAWH
p[]:`
A_A^A]_]
t6H;Q
t$ UWATAVAWH
A_A^A\_]
@USVH
p)W4)
VWATAVAWH
A_A^A\_^
UVWATAUAVAWH
D9d$xt
A_A^A]A\_^]
D9d$xt
|$ UH
USVWATAUAVAWH
}wD!}gH
A_A^A]A\_^[]
L$`H3
@USWH
@SVWH
D$PE3
L$PH3
s WAVAWH
A_A^_
UVWATAWH
pA_A\_^]
UVWATAUAVAWH
A_A^A]A\_^]
tDD9I
H;S(r'H
@USVWATAUAVAWH
D$ E3
D$hE9`
D$hE9`
A_A^A]A\_^[]
y2D9s
t$`D8t$d
@SUVWATAVAWH
|$(L9
@A_A^A\_^][
UWAVH
pA^_]
x AVH
SVWATAUAVAWH
t$8!t$<3
A_A^A]A\_^[
x UATAUAVAWH
A_A^A]A\]
@USVWATAUAVAWH
|$HD!|$LH
A_A^A]A\_^[]
D9%`n
D$ E3
UWAVH
pA^_]
UWATAVAWH
A_A^A\_]
UATAUAVAWH
A_A^A]A\]
f9<Bu
t$ ATAVAWH
 A_A^A\
x UATAUAVAWH
A_A^A]A\]
\$ VWATAVAWH
A_A^A\_^
UVWATAUAVAWH
A_A^A]A\_^]
p0S^4
l$ E3
UATAUAVAWH
A_A^A]A\]
UWAVH
\$ UVWAVAWH
A_A^_^]
t$ UWAVH
\$ UVWAVAWH
A_A^_^]
VWAVH
UVWAVAWH
D9t$0
A_A^_^]
@UVWATAVAWH
fD9dC
A_A^A\_^]
L$ VWH
w(t H
UVWAVAWH
ugD85
A_A^_^]
@USVWATAVAWH
A_A^A\_^[]
D$@E3
@SUVATAVAWH
D8$(u
fD9d_
A_A^A\^][
@SUVWH
L$PH3
D$@E3
fD9DB
L$pH3
D$@E3
t`fD9DB
L$`H3
L$ E3
UVWATAUAVAWH
A_A^A]A\_^]
t$8Lc
\$ UVWATAUAVAWH
A_A^A]A\_^]
UVWATAUAVAWH
A_A^A]A\_^]
VWATAVAWH
\$XHc{
 A_A^A\_^
\$ UVWATAUAVAWH
\$@A;~4swH
D$HA+
(D$`f
A_A^A]A\_^]
H SUVWATAUAVAWH
HA_A^A]A\_^][
D$ H;
T$0E3
WAVAWH
 A_A^_
|$ ATAVAWH
fD9$Zu
t$PfD
 A_A^A\
WAVAWH
 A_A^_
UVWATAUAVAWH
d$ E3
<)D+`
t$`Mc
L$pH;
A_A^A]A\_^]
D$@fA
UVWATAUAVAWH
0A_A^A]A\_^]
t$ WH
UVWATAUAVAWH
L$8H3
@A_A^A]A\_^]
WAVAWH
@A_A^_
WAVAWH
 A_A^_
WAVAWH
 A_A^_
USVWATAUAVAWH
A_A^A]A\_^[]
H)D$8L
xTA;Y
xTA;Y
L$ UVWH
wZtXf
UWAVH
\$ UVWAVAWH
T$(E3
A_A^_^]
l$`H+
VWAUAVAWH
 A_A^A]_^
UWAVH
UVWATAUAVAWH
A_A^A]A\_^]
|$ UATAUAVAWH
d$4E2
A_A^A]A\]
VWATAVAWH
 A_A^A\_^
\$ UVWATAUAVAWH
D$HHc
D$X;{
L$pH;
D$hLcs
A_A^A]A\_^]
\$@Lc
WAVAWH
 A_A^_
WAVAWH
 A_A^_
H;S(r(H
l$ VWAVH
WATAUAVAWH
 A_A^A]A\_
WAVAWH
0A_A^_
UVWATAUAVAWH
0A_A^A]A\_^]
\$ Lc
x AVH
H;V(r
UWATAVAWH
A_A^A\_]
d$ E3
USVWAVH
A^_^[]
L$ UVWATAUAVAWH
A_A^A]A\_^]
K UVWAVAWH
A_A^_^]
L$ UATAUAVAWH
uwM9>
D$ E3
A_A^A]A\]
UWATAUAVH
A^A]A\_]
\$ UVWATAUAVAWH
A_A^A]A\_^]
t$ WATAUAVAWH
E9~XA
fD9|]
@A_A^A]A\_
t`A9X
UVWATAUAVAWH
A_A^A]A\_^]
t$ UWAVH
x AVH
\$PM!
UVWATAUAVAWH
A_A^A]A\_^]
|$ UATAUAVAWH
\$PM;
T$DI;
L$HE3
L$DE3
G(D+p
L$HE3
fA9|F
A_A^A]A\]
USVWATAUAVAWH
t$ E3
A_A^A]A\_^[]
x ATAVAWH
fD9$Zu
 A_A^A\
UVWATAUAVAWH
A_A^A]A\_^]
(D$`f
WAVAWH
 A_A^_
@USVWATAUAVAWH
t$XfD
D$hHc
D$`fD
A_A^A]A\_^[]
D$hfD
t$ WATAUAVAWH
D$HHc
l$PE3
A_A^A]A\_
|$ ATAVAWH
 A_A^A\
I;V(r
WAVAWH
 A_A^_
H;W(r0H
H;W(r=H
x AVH
H;V(rhH
x AVH
H;V(r
@USVWATAVAWH
t$@H!t$HH!t$P3
D$pE3
H!t$8H
D$ E3
A_A^A\_^[]
H;S(r
H;S(r'H
UVWATAUAVAWH
t/D9R
pA_A^A]A\_^]
USVWAVAWH
8A_A^_^[]
VWAVH
@USVWAVH
A^_^[]
@USVWATAUAVH
A^A]A\_^[]
UVWATAUAVAWH
t-D9K
A_A^A]A\_^]
WAVAWH
 A_A^_
WATAUAVAWH
 A_A^A]A\_
VWAVH
 A^_^
UVWATAUAVAWH
A_A^A]A\_^]
D$hD9}hH
UATAUAVAWH
A_A^A]A\]
UVWATAUAVAWH
uXM9.
PA_A^A]A\_^]
t$ WH
x AVH
t$PH!>H
9C`u<H
WAVAWH
t$`H!>A
 A_A^_
x AVH
t!9{`u
L$ UVWATAUAVAWH
VUUUUUUUH
VUUUA
VUUUA
 A_A^A]A\_^]
VWATAVAWH
 A_A^A\_^
D9s u
WAVAWH
0A_A^_
UVWATAUAVAWH
VUUUUUUUH
VUUUA
pA_A^A]A\_^]
UVWATAUAVAWH
H)E@L
<.D+`
0A_A^A]A\_^]
|$ AVH
x AVH
USVWATAUAVAWH
$8E+n
A_A^A]A\_^[]
UVWATAUAVAWH
~PL9f
E8$6u
E@L9`
G8$>u
A_A^A]A\_^]
|$ AUAVAWH
 A_A^A]
t$ UWATAUAVH
p0S^4
tsD8)tnL
x3L9l$Hv,H
L9l$P
L9l$P
xnL9l$HvgH
D$8D9h
H;\$P
\$8D9k
l$hE3
D9l$8tMI
D9l$8t
D$pD9h
A^A]A\_]
UVWATAUAVAWH
A_A^A]A\_^]
D$DL;
D$DL;
UVWATAUAVAWH
T$8L9s
F8$/u
A_A^A]A\_^]
@VAVAWH
0A_A^^
UWATAVAWH
A_A^A\_]
t$ WH
UVWATAUAVAWH
f9Egu*
A_A^A]A\_^]
L$ H;
\$ UVWAVAWH
t$8fD
t$xE3
A_A^_^]
\$ UVWATAUAVAWH
D$`D9p
A_A^A]A\_^]
D$ E3
D$HE3
USVWATAVAWH
A_A^A\_^[]
t$(E3
UVWATAVH
p[]:`
PA^A\_^]
UWAWH
UVWATAUAVAWH
u09]Xt]I
pA_A^A]A\_^]
x AWH
K VWAWH
PA__^
UWATAUAVH
A^A]A\_]
UWAVH
WAVAWH
fF9<Fu
D$(E3
D9|$Pv=@
;t$Pr
A_A^_
t$ WH
D$p@8y
x ATAVAWH
fD9&t
fD9#uhA
fD9&uofD9#H
fD9$~u
@A_A^A\
fD9#t
VWATAVAWH
D$pfD
fE9$Ou
fE9$Fu
A_A^A\_^
UWATAVAWH
H!]'E3
A_A^A\_]
@USVWATAUAVAWH
A_A^A]A\_^[]
UVWATAWH
p[]:`
A_A\_^]
L$ SVWAVH
(A^_^[
@USWH
x UATAUAVAWH
p)QV+
A_A^A]A\]
UVWATAUAVAWH
A_A^A]A\_^]
` UAVAWH
L$ E3
A_A^]
UWAUAVAWH
p)QV+
A_A^A]_]
UVWATAUAVAWH
A_A^A]A\_^]
UWATAVAWH
D9}H}@
A_A^A\_]
UATAUAVAWH
A_A^A]A\]
fD9lC
UWATAVAWH
A_A^A\_]
UVWATAUAVAWH
l$ E3
A_A^A]A\_^]
UVWATAUAVAWH
p0S^4
A_A^A]A\_^]
p0S^4
p[]:`
L$hE3
UWATAVAWH
H!u'E3
A_A^A\_]
UWATAVAWH
D$ E3
A_A^A\_]
UVWATAUAVAWH
fD9$~u
fD9dG
A_A^A]A\_^]
|$ AVH
USVWATAUAWH
fD9LC
A_A]A\_^[]
UVWATAUAVAWH
p[]:`
l$ E3
A_A^A]A\_^]
}gD8-s
UATAUAVAWH
p)W4)
l$ E3
A_A^A]A\]
l$ E3
p8[8X
l$ E3
D$ E3
VWAVH
 A^_^
WATAUAVAWH
 A_A^A]A\_
WATAUAVAWH
<4A+P
0A_A^A]A\_
UWATAVAWH
E!<$H
A_A^A\_]
UAUAVH
A^A]]
UVWATAUAVAWH
A_A^A]A\_^]
@USVWAVAWH
|$XE3
A_A^_^[]
fD9>t
L$`H;
@USVWATAVAWH
H!\$hH
A_A^A\_^[]
UVWATAUAVAWH
A_A^A]A\_^]
UATAUAVAWH
A_A^A]A\]
@8}gt
UWAUAVAWH
A_A^A]_]
UWAVH
UATAUAVAWH
A_A^A]A\]
@USVWATAUAVAWH
f;D$@
H9t$x
H9t$h
H9t$`
H9t$p
A_A^A]A\_^[]
@SVWH
UATAUAVAWH
p{Q4d
A_A^A]A\]
ATAVAWH
t.fD9;t(H
D$ D9z
L$HE9y
A_A^A\
|$ UH
|$ UH
p@^r?
tMD9Z
|$ UAVAWH
A_A^]
USVWAUAVAWH
A_A^A]_^[]
UWAVH
 A^_]
WAVAWH
H;S w.H
0A_A^_
UVWATAUAVAWH
t$`E3
A_A^A]A\_^]
WAVAWH
H;S w|H
0A_A^_
t$ WAVAWH
0A_A^_
H;S(r'H
x AVH
H;V(r
SUVWATAUAVAWH
(A_A^A]A\_^][
USVWATAUAVAWH
A_A^A]A\_^[]
x AVH
WAVAWH
H;S w.H
0A_A^_
VWATAVAWH
 A_A^A\_^
WAVAWH
H;S wHH
0A_A^_
VWATAVAWH
t-A9x
 A_A^A\_^
WAVAWH
H;S w}H
0A_A^_
x AVH
USVWATAUAVAWH
|$`E3
A_A^A]A\_^[]
` UAVAWH
p[]:`
A_A^]
SWATAUAVAWH
l$pE3
!T$DE3
d$XH!T$PM
L$ E3
A_A^A]A\_[
|$`M;
UVWATAUAVAWH
A_A^A]A\_^]
UVWATAUAVAWH
A_A^A]A\_^]
VWAVH
USVWATAUAVAWH
E_L9t$P
A_A^A]A\_^[]
UVWATAUAVAWH
`A_A^A]A\_^]
x UATAUAVAWH
A_A^A]A\]
UVWATAUAVAWH
A_A^A]A\_^]
L$ UVWATAUAVAWH
A_A^A]A\_^]
@USVWATAUAVAWH
}HM9}
H9\$p
paY4b?d
paY4b?d
A_A^A]A\_^[]
L$ H;
L$ H;
pkX4A?
SUVWAVH
\$XE3
 A^_^][
UVWATAUAVAWH
fD94zu
0A_A^A]A\_^]
\$ UVWATAUAVAWH
A_A^A]A\_^]
D$0Hc
UVWATAUAVAWH
A_A^A]A\_^]
t$pLc
x AVH
UVWATAUAVAWH
 A_A^A]A\_^]
fE9d}
D$`L;
x AVH
|$ AVH
l$ VWATAVAWH
tPE9f
tPE9f
tPE9f
tPE9f
tSE9f
tSE9f
tSE9f
tQE9f
 A_A^A\_^
t$ WATAUAVAWH
 A_A^A]A\_
l$ VWAUAVAWH
 A_A^A]_^
VWAUAVAWH
\$XHcs
 A_A^A]_^
WATAUAVAWH
 A_A^A]A\_
SVWATAUAVAWH
0A_A^A]A\_^[
WAVAWH
 A_A^_
WAVAWH
 A_A^_
UVWATAUAVAWH
PA_A^A]A\_^]
USVWATAUAVAWH
A_A^A]A\_^[]
USVWATAUAVAWH
d$XIc\$
\$`Hcs
A_A^A]A\_^[]
D$PH;
d$ E3
\$XLc
\$`Lc
|$xE3
USVWATAUAVAWH
t$XIc^
\$`Hcs
D$PH;
D$hL;
L$hE3
fA9tF
A_A^A]A\_^[]
\$XLc
\$`Lc
UVWATAUAVAWH
A_A^A]A\_^]
|$ ATAVAWH
4AHcA
0A_A^A\
|$ AVH
@USVWATAUAVAWH
H9D$H
A_A^A]A\_^[]
D$PD9h
D$XD9h
|$PMco
|$0Mco
|$PMco
F8,0u
@SVWATAUAVAWH
D$@;X
L$@HcY
D$@;X
D$@fD
D$0Hc
A_A^A]A\_^[
@USVWATAVAWH
A_A^A\_^[]
VWAVH
 A^_^
@USVWATAUAVAWH
fD9$Ku
A_A^A]A\_^[]
@USVWATAUAVAWH
fD9$Ku
A_A^A]A\_^[]
WAVAWH
H;S w|H
0A_A^_
UVWATAUAVAWH
A_A^A]A\_^]
UATAUAVAWH
fD9,Gu
A_A^A]A\]
UVWAVAWH
pA_A^_^]
UATAUAVAWH
fD94Zu
A_A^A]A\]
UVWATAUAVAWH
D9l$8t
A_A^A]A\_^]
VWAVH
 A^_^
VWAVH
 A^_^
@USVWATAUAVAWH
|$pH+
A_A^A]A\_^[]
t$ ATAVAWH
@A_A^A\
@SVWH
|$PLc
|$P+H
|$ UATAUAVAWH
A_A^A]A\]
L$ SVWH
w4t,H
@USVWATAUAVAWH
A_A^A]A\_^[]
@USVWAWH
L$pH;
A__^[]
UWAUAVAWH
A_A^A]_]
UVWATAUAVAWH
A_A^A]A\_^]
UVWATAUAVAWH
A_A^A]A\_^]
t$D9k`u
D9k u
UVWATAUAVAWH
t!9w`u
A_A^A]A\_^]
USVWAVAWH
hA_A^_^[]
x AVH
WAVAWH
D$ E3
@A_A^_
(D$0H
UVWATAUAVAWH
A_A^A]A\_^]
UWAVH
D$@H!\$HH!\$PE3
L$`H;
WAVAWH
H;S v
0A_A^_
UVWATAUAVAWH
@A_A^A]A\_^]
UVWATAUAVAWH
t!9s`u
A_A^A]A\_^]
@USVWATAVH
A^A\_^[]
SVWAVAWH
t$x;>
0A_A^_^[
H;S(r(H
)D$0H
(D$0H
UVWAVAWH
`A_A^_^]
WAVAWH
H;S v
0A_A^_
SVWAVAWH
t$x;>
0A_A^_^[
SVWAVAWH
t$x;>
0A_A^_^[
UVWATAUAVAWH
L$ E3
L$ E3
pHX2Z
A_A^A]A\_^]
t$ UWATAVAWH
A_A^A\_]
|$ UATAUAVAWH
L$@E3
D$ E3
A_A^A]A\]
t$ UWAVH
@USVWATAVAWH
A_A^A\_^[]
UWAVH
\$ A^
@USVWAWH
PA__^[]
!}@!}D3
uVH98uQH
tDD9I
H;S(r(H
D$0E3
l$(E3
f9,Au
WAVAWH
L$hfD
 A_A^_
UWAWH
UATAUAVAWH
A_A^A]A\]
UVWATAUAVAWH
A_A^A]A\_^]
x AVH
\$ UVWATAUAVAWH
L$HE3
L$HE3
fE9lF
A_A^A]A\_^]
UATAUAVAWH
A_A^A]A\]
UATAUAVAWH
D9+~3
A_A^A]A\]
UAVAWH
A_A^]
\$ WH
H!\$PL
L$PE3
D$(E3
D$(E3
\$ UVWAVAWH
T$8HcB
A_A^_^]
UVWATAUAVAWH
D$XE3
u"H9|$@u"@
H9|$@tQE
|$4E3
@8t$8
|$4E3
D$`Hcp
D$@Hcp
A_A^A]A\_^]
@USVWATAUAVAWH
\$hD9{
p8[8X
D$DE3
D8|$@u
D8|$Pt
p8[8X
D8|$@u
8\$@u
8\$Pt
A_A^A]A\_^[]
UVWATAUAVAWH
D$hD+p
D8$2u
D$ E3
A_A^A]A\_^]
UWATAVAWH
A_A^A\_]
UWAWH
UVWATAUAVAWH
d$ HcK
@A_A^A]A\_^]
t$ E3
l$$E;
L$0H;
<OH;|$0r
UAUAVH
A^A]]
@USWH
!](E3
x ATAVAWH
 A_A^A\
VATAVH
l$(Hc{
`A^A\^
`A^A\^
l$$Mc
Lct$ A
WAVAWH
 A_A^_
@USVWATAUAVAWH
A_A^A]A\_^[]
L$ H;
L$ H;
@VAVAWH
@A_A^^
WATAUAVAWH
Lcd$pM
\$PfD
 A_A^A]A\_
H93tgL
@SUVWAVH
H!\$0!\$(H
\$ H9
@A^_^][
x AVH
|$ UH
p!]rm
D$ E3
\$ UVWAVAWH
fA94@u
fA94@u
fA94@u
A_A^_^]
l$ WH
x UATAUAVAWH
EhD9`
E`D9`
A_A^A]A\]
@USVWAVH
`A^_^[]
9{Xt&
;C(wYr
;C,wOr
;C0wEr
UWATAVAWH
@A_A^A\_]
@USWH
USVWH
h_^[]
@USVWAWH
HcU@H
A__^[]
x UATAUAVAWH
A_A^A]A\]
@USWH
USVWATAWH
hA_A\_^[]
D$ E3
x UATAUAVAWH
L$PE3
\$pfD
l$PE3
A_A^A]A\]
@USWH
|$ ATAUAVH
L$pE3
A^A]A\
t$ WH
t$90t
VWAVH
 A^_^
t$ WH
D#L$0D
3D$8%x
x AVH
H;N`M
x AVH
UVWAVAWH
L$HH3
PA_A^_^]
t$ WH
@USVWH
_^[]H
D$(E3
D$0E3
t$(E3
t$ WH
|$ UH
D$(E3
t$ WH
D#D$0D
3D$8%
3D$8%x
t$ WH
VWAVH
 A^_^
c AUAVAWH
t$x!t$|3
A_A^A]
@USVWATAUAVAWH
p)W4)
p0S^4
L$pE2
A_A^A]A\_^[]
x ATAVAWH
 A_A^A\
UVWATAUAVAWH
p)QV+
A_A^A]A\_^]
\$ UH
USVWAUAVAWH
A_A^A]_^[]
9}HtEH
@USWH
UWAVH
SVWAVAWH
t$x;>t
0A_A^_^[
VWAVH
 A^_^
@USVWAVH
]oD9u
A^_^[]
L$ UVWATAUAVAWH
u<D99u7H
A_A^A]A\_^]
t$ UWAVH
|$ E3
qYU6[&
WAVAWH
t$(!t$,3
A_A^_
UVWAVAWH
|$8E3
A_A^_^]
t H;Q
UWAVH
@A^_]
USVWAUAVAWH
A_A^A]_^[]
UVWATAUAVAWH
MoD9eg
A_A^A]A\_^]
VWAVH
 A^_^
D9K(u!H
p0X2x
1tAfA
p0X2x
p0X2x
USVWAVH
PA^_^[]
p0X2x
p0X2x
p0X2x
H;S(r(H
H;S(s
UVWATAUAVAWH
D$ E3
A_A^A]A\_^]
\$ E3
D$ E3
ATAVAWH
t$(!t$,3
A_A^A\
UATAUAVAWH
!|$ L
D$0D9p
9t$@t
A_A^A]A\]
UWAVH
0A^_]
pY^Tc6
@USVWAVH
@A^_^[]
|$ AVH
UVWATAWH
 A_A\_^]
UWAVH
0A^_]
x AVH
tLD9P
UWATAVAWH
0A_A^A\_]
H;S(r'H
H;S(r-H
UVWATAUAVAWH
 A_A^A]A\_^]
@SVWH
|$P+H
|$ AVH
UATAUAVAWH
|$pE3
A_A^A]A\]
|$ UH
@USVWATAVAWH
D9uHt8L
pA_A^A\_^[]
\$ UVWATAUAVAWH
l$ E3
t>D9i
fD9,Au
A_A^A]A\_^]
VWAVH
 A^_^
D$ E3
@SWAVH
D$@E3
UATAWH
A_A\]
x AUAVAWH
 A_A^A]
L$ SVWAVH
A^_^[
L$ SUVH
wEtHH
@USVWAVH
0A^_^[]
tEE9P
UVWATAUAVAWH
p[]:`
paPtl
d$ E3
A_A^A]A\_^]
x AVH
USVWATAUAVAWH
A_A^A]A\_^[]
D$@E2
@USVWATAUAVAWH
A_A^A]A\_^[]
fE94$t
x AVH
|$ UAVAWH
A_A^]
SUVWAUAVAWH
@A_A^A]_^][
H;S(s
x UATAVH
A^A\]
@USWH
9}(vQH
D$@E3
f9|$`
|$ t'L
D$D95a
f94Au
@8t$0t
@USVWATAVAWH
ug9uw
p[]:`
p[]:`
ppW^(
p[]:`
A_A^A\_^[]
WAVAWH
9\$Pt
A_A^_
9\$Pt
@USVWAVAWH
A_A^_^[]
UVWATAUAVAWH
D$@9|$Dt4H
A_A^A]A\_^]
pi\:D'X
H9{(t
D;c4s4H
|$ E3
|$ UATAUAVAWH
A_A^A]A\]
UVWATAUAVAWH
A_A^A]A\_^]
@USWH
\$pE3
\$ E3
UVWAVAWH
u493u0H
PA_A^_^]H
H;Q(s
UWAWH
\$0E3
L$hH3
D$(E3
\$ UVWATAUAVAWH
D$PE3
L$ E3
D$pL+
H+D$xH
D$ E3
D9t$l
D9t$h
|$ E3
D9|$P
H)D$p
A_A^A]A\_^]
@SVWATAUAVAWH
t/D9P u#H
H;FxwZ
A_A^A]A\_^[
UWAVH
p0S^4
t/D9P u#H
UWAVH
H!}0H
|$ UATAUAVAWH
uRM9w
A_A^A]A\]
H;S(s
H;S(s
WAVAWH
H;S w|H
0A_A^_
t$D9B
|$ ATAVAWH
@A_A^A\
|$ AVH
x UATAUAVAWH
A_A^A]A\]
UVWATAVH
p0S^4
@A^A\_^]
UATAUAVAWH
A_A^A]A\]
UWATAVAWH
A_A^A\_]
H;S(r(H
x AVH
tDD9P
WAVAWH
t.9p(u#H
 A_A^_
WAVAWH
0A_A^_
|$ UATAUAVAWH
A_A^A]A\]
WATAUAVAWH
A_A^A]A\_
|$8E3
USVWATAUAVAWH
HA_A^A]A\_^[]
pkX4A?
x AVH
R$fA;Z*s
fA9Z*
tFD9P
t$ UWAVH
f9<Bu
f9<Bu
f9<Bu
\$PM!
9B(u#H
L$(E3
SUVWATAUAVAWH
.D;}(
HA_A^A]A\_^][
x AVH
H;Q(s
fA99t
UVWATAUAVAWH
L$pE3
A_A^A]A\_^]
q{Q4d
|$ UAUAVH
A^A]]
USVWATAUAVAWH
8"u2H
T$pE3
8"u.H
L$`E3
A_A^A]A\_^[]
` UAVAWH
A_A^]
s WAVAWH
9_DvaH
@A_A^_
|$ UH
VWATAVAWH
L$0E3
D$0fD9 t
D$0fD9 t
A_A^A\_^
L$(E3
x AVH
UVWATAUAVAWH
ty@8=
t"@8=
fA9>u
@A_A^A]A\_^]
D$8E3
H;S(r
H;S(s
@USVWAWH
L$ E3
`A__^[]
x ATAVAWH
0A_A^A\
\$ E3
UWAWH
H;S(s
UVWATAUAVAWH
uOHcEW
A_A^A]A\_^]
UVWATAUAVAWH
 A_A^A]A\_^]
UWATAUAVH
A^A]A\_]
tCH;Q
UWATAVAWH
A_A^A\_]
UWAUAVAWH
A_A^A]_]
UAVAWH
A_A^]
UVWAVAWH
`A_A^_^]
UVWATAUAVAWH
A_A^A]A\_^]
L$x9Y
D$ E3
L$PH3
t$ WH
D$ ufH
L$0H3
H;S(s
UVWATAUAVAWH
H!T$ E2
D$xtq
0A_A^A]A\_^]
WAVAWH
H;S v
0A_A^_
UWAVH
L$0H;
uQf9l$@tJH
L$@H3
USVWATAUAVAWH
p@Z4x
l$ E3
t$pD;
\$xLc
A_A^A]A\_^[]
USVWATAUAVAWH
EwL!0H
HcMOH
A_A^A]A\_^[]
UVWAUAWH
pA_A]_^]
@SVWATAUAVAWH
p)QV+
D9d$Pt
D9d$Pt
D9d$Pt
D9d$Pt
A_A^A]A\_^[
UVWAVAWH
}H!}L3
pA_A^_^]
t[f9*tV
|$ UATAUAVAWH
u.@8}
F8@88t
A_A^A]A\]
L$ UVWATAUAVAWH
A_A^A]A\_^]
{ ATAVAWH
D$(H9
@A_A^A\
VWAVH
 A^_^
VWAVH
t$$fD
D$0D9r
@A^_^
qkX4A?
UAVAWH
A_A^]
VWAVH
]fE90t
t$HE3
@USWH
` UAVAWH
A_A^]
@USWH
c AUAVAWH
t$x!t$|3
A_A^A]
SVWATAUAVAWH
@85sk
p0S^4
p0S^4
D$ E3
D8wbu{
pKX>!.
pKX>!.
A8t$(A
A_A^A]A\_^[
UVWATAVH
A^A\_^]
L$`H3
USVWAVAWH
D$ E3
xA_A^_^[]
pSUVP
t*@8o
SVWATAUAVAWH
`A_A^A]A\_^[
UVWATAUAVAWH
D$P=*
D$P=*
A_A^A]A\_^]
@USVWATAVAWH
A_A^A\_^[]
ATAVAWH
t$8!t$<3
A_A^A\
u@H91u
H;S(s
UVWAVAWH
PA_A^_^]
8\$`u.3
@USVWAUAVAWH
H!uPH
A_A^A]_^[]
UWAVH
UVWATAUAVAWH
r3L9u
pY^Tc6
D$8D9p
A_A^A]A\_^]
@USVWATAVAWH
pA_A^A\_^[]
L$ UVWATAUAVAWH
A_A^A]A\_^]
fA9(t
UVWATAUAVAWH
0A_A^A]A\_^]
UWATAUAWH
A_A]A\_]
q0S^4
UATAUAVAWH
A_A^A]A\]
@USWH
@USVWAVH
;u0s{H
 A^_^[]
UVWAVAWH
PA_A^_^]
fD9?t
h UAVAWH
A_A^]
UATAUAVAWH
A_A^A]A\]
UAVAWH
A_A^]
@USVWATAUAVAWH
p3TpY
A_A^A]A\_^[]
h UAVAWH
p)W4)
A_A^]
UWAUAVAWH
L!u'E3
A_A^A]_]
SVWAVAWH
t$x;>
0A_A^_^[
D$0[H
UWAVH
t/D9R
UVWATAUAVAWH
PA_A^A]A\_^]
x AVH
\$PIi
t7f9*t2H
f9,Bu
x AVH
WAVAWH
H;S v
0A_A^_
UWAVH
`A^_]
D$ E3
D$@E3
t$ WH
L$8H3
h UAVAWH
A_A^]
USVWH
x_^[]
UAVAWH
A_A^]
|$ UATAUAVAWH
fE9,Du
fD9,Au
AfD9)u
A_A^A]A\]
\$PM!
UWAVH
PA^_]
WAVAWH
H;S w~H
0A_A^_
USVWATH
PA\_^[]
WAVAWH
H;S w|H
0A_A^_
UVWAVAWH
 A_A^_^]
L$8H3
L$HH3
UATAUAVAWH
A_A^A]A\]
VWAVH
9D$Dv
UWAUAVAWH
A_A^A]_]
WATAUAVAWH
A_A^A]A\_
UATAUAVAWH
A_A^A]A\]
WAVAWH
H;S w|H
0A_A^_
\$ UVWATAUAVAWH
A_A^A]A\_^]
UWATH
WAVAWH
H;S wqH
0A_A^_
t$0E3
UVWAVAWH
l$ E3
f9,Au
A_A^_^]
UVWATAUAVAWH
A_A^A]A\_^]
@USVWATAUAVH
pA^A]A\_^[]
uT!L$xH
D$(E3
VWATAVAWH
t$8!t$<L
D$XH!t$`H!t$hE3
D$095
t59t$<u/
A_A^A\_^
t$@E3
D$ E3
t$HE3
UWATAVAWH
D9u@t1
A_A^A\_]
x UAVAWH
A_A^]
D$ E3
K VWATAVAWH
A_A^A\_^
UVWATAUAVAWH
d$hE3
D$@D9`
A_A^A]A\_^]
UATAUAVAWH
A_A^A]A\]
UVWATAUAVAWH
p)W4)
uwD9p
p)QV+
A_A^A]A\_^]
@SUVWH
D$0L;
` AUAVAWH
t$H!t$L3
A_A^A]
UATAUAVAWH
A_A^A]A\]
UATAUAVAWH
p)W4)
p)QV+
A_A^A]A\]
t$0E3
UWAVH
WAVAWH
H;S v
0A_A^_
WAVAWH
H;S v
0A_A^_
UVWATAWH
A_A\_^]
q@Z4x
q[]:`
q)W4)
WATAUAVAWH
 A_A^A]A\_
VWATAVAWH
A_A^A\_^
q@^r?
t/D9R(u#H
UWATAVAWH
@A_A^A\_]
UWAUAVAWH
p[]:`
A_A^A]_]
` UAVAWH
A_A^]
USVWATAUAVAWH
p)W4)
I9M(t
A9M u!A
E@I9M8
A_A^A]A\_^[]
I9M(t
A9M u<H
p)QV+
L9t$xt
L9t$xu
D$`D9p
L$ UVWATAUAVAWH
A_A^A]A\_^]
WAVAWH
H;S v
0A_A^_
UWAUAVAWH
A_A^A]_]
UVWAVAWH
L!t$X
L$@E3
D$H!D$@
A_A^_^]
x AVH
rHfD97w
C9fD97u,
UWAWH
pA__]
q)QV+
qaPtl
WAVAWH
H;S v
0A_A^_
qKX>!.
WAVAWH
H;S v
0A_A^_
UAVAWH
A_A^]
ATAVAWH
t$8!t$<3
A_A^A\
UVWATAUAVAWH
l$`E3
D9l$0t
A_A^A]A\_^]
@USVWATAVAWH
A_A^A\_^[]
qSUVP
H;S(s
QTE7!
VWAVH
 A^_^
UATAUAVAWH
A_A^A]A\]
VWAVH
 A^_^
UVWAVAWH
}0H+}(H
t$`E3
0A_A^_^]
q0X2x
L$@H+
D$@f90t
HcD$$HcL$ H
\$ VH
H!\$`L
L$`E3
!\$0H
L$`E3
H!\$ E
D$PE3
x AVH
t$ WH
tTf9l$ t}f
|$":uuf9l$$unH
L$(H3
L$ E3
QTE7!
@USVWAUAVAWH
`A_A^A]_^[]
|$ UAVAWH
A_A^]
UWAVH
H;S(s
q0X2x
q0X2x
L$@H3
qbRxL
UVWATAUAVAWH
T$HE3
D$hL!t$`H
L$pA3
L$pE3
D$pE3
L$pD3
D$pE+
L$pD3
L$pA3
L$pA3
L$pE3
D$HH;
L$HH;L$H
D$HH;
L$HH;L$HrgH
D$HH;
L$HH;L$HrAH
T$8H;
T$8L;
D$xA;
+D$xA;
T$8M;
T$8L;
+D$xA;
D$8D;E
D+D$pD
3L$pD
L$@E3
T$HH;
T$8wAA
H;D$Hw
D$HE3
D$XE3
A_A^A]A\_^]
H;S(s
H;S(s
UATAUAVAWH
D$HE3
D$hL!t$`H
L$xA3
L$xE3
L$xE3
L$xD3
D$xE+
D$xD3
L$xA3
L$xA3
L$xE3
D$HH;
L$HH;L$H
D$HH;
L$HH;L$HrgH
D$HH;
L$HH;L$HrAH
T$@H;
T$@L;
D$pA;
+D$pA;
T$@M;
T$@L;
+D$pA;
D$@D;E
D$xD3
L$8E3
T$HH;
T$@wAA
H;D$Hw
D$HE3
D$XE3
L9u8u
t%D;M@
A_A^A]A\]
x ATAVAWH
 Hcl$`H
 A_A^A\
|$`E3
q:X~0
UAVAWH
A_A^]
UVWATAUAVAWH
A_A^A]A\_^]
x AVH
UWAVH
@USVWAUAVAWH
A_A^A]_^[]
USVWATAVH
hA^A\_^[]
UWAWH
0A__]
UATAUAVAWH
A_A^A]A\]
USVWH
h_^[]
ATAVAWH
t$8!t$<3
A_A^A\
VWAVH
\$ E3
@A^_^
@USWH
WAVAWH
T$0L+
A_A^_
x AVH
WAVAWH
 A_A^_
t$ WH
D$ E3
SVWAVAWH
t$x;>
0A_A^_^[
SVWAVAWH
t$x;>
0A_A^_^[
D$(fD
L$8E3
H9L$`
9\$@L
t$ WAVAWH
\$PfD
@u;L9;u$E3
0A_A^_
|$hE3
L$0E3
L$PE3
L$ WH
` AUAVAWH
t$H!t$L3
A_A^A]
q0X2x
q0R^G'
q0R^G'
q:_0#
|$ AVH
VWAVH
p:_0#
p:_0#
p:_0#
@A^_^
q:_0#
SVWAVH
8A^_^[
WAVAWH
\$8H;
A_A^_
p:_0#
@SVWH
\$ UH
M H1E
 H3E H3E
ntelA
ineID
L$ SUVWH
8_^][
H SWH
D$PE3
oD$ f
oL$0f
oT$@f
o\$PH
oD$ f
oL$0f
oT$@f
o\$PH
oD$ f
oL$0f
oT$@f
o\$PH
oD$ f
oL$0f
oT$@f
o\$PH
oD$ f
oL$0f
oT$@f
o\$PH
oD$ f
oL$0f
oT$@f
o\$PH
oD$ f
oL$0f
oT$@f
o\$PH
oD$ f
oL$0f
oT$@f
o\$PH
oD$ f
oL$0f
oT$@f
o\$PH
oD$ f
oL$0f
oT$@f
o\$PH
oD$ f
oL$0f
oT$@f
o\$PH
oD$ f
oL$0f
oT$@f
o\$PH
oD$ f
oL$0f
oT$@f
o\$PH
oD$ f
oL$0f
oT$@f
o\$PH
oD$ f
oL$0f
oT$@f
o\$PH
oD$ f
oL$0f
oT$@f
o\$PH
oD$ f
oL$0f
oT$@f
o\$PH
oD$ f
oL$0f
oT$@f
o\$PH
oD$ f
oL$0f
oT$@f
o\$PH
oD$ f
oL$0f
oT$@f
o\$PH
oD$ f
oL$0f
oT$@f
o\$PH
oD$ f
oL$0f
oT$@f
o\$PH
oD$ f
oL$0f
oT$@f
o\$PH
oD$ f
oL$0f
oT$@f
o\$PH
oD$ f
oL$0f
oT$@f
o\$PH
oD$ f
oL$0f
oT$@f
o\$PH
oD$ f
oL$0f
oT$@f
o\$PH
oD$ f
oL$0f
oT$@f
o\$PH
oD$ f
oL$0f
oT$@f
o\$PH
oD$ f
oL$0f
oT$@f
o\$PH
oD$ f
oL$0f
oT$@f
o\$PH
oD$ f
oL$0f
oT$@f
o\$PH
oD$ f
oL$0f
oT$@f
o\$PH
oD$ f
oL$0f
oT$@f
o\$PH
oD$ f
oL$0f
oT$@f
o\$PH
oD$ f
oL$0f
oT$@f
o\$PH
oD$ f
oL$0f
oT$@f
o\$PH
oD$ f
oL$0f
oT$@f
o\$PH
oD$ f
oL$0f
oT$@f
o\$PH
oD$ f
oL$0f
oT$@f
o\$PH
oD$ f
oL$0f
oT$@f
o\$PH
WAVAWH
0A_A^_
oD$ f
oL$0f
oT$@f
o\$PH
oD$ f
oL$0f
oT$@f
o\$PH
oD$ f
oL$0f
oT$@f
o\$PH
oD$ f
oL$0f
oT$@f
o\$PH
oD$ f
oL$0f
oT$@f
o\$PH
L$(E3
qq\Rv
qJ[RO
x AVH
\$ UVWAVAWH
t,D8=
L9{Hu
A_A^_^]
L$ SWH
L$XH+
SVWAVAWH
`A_A^_^[
WATAUAVAWH
H9/sDH
 A_A^A]A\_
x AVH
uPH9i
L$ SVWH
t$ !t$$3
VWAVH
ATAVAWH
t$(!t$,3
A_A^A\
\$H!\$L3
c AUAVAWH
t$(!t$,3
A_A^A]
VWAVH
`A^_^
VWAVH
`A^_^
WAVAWH
A_A^_
ZXr6I
ATAVAWH
t$(!t$,3
A_A^A\
s AWH
t$(!t$,3
ATAVAWH
t$0!t$43
A_A^A\
{ ATAVAWH
t$8!t$<3
A_A^A\
ATAVAWH
t$(!t$,3
A_A^A\
{ ATAVAWH
t$(!t$,3
A_A^A\
ATAVAWH
t$(!t$,3
A_A^A\
VWAVH
`A^_^
VWAVH
ATAVAWH
t$8!t$<3
A_A^A\
c AUAVAWH
t$H!t$L3
A_A^A]
ATAVAWH
t$8!t$<3
A_A^A\
ATAVAWH
t$(!t$,3
A_A^A\
WAVAWH
t$(!t$,3
A_A^_
s AWH
t$(!t$,3
s AWH
t$(!t$,3
VWAVH
s AWH
t$H!t$L3
q S>]
ATAVAWH
t$H!t$L3
A_A^A\
VWAVH
`A^_^
ATAVAWH
t$X!t$\3
A_A^A\
ATAVAWH
t$(!t$,3
A_A^A\
WAVAWH
A_A^_
qc[2_&
ATAVAWH
t$8!t$<3
A_A^A\
VWAVH
`A^_^
c AUAVAWH
t$H!t$L3
A_A^A]
WAVAWH
t$(!t$,3
A_A^_
\$ !\$$3
WAVAWH
t$(!t$,3
A_A^_
VWAVH
VWAVH
`A^_^
\$8!\$<3
ATAVAWH
t$(!t$,3
A_A^A\
ATAVAWH
t$(!t$,3
A_A^A\
ATAVAWH
t$(!t$,3
A_A^A\
ATAVAWH
t$(!t$,3
A_A^A\
WAVAWH
t$(!t$,3
A_A^_
t$(!t$,3
{ AVH
\$X!\$\3
\$H!\$L3
qK]0T7
ATAVAWH
t$(!t$,3
A_A^A\
ATAVAWH
t$(!t$,3
A_A^A\
ATAVAWH
t$H!t$L3
A_A^A\
s WAVAWH
A_A^_
\$8!\$<3
qK]0T7
ATAVAWH
t$(!t$,3
A_A^A\
ATAVAWH
t$(!t$,3
A_A^A\
ATAVAWH
t$(!t$,3
A_A^A\
VWATAVAWH
`A_A^A\_^
ATAVAWH
t$(!t$,3
A_A^A\
c AUAVAWH
t$8!t$<3
A_A^A]
c AUAVAWH
t$(!t$,3
A_A^A]
c AUAVAWH
t$(!t$,3
A_A^A]
c AUAVAWH
t$(!t$,3
A_A^A]
ATAVAWH
t$(!t$,3
A_A^A\
ATAVAWH
t$(!t$,3
A_A^A\
s WAVAWH
A_A^_
WAVAWH
A_A^_
WAVAWH
A_A^_
c AUAVAWH
t$8!t$<3
A_A^A]
ATAVAWH
t$H!t$L3
A_A^A\
qXW>P?
qXW>P?
q"_8l7
t$ WH
D#D$0D
3D$8%
3D$8%x
@SVWH
D$ E3
\$0I;
{ ATAVAWH
 A_A^A\
@ D+C
h UAVAWH
L$@I+
L$PH;
T$PM;
A_A^]
qpW^(
qxPV!'
qKUVP
D$ E3
D$ E3
q@\6o
UWAVH
p[]:`
@USVWAVAWH
8A_A^_^[]
H;Q(s
H;S(s
D$(E3
D$(E3
WAVAWH
H;S v
0A_A^_
qCV2R
D$ E3
@USVWATAUAVAWH
L$`E3
L$pH;
L9|$8v4H
L$pH;
A_A^A]A\_^[]
|$ UATAVH
A^A\]
L$@H3
@SVWH
@USWH
SVWAVAWH
t$x;>
0A_A^_^[
UVWATAVH
H!\$0H
D$(H!\$ D
A^A\_^]
f9D$Pr?
L$`H3
L$HH3
H;Q(t
t$ WH
t$ WH
UWAVH
s WAVAWH
fD9<~u
fD9|E
D9|$`}/H
@A_A^_
\$ UVWATAUAVAWH
pA\\|
A_A^A]A\_^]
t$ E3
x UAVAWH
D$0=n
L$@E3
D9t$0
A_A^]
@USVH
x UATAUAVAWH
D9l$Pu-A
\$XD9k
pY^Tc6
l$ E3
A_A^A]A\]
x AVH
x AVH
@SUVWATAVAWH
I!?I!>H
L$@H;
A_A^A\_^][
@USVWAVH
A^_^[]
x UAVAWH
D9=(i
A_A^]
UATAUAVAWH
pY^Tc6
l$ E3
pY^Tc6
A_A^A]A\]
UWAVH
t$ E3
UWATAVAWH
pA\\|
A_A^A\_]
@SVWH
H;S(s
H;S(s
H;S(s
H;S(s
H;S(s
|$ UH
@USWATAUAVAWH
A_A^A]A\_[]
UWATAVAWH
A_A^A\_]
\$ WH
UVWAVAWH
A_A^_^]
UVWATAUAVAWH
p)W4)
A_A^A]A\_^]
qSUVP
qSUVP
qSUVP
qSUVP
qSUVP
qSUVP
L$@H;
` UAVAWH
tGD8e
p:X~0
A_A^]
q:X~0
q:X~0
q:X~0
q:X~0
q:X~0
q:X~0
q:X~0
q:X~0
q:X~0
q:X~0
q:X~0
q:X~0
q:X~0
@USWH
p)QV+
@USVWATAUAVH
A^A]A\_^[]
@USVWATAUAVAWH
p)W4)
p)QV+
D$ E3
p8[8X
pz_2G/5
p8[8X
pz_2G/5
L$ E3
pz_2G/5
A_A^A]A\_^[]
` UAVAWH
A_A^]
@USVWATAUAVH
D$ E3
A^A]A\_^[]
@USVH
UAVAWH
|$ E3
A_A^]
UVWATAUAVAWH
d$ E3
A_A^A]A\_^]
UATAUAVAWH
A_A^A]A\]
UVWAVAWH
`A_A^_^]
L$ UVWATAUAVAWH
p)QV+
A_A^A]A\_^]
UVWATAUAVAWH
\$@D9{
D9|$8t_D
A_A^A]A\_^]
UAUAWH
A_A]]
UVWAVAWH
\$P9s
A_A^_^]
UAVAWH
A_A^]
\$ UVWATAUAVAWH
D$@L9|$Hu
pA\\|
A_A^A]A\_^]
@USVH
SVWATAUAVAWH
D$ E3
A_A^A]A\_^[
\$ UVWATAUAVAWH
pA\\|
9t$0|
9t$Tv
9t$Xv
D$0E3
A_A^A]A\_^]
@SVWATAUAVAWH
|$HE3
p)QV+
A_A^A]A\_^[
UWAUAVAWH
A_A^A]_]
@USVWATAVAWH
`A_A^A\_^[]
UATAUAVAWH
A_A^A]A\]
@USVWAWH
p)QV+
pA__^[]
UATAUAVAWH
fD9<Xu
A_A^A]A\]
H UATAUAVAWH
fD94Xu
A_A^A]A\]
UWAVH
`A^_]
UWATAVAWH
A_A^A\_]
UWATAVAWH
A_A^A\_]
@USWAVAWH
`A_A^_[]
UVWATAWH
p)QV+
PA_A\_^]
UWAUAVAWH
A_A^A]_]
UWATAUAVH
A^A]A\_]
` UAVAWH
A_A^]
UWATAVAWH
A_A^A\_]
UVWATAUAVAWH
p)QV+
pA_A^A]A\_^]
UVWAVAWH
pA_A^_^]
UVWATAUAVAWH
p)W4)
p)QV+
A_A^A]A\_^]
UWAVH
PA^_]
UATAUAVAWH
p)QV+
A_A^A]A\]
UVWATAUAVAWH
A_A^A]A\_^]
UATAUAVAWH
A_A^A]A\]
UATAUAVAWH
A_A^A]A\]
UWAWH
UVWATAUAVAWH
\$HD9{
A_A^A]A\_^]
UWAVH
`A^_]
@USVWATAUAVAWH
EHH!]PH!]XE3
p)W4)
p)QV+
L$ E3
p8[8X
p(Zr.6
A_A^A]A\_^[]
@USVWATAUAVAWH
p)W4)
p)QV+
L$ E3
D$`E3
p8[8X
p8[8X
A_A^A]A\_^[]
UAUAVH
A^A]]
UAUAWH
A_A]]
UVWATAUAVAWH
p)QV+
A_A^A]A\_^]
@USVWATAVAWH
D$0D9p
D9u`tcH
A_A^A\_^[]
UAVAWH
A_A^]
@USVWATAUAVAWH
pA\\|
A_A^A]A\_^[]
@USVWATAUAVAWH
p)W4)
p)QV+
D$ E3
p8[8X
D$`E3
A_A^A]A\_^[]
UWAUAVAWH
A_A^A]_]
@USVWATAUAVH
A^A]A\_^[]
UVWAVAWH
A_A^_^]
UWAUAVAWH
A_A^A]_]
UAVAWH
|$ E3
A_A^]
\$ UVWATAUAVAWH
pA\\|
A_A^A]A\_^]
UAVAWH
|$ E3
A_A^]
UVWATAUAVAWH
pA\\|
A_A^A]A\_^]
@USVWATAUAVAWH
A_A^A]A\_^[]
t$ UWAUAVAWH
A_A^A]_]
x UATAUAVAWH
A_A^A]A\]
UATAUAVAWH
A_A^A]A\]
USVWATAUAVH
A^A]A\_^[]
@USWAVAWH
A_A^_[]
UVWAVAWH
D$09p
A_A^_^]
UVWATAUAVAWH
A_A^A]A\_^]
UATAUAVAWH
l$ E3
A_A^A]A\]
UVWATAUAVAWH
D8l$4u#L
D9l$D
pA\\|
A_A^A]A\_^]
UATAUAVAWH
A_A^A]A\]
@USVWATAUAVAWH
pA\\|
A_A^A]A\_^[]
c AUAVAWH
t$h!7H
D$HH!D$HH
D$XH!D$XH
A_A^A]
x ATAVAWH
0A_A^A\
SVWAVAWH
 A_A^_^[
UWAVH
PA^_]
UWAVH
`A^_]
@USVWATAVAWH
p0S^4
p0S^4
A_A^A\_^[]
I;@(t
B(I;@(u
H;Q(t
B H;A(t
@USWH
@USWH
H;C(t
I(D9Q
tEL;I u
t$D9P
UWAVH
SVWAVAWH
t$x;>
0A_A^_^[
SVWAVAWH
t$x;>
0A_A^_^[
SVWAVAWH
t$x;>
0A_A^_^[
SVWAVAWH
t$x;>
0A_A^_^[
x AVH
H;V(s
UATAUAVAWH
A_A^A]A\]
H;Q(t/H
L$PE3
A I;@(t
B(I;@(u
H;P u
UWAWH
0A__]
UWAWH
0A__]
u)H91t
3s6H+
x UATAUAVAWH
A_A^A]A\]
@USWH
@USWH
q8[8X
qz_2G/5
q(Zr.6
qi\:D'X
q!WRE
x AVH
q2W\,/t
|$ UATAUAVAWH
d$8E3
A_A^A]A\]
x UATAUAVAWH
d$ E3
d$ E3
\$ E3
A_A^A]A\]
UWATAVAWH
A_A^A\_]
|$ UATAUAVAWH
D$0E3
A_A^A]A\]
UATAUAVAWH
D$ E3
A_A^A]A\]
x UAVAWH
A_A^]
UVWATAUAVAWH
A_A^A]A\_^]
UVWATAUAVAWH
A_A^A]A\_^]
UWATAVAWH
t$ E3
pbRxL
A_A^A\_]
UAVAWH
A_A^]
qXQr(
qHX2Z
q;ZPG7`
t$ UH
UVWAVAWH
`A_A^_^]
@USWH
x AVH
@USWH
G0u:H
L$@E3
qY^Tc6
D$ E3
@USWH
@USVWATAUAVAWH
A_A^A]A\_^[]
UWAWH
!](!]
UWAVH
UWATAVAWH
0A_A^A\_]
UWAVH
!]8!] !
0A^_]
D$8E3
@USVWAVH
`A^_^[]
VWAVH
D$pHcH
@A^_^
UVWATAUAVAWH
D97~4
A_A^A]A\_^]
@USWH
@USVWATAUAVAWH
L$pH;
A_A^A]A\_^[]
@USVWH
H_^[]
@USVWATAVAWH
L$`E3
9\$tt0H
A_A^A\_^[]
VWATAVAWH
D$ 0u
D$ 0u
A_A^A\_^
UVWATAUAVAWH
pA_A^A]A\_^]
@USWH
@USWH
A@tDH
UATAVH
p)W4)
A^A\]
t$ UWAUAVAWH
p)W4)
A_A^A]_]
@USVWATAUAVAWH
l$hE3
t<fD9+t6H
L$pH;
L$HD9i
A_A^A]A\_^[]
qA\\|
@USVWH
x_^[]
x AVH
WATAUAVAWH
0A_A^A]A\_
UWAUAVAWH
t5fD9+t/H
\$PE3
D$@D9h
A_A^A]_]
UWATAVAWH
H!t$HH
D$pL!t$xL!u
\$XE3
A_A^A\_]
UVWATAUAVAWH
A_A^A]A\_^]
@USVWATAVAWH
A_A^A\_^[]
L$ SH
D$ E3
UWAWH
@USVWATAVAWH
D9uwu
A_A^A\_^[]
x UATAVH
A^A\]
UWATAUAVH
A^A]A\_]
UVWATAWH
D$8H!T$0H!T$(H!T$ A
D$ E3
A_A\_^]
x UATAUAVAWH
A_A^A]A\]
@USVWATAVAWH
@8~@u
A_A^A\_^[]
UVWAVAWH
p)W4)
`A_A^_^]
x UAVAWH
p0S^4
|$ E3
A_A^]
@USVWATAVAWH
t$0D!t$0H
D$`L!t$hL!t$pE3
A_A^A\_^[]
t$ UWAUAVAWH
D9|$pu
D9|$tu
A_A^A]_]
SUVWATAUAVAWH
H9|$0u
H+T$8I
XA_A^A]A\_^][
@USVWATAUAVH
`A^A]A\_^[]
` UAVAWH
A_A^]
UVWATAUAVAWH
p)W4)
D9Eou
|$ E3
A_A^A]A\_^]
x UATAUAVAWH
A_A^A]A\]
UVWATAUAVAWH
p)W4)
D$PD9h
D$`E9h
D$PD9h
A_A^A]A\_^]
{ AVH
WAVAWH
 A_A^_
x UATAUAVAWH
\$XH+
d$ E3
L9d$x
A_A^A]A\]
UVWATAUAVAWH
D9mg}
A_A^A]A\_^]
UVWATAUAVAWH
t$ E3
D$p9p
t$ E3
t$ E3
A_A^A]A\_^]
@USWH
@USVWAVH
H!u@H!uHH!u8H
0A^_^[]
USVWATAUAVAWH
t$PE3
A_A^A]A\_^[]
UWAVH
\$8E3
UWATH
@USVWATAVH
A^A\_^[]
VWAVH
UAVAWH
A_A^]
UAVAWH
A_A^]
UWAUAVAWH
p[]:`
|$ E3
}gD8=
A_A^A]_]
UWATAVAWH
p[]:`
d$ E3
A_A^A\_]
H AVH
E9l$Xtk
fA93tPA;
;=tDA
L$(E3
t$ UWAVH
|$ ;~
L$0H;
f9,Ou
|$8E3
UWAVH
USVWAVH
@A^_^[]
UVWATAUAVAWH
L9sXu
t$`E3
A_A^A]A\_^]
UVWAVAWH
A_A^_^]
@USVWATH
(D$`f
A\_^[]
UWATAUAVH
A^A]A\_]
\$PM!
qSUVP
x UATAUAVAWH
D$HE3
T$@D9j
A_A^A]A\]
UWAVH
t$PE3
\$x9t$ 
USVWAVH
A^_^[]
q:X~0
q:X~0
t$ WH
L$ E3
UVWAVAWH
M8D9x
A_A^_^]
UWAWH
@USVWATAVAWH
A_A^A\_^[]
@USVWATAVAWH
EwHcX
A_A^A\_^[]
USVWATAVAWH
]wD9c
A_A^A\_^[]
t{f93tvH
|$ UH
tYf93tTE3
tDf9;t?H
t$ UWATAUAVH
D9t$X
;|$Xr
A^A]A\_]
x UATAUAVAWH
x^D8t$0
A_A^A]A\]
USVWATAVH
H+MoH
A^A\_^[]
x UATAUAVAWH
A_A^A]A\]
@USVWATAVAWH
A_A^A\_^[]
w%H;q
USWAVAWH
pA_A^_[]
x UATAUAVAWH
A_A^A]A\]
L$ UWAVH
|$ UH
|$ UATAUAVAWH
fE9,|u
A_A^A]A\]
@USVWATAVAWH
fD9<Gu
A_A^A\_^[]
UVWATAUAVAWH
fE9$Gu
A_A^A]A\_^]
@USVWATAUAVAWH
fA9<$
\$HE3
l$xD;
A_A^A]A\_^[]
L$PH3
L$`H3
UVWAVAWH
pA_A^_^]
D$ E3
UVWATAVH
L9vHu)
t$ E3
A^A\_^]
\$ UVWATAUAVAWH
p;ZPG7`
p)QV+
A_A^A]A\_^]
VWAVH
@A^_^
@USWATAUAVAWH
A_A^A]A\_[]
UWAVH
@A^_]
UWATAVAWH
A_A^A\_]
|$XE3
t$ WH
@USVWATAUAVH
uoH!uwH
A^A]A\_^[]
t$ WH
UWAVH
UVWATAUAVAWH
A_A^A]A\_^]
SVWAVAWH
t$x;>
0A_A^_^[
L$PH3
UVWAVAWH
A_A^_^]
UATAUAVAWH
A_A^A]A\]
t$ UWATAVAWH
|$ E3
|$ E3
A_A^A\_]
UWATAUAWH
A_A]A\_]
UWATAVAWH
A_A^A\_]
\$ UVWATAUAVAWH
D$PD9l$P
l$ E3
\$ E3
l$ E3
D$ E3
L$XHc
D$XH+
l$ E3
l$ E3
A_A^A]A\_^]
USVWATAVAWH
A_A^A\_^[]
UWAVH
E(D9p
WAVAWH
H;S v
0A_A^_
x UATAUAVAWH
A_A^A]A\]
@SVWH
L$HH3
UWATAVAWH
zt%=4
A_A^A\_]
UVWATAUAVAWH
@A_A^A]A\_^]
UWATAVAWH
A_A^A\_]
H UWAVH
UVWATAUAVAWH
PA_A^A]A\_^]
WAVAWH
H;S v
0A_A^_
SVWAVAWH
t$x;>
0A_A^_^[
SVWAVAWH
t$x;>
0A_A^_^[
UVWATAUAVAWH
PA_A^A]A\_^]
UWAUAVAWH
A_A^A]_]
@USWH
@USWH
t$ WAVAWH
H;L$@
H9]0u
 A_A^_
\$HE3
H;S(s
H;S(s
L$(E3
WAVAWH
t$`H!>A
 A_A^_
UWAVH
WAVAWH
A_A^_
WAVAWH
H;S v
0A_A^_
UVWATAUAVAWH
`A_A^A]A\_^]
VWAVH
@A^_^
VWAVH
@A^_^
|$PE3
\$0E3
UWAUAVAWH
\$ E3
A_A^A]_]
UATAUAVAWH
uaLcK
A_A^A]A\]
s AWH
d$1D!t$XD!t$\3
D!|$ A
D8=Xh
D!|$4
D!|$ E3
D!|$ E
D$4Di|$P
T$ E3
UWAVH
~ L;~(r
@USWAVAWH
p)QV+
pA_A^_[]
p)QV+
x AVH
@USVWATAVAWH
pA_A^A\_^[]
p WATAUAVAWH
 A_A^A]A\_
x UAVAWH
p)QV+
A_A^]
L$@H3
x AVH
WATAVH
@A^A\_
h UAVAWH
A_A^]
@USVWATAUAVAWH
|$TD9m
|$ E3
L9l$h
A_A^A]A\_^[]
x UATAUAVAWH
A_A^A]A\]
USVWATAUAWH
A_A]A\_^[]
|$ UATAUAVAWH
p)W4)
t$ E3
t$ E3
t$ E3
A_A^A]A\]
t$ WH
@USWH
UWAUAVAWH
A_A^A]_]
h UAVAWH
A_A^]
UVWATAUAVAWH
p)W4)
\$ E3
D$XI;
A_A^A]A\_^]
x UAVAWH
A_A^]
H UWAVH
@USWH
@USWH
@USVWATAUAVAWH
p)W4)
L$HE3
|$ E3
A_A^A]A\_^[]
t$ WH
D$ E3
D$ E3
x UATAUAVAWH
I9w(ueH
IcW0D
O(IcG0@
A+G`A
A_A^A]A\]
pA\\|
@SUVWAVAWH
A_A^_^][
UVWATAUAVAWH
A8u*H
D$(fD
D$(fD
A_A^A]A\_^]
T$PE3
t#D9Y u
T$PE3
WAVAWH
H;S v
0A_A^_
WAVAWH
H;S v
0A_A^_
WAVAWH
H;S v
0A_A^_
t$ UH
x UATAWH
A_A\]
USVWAVH
A^_^[]
UWATAVAWH
\$HE3
A_A^A\_]
USVWAVAWH
hA_A^_^[]
SWATAUAVAWH
l$pE3
!T$DE3
d$XH!T$PM
L$ E3
|$`M;
A_A^A]A\_[
UWAVH
pA^_]
8\$Pt
UWATAVAWH
A_A^A\_]
@USWAVAWH
A_A^_[]
UVWATAWH
H!]'E3
tcH!\$0!\$(!\$ E3
A_A\_^]
UWATAVAWH
A_A^A\_]
@USVWAVH
`A^_^[]
UWATAVAWH
fD94Au
A_A^A\_]
UAVAWH
A_A^]
UVWAVAWH
A_A^_^]
USVWATAUAVAWH
;s-A;
A_A^A]A\_^[]
VWAVH
UWAUAVAWH
t-D8)t(L
t2fD9.t,H
A_A^A]_]
t$ UWATAVAWH
t2fD9#t,H
A_A^A\_]
UWATAVAWH
A_A^A\_]
t$ UWATH
UVWATAUAVAWH
f9|$0
A_A^A]A\_^]
UWATAVAWH
A_A^A\_]
UVATAUAVAWH
I;D$ r
hA_A^A]A\^]
q0X2x
q0X2x
H;S(s
x AVH
t$PH!>H
WAVAWH
H;S v
0A_A^_
H;S(s
UVWAVAWH
A_A^_^]
UVWATAWH
A_A\_^]
UVWAVAWH
A_A^_^]
D$ A!
UWATAUAVH
A^A]A\_]
UVWAVAWH
A_A^_^]
UWATAVAWH
A_A^A\_]
UVWATAUAVAWH
A_A^A]A\_^]
L$XH+
UWAWH
(D$0f
@USVWATAVAWH
D$ E3
A_A^A\_^[]
h VWAVH
@A^_^
USVWAVH
A^_^[]
\$ UVWAVAWH
t$xfD
A_A^_^]
L$0H;
@USVWATAWH
xA_A\_^[]
H9^Hw
H9^Hv&H;^HsVL
H;nHr
UWATAVAWH
A_A^A\_]
@USVWATAUAVAWH
t4@8>t/H
H9|$xu"A
D$ E3
H9|$x
A_A^A]A\_^[]
UVWATAVH
A^A\_^]
UWAWH
USVWATAVAWH
A_A^A\_^[]
UWATAVAWH
A_A^A\_]
UVWAVAWH
A_A^_^]
x AVH
UVWATAUAVAWH
`A_A^A]A\_^]
|$ UATAUAVAWH
A_A^A]A\]
UVWATAUAVAWH
A_A^A]A\_^]
H WAVAWH
 A_A^_
@USVWAVH
@A^_^[]
UWATAVAWH
A_A^A\_]
UVWAVAWH
A_A^_^]
|$ UATAUAVAWH
fD9$Gu
A_A^A]A\]
UWATAUAVH
fA9<Fu
A^A]A\_]
UWATAVAWH
A_A^A\_]
UATAUAVAWH
A_A^A]A\]
UAVAWH
A_A^]
x UATAUAVAWH
A_A^A]A\]
t$ UWATAVAWH
A_A^A\_]
@USWAVAWH
pA_A^_[]
qQXPC
qQXPC
qQXPC
UWAUAVAWH
A_A^A]_]
H;S(s
UVWAUAVH
`A^A]_^]
UVWATAUAVAWH
l$`E3
D$PH;
l$ E3
A_A^A]A\_^]
q@^r?
q@^r?
UVWATAUAVAWH
A_A^A]A\_^]
UATAUAVAWH
A_A^A]A\]
pQXPC
t$`E3
UVWATAWH
D$ E3
A_A\_^]
UWATAUAVH
A^A]A\_]
USVWATAVAWH
d$ E3
A_A^A\_^[]
fD95{q
L$PH;
h UAVAWH
A_A^]
WAVAWH
trfD9:tlH
tgfD99ta
A_A^_
USVWATAVAWH
u>L9%
d$ E3
A_A^A\_^[]
UVWATAUAVAWH
A_A^A]A\_^]
@USVWAVH
A^_^[]
UWAWH
UATAVH
A^A\]
UVWATAUAVAWH
A_A^A]A\_^]
USVWH
8_^[]
UWAWH
tpf91tkH
UVWATAUAVAWH
A_A^A]A\_^]
UWATH
@USWAVAWH
A_A^_[]
@USVWAUAVAWH
A_A^A]_^[]
t$ UWAUAVAWH
A_A^A]_]
UWAVH
UVWAVAWH
E@D9x
@A_A^_^]
@USWH
UWAVH
@USVWAVH
A^_^[]
USVWAWH
A__^[]
\$ UVWH
UVWAVAWH
A_A^_^]
UWAUAVAWH
p[]:`
A_A^A]_]
t$ UWATH
UWAUAVAWH
p[]:`
A_A^A]_]
@USVWATAVAWH
A_A^A\_^[]
UATAVH
A^A\]
` UAVAWH
A_A^]
p AWH
@USVWATAVAWH
A_A^A\_^[]
L$ UWATAVAWH
A_A^A\_]
@USWH
L$ UWAUAVAWH
A_A^A]_]
UWAWH
VWATAVAWH
A_A^A\_^
x AVH
UVWAVAWH
A_A^_^]
UAVAWH
A_A^]
WAVAWH
 A_A^_
@USVWAVH
 A^_^[]
|$ UH
@USWH
UVWAVAWH
PA_A^_^]
@USVWAVAWH
HcNh9H
D+FhH
F8D9x
A_A^_^[]
T$8E3
D$(E3
t$ UWAVH
p WAVAWH
0A_A^_
L$@E3
x UAVAWH
p[]:`
A_A^]
WATAUAVAWH
A_A^A]A\_
t$ WAVAWH
H!\$8!\$@H
|$hD+
L$hH3
A_A^_
UAUAWH
A_A]]
SWATAUAVAWH
l$pE3
!T$DE3
d$XH!T$PM
L$ E3
|$`M;
A_A^A]A\_[
UVWATAUAVAWH
p[]:`
d$ E3
p[]:`
A_A^A]A\_^]
UWAUAVAWH
A_A^A]_]
@USWH
u)H91t
3s6H+
UAVAWH
A_A^]
UWATAVAWH
A_A^A\_]
t$ UWAWH
UWAVH
D9t$$
D$(D9p
UWAWH
pA__]
` UAVAWH
A_A^]
UVWATAUAVAWH
A_A^A]A\_^]
UWAWH
UVWATAUAVAWH
A_A^A]A\_^]
UWATAVAWH
fD9$Bu
A_A^A\_]
q2_<S.
UVWATAVH
p[]:`
A^A\_^]
UWAVH
t$ WAVAWH
H!\$8!\$@H
|$hD+
L$hH3
A_A^_
UAVAWH
fE9<Au(A
A_A^]
@USVWAVH
fD94Ft
PA^_^[]
UWAVH
t+f98t&L
H!t$(L
!t$ E3
L$0H!s
H!s H!s(L
H!t$(L
!t$ L
t$ UWATAVAWH
A_A^A\_]
UWAVH
PA^_]
x UATAUAVAWH
D$ E3
fA9<Fu
A_A^A]A\]
L$@H3
UATAUAVAWH
A_A^A]A\]
UWAWH
x AVH
x ATAVAWH
A_A^A\
x AVH
UWATAVAWH
A_A^A\_]
UWATAVAWH
A_A^A\_]
UATAUAVAWH
|$ E3
t$ E3
t$ E3
A_A^A]A\]
UVWATAUAVAWH
A_A^A]A\_^]
@USVWATAUAVAWH
D$hE3
|$ E3
A_A^A]A\_^[]
UWATAVAWH
A_A^A\_]
UVWATAUAVAWH
D$ E3
A_A^A]A\_^]
H UATAUAVAWH
A_A^A]A\]
p AWH
UATAUAVAWH
L$pE3
L+D$pD
A_A^A]A\]
@USVWAVH
pA^_^[]
x AVH
x AVH
onecoreuap\ds\ext\Live\identity\Lib\Utilities\credmanutility.h
targetname='%ls', type=%d, isCredential=%d
CredmanUtility::CredReadW
CSingleIdentity::PersistPendingCredential
m_strCredTypeToPersistUponSuccessfulAuth='%s',bRefreshPersistedCred=%d
HandlePersistCredentialInternal
wszCredType='%ls'
wstrCredentialType='%s'
CIdentityCredentialBag::PersistCredential
ps:membernameonly
Microsoft_WindowsLive:SerializedMaterial:
%ls%-d
Microsoft_WindowsLive:SerializedMaterial:000
%ls%ls
MicrosoftAccount:target=SSO_POP_User:user=
CAuthInfo::WriteToCache
wszUserName=%ls, wszVirtualAppName=%ls, wszAuthTokenBlob=%ls
wszUserName is too long (%Iu chars).
Microsoft_WindowsLive:authstate:
wstrTargetName=%ls
CredmanUtility::CredWriteW
targetname='%ls', type=%d, flags=0x%x, isCredential=%d
TpmSessionKeyFunctions::SignMessage
AssertFlags
Software\Microsoft\IdentityCRL\Trace
UrlUtilities::AppendMarket
UrlUtilities::GetMarket
onecoreuap\ds\ext\live\identity\lib\utilities\urlutilities.cpp
Appended market, URL is now: '%ls'
CAuthInfo::EncryptCredentialsInSystemContext
wstrCredTargetName = '%ls'.
ps:eid
CServiceRequest::ValidateAndCopyRequests
CPPCRLRequest::AddDATokenRequest
CPPCRLRequest::DecryptBase64ToString
InterruptNotifications::GetUrlFromConfigCache
URL_AccountSettings
hr = GetUserLanguages(L'\0', langList.GetAddressOf())
WS-SecureConversationWS-SecureConversation
DAToken was not requested, adding to request list.
UrlAppendQueryString
onecoreuap\ds\ext\live\identity\passport\lib\utilities\ppstr.cpp
ncalrpc
StartRpcServer
D:(A;;GRGWGX;;;WD)(A;;GRGWGX;;;RC)(A;;GA;;;BA)(A;;GA;;;OW)(A;;GR;;;S-1-15-3-1024-1941919063-976504945-3191785059-2835515153-1936800635-1519032070-1452055454-2678282739)
OnlineProviderCert RPC Interface
LiveIdSvc RPC Interface
GetWindowsDeviceId
onecoreuap\ds\ext\live\identity\ntservice\lib\svccommon\windowsdeviceid.cpp
CPPCRLRequest::ValidateAndCopyRequests
{b55d3824-693c-441b-b99f-580211532ce3}
Default
CSingleIdentity::PersistServiceTokens
CIdentityTokenBag::PersistServiceTokens
<wsse:LoginOption>%d</wsse:LoginOption>
WLIDDeleteContext
Context=0x%p
HandleDeleteContextEx
CIdentityStore::CloseIdentityHandle
CIdentityCredentialBag::HasPersistedCredential
wstrCredentialType=%s
WLIDCreateContext
##TestHook: URL-%s
CTransport::CloseAllInternet
onecoreuap\ds\ext\live\identity\ntservice\lib\svccommon\transport.cpp
fCancelRequest=%d
CIdentityCredentialBag::GetPersistedCredential
ps:password
onecoreuap\ds\ext\live\identity\ntservice\lib\svccommon\Include\credstore.h
CSingleIdentity::CheckIdentityNameAndPassword
userType=%d
CAuthInfo::GetCachedAuthInfo
CSingleIdentity::CheckIdentityNameAndNGCKey
https://
WLIDGetIdentityProperty
wszPropertyName='%ls', pwszPropertyValue=0x%p
IsTokenAppContainer
onecoreuap\ds\ext\live\identity\ntservice\lib\svccommon\svcapi.cpp
isTokenAppContainer = %d
GetUserTokenFromAppContainerContext
GetXMLNodeAttribute
CAutoImpersonateClient::ImpersonateClient
***(%lu characters redacted)***
*****
CAuthInfo::HasPersistedUserName
wszUserName=%ls
onecoreuap\ds\ext\live\identity\ntservice\lib\svccommon\singleidentity.cpp
CredmanUtility::CredEnumerateW
onecoreuap\ds\ext\Live\identity\Lib\Utilities\CredmanUtility.h
targetname='%ls', isCredential=%d
MicrosoftAccount:user=
CIdentityTokenBag::RetrieveToken
%s;%d
%s%-d
&apos;
&quot;
</wsu:Expires></wsu:Timestamp>
Current WebSSO UTC time on request is %hs.
SHA256
</wsu:Created><wsu:Expires>
onecoreuap\ds\ext\live\identity\ntservice\lib\svccommon\rst.cpp
%Y-%m-%dT%H:%M:%SZ
<wsu:Timestamp wsu:Id="Timestamp"><wsu:Created>
<wsu:Timestamp
<wsu:Timestamp xmlns:wsu="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd"
&#x%04X;
CIdentityStore::GetDeviceIdentity
&#x%06X;
&amp;
LUID=[%d,%d]
CAutoImpersonateClient::GetLogonId
onecoreuap\ds\ext\live\identity\ntservice\lib\svccommon\Include\svcapi.h
CTokenInfo::AssembleTokenBlob
hr = SafeCopyMemory(spCredentialAttributes + credentialAttributesSizeInBytes, credentialAttributesMaxSizeInBytes - credentialAttributesSizeInBytes, pAttri->Value, pAttri->ValueSize)
CAutoImpersonateClient::GetTokenUser
sid='%s'
onecoreuap\ds\ext\live\identity\ntservice\lib\svccommon\identitystore.cpp
onecoreuap\ds\ext\live\identity\ntservice\lib\svccommon\tokenbag.cpp
CIdentityStore::GetSingleIdentity
LogonId.LowPart='%d, LogonId.HighPart='%d, handle=%p
SessionId=%d
CAutoImpersonateClient::GetSessionId
CAuthInfo::GetUserTargetName
GetIdentityFromExternalHandle mapped external identity 0x%p to 0x%p.
CAutoImpersonateClient::GetTokenSid
GetIdentityPropertyHelper
MemberName
http://Passport.NET/tb
#PPAuthInfo
onecoreuap\ds\ext\live\identity\ntservice\svc\wlidrpc.cpp
WLIDAuthEndPointUrl
 no attribute - %s:%x
WLIDAuthEndPointUrlHash
FedAuthEndPointUrlHash
OneTimeCredential
IsDomainUser
AllExtendedProperties
ReturnToCaller
EndAuthUrl
AuthUrl
FlowUrl
{AFDA72BF-3409-413a-B54E-2AB8D66A7826}
DeviceIdHelpers::GetDeviceAuthToken
pwszAppId=%s,dwDeviceType=%d,flags=%llx
pwszAppId=%ls,flags=%llx,pvAdditionalParams=%p,internalFlags=%llx,pwszDeviceId=%p,ppCertContext=%p,hDeviceIdentity=%p
DeviceIdHelpers::Validate
DeviceIdHelpers::GetDeviceIDHelper
wstrAppId=%ls,dwDeviceType=%d,flags=%llx,internalFlags=%llx,bReturnedNotAssociated=%d
onecoreuap\ds\ext\live\identity\ntservice\lib\svccommon\deviceidmap.cpp
Device name for device key %ls and appId %ls is %ls. Valid DeviceId is %ls
LatestDPAPIKeyVersion
DeviceId Map Registry Key %ls
DeviceIdStore::GetRegistryKey
CDeviceIdentityMap::UpdateAppId
CDeviceIdentityMap::GetAssociatedDeviceName
hr = E_INVALIDARG
CStoredIdentity::SetProperty
LoadXMLDocumentFromString
SelectionNamespaces
hr = pDocument.CoCreateInstance(CLSID_DOMDocument60)
CStoredIdentity::LoadIdentity
onecoreuap\ds\ext\live\identity\ntservice\lib\svccommon\systemstore.cpp
CAuthInfo::GetCachedAuthInfoEx
wszUserName=%ls, wszVirtualAppName=%ls
onecoreuap\ds\ext\live\identity\lib\utilities\xmlredaction.cpp
CAuthInfo::Unpack
wszAuthToken=%ls
hr = StringCchLengthA(strNamespace, STRSAFE_MAX_CCH, &namespaceLen)
ReduceXmlForTracing
<?xml
Reg_QueryString
CStoredIdentity::LoadProperties
PersistedCredential
AssociatedCount
AccountsCount
hDeviceIdentity=%p,pCertContext=%p,pwszDeviceId=%p
DeviceIdHelpers::GetPUID
http://Passport.NET/tb
CIdentityCredentialBag::RetrieveCredential
CredType='%s'
hDeviceIdentity=%p
DeviceIdHelpers::GetDeviceCertificate
ps:ngckn
onecoreuap\ds\ext\live\identity\ntservice\lib\svccommon\credentialbag.cpp
No credential found in credbag, checking the tokenbag for persisted cred.
hIdentity
wszFilterPropertyNAme='%ls'
HandleEnumIdentities
FedAuthEndPointUrl
GetHash=%ls
CSingleIdentity::GetAuthEndPoint
Get Auth End Point URL = '%ls', Fed Partner = '%ls'
false
DeviceIdHelpers::IsHwdDeviceIDEnabled
HWIDEnabled
CPPCRLBaseRequest::CreateDOM
wszAuthToken is NULL.
DeviceIdHelpers::RetrieveDeviceID
hr = DeviceIdHelpers::Validate(pwszAppId, dwDeviceType, flags)
CIdentityStore::GetTokenBagByName
hr = PPCRL_REQUEST_E_MISSING_PRIMARY_CREDENTIAL
cfg:CookieP3PHeader
cfg:AccountDomain
cfg:ConnectAccountPolicy
cfg:AccountPolicy
cfg:DeviceDNSSuffix
wszMemberName='%ls'
HTTP/1.0
CServiceRequest::GetRequestAuthToken
ps:ngcat
AuthInfo/SessionKey node not found in auth info xml. 0x%x.
hr = DeviceIdHelpers::GetDeviceIdentityObject(wstrAppId, dwDeviceType, flags, pvAdditionalParams, internalFlags, hIdentity, bReturnedNotAssociated)
purpose=sso
WebCookieManager::GetCookieData
https://%s
Created Context 0x%p for '%ls'
Found existing token bag for '%ls'.
ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/H
ashDigestLength
<SignedInfo xmlns="http://www.w3.org/2000/09/xmldsig#">
"></SignatureMethod>
<CanonicalizationMethod Algorithm="http://www.w3.org/2001/10/xml-exc-c14n#"></CanonicalizationMethod><SignatureMethod Algorithm="
</SignedInfo>
CPPCRLRequest::BuildRequestInternalEx
#RSTS
CPPCRLRequest::BuildRSTsEx
<ps:RequestMultipleSecurityTokens xmlns:ps="http://schemas.microsoft.com/Passport/SoapServices/PPCRL" Id="RSTS">
</ps:RequestMultipleSecurityTokens>
</wsse:Security></s:Header><s:Body>
</s:Body></s:Envelope>
<wsse:Security>
<?xml version="1.0" encoding="UTF-8"?><s:Envelope xmlns:s="http://www.w3.org/2003/05/soap-envelope" xmlns:ps="http://schemas.microsoft.com/Passport/SoapServices/PPCRL" xmlns:wsse="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd" xmlns:saml="urn:oasis:names:tc:SAML:1.0:assertion" xmlns:wsp="http://schemas.xmlsoap.org/ws/2004/09/policy" xmlns:wsu="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd" xmlns:wsa="http://www.w3.org/2005/08/addressing" xmlns:wssc="http://schemas.xmlsoap.org/ws/2005/02/sc" xmlns:wst="http://schemas.xmlsoap.org/ws/2005/02/trust"><s:Header>
<Reference URI="
"></DigestMethod><DigestValue>
</DigestValue></Reference>
<Transforms><Transform Algorithm="http://www.w3.org/2001/10/xml-exc-c14n#"></Transform></Transforms><DigestMethod Algorithm="
RST%Iu
CPPCRLRequest::BuildRST
"><wst:RequestType>http://schemas.xmlsoap.org/ws/2005/02/trust/Issue</wst:RequestType><wsp:AppliesTo><wsa:EndpointReference><wsa:Address>
</wst:RequestSecurityToken>
</wsa:Address></wsa:EndpointReference></wsp:AppliesTo>
<wst:RequestSecurityToken Id="
hr = g_algProvCache.GetAlgorithmProv( xmlRef.m_wstrAlgIdDigest, 0, hAlgProv)
onecoreuap\ds\ext\live\identity\passport\lib\xmlsig\xmlsig2.cpp
CXmlSig2::ComputeSHADigest
hr = referenceHash.GetSize(&dwSize)
<wsp:PolicyReference URI="
"></wsp:PolicyReference>
pszChallenge=%ls
ParseChallengeToken
CreateDOM
Service URI is empty.
hr = ((CSingleIdentity*)hIdentity)->QueryInterface(EDeviceIdentityType, (void**)&pDeviceIdentityObj)
DeviceIdHelpers::GetDeviceIdentityObject
Failure - CAuthInfo::DecryptSystemContextCredentials, HRESULT: 0x%08X
WinHttpSetStatusCallback failed 0x%x
ps:SingleUseCode
BypassCertRevocationCheck
No credential found - checking for persistent cred.
GetPersistedCredential failed = ERROR_NOT_FOUND.
 CAuthInfo::GetCachedAuthInfo failed, hr=0x%x.
No CredProperty by this name was found, trying extended properties. 0x%x
%s; path=/; domain=%s; secure; httponly
hr = g_pPPCRL->GetIdentityStore()->CloseIdentityHandle(flags, logonId, h)
HandleGetIdentityProperty
hr = GetIdentityPropertyHelper(hIdentity, wszPropertyName, wstrPropertyValue)
No session key present in Auth Token. 0x%x.
App Id is required for disassociation.
!m_pRequest->m_pIdentity->IsRequestCancelled()
 xmlns:ps="http://schemas.microsoft.com/Passport/SoapServices/PPCRL"
CKeyCache::ProcessKeyXml
XML load for text failed at %d: %ls.
hr = client.ImpersonateClient(&hContextToken)
hr = ::CreateDOM(CA2WEX<>(strKeyPurposesXml, CP_UTF8), cvNamespaces, pXMLDoc)
%hs: %u
hr = _pIdWrapper->GetOneTimeCredential(hIdentity, IDCRL_WEBAUTH_NONE, _appID, nullptr, url, token, &unsignedToken, &timeSkew)
CPPCRLRequest::SetApplicableCookies
CIdentityTokenBag::UpdateSystemStoreProperties
Country
KeyPurposes
%ls: %ls, %ls: %ls
Flags
FamilyNotifications::NotifyIfFamilyDataHasChanged
onecoreuap\ds\ext\live\identity\lib\familynotifications\familynotifications.cpp
CIdentityTokenBag::NotifyKeyUpdate
FamilyNotifications::CompareFamilyIDValues
FamilyNotifications::GetFamilyIDFromSystemStore
FamilyID
Treating family ID non-existence as empty value.
<wsse:UsernameToken wsu:Id="user"><wsse:UsernameHint>
</wsse:UsernameToken>
</wsse:UsernameHint>
Found user market of '%ls'.
CSingleIdentity::PersistCertificates
Created '%ls' URL: %ls
FamilyNotifications::GetUserSid
cfg:InterruptResolutionDomain
AuthInfo/SessionKeyType node not found in auth info xml. 0x%x.
The credential property flags are malformed. flags = %ls, errno = %d, hr = 0x%X
hr = pIdentity->PersistCertificates()
System store's family ID = %ls
Skipping deletion of credentials for connected account.
hr = FamilyNotifications::GetUserSid(&context, wstrIdentityName, spSid)
hr = CWLIDCCHelper::GetSID(pExecutionContextLite->GetWinApiFunctions(), pUserName, &spSid)
ps:pin
Windows TPM ID: %ls
hr = PPCRL_REQUEST_E_INVALID_MEMBER_NAME
MsaUserExtImpl::FormatUserDisplayName
AuthInfoBlob is too large
ChunkAndWriteProofOfPossessionTokenCacheEntry
AuthInfo/UserName node not found in auth info xml. 0x%x.
#Timestamp
hr = pSvcWrapper->GetServiceURI(urlConfigKey, outputUrl)
FamilyNotifications::SendWNFNotification
Sending WNF notification because the Family ID value has changed.
Created new identity token bag 0x%p for '%ls'.
pAppIdDeviceMap != NULL
CDeviceIdentityMap::GetAppIdDeviceMap
TPM ID retrieval was unsuccessful, hr = 0x%x
HandleCreateContext
hr = g_pPPCRL->GetIdentityStore()->GetNewIdentityHandle(logonId, pszSid, hContextToken, dwPID, CStringW(wszMemberName), flags, pHandle)
hr = _pIdWrapper->GetCredProperty(hIdentity, PPCRL_CREDPROPERTY_CID, webCookieData.Id)
hr = client.IsImpersonatingSystem(isSystem)
WLIDPersistCredential
ChildFlags
m_pRequest->m_pIdentity->IsRequestCancelled() == false
CTransport::SendImplementation
Failed to enable revocation checking for winhttp, hr=0x%x.
'%ls' is not a valid cred type.
CredEnumerateW succeeded with count %d & credential %p
hr = PassportEncode::Base64Decode(static_cast<BSTR>(nonce), nonce.Length(), decodedNonce)
AgeGroup
System store's flags = %ls
FamilyNotifications::GetFlagFromSystemStore
liveidsvcnotify
LiveIdSvcNotify RPC Interface
hr = UrlUtilities::GetMarket(pWinApiFunctions, market)
Failure - GetThreadPreferredUILanguages, HRESULT: 0x%08X
StringCchCopyW: failed with hr=0x%x
hr = pXMLDoc->selectSingleNode(c_bstrKeyPurposes, &pPurposesNode)
AuthInfo/AuthState node not found in auth info xml. 0x%x.
hr = _pServiceWrapper->GetConfigString(c_wsz_cfg_CookieP3PHeader, webCookieData.P3PHeader)
SignInAssociatedUser
hr = client.GetTokenUser(pszSid)
.Default\Software\Microsoft\IdentityCRL\CredManLog
CIdentityCredentialBag::RefreshPersistedCredential
LogonId.LowPart='%d, LogonId.HighPart='%d, pszSid=%ls, wstrIdentityName=%ls, flags=0x%llx
phandle != nullptr
CIdentityStore::GetNewIdentityHandle
CKeyCache::GetKeyLatest
CPPCRLRequest::GetPassportHeader
CIdentityTokenBag::UpdateKeyCache
MsaUserExtDefaultImpl::FormatUserDisplayName
ShCore.dll
onecoreuap\ds\ext\live\identity\lib\systemstorelite\systemstorelite.cpp
SystemStoreLite::IsConnectedSID
Software\Microsoft\IdentityCRL\StoredIdentities
SystemStoreLite::GetSystemSidString
%s\%s
StringCchPrintf failed for full user SID path. (localHr = 0x%0x)
Connected
DelimiterSeperatedToMultiSzString
wstrRegPath=%s,wstrKeyName=%s
flags=%llx
CAuthInfo::DecryptSystemContextCredentials
DeviceIdStore::LoadFromRegistry
CSystemStore::GetIdentityProperty
LiteCryptUtilities::Base64EncodeA
SystemStoreLite::IsConnected
LiteCryptUtilities::ComputeHash
onecoreuap\ds\ext\live\identity\ntservice\lib\svccommon\webcookiemanager.cpp
WebCookieManager::SetCookieValue
deviceType=%d
onecoreuap\ds\ext\live\identity\ntservice\lib\svccommon\deviceidstore.cpp
DeviceIdStore::GetDeviceLicenseUpdateFailureCount
wstrRegPath=%s, fAllowEmtyDomLoad=%d
DeviceId
DeviceIdStore::LoadPersistedDOM
wstrUserName: %ls
CServiceTokenInfo::RetrievePersistedServiceTokens
WindowsLive:(token):name=
CTokenInfo::GetCredTargetName
Unknown credential type.
serviceuri=
onecoreuap\ds\ext\live\identity\ntservice\lib\svccommon\interruptnotifications.cpp
Software\Microsoft\IdentityCRL\InterruptState
InterruptNotifications::GetCacheState
DeviceLicenseUpdateFailureCount
CWLIDCCHelper::GetSID
CCertificateInfo::RetrievePersistedCertificates
WindowsLive:(cert):name=
CCertificateInfo::RetrievePersistedFileCertificates
RetrievePersistedFileCertificates called with PPCRLUserType = %d
DeviceIdStore::RetrieveCertificatesFromPersistantStore
DeviceIdStore::QueryCertificates
CSingleIdentity::RetrievePersistedCertificates
AccountType
StringCchPrintf failed for user SID path. (hr = 0x%0x)
LocalConnected
CSingleIdentity::RetrievePersistedServiceTokens
CServiceTokenInfo::UnPack
dwTokenBlob %ls
Microsoft_WindowsLive:serviceticket:
Retrieve token %ls.
hr = IsPasswordChangedInCloud(pServiceExecutionContext, pIdentity, hrRequest, isPasswordStale)
StringCchPrintf failed. (hr = 0x%0x)
InterruptCode
RegOpenKeyEx failed. (win32 = 0x%0x)
onecoreuap\ds\ext\live\identity\lib\utilitieslite\litecryptutilities.cpp
RootLevelInterrupt
DefaultCredSaved
CreateWellKnownSid failed. (win32 = 0x%0x)
hr = HRESULT_FROM_WIN32(::BCryptOpenAlgorithmProvider( &spAlgorithm, pAlgId, nullptr, providerFlags))
LiteCryptUtilities::UrlEscapeStringA
SID missing from LiveID key. (win32 = 0x%0x)
hr = pExecutionContext->CreateRegKey(&pRegKey.m_p)
onecoreuap\ds\ext\live\identity\lib\utilities\extensionapi.cpp
ExtensionAPI::IsApplicationFullTrust
AccountSettingsUrl
NotificationTargets
{fc177c6f-a3d6-4bb0-b1fa-23d0cd9b005d}
CreateDeviceIdentityHandle
wszMemberName='%ls', dwFlags=%d
DeviceIdHelpers::CheckAuthToken
DeviceIdHelpers::InternalCheckAuthToken
ResetExtendedError
CIdentityStore::CreateNewIdentity
DIDSystem
CDeviceIdentityBase::InitializeProtocol
hr = StringCchLengthW(pUserName, STRSAFE_MAX_LENGTH, &userNameLen)
CIdentityCredentialBag::StoreCredential
CredType='%ls', Cred='%ls'
SystemStoreLite::GetStoredIdentityProperty
Invalid user name.
SystemStore property not found.
NotificationPolicies
notificationFlags =0x%x, requestTarget ='%ls', requestPolicy ='%ls', requestStatus=0x%x
AppId
MsaUserExtImpl::CallerIsLoggedOnUser
hr = autoRevert.Revert(false)
CIdentityCredentialBag::RemoveCredential
Invalid identity handle.
InterruptNotifications::IsPasswordChangedInCloud
CDeviceIdentityBase::ConstructDeviceIdentityObjectWithLock
CIdentityTokenBag::HasToken
CSingleIdentity::ImportAuthState
CSingleIdentity::SetAuthenticationState
hrAuthState = 0x%x
ImportedDA
URI='%hs', Token='%ls'
CIdentityTokenBag::StoreToken
SetUnsignedProofOfPossessionToken
SerializeObject() completed with hr = 0x%x.
onecoreuap\ds\ext\Live\identity\Include\SerializationDefinition.h
CredSerializationHelper::EncryptBufferForSameLogon
CAuthInfo::GetAuthTokenBlob
GetAuthTokenBlob=0x%p
ServiceURI='%ls'
CSingleIdentity::GetServiceToken
CPPCRLRequest::ParseRequestSecurityTokenResponse
SessionKeyManager::DecryptWithSessionKey
urn:liveid:SP800-108CTR-HMAC-SHA256
urn:liveid:SP800108_CTR_HMAC_SHA256_DOUBLEDERIVED
SessionKeyManager::SignWithSessionKey
CPPCRLRequest::VSig_Decrypt_GetRSTR
SessionKeyManager::VerifySignatureWithSessionKey
onecoreuap\ds\ext\live\identity\lib\sessionkeymanager\sessionkeymanager.cpp
onecoreuap\ds\ext\live\identity\ntservice\lib\svccommon\keycache.cpp
CIdentityTokenBag::GetCredPropertyValue
onecoreuap\ds\ext\Live\identity\Include\tokenbag.h
CKeyCache::SetCredentialBag
wsu:Id
Processing psf:credProperty node '%s'.
AuthMembername
%Y-%m-%dT%H:%M:%S
Current time: %ls 
Token Expired time:%ls 
Clock Skew:%d(sec) 
(null)
wszUserName='%ls', wszPropertyName='%ls', wszPropertyValue=%ls
CUserExtendedProperty::SetExtProperty
wszUserName='%ls', wszPropertyName='%ls', wstrPropertyValue=0x%p
IDCRL::GetUserExtendedProperty
Software\Microsoft\IdentityCRL\UserExtendedProperties\
CUserExtendedProperty::_SetExtProperty
Read service URI for '%s' of '%s'.
onecoreuap\ds\ext\live\identity\ntservice\lib\svccommon\configuration.cpp
CClientConfigDataCacheManager::GetServiceURI
wstrHost=%ls
onecoreuap\ds\ext\live\identity\ntservice\lib\svccommon\clientconfig.cpp
Software\Microsoft\Passport
Could not open passport registry key. 0x%x
GetOneBoxSSLPort
ProviderData
propertyName=%ls
CSingleIdentity::GetExtProperty
CIdentityTokenBag::GetUserExtPropertyValue
hrRequestStatus = 0x%x
CSingleIdentity::SetRequestStatus
Could not read ext property %ls from prop bag, trying registry. 0x%x
&da=%hs
bver=
flags=0x%llx, wcszAppId=%ls, wcszTarget=%ls, wcszPolicy=%ls, wcszAdditionalParams=%ls
&appid=%s
Software\Microsoft\IdentityCRL
TestHookFlags
onecoreuap\ds\ext\live\identity\lib\utilities\util.cpp
RegQueryDWORD
Unable to open registry key for query: '[%ls]', hr = %x.
PassportSHA1Auth
</SessionKey><SessionKeyType>
</SessionKeyType>
</AuthToken><SessionKey>
CAuthInfo::Pack
</CredProperties><AuthToken>
</AuthInfo>
XMLGetNodeAttribute
CSingleIdentity::SaveExtProperties
<ExpiredTime>
</ExpiredTime>
<CreatedTime>
</CreatedTime>
Failed to get <PassportSHA1Auth> URL from the config file:  (0x%x)
HasPassword
LastName
SkipFRFS
FirstName
DisplayName
Algorithm
/S:Envelope/S:Header/wsse:Security/wssc:DerivedKeyToken[@wsu:Id = "
wssc:Nonce
 xmlns:ds="http://www.w3.org/2000/09/xmldsig#" xmlns:wsse="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd" xmlns:wssc="http://schemas.xmlsoap.org/ws/2005/02/sc" xmlns:wsu="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd" xmlns:wsp="http://schemas.xmlsoap.org/ws/2004/09/policy" xmlns:wst="http://schemas.xmlsoap.org/ws/2005/02/trust" xmlns:saml="urn:oasis:names:tc:SAML:1.0:assertion" xmlns:S="http://www.w3.org/2003/05/soap-envelope" xmlns:tb="http://schemas.microsoft.com/trustbridge/schema#1" xmlns:xenc="http://www.w3.org/2001/04/xmlenc#" xmlns:psf="http://schemas.microsoft.com/Passport/SoapServices/SOAPFault" xmlns:ps="http://schemas.microsoft.com/Passport/SoapServices/PPCRL" xmlns:wsa="http://www.w3.org/2005/08/addressing" xmlns:wlid="http://schemas.microsoft.com/windlowliveid/2007/01/sts"
CStoredIdentity::SaveProperties
TimeStamp
KeyMaterial
CKeyCache::UpdateKeyCache
invalid argument, ignore this key.
/S:Envelope/S:Header/wsse:Security/ds:Signature/ds:SignedInfo/ds:Reference[@URI = "#
"]/ds:DigestValue
onecoreuap\ds\ext\live\identity\lib\utilities\proofofpossessiontokenhelper.cpp
hr = m_pIdentity->CopyAndReplaceCredProperties(CredProp)
Could not read value of psf:credProperty node '%s'. HR=0x%x.
KeyCacheUpdate for purpose='%hs', version='%hs', material is empty=%d
CredentialKey
Creating keybag for purpose: '%hs'.
AssociatedForStrongAuth
DisableRedaction
CDeviceServiceRequest::CopyDAFromDefaultIdentity
</UserPUID><AuthState>
</AuthState><CredProperties>
<AuthInfo><UserName>
</UserName><UserPUID>
keyinfo/securityTokenReference/Reference is not found %x
CSingleIdentity::GetOneTimeCredentialEx
hr = PPCRL_NO_SESSION_KEY
CKeyCache::GetKeyLatestFromMemoryNoLock
CCRLConfig::LoadServiceURIs
CPPCRLRequest::ParseCredProperties
BinarySecurityToken
psf:weburl
wst:RequestedSecurityToken/*
CPPCRLRequest::GetRequestedSecurityToken
http://Passport.NET/purpose
Unable to Query DWORD value for '%ls', hr = %x.
Key '%hs' for '%hs' is updated.
Adding a new key for purpose: '%hs', version='%hs'
DeviceIdStore::GetRegistryPath
Current user is not connected, skipping interrupt notification update.
Persisted
RegGetValue failed. (win32 = 0x%0x)
DeviceIdHelpers::GetSystemHardwareID
hr = pDeviceHelper->ReprovisionDevice(pServiceExecutionContext, g_szStrongAuthAppId, 0, PP_E_DEVICE_EXISTS_WITH_STRONG_CREDS, hIdentityHandle, hNewIdentityHandle)
DoActionCenterNotification
hr = pIdentity->GetCredProperty(PPCRL_CREDPROPERTY_AUTHMEMBERNAME, authMembername)
Associated
Token type node not found in service token info xml. 0x%x.
InternetCrackUrl failed for URL: %ls. (0x%x)
Changed Host Name from %ls to: %ls.
Final Web Auth URL is: %ls.
IsLinkedId
Invalid dataSize %d. HR=0x%x.
onecoreuap\ds\ext\live\identity\lib\serialization\credserializationhelper.cpp
GetRegistryPath failed hr = %x for %s
Current connected username (%ls) does not match request (IdentityName: %ls, AuthMemberName: %ls), skipping interrupt notification update.
sessionKey1SizeBytes < (bpSessionKey.GetLength() - (4 * sizeof(DWORD)))
SetUserPropertiesToSystemStore
hr = pStoredId->SetProperty(propertyName, propertyValue)
hr = client.GetLogonId(logonId)
Token node not found in service token info xml. 0x%x.
hr = pRequest->QueryRequestStatus(hrRequestStatus, hasInterrupt )
OpenThreadToken failed (0x%x).
onecoreuap\ds\ext\Live\identity\Include\transferimp.h
Failed to parse attribute node: hr = 0x%x
hr = pRequest->GetServiceTicketRequestData(requestTargets, requestPolicies)
InterruptNotifications::GetNotificationData
Invalid member name.
UserTileUrl
Could not get Name attribute of psf:credProperty node '%s'. hr=0x%x.
Failed to get attributes: hr = 0x%x
ps:ClientCapabilities
CipherValue
haspassword
ps:ExpirationTime
ps:DisplaySessionID
S:Text
psf:authstate
wsu:Created
ps:BinaryVersion
ServerInfo
wst:RequestType
Password
ds:KeyName
psf:mobileConfigVersion
AuthState
psf:errorstatus
childflags
psf:configVersion
wst:TokenType
wsse:LoginOption
iswinliveuser
KeyMaterial
ps:IsAdmin
wst:BinarySecret
ps:Password
ps:WindowsClientString
psf:serverInfo
ps:PackageSID
ps:UIVersion
wsse:BinarySecurityToken
ps:RequestParams
psf:value
psf:appDataVersion
NewPassword
ps:RequestTime
psf:code
CreatedTime
SessionKeyType
ErrorSubcode
temporarypassword
S:Value
psf:serverVersion
ps:HostingApp
UserPUID
wsse:Password
psf:reqstatus
ExpiredTime
ps:InlineUX
wsa:Address
wsu:Expires
restrictedda
ps:SessionID
ps:State
psf:returnToCaller
SessionKey
psf:text
psf:uiVersion
ps:NewPassword
associatedforstrongauth
KeyUpdateNotification
%hs,%hs,
hr = m_hTokenBag->GetUserExtPropertyNames( arrNames )
hr = SafeCopyMemory(&sessionKey1Type, sizeof(DWORD), pSessionKey, sizeof(DWORD))
SessionKeyManager::UnPackSessionKeys
hr = HRESULT_FROM_WIN32(pRegKey->SetMultiStringValue(PPCRL_REG_ACTIONCENTER_TARGETS, targetMultiSzString))
hr = SafeCopyMemory(&sessionKey1SizeBytes, sizeof(DWORD), pSessionKey, sizeof(DWORD))
failed to decrypt token response:%x
InterruptNotifications::SetCacheState
hr = HRESULT_FROM_WIN32(pRegKey->SetStringValue(PPCRL_REG_ACTIONCENTER_APPID, pAppId))
hr = InitializeProtocol()
CDeviceIdentityBase::InitHandle
bpSessionKey.GetLength() > 4 * sizeof(DWORD)
hr = SafeCopyMemory(&sessionKey2Type, sizeof(DWORD), pSessionKey, sizeof(DWORD))
hr = SafeCopyMemory(&sessionKey2SizeBytes, sizeof(DWORD), pSessionKey, sizeof(DWORD))
Failure - CryptUnprotectData, HRESULT: 0x%08X
CAuthInfo::Unpack failed, hr = 0x%x
ULongAdd hr = 0x%x.
Could not read node. HR=0x%x.
hr = HRESULT_FROM_WIN32(::BCryptGetProperty( spAlgorithm, BCRYPT_HASH_LENGTH, reinterpret_cast<PUCHAR>(&hashBlobSizeBytes), sizeof(hashBlobSizeBytes), &resultSizeBytes, 0))
System store not found.
pDeviceIdentity != nullptr
connected identity doesn't have default cred is unexpected.
CIdentityTokenBag::GetKeySpecific
CKeyCache::GetKeySpecificFromMemory
CPassportClientLibrary::Initialize
CIdentityStore::AddAndGetDeviceIdentity
DeviceIdHelpers::GetCurrentUserSID
GetCurrentUserToken
onecoreuap\ds\ext\live\identity\ntservice\lib\svccommon\deviceidhelpers.cpp
DeviceIdHelpers::IsCallerAccountType
IsLoggedInUserMatchSID
AllocateAndInitializeSid failed with hr = 0x%x
InitializeAcl failed with hr = 0x%x
hr = IsCallerAccountType(SECURITY_LOCAL_SYSTEM_RID, isSystemContext)
AddAccessAllowedAce failed with hr = 0x%x
hr = HRESULT_FROM_WIN32(pRegKey->SetMultiStringValue(PPCRL_REG_ACTIONCENTER_POLICIES, policyMultiSzString))
CKeyCache::BroadcastUpdate
DeviceIdHelpers::HandleRenewDeviceId
hr = PPCRL_E_DEVICEID_SERVERCALLNEEDED
hr = HRESULT_FROM_WIN32(::BCryptCreateHash( spAlgorithm, &spHash, nullptr, 0, static_cast<PUCHAR>(const_cast<BYTE*>(pKey)), static_cast<ULONG>(keySizeBytes), 0))
pSvcWrapper->Revert(&revert)
HandleDeleteNotificationContext
HandleCreateNotificationContext
CPPCRLRequest::CopyResponseString
Global\
onecoreuap\ds\ext\live\identity\ntservice\lib\svccommon\wlidnotifications.cpp
hr = GenRandomNumber(reinterpret_cast<LPBYTE>(&handle), sizeof(handle))
CWLIDNotificationsTable::CreateQueue
hr = token.GetAuthzToken(pszAuthzToken)
AppIdList
DeviceIdStore::LoadAppIdDeviceIdNameMap
wstrDIDKey=%s
TOKEN_BROKER
DeviceIdHelpers::InternalRetrieveDeviceCert
MSN-Messenger-DIDC
hr = g_pPPCRL->GetCertManager()->GetCert(m_pIdentity, m_rgRequests[i].wszServiceTarget, dwTTL, &pCertCtxt, NULL, NULL, NULL, NULL )
ValidDeviceId
PURPOSE_APPROVERREGISTER
hr = StringCchCopyW(rgResponses[i].wszAuthorizationToken, pszAuthzToken.GetLength()+1, pszAuthzToken)
CPPCRLRequest::GetResponse
CIdentityStore::GetNewIdentityHandle can't find a unique handle value. hr=0x%x
%1 %2
StrongCredentialKey
Strong Credential GetUserKeyData Request result: hr = 0x%x, requestCount = %u, resendRequest = %u
CPPCRLRequest::BuildAndSendRequest
CSingleIdentity::AuthDeviceIdentity
CCertManager::GetCert
<ps:AuthInfo xmlns:ps="http://schemas.microsoft.com/Passport/SoapServices/PPCRL" Id="PPAuthInfo">
</ps:BinaryVersion>
<wsse:BinarySecurityToken id="LoginProofToken" ValueType="ps:LoginProofToken">
StrongCredentialKeyDataRequest::BuildRequest
</ps:AuthInfo>
</wsse:BinarySecurityToken>
onecoreuap\ds\ext\live\identity\ntservice\lib\svccommon\strongcredentialkeydatarequest.cpp
onecoreuap\ds\ext\live\identity\lib\msauserextimpl\msauserextimpl.cpp
MsaUserExtImpl::GetDeviceTypeParameterValue
MsaUserExtDefaultImpl::GetDeviceTypeParameterValue
Windows.%d
<ps:DeviceType>
</SignatureValue><KeyInfo>
<Signature xmlns="http://www.w3.org/2000/09/xmldsig#">
<SignatureValue>
<SignedInfo>
</KeyInfo></Signature>
<KeyName>
</KeyName>
</ps:DeviceType>
CDeviceAuthRequest2::SignRequest
<ps:GetKeyDataRequest xmlns:ps="http://schemas.microsoft.com/Passport/SoapServices/PPCRL" Id="GKDR" version="1.0"><ps:KeyPurposes><ps:KeyPurpose>StrongCredentialKey</ps:KeyPurpose></ps:KeyPurposes></ps:GetKeyDataRequest>
<ps:BinaryVersion>
CTransport::SendRequest
this=0x%p, skipRequestThrottling=%d
hr = CAuthInfo::EncryptCredentialsInSystemContext(pExecutionContext, plain.GetBuffer(), plain.GetLength() * sizeof(CHAR), blob)
CAuthInfo::EncryptStringInSystemContext
CPPCRLRequest::SignRequestWithSessionKey
<wssc:DerivedKeyToken wsu:Id="SignKey" Algorithm="%s"><wsse:RequestedTokenReference><wsse:KeyIdentifier ValueType="http://docs.oasis-open.org/wss/2004/XX/oasis-2004XX-wss-saml-token-profile-1.0#SAMLAssertionID"/><wsse:Reference URI="
"/></wsse:RequestedTokenReference><wssc:Nonce>
RequestKey
{"wam_account_on_end":"
CWLIDSvcModule::HandlerEx
onecoreuap\ds\ext\live\identity\ntservice\svc\wlidsvc.cpp
0x%x.
CClientConfigDataCacheManager::CheckConnection
get_IsConnectedToInternet returned S_OK; isConnected = %d
CPPCRLRequest::TriggerNewFilesDownload
Skipping download of new files, existing files are up-to-date.
CClientConfigDataCacheManager::TriggerNewFilesDownload
wstrConfigVersion=%ls
Environment: '%ls'. 
ServiceEnvironment
OnecoreUAP
.devicedns.live.com
production
CClientConfigDataCacheManager::Initialize
{DF60E2DF-88AD-4526-AE21-83D130EF0F68}
InitializePathsAndMutableConfigs
RtlQueryFeatureConfiguration
%d.%d.%d.%d.%d %ls
IsTest
SOFTWARE\Policies\Microsoft\SQMClient
MSAWindows/%hs (OS %ls; IDK %ls %ls; Cfg %ls; Test %d)
User-Agent: %hs
CClientConfigDataCacheManager::InitializeDownloadMgr
Failed RegGetValueW SQMClient IsTest, Error = %d
Software\Microsoft\IdentityCRL\DeviceIdentities
CIdcrlDownloadManager::Initialize
Existing Config Version: %ls
AcquireTokens
Failed GetVersionExW, GetLastError = %d
Failed GetModuleFileNameW, GetLastError = %d
LoadConfiguration
Client config directory is '%ls'.
\wlidsvcconfig.xml
Microsoft\IdentityCRL
Client config file is '%ls'.
NtQueryWnfStateData
hr = InitializePathsAndMutableConfigs()
hr = InitializeDownloadMgr()
RtlDllShutdownInProgress
RtlRegisterFeatureConfigurationChangeNotification
MsaWnfNotifications::GetWNFStateNameString
WNF_LIC_DEVICE_LICENSE_MISSING
WLIDAcquireTokensWithNGC
HandleAcquireTokensWithNGC
CClientConfigDataCacheManager::LoadClockSkew
IdentityCRL
CClientConfigDataCacheManager::UpdateRegistryWithLoginUrl
onecoreuap\ds\ext\live\identity\lib\stateseparationredirection\stateseparationredirection.cpp
Could not update LoginUrl, GetPassportSTSHost failed.
RpcIdleTimeoutSeconds
Could not get LoadConfigData mutex. hr = 0x%x. This thread is abandoning the LoadConfigData.
szFileName=%ls
Time elapsed to start the service: %I64u.%I64u sec.
Global\{c245290c-487c-4f81-9aba-7eb0dac882a2}
D:P(A;;0x1F0003;;;SY)(A;;0x00100000;;;AU)
Global\{44ea083b-899c-4440-8338-2469fd4681cf}
Failure - hr, HRESULT: 0x%08X
CPassportClientLibrary::Uninitialize
Uninitialized configuration manager... 0x%x
Uninitialized external memory manager... 0x%x
Uninitialized cryptographic provider... 0x%x
Uninitialized identity store... 0x%x
Uninitialized cert manager... 0x%x
Uninitialized random key... 0x%x
WLIDTimerQueue
Time elapsed to stop the service: %I64u.%I64u sec.
CClientConfigDataCacheManager::Uninitialize
RandomFunctionsInitialize
Microsoft Base Cryptographic Provider v1.0
InitializeGlobals
hr = RandomFunctionsInitialize()
CWLIDTimerQueue::Initialize
SvcApi
Local\Identity CRL v2 File Access
IDCRL
Local\Identity CRL v2 File Download
CSessionAppSettingsMap::GetRPCClientAppKey
onecoreuap\ds\ext\live\identity\ntservice\lib\svccommon\appconfig.cpp
HandleGetConfigDWORDValue
WLIDGetConfigDWORDValue
CSessionAppSettingsMap::GetAppSettings
./cfg:DIDDisabled
./cfg:DevicePWDLen
./cfg:Protocol
./cfg:MinCertValidTime
CCRLConfig::ParseDIDCOMMetaData
./cfg:SITEID
./cfg:SYSTEM
./cfg:PREFIX
CCRLConfig::ParseDIDCOMMetaDataHelper
./cfg:DATA
./cfg:DeviceMNLen
CCRLConfig::ParseDIDConfigLong
CCRLConfig::ParseDIDConfigBoolean
./cfg:DIDCertWithAuth
./cfg:DIDDARefresh
./cfg:AssocPDIDToLDID
./cfg:DIDWithAuth
./cfg:DIDSignCheck
%s is %s
LsaGetLogonSessionData failed 0x%x.
hr = client.GetLogonId(luid)
ParseDIDConfigLong for %s failed with %x
DisableWinHttpCache
HTTPRequest::CancelPendingRequest
WinHttp session not cached because of registry setting.
WinHttpOpen failed 0x%x.
CClientConfigDataCacheManager::ReadConfigData
CP="CAO DSP COR ADMa DEV CONo TELo CUR PSA PSD TAI IVDo OUR SAMi BUS DEM NAV STA UNI COM INT PHY ONL FIN PUR LOCi CNT"
CStoredIdentity::ProcessDefaultCertInStore
CStoredIdentity::SaveIdentity
WLIDGetUserPropertiesFromSystemStore
CStoredIdentityTransaction::Start
onecoreuap\ds\ext\live\identity\ntservice\lib\svccommon\Include\systemstore.h
IsDefault
CStoredIdentity::HasAnyKeyword
hr = client.ImpersonateClient()
CStoredIdentityTransaction::Commit
HandleGetUserPropertiesFromSystemStore
hr = Transaction.Start()
ppv != nullptr
CReadStreamOnMemory::QueryInterface
onecoreuap\ds\ext\live\identity\lib\utilities\xmlutilities.cpp
DeviceIdHelpers::VerifyInitialization
GetDeviceIdInternal
DeviceIdHelpers::IsAdminDisabled
Open for %s failed with hr=%x
RetrieveDeviceID failed with hr = 0x%x
DeviceIdHelpers::IsDeviceIdRemoteDisabled
DIDDisable
QueryStringValue for %s with hr=%x
Non critical error SetExtendedProperty for MUID failed with hrLocal = 0x%x
SetExtendedPropertyInternal
wszPropertyName='%ls', wszPropertyValue=%ls
Software\Microsoft\IdentityCRL\ExtendedProperties
Unable to open current user registry, hr = %x.
g_pPPCRL != NULL
CReadStreamOnMemory::Read
(pDest != nullptr) && (m_szMem != nullptr)
IsCallerInAdminGroup
hr = E_UNEXPECTED
CSingleIdentity - Serializing %Iu request params from identity.
CSingleIdentity - Serializing %Iu cookies from identity.
SystemStoreLite::GetCurrentUserSidString
LocalAlloc failed. (win32 = 0x%0x)
OpenThreadToken failed. (win32 = 0x%0x)
Processing psf:extProperty node '%ls'.
CSingleIdentity::SetExtProperty
Could not get IgnoreRememberMe attribute of psf:extProperty node '%ls'. hr=0x%x.
CPPCRLRequest::ParseExtProperties
Could not get Attributes attribute of psf:extProperty node '%ls'. hr=0x%x.
CIdentityTokenBag::SetUserExtPropertyValue
CUserExtendedProperty::SetExtPropertyAndCookie
wszUserName='%ls', wszPropertyName='%ls', wszPropertyValue=%ls wszDomains=%ls, wszExpiry=%ls, wszAttributes=%ls, wszIgnoreRememberMe=%ls
Could not get Domains attribute of psf:extProperty node '%ls'. hr=0x%x.
%s%s%s%s%s%s
%s%c%s%c%s%c%s%c%s%c%s
Could not get Expiry attribute of psf:extProperty node '%ls'. hr=0x%x.
Could not read value of psf:extProperty node '%ls'. HR=0x%x.
Could not read next psf:extProperty node from response. hr=0x%x.
CWLIDTimerQueue::TimerDriver
onecoreuap\ds\ext\Live\identity\Include\TimerQueue.h
m_hTimer=%p, m_hTimerQueue=%p, m_Param=%p, m_pfCallback=%p
Network notification event signaled
onecoreuap\ds\ext\live\identity\ntservice\lib\svccommon\liveconnector.cpp
SubscribeToNetworkNotification
NetworkChangeNotificationWorker
CWLIDTimerQueue::QueueWorkItem
CWLIDTimerQueue::AddTimerData
MsaWnfNotifications::RegisterWnfEvent
CreateProcessUserTask
CreateProcessUserTask. SessionId %d, LogonId %d, %d. (0x%x)
ProcessUserLogon
DeviceIdHelpers::IsPhysicalDIDEnabled
PhysicalDIDEnabled
MigrateStoredPasswords
onecoreuap\ds\ext\live\identity\ntservice\lib\svccommon\migratepasswords.cpp
MigrationDone
SOFTWARE\Microsoft\IdentityCRL
Service started
The service will auto stop if no requests received for some period of time.
DeviceIdHelpers::PersistGlobalIdForLicensing
onecoreuap\ds\ext\live\identity\ntservice\lib\svccommon\setregistrypermission.cpp
Already done, skip.
RestrictMsaRootRegistryKeyAccess
.default\Software\Microsoft\IdentityCRL
Error - 0x%lx GetTokenInformation.
AMsaWnfNotifications::RegisterForWnfEvents
AInitializeNetworkEventListner
Version %d.%d of the Windows Socket API has been initialized.
SignInAssociatedUser. (0x%x)
ProcessUserLogoff
WSAStartup() failed with error code: %d.
pParam != NULL
DeviceIdHelpers::GetDeviceIDAsyncOnLogon
DeviceIdHelpers::UpdateDeviceTpmInfo
DeviceIdHelpers::IsDeviceTPMEnabled
ProcessExistingLogons
WNF LastTimeStamp for %ls is %d
MsaWnfNotifications::GetLastTimeStamp
.Default\Software\Microsoft\IdentityCRL\WnfLastTimeStamps
CPPCRLBaseRequest::SetClockSkew
onecoreuap\ds\ext\live\identity\ntservice\lib\svccommon\Include\clientconfig.h
wstrServerTime: %s
Set clock skew to '%d' seconds.
Unable to create registry key '%ls', hr = %x.
CClientConfigDataCacheManager::SaveClockSkew
NgcAttestationKeyType
%ls\%ls
ThrottleCount
Software\Microsoft\IdentityCRL\ThrottleCache
ThrottleManager::BuildThrottleKey
onecoreuap\ds\ext\live\identity\ntservice\lib\svccommon\throttle.cpp
%ls_%ls
ThrottleStartedTime
ThrottleManager did NOT hit limit. Application=%ls, hitCount=%d, hitLimit=%d
hr = g_pPPCRL->GetThrottleManager()->CheckCurrentLimit(this, EPPCRLRequestTypeUserIdKeyRegistration, throttleScenario, false)
CSingleIdentity::UpdateUserIdKeyAttestation
CIdentityStore::ReleaseTokenBag
Removing token bag for user '%ls' 0x%p - no longer in use.
Negative cache cleared - recent successful request, app key: %ls
Internal Error: 0x%x, Collapsed Internal Error: 0x%x, External Error: 0x%x, isUserActionable: %d
ErrorHandlingUtilities::MapInternalErrorToExternal
NegativeCacheManager::LoadNegativeCacheData
NegativeCacheManager::ConstructNegativeCacheAppKey
NegativeCacheManager::AddNegativeCacheData
ErrorHandlingUtilities::CollapseError
internal error: 0x%X
WS-SecureConversation
SHA256
ct=%I64u&hashalg=%s&%s&nonce=%s
LiteCryptUtilities::GetCurrentTimeInSeconds
hr = UrlEscapeStringA(spEncodedRandom, &spEscapedRandom)
hr = sessionKeyManager.SignWithSessionKey( &sessionKeyExecutionContext, hLogonUserToken, SessionKey(pSessionKey, sessionKeyLength, static_cast<SessionKeyTypes::Type>(sessionKeyType)), CBytePtr(randomBytes, ARRAYSIZE(randomBytes), false), CStringA(LiteCryptUtilities::SeedLabel::SecureConversation), PPCRL_NGC_DERIVED_KEY_LENGTH_BYTES, CStringA(spUnsignedEncapsulatedPayload), encodedHash, derivedKeyAlgorithm, needsDeviceDARefresh)
LiteCryptUtilities::HmacEncapsulateString
PassportFreeMemoryInternal
pMemoryToFree=0x%p
CExternalMemoryManager: Tried to free 0x%p, which is not valid PPCRL memory.
CExternalMemoryManager: Freeing memory at 0x%p.
CPPCRLBaseRequest::ParseNumericHResult
HRESULT in response: %ls
HRESULT in response: %s is wrong
hr = PPCRL_E_INVALID_AUTH_SERVICE_RESPONSE
DeviceIdStore::GetMembernameFromPersistantStore
wstrDeviceIDKey=%s,wstrUsername=%s
onecoreuap\ds\ext\live\identity\ntservice\lib\svccommon\deviceidentity.cpp
CDeviceIdentityBase::GetDeviceInfo
DeviceIdStore::GetDeviceInfoFromPersistantStore
wstrDeviceIDKey=%ls,wszUserName=%ls
//%s[@%s='%s']/%s
wstrDeviceIDKey=%s,wstrDeviceIDName=%s,fAllowEmtyDomLoad=%d
LicenseKeySequence
LicenseKeyVersion
LicenseInstallError
getAttribute failed with hr = %x
::selectSingleNode failed with hr = %x
selectSingleNode for %ls failed with hr = %x
CPPCRLRequest::GetServiceTicketRequestData
Local\SM0:%lu:%lu:%hs
NtQuerySystemInformation
ntdll.dll
CXmlHMACSHASig2::GetHMACDigest
hr = g_algProvCache.GetAlgorithmProv( m_wstrAlgId, BCRYPT_ALG_HANDLE_HMAC_FLAG, hAlgProv)
GetXMLNodeText
TpmSessionKeyFunctions::DecryptMessage
hr = SafeCopyMemory( plainText.GetBufferSetLength(decryptedBlobSizeBytes), decryptedBlobSizeBytes, spDecryptedBlob, decryptedBlobSizeBytes)
onecoreuap\ds\ext\live\identity\lib\sessionkeymanager\tpmsessionkeyfunctions.cpp
AddCertificateAuthority
CertOpenStore failed with hr=0x%x
%s\%s\%s
WebCookieManager::PublishCookie
Software\Microsoft\AuthCookies\Live
RegOpenCurrentUser failed, hr = 0x%x
WebCookieManager::SetCookie
hr = SetCookieValue<LPCTSTR>(regCookieKey, PPCRL_REG_COOKIES_DATA, cookie.CookieData, cookie.CookieData.IsEmpty(), &(ICRegKeyWrapper::SetStringValue))
hr = SetCookieValue<LPCTSTR>(regCookieKey, PPCRL_REG_COOKIES_P3P, cookie.P3PHeader, cookie.P3PHeader.IsEmpty(), &(ICRegKeyWrapper::SetStringValue))
hr = SetCookieValue<LPCTSTR>(regCookieKey, PPCRL_REG_COOKIES_ID, cookie.Id, cookie.Id.IsEmpty(), &(ICRegKeyWrapper::SetStringValue))
CIdentityTokenBag::SetCredPropertyValue
hr = pIdentity->GetCredProperty(PPCRL_CREDPROPERTY_AUTHMEMBERNAME, renameAccountData.newEmailId)
onecoreuap\ds\ext\live\identity\ntservice\lib\svccommon\renamemembername.cpp
RenameLiveIdIfRequired
onecoreuap\ds\ext\live\identity\lib\utilitieslite\registryhelper.cpp
CPassportClientLibrary::GetServiceURIFromConfig
%ls URL: '%ls'
onecoreuap\ds\ext\live\identity\ntservice\lib\svccommon\passportclientlibrary.cpp
MSXML2.DOMDocument.6.0
UserId
IdentityStorage::DeleteTicketsForUser
Software\Microsoft\IdentityCRL\Immersive\%s\Token\
onecoreuap\ds\ext\live\identity\lib\immersiveidentitystorage\identitystorage.cpp
IdentityStorage::GetEnvironmentSpecificRegistryKey
RegOpenKeyEx failed with hr=%x
Reading current environment failed, using production as default
InterruptNotifications::DoNotificationUpdate
hr = pSvcWrapper->Impersonate(&client)
InterruptNotifications::SetActionCenterState
Setting Action Center state to new value: %d.
viV4u
{CA75DFE9-25B1-4E56-B4DD-C81364EBF8F8}
cfg:StrongAuthPolicy
hr = SetCacheState(pParams->pServiceExecutionContext, pParams->InterruptCode, pParams->IsRootLevelInterrupt, accountSettingsUrl, targets, policies, applicationId )
InterruptNotifications::GetStateForServerResult
Keywords
onecoreuap\ds\ext\live\identity\ntservice\lib\svccommon\deviceidhelpers2.cpp
Microsoft Platform Crypto Provider
TpmBaseServicesFunctions::GetWindowsAIKLocation
PCP_ALTERNATE_KEY_STORAGE_LOCATION
\Microsoft\Crypto\PCPKSP\WindowsAIK
Windows AIK
hr = HRESULT_FROM_NT(NCryptSetProperty( spProviderHandle, NCRYPT_PCP_ALTERNATE_KEY_STORAGE_LOCATION_PROPERTY, reinterpret_cast<PBYTE>(aikLocation.GetBuffer()), aikLocation.GetLength() * sizeof(WCHAR), NCRYPT_FLAGS))
TpmBaseServicesFunctions::GetWindowsAIK
hr = GetProvider(MS_PLATFORM_KEY_STORAGE_PROVIDER, &spProviderHandle)
CWLIDCCHelper::SetClockReliabilityData
onecoreuap\ds\ext\live\identity\lib\utilitieslite\wlidcchelper.cpp
Software\Microsoft\IdentityCRL\ClockData
ClockTimeSeconds
CWLIDCCHelper::SetClockReliabilityDataHelper
TickCount
WriteBufferToRegistry wrote tick count = %I64d
WriteBufferToRegistry wrote current time = %I64d
WriteBufferToRegistry failed to write current time. (0x%0x)
MsaUserExtImpl::CheckIfAppTrusted
MsaUserExtDefaultImpl::CheckIfAppTrusted
{AEEBBB7D-51C6-4871-9258-D8E5904DD66B}
{D6D5A677-0872-4AB0-9442-BB792FCE85C5}
{9F46D608-CC47-4686-8F51-2D39C2D57323}
{59760330-7637-4417-8d86-1273942d5cd7}
{3E28FFA3-C879-4A18-A9A4-35875C40229A}
{922df99b-f4c3-4b57-b70a-aa696443101a}
{76FDA24A-FCF8-4EEF-A7B3-7C99C1BD3E59}
{283F80E3-1849-4143-A8A5-48062C18F018}
{56B26D4E-03F5-11E1-B7CD-92914824019B}
{378F5C57-F4C5-4CF6-8794-1EE28D216ED9}
{DC15FE03-EF48-4962-A00C-DD0EC17FB09A}
{FB0DB4BF-F4B9-4253-85E3-DBFBB513F2E3}
{CC553C39-4B1C-43DB-94A0-3B78F751ACEF}
{7D629E2E-CC4C-4CC4-95B7-25C48B11C53D}
{21709F64-3CA2-5DBB-B7EF-A0DF9ACE9F31}
{ABB475D0-3084-47D4-A86F-CF40255A8E3A}
{A6CCBA24-AF6C-49B5-8EB6-8836FB98A8D1}
{2b379600-b42b-4fe9-a59c-a312fb934935}
{de7a018e-e34d-46b0-8313-88f78f5e1bfe}
{E8B2105F-3392-40C5-89FD-B6834891DA21}
{D80D1001-5B38-49E9-9D34-EC9B84779189}
{0CB4A94A-6E8C-477B-88C8-A3799FC97414}
{28520974-CE92-4F36-A219-3F255AF7E61E}
{12E984BD-5803-4D78-9EFB-BED7B9212C26}
{B74AF551-07E0-4F25-9EB4-1B00144C8D3F}
{29F3C4CF-2A74-4162-8D2A-A817E622F888}
WLIDAcquireTokens
HandleAcquireTokens
requestFlags value: 0x%llx
CSingleIdentity::SetCancellableRequestTransport
@CSingleIdentity::HasSuppliedCredential
@MsaUserExtImpl::GetInlineUxParameterValue
TokenBroker
MsaUserExtDefaultImpl::GetInlineUxParameterValue
hr = spCopy.Allocate(bytesNeeded)
WabAuthFlowDisabled
CAutoImpersonateClient::GetCallerProcessID
Aonecoreuap\ds\ext\live\identity\ntservice\lib\svccommon\Include\rst.h
CPPCRLBaseRequest::GetPassportRequestPort
HWID_HardwareUpdate_OutOfTolerance
HWID_HardwareUpdate
HWID_HardwareBinding
HWID_TpmBinding
NGC_TpmBinding
ThrottleManager:SetConfiguration flags=%x, maxRequests=%d, totalIntervalSeconds=%d
ShouldCreateNgcKey
No usable NGC containers found for SID %ls.
login.live.com
PCP_TPM_IFX_RSA_KEYGEN_VULNERABILITY
wstrUserName=%ls
onecoreuap\ds\ext\live\identity\ntservice\lib\svccommon\cert.cpp
CCertManager::PersistCert
WLIDEnumIdentities
RpcServerInterfaceGroupDeactivate returned 0x%x
IdleCallback isGroupIdle=0x%x
CSystemStore::IsPublishing returned 0x%x, isPublishing=0x%x
PublishedServicesCount
Unable to write or create registry key '%s', hr = %x.
EnumIdentities failed with hr=0x%x
ClientKeyState %d. ServerKeyState %d
CPPCRLRequest::ParseBrowserCookies
ErrorHandlingUtilities::IsErrorUserActionable
onecoreuap\ds\ext\Live\identity\Lib\UtilitiesLite\ErrorHandlingUtilities.h
Error: 0x%x, IsErrorUserActionable: %d
TriggerNotificationUpdate failed with hr = 0x%x
requestStatus=0x%x,interruptFlags=0x%x,appid='%ls',Target='%ls',Policy='%ls',MemberName='%ls'
InterruptNotifications::TriggerNotificationUpdate
<wsse:Password>
<wsse:Username>
CClientConfigDataCacheManager::AddCertificateToIDCRLStoreNoLock
Base 64 decode failed with hr=0x%x
TpmSessionKeyFunctions::VerifySignature
CSingleIdentity - Deserialized %Iu response params.
CSingleIdentity - Deserialized %Iu identity cookies.
CTokenInfo::GetServiceName
Invalid credential target name.
CServiceRequest::ParseResponse
CDeviceServiceRequest::ParseResponse
hr = CPPCRLRequest::ParseResponse(pResponse, responseSizeCharacters, errorCategory)
CPPCRLRequest::ParseResponse
CAuthRequest::ParseResponse
CPPCRLRequest::ExtractSessionKey
hr = pXmlRSTResponse->selectSingleNode(k_bstrRSTRBinarySecret, &pSessionSecretNode)
pXmlRSTResponse != nullptr
CDeviceServiceRequest::ValidateAndCopyRequests
onecoreuap\ds\ext\live\identity\ntservice\lib\svccommon\rstdevice.cpp
CIdentityTokenBag::GetCachedPassword
psf:pp/psf:inlineendauthurl
wst:SecurityTokenResponseData
BoundTime
psf:browserCookie
ServiceTokenInfo/SessionKeyType
/psf:pp
psf:credProperty
psf:inlineendauthurl
CertInfo/Cert
ServiceTokenInfo/Ticket
psf:UserNGCFlags
TpmKeyStateClient
/S:Envelope/S:Header/psf:EncryptedPP/xenc:EncryptedData
/S:Envelope/S:Body/xenc:EncryptedData
IgnoreRememberMe
psf:browserCookies
wst:Lifetime/wsu:Created
psf:pp/psf:reqstatus
AuthInfo/SessionKey
targetname
psf:UserSessionKey
/S:Envelope/S:Body//wst:RequestSecurityTokenResponse
/S:Envelope/S:Body/S:Fault/S:Code/S:Detail/wlid:flowurl
wsp:AppliesTo/wsa:EndpointReference/wsa:ServiceName
psf:PUID
psf:response
AuthInfo/UserPUID
/S:Envelope/S:Body
psf:extProperty
psf:serverInfo/@ServerTime
Domains
psf:extProperties
wst:RequestedAttachedReference/wsse:SecurityTokenReference/wsse:KeyIdentifier
AuthInfo/AuthToken
S:Detail/psf:error/psf:internalerror/psf:text
ps:KeyPurposes
LastUpdatedTime
psf:signChallenge
*/Error/@Code
AuthInfo/ExpiredTime
psf:authreq
CertInfo/KeyGenFlags
psf:pp/psf:weburl
psf:RefreshDeviceLicense
psf:pp/psf:flowurl
ps:Property
/OTCRequestResponse/Error
AuthInfo/CredProperties
DAInvalidationTime
/S:Envelope/S:Body/xenc:EncryptedData/ds:KeyInfo/wsse:SecurityTokenReference/wsse:Reference
psf:serverInfo/@BuildVersion
wst:Lifetime/wsu:Expires
psf:inlineauthurl
/S:Envelope/S:Header/psf:EncryptedPP/xenc:EncryptedData/xenc:CipherData/xenc:CipherValue
AuthInfo/AuthState
/S:Envelope/S:Body/S:Fault/S:Code/S:Subcode/S:Value
AuthInfo/UserName
AuthInfo/CreatedTime
psf:pp/psf:authreq
/S:Envelope/S:Header/wsse:Security/wsu:Timestamp
psf:credProperties
ServiceTokenInfo/ExpiredTime
CertInfo/ExpiredTime
TpmKeyStateServer
HardwareInfo
keyword
psf:DeviceTpmKeyState
version
/OTCRequestResponse/State
Certificate
/S:Envelope/S:Header/psf:pp
username
AuthInfo/SessionKeyType
/S:Envelope/S:Header/wsse:Security/ds:Signature/ds:KeyInfo/wsse:SecurityTokenReference/wsse:Reference
ps:KeyData
psf:pp/psf:inlineauthurl
wst:RequestedProofToken/xenc:EncryptedKey/xenc:CipherData/xenc:CipherValue
Attributes
/S:Envelope/S:Header/psf:EncryptedPP/xenc:EncryptedData/ds:KeyInfo/wsse:SecurityTokenReference/wsse:Reference
/S:Envelope/S:Body/xenc:EncryptedData/xenc:CipherData/xenc:CipherValue
psf:flowurl
wst:RequestedProofToken/wst:BinarySecret
wsp:AppliesTo/wsa:EndpointReference/wsa:Address
*/ErrorSubcode
psf:cookies
CertInfo/Keypair
wst:RequestedAttachedReference/wsse:SecurityTokenReference/wsse:Reference
S:Detail/psf:error/psf:internalerror/psf:code
*/*/*/ErrorSubcode
ps:KeyPurpose
/S:Envelope/S:Header/wsse:Security/ds:Signature/ds:SignedInfo
ServiceTokenInfo/Type
/OTCRequestResponse
//wst:RequestSecurityTokenResponse
*/*/Error/@Code
/S:Envelope/S:Fault/psf:redirectUrl
/S:Envelope/S:Body/S:Fault
/S:Envelope/S:Header/wsse:Security/ds:Signature/ds:SignatureValue
psf:HWPUIDFlipped
Expiry
ServiceTokenInfo/SessionKey
GetFileVersion
CPPCRLRequest::ShouldResendRequest
onecoreuap\ds\ext\live\identity\ntservice\lib\svccommon\negativecachemanager.cpp
NegativeCacheManager::SetConfiguration flags=%x, maxRequests=%d, totalIntervalSeconds=%d, intervalMultiplierForPersistentFailures=%d
NegativeCacheIntervalSeconds
NegativeCacheIntervalMultiplierForPersistentFailures
NegativeCacheFlags
NegativeCacheMaxRequests
CSingleIdentity - Setting request param '%ls' to '%ls'.
CExternalMemoryManager: Allocated %Iu bytes at 0x%p.
onecoreuap\ds\ext\live\identity\lib\utilities\memorymanager.cpp
CPPCRLRequest::ParseServerInternalError
hr = pXmlResponse->selectSingleNode(k_bstrSoapFault, &pXmlInternalErr)
hrServerInternal = 0x%x
CSingleIdentity::SetServerInternalErrorCode
CIdentityTokenBag::GetUserExtPropertyNames
MsaUserExtDefaultImpl::CallerIsLoggedOnUser
pSessionData->UserFlags = 0x%x.
CSingleIdentity::HandleUserNgcKeyUpdate
NgcKeyAttestationEnabled
CClientConfigDataCacheManager::IsNgcKeyAttestationEnabled
CDeviceIdentityBase::GetDeviceIdentity
PrependStringToMultiSzString
hr = GetLogonId(logonId)
CAutoImpersonateClient::IsImpersonatingSystem
CPPCRLRequest::ParseFaultUrl
TpmBaseServicesFunctions::GetProvider
onecoreuap\ds\ext\live\identity\ntservice\lib\svccommon\tpmbaseservicesfunctions.cpp
CPPCRLRequest::BuildRequestEx
hr = pIdentity->GetCredBag()->StoreCredential(arrAuthData[i].m_wstrCredType, arrAuthData[i].m_wstrCredValue)
HandleSetAuthData
ParseAuthData
hr = CredSerializationHelper::DecryptBufferInPlaceForSameLogon(execContextLite.GetWinApiFunctions(), pBuffer, &cbBuffer)
CryptUnprotectMemory failed. HR=0x%x.
CredSerializationHelper::DecryptBufferInPlaceForSameLogon
DeserializeObject() completed with hr = 0x%x.
ppCertContext != NULL
CDeviceIdentityBase::GetDeviceCert
<ServiceTokenInfo>
</ServiceTokenInfo>
<SessionKey>
<Ticket>
Token info: %ls 
</Type>
</SessionKey>
</Ticket>
<Type>
CServiceTokenInfo::Pack
<SessionKeyType>
CTransport::AddCustomHTTPHeaders
Content-Type: application/soap+xml
onecoreuap\ds\ext\live\identity\ntservice\lib\svccommon\Include\transport.h
CleanupCertificateAuthority
CIdentityTokenBag::CacheAndEncryptPersistedPassword
kernelbase.dll
LogStagedFeatureUsage
MsaWnfNotifications::UnregisterForWnfEvents
onecoreuap\ds\ext\live\identity\ntservice\lib\svccommon\msawnfnotifications.cpp
CIdentityTokenBag::AddStoredToken
DeviceIdHelpers::HandleTpmKeyStateChange
hr = GetSystemHardwareID(pServiceExecutionContext, IDCRL_DEVICE_ID_FROMCACHE, hIdentity)
hIdentity != nullptr
fExpiredStore: %d
CClientConfigDataCacheManager::DeleteAllCertificatesFromCertStoreNoLock
hCertStore != NULL
MsaWnfNotifications::MsaWnfEventHandler
StopRpcServer
RpcServerInterfaceGroupClose returned 0x%x
ThrottleManager::SaveThrottleDataState keyName: %ls
ThrottleManager::SaveThrottleDataState failure on Create. lRes: 0x%x
ThrottleManager::SaveThrottleDataState failure on SetDWORDValue. lRes: 0x%x
WindowsLive:target=virtualapp/
CAuthInfo::GetVirtualAppTargetName
LsaLookupUserAccountType returned accountType: %d which mapped to CONNECT_UX_SCENARIO: %d
onecoreuap\ds\ext\live\identity\lib\platformextension\urlcontextinfo.cpp
UrlContextInfo::GetInlineUxScenarioId
UrlContextInfo::IsUserAADJoined
ThrottleManager:SetConfiguration throttlekey=%ls, maxRequests=%d
SetExtendedError: dwErrorCategory=%d, dwErrorCode=%d, dwPort=%d
strErrorRequest=
strErrorResponse=
CPPCRLRequest::QueryRequestStatus
HandleGetKeyWithVersionInternal
KeyVersion: %ls
WLIDGetKeyLatest
HandleGetKeyLatestInternal
CServiceRequest::GetEncryptedSessionKey
SystemStoreLite::IsUserDomainConnected
DomainConnected
Software\Microsoft\IdentityCRL\KeyCache
cbLicenseBlobSize != 0
onecoreuap\ds\ext\live\identity\ntservice\lib\svccommon\devicelicensefunctions.cpp
DeviceLicenseFunctions::InstallDeviceLicense
Microsoft Enhanced Cryptographic Provider v1.0
Microsoft Enhanced RSA and AES Cryptographic Provider
Trying Crypt provider: %S, provider type: %d
Initializing random key.
Unable to acquire cryptographic provider (0x%x).
DIDLogical
WilStaging_02
AppendInlineUrlContextDataInternal
inlineUrlData: %ls
hrAuthRequired = 0x%x
CSingleIdentity::SetAuthenticationRequired
DeviceIdHelpers::RenewDeviceId
wstrAppId=%ls,flags=%llx,dwDeviceType=%d
HandleUpdateToken
{"typ":"JWT","alg":"RS256","kid":"
","cnf":{"jwk":{"kty":"RSA","n":"
CPPCRLRequest::AppendLoginKeyTokenToRequestXml
{"aud":"
http://%s
","alg":"RSA-OAEP","use":"enc"}}
","e":"
hr = Base64UrlEncodeWithNoPadding(jwtHeader, encodedJwsHeader)
CDeviceAuthRequest2::GetSystemDeviceIdentifier
hr = pDeviceHelperWrapper->GetSystemHardwareID(pServiceExecutionContext, flags, hSystemDeviceId)
CDeviceAuthRequest2::GetRequestAuthToken
<wsse:UsernameToken wsu:Id="devicesoftware"><wsse:Username>
</wsse:Username></wsse:UsernameToken>
hr = GetSystemDeviceIdentifier(&serviceExecutionContext, systemDeviceIdentifier)
DeviceLicenseFunctions::SignHashWithDeviceKey
=L9o<
ACCRLConfig::SavePasswordPolicyToRegistry
minPasswordLength=%d,minPasswordCharacterGroups=%d
hr = HRESULT_FROM_WIN32(GetLastError())
http://www.w3.org/2001/04/xmldsig-more#hmac-sha256
onecoreuap\ds\ext\live\identity\lib\sessionkeymanager\obfuscatedsessionkeyfunctions.cpp
ObfuscatedSessionKeyFunctions::GetDerivedKey
WLIDGetCachedTokens
HandleGetCachedTokens
CredmanUtility::CredDeleteW
pxmlRSTRNode != nullptr
CPPCRLRequest::ParseFaultInRSTR
Sleeping on _handlerTaskCount=%d
UninitializeNetworkEventListner
SetNewVersionAndDownloadAsync
CWLIDTimerQueue::Shutdown
CWinhttpSessions::SendRequestAndReceiveResponse
WinHttpSendRequest failed 0x%x.
Clearing request params collection.
SymmetricSessionKeyFunctions::VerifySignature
onecoreuap\ds\ext\live\identity\lib\sessionkeymanager\symmetricsessionkeyfunctions.cpp
NegativeCacheManager::IsNegativeCacheForSubScenarioEnabled
Negative cache for subScenario:%d is disabled.
DeviceIdHelpers::AuthDevice
!deviceInfo.IsEmpty()
CUpdateDeviceLicenseRequest::SignRequest
//*[text()[normalize-space()!=""] and not(*)]
 xmlns:S="http://www.w3.org/2003/05/soap-envelope" xmlns:ps="http://schemas.microsoft.com/Passport/SoapServices/PPCRL" xmlns:psf="http://schemas.microsoft.com/Passport/SoapServices/SOAPFault" xmlns:wsa="http://www.w3.org/2005/08/addressing" xmlns:wst="http://schemas.xmlsoap.org/ws/2005/02/trust" xmlns:wsu="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd" xmlns:wsse="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd" xmlns:xenc="http://www.w3.org/2001/04/xmlenc#"
InstalledConfigVersion
Software\Microsoft\IdentityCRL\Environment
DownloadAndReloadConfig
CIdentityTokenBag::GetKeyLatest
HandleGetProofOfPossessionTokens
CIdentityTokenBag::SetTokenCachedFlag
UpdateNegativeCacheForScenario, scenarioId = %d, subScenarioId = %d
LiteCryptUtilities::GetPublicKeyComponents
http://www.w3.org/2001/04/xmldsig-more#ecdsa-sha256
CClientConfigDataCacheManager::IsDeviceKeyBindingEnabled
WLIDGetProofOfPossessionTokens
RandomWait
CredSerializationHelper::FreeCredentialBagContent
DeviceIdStore::IsXmlLiteSupported
onecoreuap\ds\ext\live\identity\ntservice\lib\svccommon\networkaddresses.cpp
CNetworkAddresses::Initialize
GetDisplayFileVersion
TranslateScenarioIDByPolicy
CNetworkAddresses::Shutdown
DisableServiceByPolicy
RPC error=%d.
wlidsvc
GetVersionEx: failed with hr=0x%x
WLIDSTS_WCF
http://www.w3.org/2001/04/xmlenc#sha256
http://www.w3.org/2001/04/xmldsig-more#rsa-sha256
WilError_03
WLIDGetKeyWithVersion
bad array new length
AutoPilot.dll
OLEAUT32.dll
RPCRT4.dll
api-ms-win-security-sddl-l1-1-0.dll
api-ms-win-service-core-l1-1-0.dll
CRYPT32.dll
api-ms-win-security-lsalookup-l2-1-0.dll
USERENV.dll
SspiCli.dll
bcrypt.dll
api-ms-win-security-credentials-l1-1-0.dll
api-ms-win-service-management-l1-1-0.dll
api-ms-win-service-management-l2-1-0.dll
ncrypt.dll
WINHTTP.dll
WS2_32.dll
IPHLPAPI.DLL
samcli.dll
netutils.dll
CRYPTSP.dll
api-ms-win-security-lsalookup-l1-1-2.dll
profapi.dll
api-ms-win-security-provider-l1-1-0.dll
api-ms-win-core-registry-l2-1-0.dll
api-ms-win-shell-shellfolders-l1-1-0.dll
ext-ms-win-devmgmt-policy-l1-1-0
ext-ms-win-devmgmt-policy-l1-1-1
ext-ms-win-devmgmt-policy-l1-1-2
ext-ms-win-devmgmt-policy-l1-1-3
ext-ms-win-devmgmt-policy-l1-1-0.dll
ext-ms-win-session-usertoken-l1-1-0
ext-ms-win-session-usertoken-l1-1-0.dll
ext-ms-win-session-winsta-l1-1-0
ext-ms-win-session-winsta-l1-1-1
ext-ms-win-session-winsta-l1-1-2
ext-ms-win-session-winsta-l1-1-3
ext-ms-win-session-winsta-l1-1-4
ext-ms-win-session-winsta-l1-1-5
ext-ms-win-session-winsta-l1-1-1.dll
ext-ms-win-session-winsta-l1-1-0.dll
ext-ms-win-session-wtsapi32-l1-1-0
ext-ms-win-session-wtsapi32-l1-1-1
ext-ms-win-session-wtsapi32-l1-1-0.dll
ext-ms-win-session-usermgr-l1-1-0.dll
ext-ms-win-msa-device-l1-1-0.dll
ext-ms-win-msa-device-l1-1-0
ext-ms-win-msa-user-l1-1-0
ext-ms-win-msa-user-l1-1-1
ext-ms-win-msa-user-l1-1-1.dll
ext-ms-win-els-elscore-l1-1-0.dll
ext-ms-win-core-game-streaming-l1-1-0
ext-ms-win-core-game-streaming-l1-1-0.dll
cryptngc.dll
ngcpopkeysrv.dll
CLIPC.dll
ktmw32.dll
tbs.dll
USER32.dll
Bcp47Langs.dll
ext-ms-win-uxtheme-themes-l1-1-0.dll
ext-ms-win-msa-user-l1-1-0.dll
ext-ms-win-shell-embeddedmode-l1-1-0
ext-ms-win-shell-embeddedmode-l1-1-0.dll
PhoneOm.dll
FUnknown exception
abcdefghijklmnopqrstuvqxyz
{83928489-55ae-4c23-94ec-03a106b80ba2}
{fc36fe91-19d3-49d4-866e-dc3d55f27f2a}
{f102501f-1505-46a2-af40-9dbecceca0cf}
{c1890aa2-381f-4dc6-a2b1-4eb1be650009}
{cacf4700-5e74-446f-9320-7eca7abf9037}
{3d2a0e7e-003a-4288-859f-c54ef739b852}
{73e96b4f-91d0-4d7d-830f-b3d159f6a8ed}
{28cc6ce2-e2e9-44f3-9044-a9a21fe9aec0}
{8596cdfb-b010-41e3-8d6e-0ff05589849f}
{d01933b2-4928-49be-ab6a-24e98a8cdc09}
{0bb18228-49ac-4ec3-8fad-e7c0b17741f3}
{d9ffeb4b-30de-45b4-a72d-0c3fdc12ac7f}
{29637f21-d0bc-44c6-a1f9-fb6642136967}
{07f912dc-3518-4549-8286-7de7a2a443e6}
{d1f1d8be-c318-497e-a721-00e06fe56916}
{d0d7679d-3fb6-470e-8b4b-857a57e92f82}
cfg:ThrottleFlags
cfg:ThrottleMaxRequests
cfg:ThrottleTotalIntervalSeconds
cfg:ThrottleHWBindingMaxRequests
cfg:ThrottleHWUpdateMaxRequests
cfg:ThrottleHWUpdateOutOfToleranceMaxRequests
cfg:ThrottleTpmBindingMaxRequests
cfg:ThrottledApplications
cfg:NegativeCacheFlags
cfg:NegativeCacheMaxRequests
cfg:NegativeCacheIntervalSeconds
cfg:NegativeCacheIntervalMultiplierForPersistentFailures
cfg:RPCIdleStopTimeout
Platform
Windows10
Xbox1Core
uiflavor
Win10
XboxOneCore
Phone
Win8Colors
urn:passport:compact
urn:oasis:names:tc:SAML:1.0
http://docs.oasis-open.org/wss/oasis-wss-saml-token-profile-1.1#SAMLV1.1
http://docs.oasis-open.org/wss/oasis-wss-saml-token-profile-1.1#SAMLV2.0
urn:passport:legacy
wsse:X509V3
urn:passport:loginprooftoken
<CertInfo>
</CertInfo>
<Keypair>
</Keypair>
<Cert>
</Cert>
<KeyGenFlags>
</KeyGenFlags>
CXHSignInUpsell
CXHSignIn
CXHTransientSignIn
CXHReAuth
CXHNGCUpsell
DeviceSessionKey
<ps:AssertionFormat xmlns:ps="http://schemas.microsoft.com/Passport/SoapServices/PPCRL">EId</ps:AssertionFormat>
MBI_X509_DID
MBI_X509_DID_SYSTEM
WLDomain
ManageApproverLID
CertThumb
ContainerName
cfg:MinPasswordLength
cfg:MinPasswordCharacterGroups
cfg:PasswordReset
cfg:EnableServerPasswordChange
cfg:DeviceProvisioningFailureThreshold
<psf:ErrorData xmlns:psf="http://schemas.microsoft.com/Passport/SoapServices/SOAPFault"><psf:AuthState>0x%x</psf:AuthState><psf:AuthRequired>0x%x</psf:AuthRequired><psf:RequestStatus>0x%x</psf:RequestStatus><psf:FlowUrl>%s</psf:FlowUrl></psf:ErrorData>
<extProperties>
</extProperties>
abcdefghijklmnopqrstuvqxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^*()-_=+;:,./?`~
{8FB02294-1882-41ff-9CFD-AFBFA366DA33}
{8CC11465-DF53-4789-AC99-F7C08E1D5200}
Exception
ReturnNt
ReturnHr
LogNt
LogHr
FailFast
%hs(%u)\%hs!%p: 
%hs!%p: 
(caller: %p) 
%hs(%d) tid(%x) %08X %ws
Msg:[%ws] 
CallContext:[%hs] 
[%hs(%hs)]
[%hs]
RaiseFailFastException
std::exception: %hs
onecore\internal\sdk\inc\wil\opensource\wil\resource.h
RtlNtStatusToDosErrorNoTeb
RtlDisownModuleHeapAllocation
WilFailureNotifyWatchers
IdleCallback
ConvertStringSecurityDescriptorToSecurityDescriptor returned 0x%x
WLIDInitializeEx
WLIDCreateContextWithLogonId
WLIDCreateContextWithChallenge
WLIDSetAuthData
WLIDPublishService
WLIDUnpublishService
WLIDResolveDevice
WLIDGetLocalDeviceName
WLIDConnectIdentity
WLIDUpdateConnectedIdentity
WLIDCompleteConnect
WLIDDisconnectIdentity
WLIDCreateIdentity
WLIDDeleteIdentity
WLIDImportIdentity
WLIDResolveUser
WLIDGetServiceConfig
WLIDWatsonReport
WLIDGetExtendedError
WLIDGetUserExtendedProperty
WLIDSetUserExtendedProperty
WLIDSetOptions
WLIDHasPersistedCredential
WLIDPersistCredentialForConnectedUser
WLIDRemovePersistedCredential
WLIDVerifyAssertion
WLIDGetDeviceId
WLIDProvisionDeviceId
WLIDGetDeviceIdEx
WLIDRenewDeviceId
WLIDDeProvisionDeviceId
WLIDEnumDevices
WLIDAssociateDeviceToUser
WLIDDisassociateDeviceFromUser
WLIDEnumerateUserAssociatedDevices
WLIDUpdateUserAssociatedDeviceProperties
WLIDCreateContextForLinkedIdentity
WLIDNCreateContext
WLIDNDeleteContext
WLIDNGetNextNotification
WLIDAddUserToSsoGroup
WLIDGetUsersFromSsoGroup
WLIDRemoveUserFromSsoGroup
WLIDGetAuthError
WLIDGetDeviceShortLivedToken
RenewCertificate
WLIDGetHIPChallenge
WLIDSetHIPSolution
WLIDSetDefaultUserForTarget
WLIDGetDefaultUserForTarget
WLIDGetDefaultUserForTargetEx
WLIDGetOpenHandlesData
WLIDGetSvcEnvironment
WLIDGetIdName
WLIDIsKioskMode
WLIDGetConfigString
WLIDSetUserPropertiesToSystemStore
WLIDGetUserPropertiesFromHandle
WLIDEnableTrace
WLIDDisableTrace
WLIDGetOneTimeCredential
WLIDGetIssuerCertificate
WLIDSendOneTimeCode
WLIDUpdateToken
WLIDAddOrDeleteColorSetCookie
WLIDGetSignedTokens
WLIDGetDeviceDAToken
WLIDRegisterUserIdkey
WLIDUpdateDeviceLicenseInfo
WLIDManageApprover
WLIDListSessions
WLIDApproveSession
WLIDGetScenarioInlineUrlWithContextData
WLIDGetInlineUrlContextData
WLIDGetTotpCode
WLIDCleanupIdentity
WLIDGetAppData
WLIDProvisionIdentityWithTransferToken
@6666666
@66\[
6666666[
TlgRegisterAggregateProvider failed with 0x%x, continuing...
InitializeGlobals failed. hr=0x%x
StartAsyncInit failed. hr=0x%x
Service initialization failed with: hr=0x%x
RtlUnregisterFeatureConfigurationChangeNotification
RtlNotifyFeatureUsage
NtUpdateWnfStateData
onecore\internal\sdk\inc\wil\Staging.h
Software\Microsoft\Windows\CurrentVersion\Policies\System
EnterpriseDeviceAuthOnly
API-MS-Win-Core-LocalRegistry-L1-1-0.dll
RegDeleteKeyExW
advapi32.dll
RegDeleteKeyW
Failed to retrieve the current user's SID string. (hr = 0x%0x)
GetStoredIdentityProperty failed. (hr = 0x%0x)
Failed to retrieve the SYSTEM user's SID string. (hr = 0x%0x)
RegEnumKey failed. (win32 = 0x%0x)
StringCbLengthW failed. (hr = 0x%0x)
StringCchCopyW failed. (hr = 0x%0x)
OpenProcessToken failed. (win32 = 0x%0x)
OpenProccessToken failed. (win32 = 0x%0x)
ConvertSidToStringSid failed. (win32 = 0x%0x)
ConvertSidToStringSidW failed. (win32 = 0x%0x)
SystemStoreLite::GetRegistryStringValue
WLIDRes.DLL
hr = CacheResStrings(lcid)
CStringSrv::Initialize
onecoreuap\ds\ext\live\identity\lib\utilities\stringsrv.cpp
hr = CStringSrv::Initialize()
CStringSrv::GetStringForID
hr = SearchError( errHr, node )
CStringSrv::GetMappedErrorMsg
hr = CStringSrv::GetStringForID( node.dwErrorMsgId, wstrErrMsg)
pXMLNode is NULL
Failed to parse attribute value: hr = 0x%x
hr = XMLGetNodeAttribute( (LPCWSTR)bstrAttributeName,pXMLNode,wstrNodeText)
pCert: 0x%p
CertGetSKI
Could not allocate memory for pbSKI.
CertGetCertificateContextProperty failed. 0x%x.
Could not allocate memory for wstrSKI. 0x%x
CertGetSubjectName
Could not allocate memory for cert subject name. 0x%x
No subject name was found in the certificate.
1.2.840.113549.1.1.5
pCertContext: 0x%p, pbSignedMessageBlob: 0x%p, cbSignedMessageBlob: %d
VerifyPOPMessage
CryptVerifyMessageSignature failed. 0x%x.
Could not allocate %d bytes for pbDecodeddMessageBlob.
CryptVerifyMessageSignature failed or emtpy decoded message. 0x%x.
Successfully verified message: %hs.
DeserializeWininetProxyOptions
Size of option value (%lu) is not equal to size ofINTERNET_PROXY_INFO struct (%Iu) or pointer is not correctly aligned.
hr = DWordAdd(cbOption, sizeof(WCHAR), &bufferSize)
hr = SafeCopyMemory(pBuffer, bufferSize, pbOption, cbOption)
hr = SafeCopyMemory(&dwAccessType, sizeof(DWORD), pBuffer, sizeof(DWORD))
hr = StringCbLength((WCHAR*)pBuffer, cbRemain, &len)
Proxy list is too long, max allowed = %Iu chars.
Proxy bypass list is too long, max allowed = %Iu chars.
%d.%d.%d.%d
GetFileVersion(%ls) failed with (0x%x)
Could not get file mutex, hr = 0x%x
Unable to create CLSID_DOMDocument60 instance. hr=0x%x
Unable to set selection namespaces on XML DOM.
Unable to Parse the xml.
/WlidToken/Type
Could not obtain message type from challange.
Could not obtain message type value from challange.
incorrect challenge message type. expected: '%ls', got '%ls'
/WlidToken/ChallengeToken/Policy
Could not obtain policy from challange.
Could not obtain policy value from challange.
/WlidToken/ChallengeToken/Flags
Could not obtain flags from challange.
OpenThreadToken failed with hr = 0x%x
OpenProcessToken failed with hr = 0x%x
InitializeSecurityDescriptor failed with hr = 0x%x
SetSecurityDescriptorDacl failed with hr = 0x%x
IsValidSecurityDescriptor failed with hr = 0x%x
IsCallerAdminAccount
DuplicateToken failed with hr = 0x%x
requiredBytes != 0
ConvertW2A
convertedBytes == requiredBytes
lengthWCharRequired != 0
ConvertA2W
</wsse:Password>
<wsse:Username>*********
<wsse:Password>*********
NoConnectedUser
hr = SafeCopyMemory(spNewMultiSzBuffer, totalStringLengthBytes, pStringToAppend, stringLengthBytes)
hr = SafeCopyMemory(spNewMultiSzBuffer + stringLengthBytes, totalStringLengthBytes - stringLengthBytes, spMultiSzString, multiSzstringLengthBytes)
hr = E_OUTOFMEMORY
hr = PrependStringToMultiSzString(static_cast<LPCWSTR>(stringPiece), spMultiSzString)
DuplicateString
hr = StringCchCopy(pDestination, bufferSizeCharacters, static_cast<LPCWSTR>(source))
Bad optional access
Updating offline hash of valid credential.
Unable to record hash of correct password (0x%x).
hr = configManager.TriggerNewFilesDownload(wstrConfigVersion)
CDeviceUserAssociation::InitializeDeviceRequest
CPublishDeviceRequest::Initialize
dwCount > 0 && dwCount < MAX_DEVICE_PROPERTIES && pNameValuePair
CUpdateDeviceProperties::Initialize
hr = InitializeDeviceRequest(pUserIdentity, pDeviceIdentity)
CUpdateDeviceReaders::Initialize
CResolveDeviceRequest::Initialize
CResolveDeviceRequest::GetResponse
CEnumDevicesRequest::Initialize
CResolveUserRequest::Initialize
CResolveUserRequest::GetResponse
onecoreuap\ds\ext\Live\identity\Include\ServiceHelper.h
ServicesActive
onecoreuap\ds\ext\live\identity\ntservice\lib\svccommon\Include\ProvisionIdentityWithTransferTokenRequest.h
Notifications exist.
Invalid SessionKeyType value specified, dwSessionKeyType = %d
ValidateSessionKeyType
GetProductInfo failed
AllowMicrosoftAccountSignInAssistant
Accounts
ConfigureServiceStart: failed with hr=0x%x
The service has stopped.
Service stopped
ServiceDisabledByPolicy
WLIDInitializationTimerQueue
hr = InterruptNotifications::InitializeGlobals()
hr = CStringSrv::InitializeGlobals()
DeviceIdHelpers::GetSystemHardwareID (0x%x).
DeviceIdHelpers::UpdateDeviceTpmInfo (0x%x).
DeviceIdHelpers::RetrieveDeviceID (0x%x).
HandleInitializeEx
hr = g_pPPCRL->GetIdentityStore()->GetSingleIdentity(logonId, *pHandle, pIdentity)
HandleCreateContextWithLogonId
hr = pSvcWrapper->HasAdminPermission()
hr = pSvcWrapper->GetNewIdentityHandle(logonId, CStringW(pszSid), hContextToken, dwPID, CStringW(wszMemberName), flags, pHandle)
HandleCreateContextWithChallenge
hr = ParseChallengeToken(wszChallenge, pszPolicy, dwLocalFlags)
hr = HandleCreateContext(wszMemberName, CREATECONTEXT_SET_APP_IDENTITY, pHandle, c_contextWithChallengeApplicationId)
hr = HandleAddUserToSsoGroup(wszMemberName, SSO_GROUP_OPTION_SESSION, (dwLocalFlags & SSO_ALL_GROUPS))
hr = g_pPPCRL->GetIdentityStore()->GetSingleIdentity(logonId, handle, pIdentity)
autoRevert.Revert(TRUE)
hr = ParseAuthData(dwAuthData, pbAuthData, arrAuthData)
hr = pIdentity->SetFlags(flags)
CloseIdentityHandleProc
hr = g_pPPCRL->GetIdentityStore()->CloseIdentityHandle(pParam->m_flags, pParam->m_LogonId, pParam->m_handle)
hr = g_WLIDTimerQueue.QueueWorkItem(CloseIdentityHandleProc, pParam, 0, WT_EXECUTEONLYONCE | WT_EXECUTELONGFUNCTION | WT_TRANSFER_IMPERSONATION )
CheckAdminPermission
Caller doesn't have Admin permission, can't get caller's id 0x%x
Caller doesn't have Admin permission, caller is (%#x:%#x)
GetActiveTSSessionID
WTSEnumerateSessions failed with hr 0x%x
sessionId=%d
No active TS session was found.
PublishSEBEdgeEvent
hr = GetActiveTSSessionID(pServiceWinApi, &sessionId)
PubSebEdgeEvent failed with hr 0x%x
AssociateDeviceToUserHelper
hr = pAssociateRequest->Initialize(pUserIdentity, pDeviceIdentity, pFriendlyName, associationType)
hr = lock.Lock()
hr = pAssociateRequest->BuildRequest()
hr = transport.SendDeviceRequest(pAssociateRequest)
hr = pAssociateRequest->GetResponse()
AssociateSystemDeviceToConnectedUserInternal
hr = DeviceIdHelpers::ProvisionDeviceId(g_szWindows7AppId, IDCRL_DEVICE_ID_SYSTEM, 0, hDeviceIdentity)
hr = client.GetSessionId(dwSessionId)
hr = g_pPPCRL->GetIdentityStore()->GetSingleIdentity(logonId, hUser, pUserIdentity)
hr = AssociateDeviceToUserHelper(pUserIdentity, pDeviceIdentity, strFriendlyName, 0)
hr = DeviceIdHelpers::Validate(g_szWindows7AppId, IDCRL_DEVICE_ID_SYSTEM, 0)
AssociateSystemDeviceToConnectedUser
hr = DeviceIdHelpers::RenewDeviceId( g_szWindows7AppId, IDCRL_DEVICE_ID_SYSTEM, 0, hDeviceIdentity, NULL, NULL)
HandleConnectIdentityInternal
Connect Param can't be null
Invalided Association flags 0x%x
Invalided account type 0x%x
hr = CheckAdminPermission()
hr = pUserIdentity->GetCredProperty(PPCRL_CREDPROPERTY_LASTNAME, lastName)
hr = pStoredId->SetProperty(PPCRL_CREDPROPERTY_LASTNAME, lastName)
hr = pUserIdentity->GetCredProperty(PPCRL_CREDPROPERTY_FIRSTNAME, firstName)
hr = pStoredId->SetProperty(PPCRL_CREDPROPERTY_FIRSTNAME, firstName)
hr = ExtensionAPI::FormatUserDisplayName(firstName, lastName, &displayName, nullptr)
hr = pStoredId->SetProperty(WLID_DISPLAY_NAME, displayName)
hr = pUserIdentity->GetCredProperty(PPCRL_CREDPROPERTY_HASPASSWORD, hasPassword)
hr = pStoredId->SetProperty(PPCRL_CREDPROPERTY_HASPASSWORD, hasPassword)
hr = pUserIdentity->GetCredProperty(PPCRL_CREDPROPERTY_COUNTRY, country)
hr = pStoredId->SetProperty(PPCRL_CREDPROPERTY_COUNTRY, country)
hr = pUserIdentity->GetCredProperty(PPCRL_CREDPROPERTY_AGEGROUP, ageGroup)
hr = pStoredId->SetProperty(PPCRL_CREDPROPERTY_AGEGROUP, ageGroup)
hr = pStoredId->SetProperty(PPCRL_CREDPROPERTY_ACCOUNTTYPE, propertyValue)
hr = CSystemStore::HasDefaultUser(pszSid, logonId, fAlreadyAssociated)
User is already connected.
hr = pUserIdentity->GetCredProperty(g_wszCIDPropName, wstrCIDPropValue)
hr = pStoredId->SetCID(wstrCIDPropValue)
hr = pStoredId->Associate()
hr = pStoredId->AddKeywords(CStringW(g_wszKeyword_Connected), fChanged, false, eLocal)
hr = pStoredId->SetProperty(PPCRL_CREDPROPERTY_DEFAULTCREDSAVED, L"")
hr = pUserIdentity->GetCredProperty(PPCRL_CREDPROPERTY_FLAGS, flags)
hr = pStoredId->SetProperty(PPCRL_CREDPROPERTY_FLAGS, flags)
hr = Transaction.Commit( hKernelTransaction, true)
AddDeviceAssociationData
2.5.4.3
DisassociateDeviceInternal
Identity does not have Auth Token therefore returning PPCRL_REQUEST_E_FORCE_SIGNIN.
hr = pDisassociateRequest->Initialize(pUserIdentity, pDeviceIdentity, associationDataArray)
hr = pDisassociateRequest->BuildRequest()
hr = transport.SendDeviceRequest(pDisassociateRequest)
hr = pDisassociateRequest->GetResponse()
SendConnectILR
Failed to allocate memory for CWLIDNotification(WLID_IDENTITY_ASSOCIATED)
Failed to allocate memory for CWLIDNotification(WLID_IDENTITY_CONNECTED)
SendDisconnectILR
Failed to allocate memory for CWLIDNotification(WLID_IDENTITY_DISASSOCIATED)
Failed to allocate memory for CWLIDNotification(WLID_IDENTITY_DISCONNECTED)
CleanConnectedAccountState
DisassociateDevice
DeleteIdentityStore
hr = HandleRemovePersistedCredential(hUser, PPCRL_CREDTYPE_PASSWORD, WLID_REMOVECREDENTIAL_DEFAULT_CRED)
hr = pStoredId->Disassociate()
hr = pStoredId->RemoveKeywords(CStringW(g_wszKeyword_Connected), fChanged, FALSE, eLocal)
HandleDisconnectIdentity
hr = DeleteIdentityStore(hUser, false, NULL, wstrCIDPropValue, isAssociated)
HandleResolveDeviceInternal
hr = pResolveDeviceRequest->Initialize(pUserIdentity, strDeviceName)
hr = pResolveDeviceRequest->BuildRequest()
hr = transport.SendDeviceRequest(pResolveDeviceRequest)
hr = pResolveDeviceRequest->GetResponse(pszAddresses)
HandleResolveDevice
HandleGetDeviceNameInternal
Can't get device certificate
HandleGetDeviceName
HandleUpdateDeviceLicenseInfo
hr = DeviceIdHelpers::UpdateDeviceLicenseInfo( &serviceExecutionContext, HardwareChangeState::TolerantChange, false)
HandlePublishDevice
hr = client.GetTokenUser(pszNtUserSid)
hr = pStoredId->AddService(wstrServiceName, fNewService)
hr = AssociateSystemDeviceToConnectedUser(hUser)
hr = CSystemStore::AddGlobalPublishedService()
hr = Transaction.Commit()
HandlePublishRequestInternal
hr = pPublishDeviceRequest->Initialize(flags, pDeviceIdentity, pszAddresses, pszFriendlyName )
hr = pPublishDeviceRequest->BuildRequest()
hr = transport.SendDeviceRequest(pPublishDeviceRequest)
hr = pPublishDeviceRequest->GetResponse(pdwServerBackOffTime)
HandlePublishRequest
HandleUnpublishAllServices
hr = pStoredId->RemoveAllServices()
hr = CSystemStore::RemoveGlobalPublishedService(dwServicesCount)
HandleUnpublishDevice
hr = pStoredId->RemoveService(wstrServiceName, fExisted)
hr = CSystemStore::RemoveGlobalPublishedService(1)
HandleConnectIdentity
HandleCompleteConnect
HandleUpdateConnectedIdentity
hr = pStoredId->SetProperty(PPCRL_CREDPROPERTY_DEFAULTCREDSAVED, PPCRL_CREDPROPERTY_VALUE_PERSISTED)
PersistedFromCache
hr = pStoredId->SetProperty(PPCRL_CREDPROPERTY_DEFAULTCREDSAVED, PPCRL_CREDPROPERTY_VALUE_PERSISTED_CACHE)
DefaultCredsPersistFailed
hr = pStoredId->SetProperty(PPCRL_CREDPROPERTY_DEFAULTCREDSAVED, PPCRL_CREDPROPERTY_VALUE_PERSIST_FAILED)
HandleCreateIdentity
hr = HandleResolveUser(hUser, pwszUserName, flags, &pszCID )
hr = pStoredId->SetCID(wstrCID)
hr = pStoredId->AddKeywords(wstrKeywords, fChanged)
hr = HandleUpdateDeviceReaders(TRUE, hUser, TRUE, 1, (PWSTR*)&pwszUserName, FALSE)
hr = StringCchCopyW(*ppwszCID, wstrCID.GetLength() + 1, (LPCWSTR)wstrCID)
HandleDeleteIdentity
Failed Enumeratingidentities. (0x%x)
Cannot find user with CID: %ls.
WLIDCEnumIdentities didn't return exactly one identity. (0x%x)
hr = pStoredId->RemoveAllKeywords()
hr = pStoredId->RemoveKeywords(wstrKeywords, fChanged)
Failed HandleUpdateDeviceReaders. (0x%x)
HandleImportIdentity
hr = pStoredId->SetProperty(pProps[i].pszProperty, pProps[i].pszValue)
HandleUpdateDeviceReadersInternal
hr = CSystemStore::IsPublishing(&fPublishing)
HandleUpdateDeviceReaders is noop as system is not publishing currently.
hr = pUpdateDeviceReaders->Initialize(pUserIdentity, pDeviceIdentity, fAdd, dwReaders, (PCWSTR *)ppszReaderNames )
hr = pUpdateDeviceReaders->BuildRequest()
hr = transport.SendDeviceRequest(pUpdateDeviceReaders)
HandleUpdateDeviceReaders reader being removed doesn't exist. will ignore.
HandleUpdateDeviceReaders
Not Supported anymore
HandleWatsonReport
No notification because: Usertype is = 0x%x.
MsaUserExtImpl::CallerIsLoggedOnUser(0, pLogonId, &isLoggedOn)
Session is not logged on.
hr = SystemStoreLite::IsConnected(serviceExecutionContext.GetExternalExecutionContextLite(), &isConnected, &pConnectedLiveUserName)
hr = pClient->GetTokenUser(sid)
hr = pIdentity->GetCredBag()->RetrieveCredential( PPCRL_CREDTYPE_PASSWORD, password)
hr = pIdentity->GetCredBag()->PersistCredential(false, PPCRL_CREDTYPE_PASSWORD)
hr = SystemStoreLite::IsUserDomainConnected( serviceExecutionContext.GetExternalExecutionContextLite(), static_cast<LPCWSTR>(sid), isDomainConnected)
Failure - LogonUserExExW, HRESULT: 0x%08X
hr = InterruptNotifications::GetNotificationData( hrRequest, &serviceExecutionContext, pIdentity, static_cast<LPCWSTR>(sid), pRequestParams, requestCount, pRSTRequest, notificationFlags, triggerRequestTargets, triggerRequestPolicies, hrRequestStatus )
GetCallingProcessSessionId - Failed to get calling process session ID. hr = 0x%x.
ContainerStatus = %d
TPM is vulnerable, do not upsell NGC %d.
No NGC keys found for CID %ls.
createNgcKey is true but UI is disallowed.
hr = ONL_E_ACTION_REQUIRED
IsAuthDisabledByPolicy
hr = HRESULT_FROM_WIN32(ERROR_ACCESS_DISABLED_BY_POLICY)
DisableUserAuth
Software\Policies\Microsoft\MicrosoftAccount
IsAuthDisabledByEnterpriseDeviceAuthPolicy
IsCallerInTokenRequestAllowedList
Test hook value: 0x%x
ModernTestHook_AllowedApps
App GUID: %s
App SID: %s
Blocked on Empty App ID
Blocked App ID: %s
pIdentity != nullptr
hr = g_pPPCRL->GetNegativeCacheManager()->CheckNegativeCache( rgRequests[i].wszServiceTarget, rgRequests[i].wszServicePolicy, pIdentity, (pIdentity->GetUserType() == PPCRL_EMAIL))
hr = IsAuthDisabledByEnterpriseDeviceAuthPolicy(&serviceExecutionContext, pIdentity)
hr = IsAuthDisabledByPolicy(&serviceExecutionContext, pIdentity)
!pIdentity->IsRequestCancelled()
TestAndSetIsMissingCredValue failed: hr = 0x%x.
DefaultCredsMissing
pIdentity->GetCredProperty(PPCRL_CREDPROPERTY_CID, accountCid)
NonGuidParsed
hr = IsCallerInTokenRequestAllowedList(pIdentity)
hr = pIdentity->SetFlags(requestFlags & ~ACQUIRE_TOKEN_FLAGS_FILTER)
hr = pIdentity->ValidateCreds(pIdentity->GetUserType())
S-1-15-2-278586202-1783374767-3755652818-1001658646-1865713925-2047498344-1799408599
hr = HRESULT_FROM_NT(LsaLookupUserAccountType(nullptr, &accountType))
Identity IsConnected value: %ls ; accountType value: %d
WinStationGetCurrentSessionCapabilities returns false with 0x%08x.
hr = client.GetTokenUser(userSid)
hr = pIdentity->GetCredProperty(PPCRL_CREDPROPERTY_CID, userCid)
No CID found for SID %ls.
User is in remote session, skip registering NGC for secondary MSA 
hr = ShouldCreateNgcKey(&serviceExecutionContext, userSid, userCid, noUI, createNgcKey)
hr = PPCRL_E_NGC_REGISTRATION_REQUIRED
hr = pRequest->Initialize(pIdentity, "")
hr = DeviceIdHelpers::RetrieveDeviceID( g_szStrongAuthAppId, 0, nullptr, IDCRL_DEVICE_ID_GET_VALID_DA_TOKEN, nullptr, nullptr, nullptr, pDeviceIdentity)
CSingleIdentity::AuthIdentity - Failed when sending auth request.
hr = DeviceIdHelpers::HandleRenewDeviceId(&serviceExecutionContext, g_szStrongAuthAppId, pIdentity->GetUserType(), 0, pDeviceIdentity, pNewDeviceIdentity, nullptr, nullptr)
hr = pRequest->ShouldResendRequest(++requestCounter, resendRequest)
hr = pRequest->GetResponse(&rgResponses)
Secondary
SecondaryOnConnected
SecondaryOnAssociated
SetNgcKeyName
hr = pNgcFunctions->NgcEnumUserIdKeys( PPCRL_MSA_IDP_DOMAIN, nullptr, pUserCid, pUserSid, &spKeyInfo, &spEnumState)
hr = hIdentity->GetCredBag()->StoreCredential(PPCRL_CREDTYPE_NGCKEYNAME, spKeyName)
NgcEnumUserIdKeys returned ContainerStatus = %d.
hr = NTE_NO_MORE_ITEMS
hr = DWordMult(sizeof(WLIDResponseParams), dwRequestCount, &responseSize)
hr = pIdentity->GetServiceToken(rgRequest[i].wszServiceTarget, token)
Service token is expired
hr = ConstructTokenResponse(pIdentity, token, encryptToken, rgResponse[i])
HandleGetUserExtendedProperty
hr = CUserExtendedProperty::GetExtProperty(wszUserName, wszPropertyName, wstrPropertyValue)
Unable to write or open registry key for read: '%ls', hr = %x.
Unable to write or QueryStringValue for size: '%ls', hr = %x.
Unable to write or QueryStringValue: '%ls', hr = %x.
hr = StringCchCopyW(wszPropertyValue, wstrPropertyValue.GetLength() + 1, (LPCWSTR)wstrPropertyValue)
HandleSetUserExtendedProperty
hr = client_local.ImpersonateClient()
hr = client_local.GetLogonId(logonId)
hr = g_pPPCRL->GetIdentityStore()->GetTokenBagByName(logonId, wszUserName, hTokenBag)
hr = hTokenBag->ClearUserExtProperties()
hr = DeleteUserAllExtendedProperties(wszUserName)
hr = hTokenBag->SetUserExtPropertyValue(wszPropertyName, wszPropertyValue)
hr = CUserExtendedProperty::SetExtProperty(wszUserName, wszPropertyName, wszPropertyValue)
hr = SetExtendedPropertyInternal(wszPropertyName, wszPropertyValue)
GetCachedIdentities
ps:virtualapp=
CredEnumerateW returned a null cred pointer index =%d.
%A, %B %c  %H %d, %Y
User: %ls; LastWritten: %ls.
User: %ls
hr = client.ImpersonateClient(&ContextToken)
hr = g_pPPCRL->GetIdentityStore()->GetSignedInUsernames(logonId, dwSessionId, wszFilterPropertyName, arrMemberNames)
hr = GetCachedIdentities(wszCachedCredType, arrMemberNames)
hr = CSystemStore::EnumIdentities(pszSid, logonId, enumFlags, wszFilterPropertyName, wszFilterPropertyValue, arrMemberNames )
hr = StringCchCopyW(rgwszMemberNames[i], arrMemberNames[i].GetLength() + 1, (LPCWSTR)arrMemberNames[i])
HandleHasPersistedCredential
g_pPPCRL->GetNegativeCacheManager()->ClearNegativeCacheData(pIdentity, daCreatedTime.GetTime())
pIdentity->GetCredBag()->SetPropertyDefaultCredSavedToPersisted()
Windows_Default_Cred_SLC
hr = pIdentity->DeLinkCertObject(DEFAULT_CRED_SLC, &pTempCert)
hr = pIdentity->PersistServiceTokens()
hr = pIdentity->RemovePersistedServiceTokens()
hr = pIdentity->RemovePersistedCertificates()
HandlePersistCredentialForConnectedUser
Current user is not connected.
HandleRemovePersistedCredential
Cannot delete stored CAW cookie hr=0x%x
Cannot delete stored credentials hr=0x%x
Cannot remove user persisted service tokens hr=0x%x
Cannot remove user presisted certificates hr=0x%x
MicrosoftAccount:(TOTPSharedKey):UserPuid=
Cannot remove user persisted TOTP Shared Key hr=0x%x
CID is not set for the current identity hr=0x%x
Cannot remove linked user creds hr=0x%x
Cannot cleare user ext properties hr=0x%x
HandleProvisionDeviceId
hr = DeviceIdHelpers::Validate(wcszAppId, dwDeviceType, flags)
hr = DeviceIdHelpers::ProvisionDeviceId(wcszAppId, dwDeviceType, flags, hDeviceIdentity)
HandleGetDeviceIdEx
hr = DeviceIdHelpers::GetDeviceIDHelper(wcszAppId, dwDeviceType, flags, pvAdditionalParams, 0, &pCertCtxt, &pszKeypair, hDeviceIdentity, bReturnedNotAssociated )
pCertCtxt
hr = ConstructDeviceInfo(pCertCtxt, pszKeypair, pwszKeypair, ppbDeviceCert, pcbDeviceCert )
hr = DeviceIdHelpers::GetPUID(hDeviceIdentity, pCertCtxt, &wszDeviceId)
StringCchCopyW hr=0x%x
HandleRenewDeviceId
hr = DeviceIdHelpers::RenewDeviceId(wcszAppId, dwDeviceType, flags | IDCRL_DEVICE_ID_RENEW_CERT, hDeviceIdentity, NULL, NULL)
HandleDeProvisionDeviceId
hr = DeviceIdHelpers::DeProvisionDeviceId(wcszAppId, dwDeviceType, flags, hDeviceIdentity, PPCRL_E_DEVICEID_DEPROVISION_CALL)
HandleGetDeviceId
hr = GetDeviceIdInternal(wcszAppId, flags, pvAdditionalParams, IDCRL_DEVICE_ID_NO_DA_TOKEN, &wszDeviceId, &pCertCtxt, &pszKeypair, &pIdentity )
hr = ConstructDeviceInfo(pCertCtxt, pszKeypair, pwszKeypair, ppbDeviceCert, pcbDeviceCert)
HandleEnumDevices
hr = DeviceIdHelpers::VerifyInitialization()
IsCallerAdminEnabled failed with hr = 0x%x
Open for %ls failed with hr=%x
RegQueryInfoKey failed with hr=%x
RegEnumKeyEx for %ls failed with hr=%x
PhysicalDeviceID
Enumerate Device ID TlsSetValue failed with hr = 0x%x
EnumerateDeviceID TlsSetValue = 0x%x,  RetrieveDeviceID  = 0x%x, appdatafilepath = %ls
hr = StringCchCopyW(rgDeviceInfo[dwCount].wszDeviceId, length + 1, wszDeviceId)
hr = ConstructDeviceInfo(pCertContext, pszKeypair, &rgDeviceInfo[dwCount].wszKeypair, &rgDeviceInfo[dwCount].pbDeviceCert, &rgDeviceInfo[dwCount].cbDeviceCert )
HandleVerifyAssertion
pCert context passed to VerifyCertificate is NULL, or pdwTTL is NULL or 0.
VerifyCertificate: verifying already initialized failed with hr=0x%x
AssociateCert: failed to CertCreateCertificateContext 0x%X
VerifyCertificate: CertVerifySubjectCertificateContext failed with hr=0x%x
CheckCertTTL returned 0x%x.
POP verification failed with 0x%x.
hr = CertGetSubjectName(pCertContext, strCID)
hr = StringCchCopyW(*pwszCID, wstrCID.GetLength() + 1, wstrCID.GetBuffer())
hr = SafeCopyMemory(*ppbCACert, pCACertContextLocal->cbCertEncoded, pCACertContextLocal->pbCertEncoded, pCACertContextLocal->cbCertEncoded)
Get Auth End Point URL failed hr=0x%x
Get Auth End Point URL Hash failed hr=0x%x
GetOneTimeCredential failed hr=0x%x
hr = g_pPPCRL->GetIdentityStore()->GetSingleIdentity(logonId, handle, hIdentity)
HandleSetOptions
g_pPPCRL != nullptr && SUCCEEDED(g_pPPCRL->VerifyInitialized())
hr = g_pPPCRL->SetAppSettings(NULL, false)
rgOptions.SetCount(dwOptions) == true
hr = g_pPPCRL->SetAppSettings(&options, false)
hr = g_pPPCRL->SetAppSettings(&options, true)
HandleGetExtendedError
No extended error info is set.
hr = StringCchCopyA(*pszFileAndLine, strFileAndLine.GetLength() + 1, (LPCSTR)strFileAndLine)
hr = StringCchCopyA(*pszRequest, strRequest.GetLength() + 1, (LPCSTR)strRequest)
hr = StringCchCopyA(*pszResponse, strResponse.GetLength() + 1, (LPCSTR)strResponse)
hr = StringCchCopyW(*pwszHost, wstrHost.GetLength() + 1, (LPCWSTR)wstrHost)
wszPropertyName='%ls'
HandleGetServiceConfig
hr = g_pPPCRL->VerifyInitialized()
hr = CClientConfigDataCacheManager::theConfigDataManager().GetServiceURI( wszPropertyName, wstrValue)
hr = StringCchCopyW(*pwszPropertyValue, wstrValue.GetLength() + 1, (LPCWSTR)wstrValue)
HandleCreateContextForLinkedIdentity
Could not find membername in linked Ids.
hr = g_pPPCRL->GetIdentityStore()->GetNewIdentityHandle(logonId, CStringW(L""), hContextToken, dwPID, CStringW(wszMemberName), 0, &hLinkedIdentity)
hr = g_pPPCRL->GetIdentityStore()->GetSingleIdentity(logonId, hLinkedIdentity, pLinkedIdentity)
hr = pLinkedIdentity->SetCredProperty(PPCRL_CREDPROPERTY_CID, wstrCID)
Copying auth state from handle 0x%p to 0x%p.
hr = pLinkedIdentity->CopyAuthStateFromLinkedHandle(pIdentity, flags)
RetrievePersistedServiceTokens: failed hr = 0x%x, trying to continue
RetrievePersistedCertificates: failed hr = 0x%x, trying to continue
HandleResolveUserInternal
hr = g_pPPCRL->GetIdentityStore()->GetSingleIdentity(logonId, handle, pUserIdentity)
hr = pResolveUserRequest->Initialize(pUserIdentity, strUserName)
hr = pResolveUserRequest->BuildRequest()
hr = transport.SendDeviceRequest(pResolveUserRequest)
hr = pResolveUserRequest->GetResponse(wszCID)
hr = g_UserCIDCache.AddCID(strUserName, wszCID)
hr = StringCchCopyW(*pwszCID, wszCID.GetLength() + 1, (LPCWSTR)wszCID)
HandleResolveUser
hr = g_NotificationTable.CreateQueue(logonId, dwTypes, ppszEventName, phNotify)
hr = g_NotificationTable.DeleteQueue(pLuid, hNotify)
HandleGetNextNotification
hr = g_NotificationTable.NextNotification(hNotify, logonId, pNotification)
hr = SafeCopyMemory(*pData, *pcbData, pNotification->m_pData.GetBuffer(), *pcbData)
HandleRenewCertificate
MBI_X509_CID_7D
hr = HandleRenewDeviceId(g_szWindows7AppId, IDCRL_DEVICE_ID_SYSTEM, 0)
GetExtendedPropertyInternal
CAuthInfo::GetCachedAuthInfo failed with hr = 0x%x, trying to continue
ImportAuthState: failed hr = 0x%x
NULL out parameters passed to GetDeviceId hr=0x%x
non null passed for pvAdditionalParams hr=0x%x
VerifyInitialization: failed hr = 0x%x
Unable to write or create registry key '%ls', hr = %x.
Unable to set string value '%ls'='%ls' under '%ls', hr = 0x%x.
hr = pIdentity->GetCredProperty(PPCRL_CREDPROPERTY_CID, wstrCID)
ConstructTokenResponse
hr = StringCchCopyW(response.wszAuthChallenge, wszFlowUrl.GetLength() + 1, wszFlowUrl)
hr = CAuthInfo::EncryptStringInSystemContext(&executionContext, token.GetToken(), tokenBlob)
hr = StringCchCopyW(response.wszToken, tokenBlob.GetLength() + 1, tokenBlob)
hr = SafeCopyMemory(response.pbSessionKey, bpSessionKey.GetLength(), bpSessionKey.GetBuffer(), bpSessionKey.GetLength())
hr = StringCchCopyW(response.wszCID, wstrCID.GetLength() + 1, wstrCID)
hr = StringCchCopyW(response.wstrKeyPair, token.GetKeyPair().GetLength() + 1, token.GetKeyPair())
hr = StringCchCopyW(response.wszAuthorizationToken, pszAuthzToken.GetLength() + 1, pszAuthzToken)
hr = StringCchCopyW(response.wstrTokenURI, token.GetTokenURI().GetLength() + 1, token.GetTokenURI())
pwszKeypair
ConstructDeviceInfo
ppbDeviceCert
hr = StringCchCopyW(wszKeypair, wstrKeypair.GetLength() + 1, wstrKeypair.GetBuffer())
hr = SafeCopyMemory(pbDeviceCert, pCertCtxt->cbCertEncoded, pCertCtxt->pbCertEncoded, pCertCtxt->cbCertEncoded)
HandleGetAuthError
No service name provided, will return status from last response.
Could not get token bag or token for service: %ls.
hr = StringCchCopyW(*pwszErrorXml, wszErrorXml.GetLength() + 1, (LPCWSTR)wszErrorXml)
HandleGetDeviceShortLivedToken
hr = StringCchCopyW( *ppszDeviceToken, strToken.GetLength() + 1, (LPCWSTR)strToken)
HandleGetHIPChallenge
One or more parameter(s) is invaild.
GetResponseParam failed hr = 0x%x
hr = StringCchCopyW( *pwszHIPChallenge, wstrBuffer.GetLength() + 1, (LPCWSTR)wstrBuffer)
Get Hip Challenge: %ls = '%ls'.
HandleSetHIPSolution
Set Hip solution: %ls = '%ls'.
wszHipSolution is invalid.
HIPAudioSolution
hr = pIdentity->GetResponseParam(PPCRL_HIPCHALLENGE_AUDIOSOLUTION, wstrAudioHIPSolution)
HIPSolution
hr = pIdentity->SetIdentityCookie(PPCRL_HIPSOLUTION_SOLUTION_NAME, wstrAudioHIPSolution)
hr = pIdentity->SetRequestParam(wszResponseType, wszHipSolution)
handle=%p, wszUsername=%ls, flags=%llx, wszServiceTarget=%ls
HandleSetDefaultUserForTarget
hr = pIdentity->SetDefaultUserForTarget(wszServiceTarget)
HandleGetDefaultUserForTarget
Found %d SSO user
Found user %ls
hr = StringCchCopyW(*pwszMemberName, wstrMemberName.GetLength() + 1, (LPCWSTR)wstrMemberName)
VerifySsoParams
dwSSOGroup == SSO_GROUP_LIVE
(flags & (DWORD)(~SSO_GROUP_OPTION_ALL_BIT)) == 0
wszUsername=%ls, flags=%llx, dwSSOGroup=%d
HandleAddUserToSsoGroup
wszUsername
hr = VerifySsoParams(flags, dwSSOGroup)
hr = g_pPPCRL->GetIdentityStore()->GetTokenBagByName(logonId, wszUsername, hTokenBag)
hr = hTokenBag->AddSSOGroup(dwSSOGroup)
hr = g_pPPCRL->GetIdentityStore()->SetPersistedSsoGroupUser(logonId, dwSSOGroup, wszUsername)
flags=%llx, dwSSOGroup=%d, pdwMemberNames=%p, prgwszMemberNames=%p
HandleGetUsersFromSsoGroup
hr = g_pPPCRL->GetIdentityStore()->GetPersistedUserNameBySsoGroup(logonId, dwSSOGroup, wstrMemberName)
hr = HandleEnumIdentities( WLID_ENUMIDENTITIES_SIGNEDIN, L"", L"", &cNames, &rgwszMemberNamesSignedIn)
hr = g_pPPCRL->GetIdentityStore()->GetTokenBagByName(logonId, rgwszMemberNamesSignedIn[dwNames], hTokenBag)
HandleRemoveUserFromSsoGroup
hr = g_pPPCRL->GetIdentityStore()->GetPersistedUserNameBySsoGroup(logonId, dwSSOGroup, wstrExistingUserName)
hr = g_pPPCRL->GetIdentityStore()->SetPersistedSsoGroupUser(logonId, dwSSOGroup, L"")
hr = hTokenBag->RemoveSSOGroup(dwSSOGroup)
HandleSendOneTimeCode
hr = g_pPPCRL->GetIdentityStore()->GetSingleIdentity(logonId, hUser, hIdentity)
hr = sendOTCRequest.Initialize(hIdentity, wszPurpose, wszChannel, wszChannelValue, dwLcid)
hr = sendOTCRequest.BuildRequest()
hr = transport.SendRequest(&sendOTCRequest)
HandleGetOpenHandlesData
hr = g_pPPCRL->GetIdentityStore()->GetOpenHandles(aResponse)
hr = autoCredBag.DeSerializeCredentials(pBuffer, cbBuffer)
ps:active
HandleGetSvcEnvironment
hr = CClientConfigDataCacheManager::theConfigDataManager().GetEnvironment(wstrEnvironment)
hr = StringCchCopyW(*pwszSvcEnv, wstrEnvironment.GetLength() + 1, (LPCWSTR)wstrEnvironment)
HandleGetIdName
hr = StringCchCopyW(*pwszIdName, wstrIdName.GetLength() + 1, (LPCWSTR)wstrIdName)
HandleIsKiosk
HandleGetConfigString
hr = CClientConfigDataCacheManager::theConfigDataManager().GetConfigString(wszType, wstrCfgValue)
hr = StringCchCopyW(*pwszValue, dwCfgLength, (LPCWSTR)wstrCfgValue)
AssignIdentityProperty
hr = StringCchCopyW(apIdentityProperty[dwIndex].pszProperty, pszProp.GetLength() + 1, (LPCWSTR)pszProp)
hr = StringCchCopyW(apIdentityProperty[dwIndex].pszValue, pszPropValue.GetLength() + 1, (LPCWSTR)pszPropValue)
hr = pStoredId->GetNextProperty(pszProp, pszPropValue)
HandleGetUserPropertiesFromHandle
UserName
hr = AssignIdentityProperty(&apIdentityProperty[dwPropCount], L"UserName", wstrPropertyValue)
hr = GetIdentityPropertyHelper(hIdentity, PPCRL_CREDPROPERTY_FIRSTNAME, wstrPropertyValue)
hr = AssignIdentityProperty(&apIdentityProperty[dwPropCount], L"DisplayName", wstrPropertyValue)
hr = GetIdentityPropertyHelper(hIdentity, PPCRL_CREDPROPERTY_PUIDSTR, wstrPropertyValue)
hr = AssignIdentityProperty(&apIdentityProperty[dwPropCount], L"CID", wstrPropertyValue)
HandleCreateContext failed, hr = %x
Failed to renew DA token, hr = %x
WebCookieManager::WriteCookieData failed (0x%x).
GetNewIdentityHandle failed, hr = %x
HandleAssociateDeviceToUserInternal
dwAssocType > 0
pUserIdentity != NULL && pUserIdentity->HasAuthToken()
hr = AssociateDeviceToUserHelper(pUserIdentity, pDeviceIdentity, strFriendlyName, dwAssocType)
HandleDisassociateDeviceFromUserInternal
wszDeviceId != nullptr
Falied to send disassociate request. hr=0x%x
Failed Disassociate request. hr=0x%x
HandleEnumerateUserAssociatedDevices
pdwCount && ((paNames && paFriendlyNames) || prgDevices)
hr = pEnumDevicesRequest->Initialize(pUserIdentity, strOwnerName, dwAssocType)
hr = pEnumDevicesRequest->BuildRequest()
hr = transport.SendDeviceRequest(pEnumDevicesRequest)
hr = pEnumDevicesRequest->GetResponse(&dwCount, &pNamesTemp, &pFNamesTemp, &dwNamesSize, &dwFriendlyNamesSize )
hr = StringCchCopyW(rgDevices[i].wszString1, dwStrLen + 1, pNamesTemp[i])
hr = StringCchCopyW(rgDevices[i].wszString2, dwStrLen + 1, pFNamesTemp[i])
HandleUpdateUserAssociatedDevicePropertiesInternal
hUser && pNameValuePair && dwPropCount > 0 && dwPropCount < MAX_DEVICE_PROPERTIES
hr = pUpdateDeviceRequest->Initialize(pUserIdentity, pDeviceIdentity, dwAssocType, dwPropCount, pNameValuePair)
hr = pUpdateDeviceRequest->BuildRequest()
hr = transport.SendDeviceRequest(pUpdateDeviceRequest)
hr = pUpdateDeviceRequest->GetResponse()
Error - 0x%lx WTSQueryUserToken.
Error - 0x%lx QueryUserToken.
Error - 0x%lx QueueWorkItem.
CreateProcessUserTask. LogonId %d, %d. (0x%x)
HandleEnableTrace
HandleDisableTrace
HandleGetOneTimeCredential
hr = hIdentity->GetOneTimeCredential(flags, wcszAppId, wcszTarget, wcszPolicy, wcszAdditionalParams, wstrWebAuthUrl, wstrOneTimeCredential)
hr = StringCchCopyW(*pwszWebAuthUrl, wstrWebAuthUrl.GetLength() + 1, (LPCWSTR)wstrWebAuthUrl)
hr = StringCchCopyW(*pwszOneTimeCredential, wstrOneTimeCredential.GetLength() + 1, (LPCWSTR)wstrOneTimeCredential)
HandleGetIssuerCertificate
HandleGetIssuerCertificate: failed to CertCreateCertificateContext 0x%X
hr = GetIssuerCertificate(spCertContext, fGetFromExpiredStore, spIssuerCertContext)
hr = SafeCopyMemory(*ppbIssuerCert, spIssuerCertContext->cbCertEncoded, spIssuerCertContext->pbCertEncoded, spIssuerCertContext->cbCertEncoded)
GetUserKeyData Request result: hr = 0x%x, requestCount = %u, resendRequest = %u
hr = pSvcWrapper->GetLogonId(&client, logonId)
hr = pSvcWrapper->GetIdentityHandle(logonId, handle, hIdentity)
!pIdentityWrapper->IsIdentityNULL(hIdentity) && pIdentityWrapper->HasAuthToken(hIdentity)
hr = pTokenBagWrapper->GetKeyLatest( hTokenBag, wcszPurpose, requireMaterial, wstrKeyVersion, wstrKeyMaterial)
hr = ParseDateTimeString(wstrKeyVersion, keyVersionTimeStamp, TRUE)
Key version = %I64d
hr = StringCchCopyW(*pwszKeyVersion, wstrKeyVersion.GetLength() + 1, (LPCWSTR)wstrKeyVersion)
hr = StringCchCopyW(*pwszKeyMaterial, wstrKeyMaterial.GetLength() + 1, (LPCWSTR)wstrKeyMaterial)
(wstrVersion.IsEmpty() == false || versionTimeStamp > 0)
Key version asked for is %ls, timeStamp=%I64d.
hr = pTokenBagWrapper->GetKeySpecific( hTokenBag, wcszPurpose, wstrVersion, wstrKeyMaterial)
hr = ValidateSessionKeyType(pToken->sessionKeyType, sessionKeyType)
Reusing existing encrypted session key.
pIdentityWrapper->IsIdentityNULL(hIdentity) == false
pTokenBagWrapper->IsNULL(hTokenBag) == false
Session key type on handle (%d).
hr = PPCRL_E_IDENTITY_NOT_AUTHENTICATED
Session key type in tokenbag (%d) is not EncryptedSymmetric. DA token will not be updated in tokenbag.
hr = pIdentityWrapper->GetCredProperty(hIdentity, PPCRL_CREDPROPERTY_CID, accountCid)
CID is not set for the current identity.
hr = PPCRL_E_CREDPROP_NOTFOUND
hr = pNgcFunctions->NgcImportSymmetricPopKey( &accountInfo, nullptr, NGC_DEVICE_KEY_TRANSPORT_KEY, pToken->pSessionKey, pToken->sessionKeyLengthBytes, &decryptedSessionKey, &decryptedSessionKeySizeBytes)
hr = ParseDateTimeString(pCreateTime, createTime)
hr = ParseDateTimeString(pExpireTime, expireTime)
hr = pTokenBagWrapper->StoreToken( hTokenBag, pToken->pTokenUri, pToken->pToken, L"", CTime(createTime), CTime(expireTime), spSessionKey, pToken->tokenType, sessionKeyType )
HandleGetSignedTokens
hr = pServiceWrapper->Impersonate(&client)
hr = pServiceWrapper->GetLogonId(&client, logonId)
Error generating signed tokens: userTokenHr=0x%x deviceTokenHr=0x%x
hr = userTokenHr
hr = StringCchCopyW(pAutoUserToken, userTokenBufferSizeChars, (LPCWSTR)userToken)
hr = StringCchCopyW(pAutoDeviceToken, deviceTokenBufferSizeChars, (LPCWSTR)deviceToken)
Error being collapsed to common error code. Original error: 0x%x.
HandleGetDeviceDAToken
hr = pServiceWrapper->GetLogicalDeviceDAToken(flags, token, refreshTokenIfNeeded)
hr = StringCchCopyW( copyOfDeviceDA, (DWORD)deviceDABufferSizeChars, token.GetBuffer(deviceDABufferSizeChars))
GetLocalSignedUserToken
hr = pServiceWrapper->HandleCreateContext(L"", CREATECONTEXT_SET_APP_IDENTITY, &hUser, c_signedUserTokenApplicationId)
hr = pServiceWrapper->GetIdentityHandle(*pLogonId, hUser, pUserIdentity)
hr = PPCRL_AUTHSTATE_E_EXPIRED
hr = pIdentityWrapper->GetOneTimeCredential(pUserIdentity, 0, PPCRL_OTC_REQUESTING_APPID, NULL, NULL, NULL, url, userToken, NULL)
Unable to get CAW because caller is not connected.
hr = pServiceWrapper->GetIdentityHandle(logonId, hUserIdentity, hInternal)
hr = pServiceWrapper->GetCookieData(webCookieManager, hInternal, webCookie)
hr = pServiceWrapper->GetDeviceIdInternal( g_szStrongAuthAppId, IDCRL_DEVICE_ID_FROMCACHE, NULL, IDCRL_DEVICE_ID_NO_ASSOCIATION_UPDATE, NULL, NULL, NULL, &hInternal)
hr = DuplicateString(webCookies[i].CookieName, response[i]->Name)
hr = DuplicateString(webCookies[i].CookieData, response[i]->Data)
hr = DuplicateString(webCookies[i].P3PHeader, response[i]->P3PHeader)
HandleRegisterUserIdkey
hr = pServiceWrapper->HandleCreateContext(accountId, CREATECONTEXT_SET_APP_IDENTITY, &hUserIdentity, c_registerUserIdkeyApplicationId)
hr = pServiceWrapper->GetTokenUser(&client, pszSid)
hr = pServiceWrapper->GetIdentityHandle(logonId, hUserIdentity, pIdentity)
hr = pRequestWrapper->InitializeUserIdKeyRegistrationRequest(pIdentity, pRequest, useStrongAuth)
hr = pNgcFunctions->NgcGetUserIdKeyPublicKey( pUserIdKeyName, &spPublicKey, &publicKeySizeBytes)
hr = pIdentityWrapper->Lock(&lock)
Register
RegisterWeak
hr = pRequestWrapper->BuildUserIdKeyRegistrationRequest( pRequest, pLoginProofToken, (useStrongAuth == true) ? "Register" : "RegisterWeak", spPublicKey, publicKeySizeBytes, "", spAttestationStatement, attestationStatementSizeBytes, spAikCertChain, aikCertChainSizeBytes)
hr = pRequestWrapper->SendRequest(&transport, pRequest)
hr = pRequestWrapper->GetUserIdKeyRegistrationRequestServerError(pRequest)
hr = IsTokenAppContainer(hThreadToken, isTokenAppContainer)
hr = UMgrQueryUserContext(hThreadToken, &userContext)
hr = UMgrQueryUserToken(userContext, &hUserTokenLocal)
HandleManageApprover
hr = pServiceWrapper->HandleCreateContext(pUserName, CREATECONTEXT_SET_APP_IDENTITY, &hUserIdentity, c_sessionApprovalApplicationId)
hr = pServiceWrapper->GetDeviceIdInternal( g_szStrongAuthAppId, IDCRL_DEVICE_ID_FROMCACHE, nullptr, NULL, &pDeviceId, nullptr, nullptr, &pDeviceIdentity)
hr = pIdentityWrapper->GetCredProperty(pIdentity, PPCRL_CREDPROPERTY_PUIDSTR, accountPuid)
PUID is not set for the current identity.
hr = pIdentityWrapper->GetCredProperty(pIdentity, PPCRL_CREDPROPERTY_CID, accountCid)
hr = pServiceWrapper->GetTokenUser(&client, accountSid)
NgcFunctions::NgcEnumUserIdKeys.(hr = 0x%x)
hr = pNgcFunctions->NgcGetUserIdKeyPublicKey( spKeyInfo->pwszKeyName, &ngcPublicKey, &ngcPublicKeySizeBytes)
hr = HandleGetDeviceDAToken(pExecutionContext, &pDeviceDA)
hr = pRequestWrapper->InitializeManageApproverRequest(pIdentity, pRequest)
hr = CAuthInfo::DecryptSystemContextString(pExecutionContext, pLoginProofToken, decryptedToken)
hr = pRequestWrapper->BuildRegisterApproverRequest( pRequest, pAppVersion, pApplicationSid, pChannelId, decryptedToken, static_cast<LPCWSTR>(pDeviceId), static_cast<LPCWSTR>(pDeviceDA), ngcPublicKey, ngcPublicKeySizeBytes)
hr = pRequestWrapper->GetManageApproverRequestServerError(pRequest)
Non critical error SetExtendedProperty for Manage Approver returned hr = 0x%x
hr = pRequestWrapper->SaveApproverTotpKeyToCache(pRequest, static_cast<LPCWSTR>(keyIdentifier), isTotpEnabled)
hr = pIdentityWrapper->GetOneTimeCredential(pDeviceIdentity, 0, PPCRL_OTC_REQUESTING_APPID, nullptr, nullptr, nullptr, url, deviceToken, nullptr)
hr = pRequestWrapper->BuildManageApproverRequest( pRequest, localActionType, pAppVersion, pApplicationSid, pChannelId, static_cast<LPCWSTR>(escapedDeviceToken), accountPuid)
hr = ManageApproverRequest::DeleteTotpKeyFromCache(static_cast<LPCWSTR>(keyIdentifier))
HandleListSessions
hr = pServiceWrapper->GetDeviceIdInternal( g_szStrongAuthAppId, IDCRL_DEVICE_ID_FROMCACHE, nullptr, NULL, &deviceId, NULL, nullptr, &pDeviceIdentity)
GetDeviceIdInternal returned null deviceID
hr = PPCRL_E_DEVICEID_INTERNAL_ERROR
hr = HRESULT_FROM_WIN32(ERROR_DEVICE_REINITIALIZATION_NEEDED)
hr = pServiceWrapper->HandleCreateContext(pIdentityWrapper->GetIdentityName(pDeviceIdentity), CREATECONTEXT_SET_APP_IDENTITY, &hDeviceIdentity, c_sessionApprovalApplicationId)
hr = pServiceWrapper->GetIdentityHandle(logonId, hDeviceIdentity, pDeviceIdentityInternal)
hr = pRequestWrapper->InitializeListSessionsRequest(pDeviceIdentityInternal, pRequest)
hr = pRequestWrapper->BuildListSessionsRequest( pRequest, static_cast<LPCWSTR>(escapedDeviceToken), checkRegistrationFlag, pAppVersion, ppPuids, puidCount)
hr = pRequestWrapper->GetListSessionsRequestServerError(pRequest)
hr = pRequestWrapper->GetListSessionsResponse(pRequest, &pSessionData, &sessionCount, &pNotRegisteredPuids, &notRegisteredPuidCount)
HandleApproveSession
Approve
ApproveUSID
Device
hr = pRequestWrapper->InitializeApproveSessionRequest(pIdentity, pRequest)
hr = pServiceWrapper->GetDeviceIdInternal( g_szStrongAuthAppId, IDCRL_DEVICE_ID_FROMCACHE, nullptr, NULL, nullptr, NULL, nullptr, &pDeviceIdentity)
hr = pIdentityWrapper->GetOneTimeCredential( pDeviceIdentity, 0, PPCRL_OTC_REQUESTING_APPID, nullptr, nullptr, nullptr, url, deviceToken, nullptr)
hr = pRequestWrapper->BuildApproveSessionRequest( pRequest, pExecutionContext, static_cast<LPCWSTR>(escapedDeviceToken), nullptr, pUserName, accountPuid, pAppVersion, pSessionID, pSessionState, pSessionType)
hr = pRequestWrapper->GetApproveSessionRequestServerError(pRequest)
hr = pIdentityWrapper->GetOneTimeCredential( pIdentity, 0, PPCRL_OTC_REQUESTING_APPID, NULL, NULL, NULL, url, userToken, NULL)
hr = pNgcFunctions->NgcEnumUserIdKeys( PPCRL_MSA_IDP_DOMAIN, nullptr, static_cast<PCWSTR>(accountCid), static_cast<PCWSTR>(accountSid), &spKeyInfo, &spEnumState)
hr = SetNgcKeyName(pExecutionContext, pIdentity, accountCid, accountSid)
hr = pRequestWrapper->BuildApproveSessionNonceRequest( pRequest, pUserName, pAppVersion, pSessionID, pSessionState, pSessionType, static_cast<BYTE*>(ngcPublicKey), ngcPublicKeySizeBytes)
hr = pRequestWrapper->BuildApproveSessionRequest( pRequest, pExecutionContext, nullptr, static_cast<LPCWSTR>(escapedUserToken), pUserName, accountPuid, pAppVersion, pSessionID, pSessionState, pSessionType)
HandleGetScenarioInlineUrlWithContextData
hr = IsAuthDisabledByEnterpriseDeviceAuthPolicy(pExecutionContext)
hr = IsAuthDisabledByPolicy(pExecutionContext)
hr = UrlContextInfo::GetInlineUxScenarioId(pExecutionContext->GetExternalExecutionContextLite(), serverScenarioId)
hr = pServiceWrapper->GetServiceURI(k_wstrCXHSignInUpsellURL, inlineUrlLocal)
hr = UrlAppendQueryString(inlineUrlLocal, PPCRL_URL_QS_SCID, serverScenarioId)
hr = pServiceWrapper->GetServiceURI(k_wstrCXHReAuthURL, inlineUrlLocal)
hr = UrlAppendQueryString(inlineUrlLocal, L"fsui", L"1")
hr = pServiceWrapper->GetServiceURI(k_wstrCXHTransientSignInURL, inlineUrlLocal)
hr = pServiceWrapper->GetServiceURI(k_wstrCXHSignInURL, inlineUrlLocal)
hr = pServiceWrapper->GetServiceURI(k_wstrAccountSettingsURL, inlineUrlLocal)
hr = UrlAppendQueryString(inlineUrlLocal, PPCRL_URL_QS_SCID, scidOOBE)
hr = pServiceWrapper->GetServiceURI(k_wstrCXHNGCUpsell, inlineUrlLocal)
hr = AppendInlineUrlContextDataInternal(pExecutionContext, appendPlatform, appendUiFlavor, inlineUrlLocal)
Scenario:%d InlineUrl: %ls
hr = StringCchCopyW(*inlineUrl, inlineUrlLocal.GetLength() + 1, static_cast<LPCWSTR>(inlineUrlLocal))
HandleGetInlineUrlContextData
hr = AppendInlineUrlContextDataInternal( pExecutionContext, false, false, inlineUrlDataLocal)
hr = StringCchCopyW(*inlineUrlData, inlineUrlDataLocal.GetLength() + 1, static_cast<LPCWSTR>(inlineUrlDataLocal))
hr = UrlUtilities::AppendMarket(pWinApiLite, inlineUrlData)
hr = UrlContextInfo::GetPlatformIdentifiers(platform, uiflavor)
hr = UrlAppendQueryString(inlineUrlData, PPCRL_URL_QS_PLATFORM, platform)
hr = UrlAppendQueryString(inlineUrlData, PPCRL_URL_QS_UIFLAVOR, uiflavor)
GetPhoneNumberList hr:0x%x phoneList:%ls
hr = UrlAppendQueryString(inlineUrlData, PPCRL_URL_QS_PHONE_LIST, phoneList)
HandleGetTotpCode
hr = pRequestWrapper->ReadTotpSharedSecret( pTotpHelper, static_cast<LPCWSTR>(keyIdentifier), totpSharedKeyBlob)
hr = pRequestWrapper->GetTimeStep( pTotpHelper, pbTimeStep, skewAdjustedCurrentTime)
hr = LiteCryptUtilities::ComputeHash(pbTimeStep.GetBuffer(), pbTimeStep.GetLength(), reinterpret_cast<BYTE*>(totpSharedKeyBlob.GetBuffer()), totpSharedKeyBlob.GetLength(), BCRYPT_ALG_HANDLE_HMAC_FLAG, &spHash, &hashLen, BCRYPT_SHA1_ALGORITHM)
hr = pTotpHelper->GetTOTPCode( spHash, hashLen, codeLengthCharacters, &spTotpCode)
CleanupSystemStoreEntryForSid
hr = HRESULT_FROM_WIN32(ERROR_PRIVILEGE_NOT_HELD)
hr = HRESULT_FROM_WIN32(regOpsStatus)
Found Account %ls for SID %ls.
SID %ls not found in system store.
SID %ls is not Associated.
SID %ls is not Connected.
hr = Transaction.Commit( NULL, true)
HandleCleanupIdentity
hr = CleanupSystemStoreEntryForSid(userSid)
RemoveMSAIDPKeyIfSecondaryOrAssociated
Failed in NgcDeleteUserIdKey, hr=0x%08x
NgcEnumUserIdKeys returns NTE_NO_MORE_ITEMS
Failed in NgcEnumUserIdKeys, hr=0x%08x
GetAppDataFromServer
GetAppData Request failure details: error = 0x%x, suberror = 0x%x
GetAppData Request's isFirstParty bool value: %d
appid=
&clientid=
.default\Software\Microsoft\IdentityCRL\AppData
FirstParty
HandleGetAppData
Microsoft Enhanced Cryptographic Provider v1.0
ProvisionIdentityWithTransferToken
GetAppData
cchBuffer > 0
cchBuffer == ATL::EscapeXML(m_wstrToken, m_wstrToken.GetLength(), pszBuffer, cchBuffer )
CPPCRLToken::BuildAuthorizationToken
onecoreuap\ds\ext\Live\identity\Include\clientcauto.h
<WlidToken><Version>%ws</Version><Type>%ws</Type><AuthorizationToken><Flags>%d</Flags><Ticket Type="%ws">%ws</Ticket></AuthorizationToken></WlidToken>
CIdentityTokenBag::ClearUserExtProperties
onecore\internal\sdk\inc\wil\opensource/wil/result.h
hr = GetTokenSid(sid)
CWLIDTimerQueue:Shutdown-DeleteTimerQueueEx(m_hTimerQueue) failed with hr=0x%x
CWLIDTimerQueue:Shutdown-WaitForSingleObject dwWaitResult = %d, hr=0x%x
SetThreadToken failed (0x%x).
DeleteTimerQueueTimer failed for Queue %p and timer %p with hr=0x%x
hr = pIdentity->QueryInterface(EDeviceIdentityType, reinterpret_cast<void**>(&pSystemDeviceId))
IdentityWrapper::IsHardwareBound
onecoreuap\ds\ext\live\identity\ntservice\lib\svccommon\identitywrapper.cpp
IdentityWrapper::BindDeviceToHardware
hr = pSystemDeviceId->BindDeviceToHardware()
IdentityWrapper::MarkForDelete
IdentityWrapper::Delete
hr = pSystemDeviceId->Delete()
IdentityWrapper::GetHardwareBoundTime
IdentityWrapper::UpdateDeviceLicenseInfo
hr = pSystemDeviceId->UpdateDeviceLicenseInfo(hardwareChangeState, sendTpmInfo)
TpmBaseServicesFunctions::GetDeviceTransportKey
hr = pNgcFunctions->NgcGetSymmetricPopKeyTransportKeyName( &accountInfo, nullptr, &keyType, keyFlags, &spTransportKeyName, pKeyStatus)
Microsoft Software Key Storage Provider
hr = GetProvider(kspProviderName, &spProviderHandle)
hr = HRESULT_FROM_NT(NCryptOpenKey( spProviderHandle, &spKeyHandle, spTransportKeyName, 0, NCRYPT_FLAGS))
PUBLICBLOB
hr = HRESULT_FROM_NT(NCryptExportKey( spKeyHandle, NULL, BCRYPT_PUBLIC_KEY_BLOB, nullptr, nullptr, 0, &transportKeyPublicSizeBytes, NCRYPT_FLAGS))
hr = spTransportKeyBlob.Allocate(transportKeyPublicSizeBytes)
hr = HRESULT_FROM_NT(NCryptExportKey( spKeyHandle, NULL, BCRYPT_PUBLIC_KEY_BLOB, nullptr, spTransportKeyBlob, transportKeyPublicSizeBytes, &transportKeyPublicSizeBytes, NCRYPT_FLAGS))
TpmBaseServicesFunctions::GetWindowsAIKCertChain
TpmBaseServicesFunctions::GetAttestationStatement
hr = HRESULT_FROM_NT(NCryptCreateClaim( hSubjectKey, hAuthorityKey, NCRYPT_CLAIM_SUBJECT_ONLY, nullptr, nullptr, 0, &attestationClaimSizeBytes, NCRYPT_FLAGS))
hr = spAttestationClaim.Allocate(attestationClaimSizeBytes)
hr = HRESULT_FROM_NT(NCryptCreateClaim( hSubjectKey, hAuthorityKey, NCRYPT_CLAIM_SUBJECT_ONLY, nullptr, spAttestationClaim, attestationClaimSizeBytes, &attestationClaimSizeBytes, NCRYPT_FLAGS))
hr = GetBasicProfileFolderPath( FOLDER_PROGRAM_DATA, NULL, aikLocation.GetBuffer(MAX_PATH + 1), MAX_PATH)
TpmBaseServicesFunctions::GetEKCert
PCP_EKCERT
hr = HRESULT_FROM_NT(NCryptGetProperty( spProviderHandle, NCRYPT_PCP_EKCERT_PROPERTY, reinterpret_cast<PBYTE>(&spCertStore), sizeof(spCertStore), &ekCertSizeBytes, NCRYPT_FLAGS))
hr = spEncodedCert.Allocate(spCertContext->cbCertEncoded)
hr = SafeCopyMemory(spEncodedCert, spCertContext->cbCertEncoded, spCertContext->pbCertEncoded, spCertContext->cbCertEncoded)
TpmBaseServicesFunctions::RevokeDeviceAttestationKey
hr = GetWindowsAIK(&spAikKeyHandle)
SmartCardKeyCertificate
hr = HRESULT_FROM_NT(NCryptSetProperty( spAikKeyHandle, NCRYPT_CERTIFICATE_PROPERTY, NULL, 0, NCRYPT_FLAGS))
hr = NgcTriggerTask(AikCertEnroll)
TpmBaseServicesFunctions::GetTpmKeyBlob
OpaqueKeyBlob
hr = HRESULT_FROM_NT(NCryptExportKey( hKey, NULL, BCRYPT_OPAQUE_KEY_BLOB, nullptr, spKeyBlob, keyBlobSizeBytes, &keyBlobSizeBytes, NCRYPT_FLAGS))
hr = spKeyBlob.Allocate(keyBlobSizeBytes)
hr = GetWindowsAIKLocation(aikLocation)
hr = HRESULT_FROM_NT(NCryptOpenKey( spProviderHandle, &spKeyHandle, WINDOWS_AIK, 0, NCRYPT_FLAGS | NCRYPT_MACHINE_KEY_FLAG))
DeviceLicenseFunctions::GetDeviceLicenseRequest
pcbBlobSize != nullptr
ppbLicenseRequest != nullptr
hr = ClipOpen(&spClipHandle)
hr = ClipGenerateDeviceLicenseRequest(spClipHandle, pcbBlobSize, ppbLicenseRequest)
pbLicenseBlob != nullptr
hr = ClipInstallLicense( spClipHandle, cbLicenseBlobSize, pbLicenseBlob, *pLicenseType, &associatedId)
(pbSignature != nullptr && pbHashValue != nullptr)
(cbSignatureLength != 0 && cbHashValue != 0)
hr = SPCallClepSign( pbHashValue, cbHashValue, pbSignature, cbSignatureLength)
DeviceLicenseFunctions::FormatDeviceLicenseRequest
hr = PPCRL_E_DEVICE_INVALID_HW_TFLV_BLOB
<DeviceInfo Id="DeviceInfo">
<Component name="
 error="
</Component>
</DeviceInfo>
DeviceLicenseFunctions::GenerateXmlSignature
!message.IsEmpty()
hr = LiteCryptUtilities::ComputeHash(reinterpret_cast<const BYTE*>(message.GetString()), message.GetLength(), nullptr, 0, 0, &spMessageDigest, &digestLen)
hr = SignHashWithDeviceKey( spMessageDigest, digestLen, signatureBytes.GetBufferSetLength(PPCRL_DEVICE_SIGNING_KEY_LENGTH), PPCRL_DEVICE_SIGNING_KEY_LENGTH)
hr = PassportEncode::Base64Encode(static_cast<void*>(signatureBytes), PPCRL_DEVICE_SIGNING_KEY_LENGTH, signature)
</SignatureValue></Signature>
http://www.w3.org/2000/09/xmldsig#rsa-sha1
PublishedServices
CStoredIdentity::AddKeywords
CStoredIdentity::RemoveKeywords
CStoredIdentity::RemoveAllKeywords
CStoredIdentity::Disassociate
CStoredIdentity::Associate
CStoredIdentity::RemoveService
CStoredIdentity::AddService
hr = SetProperty(eLocal, pszProperty, pszPropValue)
regStoredId.Flush failed with error=0x%x, continuing...
regIdKey.Flush() failed with error=0x%x, continuing...
CertGetCertificateContextProperty failed with hr=0x%x
CertHash
CStoredIdentity::RemoveFromCertStore
CertFindCertificateInStore failed with hr=0x%x
CStoredIdentity::WriteToCertStore
CertDeleteCertificateFromStore failed with hr=0x%x
CertAddCertificateContextToStore failed with hr=0x%x
hr = HRESULT_FROM_WIN32(returnValue)
EnumIdentities returned %Iu results.
EnumIdentities returned no results.
CSystemStore::ProcessNewDevice
hr = IsPublishing(&fPublishing)
CSystemStore::RemoveAllPublishedServices
fPublishing == TRUE
pRegCredsKey->Open failed with hr=0x%x
hr = pExecutionContext->CreateRegKey(&pRegCredsKey.m_p)
Ignoring bad data found by EnumKey
No identities to process
CreateRegKey failed with hr=0x%x
CRegKey::EnumKey failed with hr=0x%x
CRegKey::Open failed with hr=0x%x
CRegKey::SetValue failed with hr=0x%x
Failure - pRegCredsKey->SetDWORDValue, HRESULT: 0x%08X
tmpconfig.xml
https://go.microsoft.com/fwlink/?LinkId=859524
RemoteFileLink
\IdentityCRL\INT
\IdentityCRL\production
CONFIGDATA::SetOptions
NULL value specified for option id %d
No options were provided for initialization.
Deserialize IDCRL_OPTION_PROXY failed with error, hr=0x%x. 
IDCRL_OPTION_PROXY: Size of option value (%Iu bytes) exceeds max allowed %lu bytes.
Option IDCRL_OPTION_PROXY_PASSWORD. 
Processing option IDCRL_OPTION_PROXY_PASSWORD failed with error, hr=0x%x. 
Option IDCRL_OPTION_PROXY_USERNAME with value '%ls'. 
IDCRL_OPTION_PROXY_USERNAME: Size of option value (%Iu bytes) exceeds max allowed %Iu bytes.
Option IDCRL_OPTION_CONNECT_TIMEOUT with value %d. 
IDCRL_OPTION_CONNECT_TIMEOUT: Size of option value (%Iu) is not equal to size ofDWORD struct (%Iu)
Option IDCRL_OPTION_SEND_TIMEOUT with value %d. 
IDCRL_OPTION_SEND_TIMEOUT: Size of option value (%Iu) is not equal to size ofDWORD struct (%Iu)
Option IDCRL_OPTION_RECEIVE_TIMEOUT with value %d. 
IDCRL_OPTION_RECEIVE_TIMEOUT: Size of option value (%Iu) is not equal to size ofDWORD struct (%Iu)
Option IDCRL_OPTION_LCID with value %d. 
IDCRL_OPTION_LCID: Size of option value (%Iu) is not equal to size ofDWORD struct (%Iu)
Could not set IDCRL option (%d). hr=0x%x
Skipping unknown IDCRL option (%d). hr=0x%x
No options were provided to reset.
CONFIGDATA::ResetOptions
Set Internet access type = INTERNET_OPEN_TYPE_PRECONFIG
Processing option id %d
Set proxy username = ""
Set proxy password = ""
Set Send timeout = %d msec.
Set connect timeout = %d msec.
Reset LCID = %d.
Set Receive timeout = %d msec.
Could not reset IDCRL option (%d). hr=0x%x
Downloaded new config file version %ls. HR=%x.
CIdcrlDownloadManager::SetNewVersionAndDownload
Download called with newVersion=%ls
Unable to download new config file version %ls. HR=%x.
ClockSkew
Unable to open registry key '%ls', hr = %x.
QueryDWORDValue(PPCRL_REG_CLOCKSKEW) lRet = %x.
Unable to write registry key '%ls', hr = %x.
https://%ls
LoginUrl
!m_bInitialized
Failed query of environment: 0x%x
hr = DownloadAndReloadConfig()
ReadRegConfigURL loaded Configuration URL from registry
CoCreateInstance(CLSID_NetworkListManager) failed = 0x%x assuming network connectivity
ReadRegConfigURL failed with hr=%x. IDCRL will use production URL as default.
LastCopiedConfigVersion
.DEFAULT\Software\Microsoft\IdentityCRL\Environment
\Microsoft
Read empty version from config file.
Error creating location strings. 0x%x
%SettingsDrive%
Could not initialize download manager object
Getting config version failed with error 0x%x
Loading config data failed with error 0x%x
Config update is NOT needed.
Config update is needed.
get_IsConnectedToInternet failed = 0x%x; assuming network connectivity
Mozilla/4.0 (compatible; MSIE 5.01; Windows NT 5.0
Unable to generate user agent string 0x%x.
ReadFile HTTP_STATUS (0x%x).
URL: %ls
PPCRL_MAX_PROXY_PASSWORD: Size of option value (%Iu bytes) exceeds max allowed %Iu bytes.
IDCRL_OPTION_PROXY_PASSWORD: Size of option value (%Iu bytes) exceeds max allowed %Iu bytes.
\Environment\
Could not encrypt proxy password. HR=0x%x
CClientConfigDataCacheManager::ReadRegConfigURL
hr = Reg_QueryString( HKEY_LOCAL_MACHINE, wstrReg, c_wszRemoteFileLink, rRegConfigData.m_strConfigServer )
Unable to delete file '%ls'. HR=0x%x.
hr = Reg_QueryString( HKEY_LOCAL_MACHINE, wstrReg, c_wszRemoteFileLink, rRegConfigData.m_strEnterpriseConfigServer )
HRESULT_FROM_WIN32(GetLastError())
hr = LoadXMLFromString(resourceXML, &rpXMLConfigData)
Could not allocate memory for strVal. 0x%x
InternetCrackUrl failed for Config value: %ls, it may not be a URL. (0x%x)
m_pIClientConfig is nullptr
Could not create URL. 0x%x.
Could not query passport version. 0x%x
Version
Onebox
Could not open OneBox registry key '%ls'. 0x%x
\OneBox
Onebox mode not detected. dwOneBox=%d. 0x%x
pCertContext: 0x%p
Could not get port number for host '%ls'. 0x%x
GetIssuerCertificate: no certificates loaded
CClientConfigDataCacheManager::GetIssuerCertificate
IssuerCert Context=0x%p, IssuerCert SKI=%ls.
CertGetIssuerCertificateFromStore failed to get issuer from hCertStore=0x%p certificate with hr=0x%x
Failed CertDuplicateCertificateContext hr = %x
CertGetIssuerCertificateFromStore. Certificate failed the CERT_STORE_SIGNATURE_FLAG check. Trying next cert...
Could not find a good issuer cert.
CertVerifySubjectCertificateContext. Certificate failed the CERT_STORE_TIME_VALIDITY_FLAG check. 0x%x. Trying next cert..
hr = ::DeleteAllCertificatesFromCertStore(hCertStore)
CertCreateCertificateContext failed with hr=0x%x
DeviceKeyBindingEnabled
GetRegistryKeyPath returned null, treating like user id key attestation enabled
strUserAgent: %hs, dwAccessType 0x%x
InternetOpen failed (hr = 0x%x). Proxy: %hs, bypass: %hs, accesstype: %d.
HTTPRequest::Open
receive
connect
resolve
Unable to set %ls timeout - InternetSetOption failed (0x%x).
Configured %ls timeout is %d ms.
HTTPRequest::RequestUrl
strUrl: %ls
wstrUrl: %ls
Opening Internet connection in WinInet.
HTTPRequest::RequestUrlHelper
HRESULT_FROM_WIN32(ERROR_WINHTTP_SECURE_FAILURE)
InternetCrackUrlA failed (0x%x) for URL: %ls.
InternetConnect failed 0x%x.
Unable to set INTERNET_OPTION_PROXY_USERNAME - InternetSetOption failed (0x%x).
HttpOpenRequest failed 0x%x
SendRequestAndReceiveResponse('%ls') failed (0x%x).
Unable to set INTERNET_OPTION_PROXY_PASSWORD - InternetSetOption failed (0x%x).
HttpQueryInfo returned status: %d.
WinHttpQueryHeaders failed 0x%x.
No data
HttpQueryInfo failed (0x%x).
WinHttpQueryDataAvailable failed 0x%x
HTTPRequest::ReadFile
InternetReadFile failed (0x%x).
SaveDownloadedConfig
Initializing cryptographic provider...
Unable to initialize cryptographic provider 0x%x.
EnterpriseWLIDSTS_WCF
Could not get WLID_AUTHURL from config. 0x%x
DeviceChangeService
Could not get Enterprise WLID_AUTHURL from config. 0x%x
EnterpriseDeviceChangeService
Could not get DeviceChangeService from config. 0x%x
DeviceAddService
Could not get EnterpriseDeviceChangeService from config. 0x%x
EnterpriseDeviceAddService
Could not get DeviceAddService from config. 0x%x
DeviceRemoveService
Could not get EnterpriseDeviceAddService from config. 0x%x
EnterpriseDeviceRemoveService
Could not get DeviceRemoveService from config. 0x%x
GetUserKeyDataService
Could not get EnterpriseDeviceRemoveService from config. 0x%x
ManageLoginKeys
Could not get GetUserKeyDataService from config. 0x%x
ManageApprover
Could not get ManageLoginKeys from config. 0x%x
ListSessions
Could not get ManageApprover from config. 0x%x
ApproveSession
Could not get ListSessions from config. 0x%x
GetAppDataService
Could not get ApproveSession from config. 0x%x
DeviceAssociateService
Could not get GetAppDataService from config. 0x%x
EnterpriseDeviceAssociateService
Could not get DeviceAssociateService from config. 0x%x
DeviceDisassociateService
Could not get EnterpriseDeviceAssociateService from config. 0x%x
EnterpriseDeviceDisassociateService
Could not get DeviceDisassociateService from config. 0x%x
DeviceUpdateService
Could not get EnterpriseDeviceDisassociateService from config. 0x%x
EnterpriseDeviceUpdateService
Could not get DeviceUpdateService from config. 0x%x
DeviceQueryService
Could not get EnterpriseDeviceUpdateService from config. 0x%x
EnterpriseDeviceQueryService
Could not get DeviceQueryService from config. 0x%x
DeviceEnumerateService
Could not get EnterpriseDeviceQueryService from config. 0x%x
EnterpriseDeviceEnumerateService
Could not get DeviceEnumerateService from config. 0x%x
ResolveUserService
Could not get EnterpriseDeviceEnumerateService from config. 0x%x
EnterpriseResolveUserService
Could not get ResolveUserService from config. 0x%x
OTCRequestService
Could not get EnterpriseResolveUserService from config. 0x%x
Initializing TLS...
Could not get OTCRequestService from config. 0x%x
Failure - unrolling initialization. 0x%x
Uninitializing cryptographic provider...
Unable to close mutex for device provisioning 0x%x.
CryptAcquireContext failed with CRYPT_SILENT flag - trying without.
Initialized Crypt provider: %S, provider type: %d
Could not get default STS URL from config data.
WinHttpCrackUrl failed for STS URL: %ls. (0x%x)
CPPCRLRequest::SignRequestCommon
CPPCRLRequest::SignRequestWithHardwareKey
"/></wsse:SecurityTokenReference>
<wsse:SecurityTokenReference><wsse:Reference URI="
hr = PassportEncode::Base64Encode( reinterpret_cast<void*>(randomByte), sizeof(randomByte), randomBase64)
<wsse:SecurityTokenReference><wsse:Reference URI="#SignKey"/></wsse:SecurityTokenReference>
</wssc:Nonce></wssc:DerivedKeyToken>
hr = PassportEncode::Base64Encode(spSignatureBlob, signatureBlobSizeBytes, encodedSignature)
hr = pNgcFunctions->NgcSignWithSymmetricPopKey( m_spAuthSessionKey.GetBuffer(), m_spAuthSessionKey.GetLength(), reinterpret_cast<const BYTE*>(LiteCryptUtilities::SeedLabel::SecureConversationRst2), static_cast<DWORD>(strlen(LiteCryptUtilities::SeedLabel::SecureConversationRst2) * sizeof(CHAR)), randomByte, sizeof(randomByte), reinterpret_cast<const BYTE*>(signedInfo.GetString()), signedInfo.GetLength() * sizeof(CHAR), &spSignatureBlob, &signatureBlobSizeBytes)
Session key sign failure 0x%x
https
CPPCRLRequest::GetAddressingHeader
http://schemas.xmlsoap.org/ws/2005/02/trust/RST/Issue
<wsa:Action s:mustUnderstand="1">%s</wsa:Action><wsa:To s:mustUnderstand="1">%s://%S:%d%S</wsa:To><wsa:MessageID>%I64u</wsa:MessageID>
<ps:HostingApp>
</ps:HostingApp>
{00000000-0000-0000-0000-000000000000}
<ps:IsWebFlow>1</ps:IsWebFlow>
<ps:UIVersion>1</ps:UIVersion>
<ps:ShowSkipFRFS>1</ps:ShowSkipFRFS>
<ps:IsFRFS>1</ps:IsFRFS>
InlineUX Override is: '%ls'
RemoteSilent
<ps:InlineUX>%hs</ps:InlineUX>
InlineUX Override is invalid: '%ls'
</ps:InlineUX>
<ps:InlineUX>
Configured InlineUX is invalid: '%hs'
</ps:Telemetry>
<ps:Telemetry>
Software\Microsoft\Windows\CurrentVersion\AccountPicture
AppsReadAccess
<ps:IsConnected>1</ps:IsConnected>
<ps:ConsentFlags>1</ps:ConsentFlags>
<ps:InlineFT>%s</ps:InlineFT>
<ps:IsAdmin>1</ps:IsAdmin>
xbox-app://
PackageSID
<ps:%s>
ClientAppURI
Sending identity cookies.
</ps:%s>
<ps:Cookies>
Unable to SerializeCookies (0x%x).
Sending request parameters.
</ps:Cookies>
<ps:RequestParams>
Unable to SerializeRequestParams (0x%x).
<ps:WindowsClientString>
</ps:RequestParams>
LicenseSignatureKeyVersion %d
</ps:WindowsClientString>
<ps:ClientCapabilities>1</ps:ClientCapabilities>
<ps:LicenseSignatureKeyVersion>%d</ps:LicenseSignatureKeyVersion>
no attribute - %s:%x
<S:Envelope 
<SOAP:Envelope 
</S:Envelope>
<Envelope 
</SOAP:Envelope>
<s:Envelope 
</Envelope>
<soap:Envelope 
</s:Envelope>
<DeviceUpdateResponse 
</soap:Envelope>
<DeviceAddResponse 
</DeviceUpdateResponse>
<DeviceCloseResponse 
</DeviceAddResponse>
</DeviceCloseResponse>
XML load for response failed (0x%x).
Error in response header, check internal error in the body. 0x%x
Get request status 0x%x.
RequestSecurityTokenResponse
Signature verification failed or /Envelope/Body//RequestSecurityTokenResponse was not found. (hr=0x%x).
Unknown token type found: '%s'
PutCert failed (0x%x).
Could not get next RSTR node (0x%x).
No token bag for identity.
SetApplicableCookies failed (0x%x).
Could not persist pending credential, this is not a critical error, ignoring... (hr = 0x%x)
TriggerNewFilesDownload failed (0x%x).
hr = ParseNumericHResult( pXmlInternalErr, k_bstrSoapFaultInternalErrorCode, hrServerInternal )
hr = GetXMLNodeText(pXmlInternalErr, k_bstrSoapFaultInternalErrorText, bstrErrText)
Missing EndPointAddress %x
Token applies to missing:%x
Unexpected error: pxmlToken is NULL. 0x%x
Missing TokenType %x
BinarySecurityToken get_text failed (0x%x).
Missing expires time %x
Missing created time %x
Failed to parse expires time: %s, %x
Failed to parse created time: %s, %x
hr = m_pIdentity->GetCredProperty(PPCRL_CREDPROPERTY_CID, accountCid)
hr = ExtractSessionKey(serviceExecutionContext, pxmlnTokenResponse, sessionKey)
hr = GetEncryptedSessionKey(pxmlnTokenResponse, accountCid, bpSessionKey, sessionKeyType)
CAuthRequest::GetEncryptedSessionKey
hr = pXmlnEncryptedKey->get_text(&bstrEncryptedKey)
hr = pXmlnTokenResponse->selectSingleNode(k_bstrRSTREncryptedKey, &pXmlnEncryptedKey)
hr = PassportEncode::Base64Decode(strEncodedSessionKey, strDecodedSessionKey)
hr = ConvertW2A(bstrEncryptedKey, strEncodedSessionKey)
hr = webCookieManager.WriteCookieData(hIdentity)
hDeviceIdentity != nullptr
CPPCRLBaseRequest::GetDeviceOneTimeToken
hr = GetOneTimeToken(hNewDeviceIdentity, strAuthToken)
hr = DeviceIdHelpers::HandleRenewDeviceId(&serviceExecutionContext, g_szStrongAuthAppId, hDeviceIdentity->GetUserType(), 0, hDeviceIdentity, hNewDeviceIdentity, nullptr, nullptr)
CPPCRLBaseRequest::GetOneTimeToken
hr = GetOneTimeToken(hDeviceIdentity, strAuthToken)
<wsse:BinarySecurityToken ValueType="urn:liveid:device" id="DeviceDAToken">
<ps:OneTimeCredentials xmlns:ps="http://schemas.microsoft.com/Passport/SoapServices/PPCRL">
<wsse:SecurityTokenReference> <wsse:Embedded wsu:Id="DeviceDAToken">%hs%ls%hs</wsse:Embedded></wsse:SecurityTokenReference>
<wsse:BinarySecurityToken ValueType="urn:liveid:user" id="UserDAToken">
</ps:OneTimeCredentials>
</wsse:BinarySecurityToken>
<wsse:BinarySecurityToken id="UserDAToken">
Response contained RequestStatus of 0x%x.
CPPCRLRequest::ParsePassportHeaderIfPresent
SetClockSkew failed. HR = 0x%x.
Response contained AuthState of 0x%x.
Response contained error URL '%ls'.
Could not read ServerTime attribute of psf:serverInfo node. HR=0x%x.
Response contained endauthURL '%ls'.
Response contained authURL '%ls'.
Response contained AuthRequired of 0x%x.
Response contained webURL '%ls'. Overriding endAuthURL.
Base64Decode failed (0x%x).
Response included request cookie collection.
Response included response parameters.
DeserializeCookies failed (0x%x).
GlobalDeviceUpdateTime
DeserializeResponseParams failed (0x%x).
Could not read next psf:credProperty node from response. hr=0x%x.
Property PWID cannot be returned to caller.
Could not set cred property name: '%ls', value: '%ls'. hr=0x%x.
hr = m_pIdentity->UpdateSystemStoreProperties(CredProp)
Processing psf:browserCookie node '%s'.
Could not read next psf:browserCookie node from response. hr=0x%x.
Could not read value of psf:browserCookie node '%s'. hr=0x%x.
Could not get URL attribute of psf:browserCookie node '%s'. hr=0x%x.
Could not get Name attribute of psf:extProperty node '%ls'. hr=0x%x.
Could not set ext property name: '%ls', value: '%ls'. hr=0x%x.
SetExtProperty Failed but trying to set cookie
hr = PPCRL_REQUEST_E_RSTR_FAULT
Response contained error URL '%s' .
hr = pXmlRSTRNode->selectSingleNode(xmlFaultUrlPath, &pFaultUrlNode)
hr = ParseFaultUrl(pxmlRSTRNode, k_bstrRSTRErrorURLPath, wstrFlowUrl)
hr = ParseFaultUrl(pxmlRSTRNode, k_bstrRSTRErrorEndAuthURLPath, endAuthUrl)
hr = ParseFaultUrl(pxmlRSTRNode, k_bstrRSTRErrorAuthURLPath, authUrl)
hr = ParseNumericHResult(pxmlRSTRNode, k_bstrRSTRRequestStatusPath, hrRequestStatus)
hr = ParseNumericHResult(pxmlRSTRNode, k_bstrRSTRAuthRequiredPath, hrAuthRequired)
hr = ParseFaultUrl(pxmlRSTRNode, k_bstrRSTRErrorWebURLPath, webUrl)
Response contained requestStatus of 0x%x.
hr = CopyDAFromDefaultIdentity(pDeviceIdentity)
hr = BuildRequestEx(wszAuthData, requestFlags, dwRequestCount, rgRequests)
<wsse:BinarySecurityToken ValueType="urn:liveid:sha1device" id="DeviceDAToken">
CPPCRLRequest::AppendSignedDeviceDaTokenToRequestXml
CPPCRLRequest::AppendDeviceDaTokenToRequestXml
#DeviceDAToken
hr = DeviceIdHelpers::GetDeviceAuthToken(flags, token, deviceAuthToken, refreshTokenIfNeeded)
rgRequestsOut.SetCount(dwRequestCount)
requests.SetCount(requestCount)
#RST0
Not sending SLC request for service target '%s' because REQUEST_NO_SLC is set.
BuildCertRST failed (0x%x).
Time skew: Request failed with a resendable error 0x%x after %u retries.
hr = StringCchCopyW(*ppResponseString, inputString.GetLength()+1, inputString)
hr = CopyResponseString(&rgResponses[i].wszAuthChallenge, wszFlowUrl)
Could not get CID for this ID handle, even though it is marked linked. 0x%x
hr = CopyResponseString(&rgResponses[i].wszInlineEndAuthUrl, endAuthUrl)
hr = CopyResponseString(&rgResponses[i].wszInlineAuthUrl, authUrl)
g_pPPCRL->GetNegativeCacheManager()->UpdateNegativeCache( m_rgRequests[i].wszServiceTarget, m_rgRequests[i].wszServicePolicy, rgResponses[i].hrRequestStatus, m_pIdentity, (!m_pIdentity->GetAuthUrl().IsEmpty() || !m_pIdentity->GetEndAuthUrl().IsEmpty() || !authUrl.IsEmpty() || !wszFlowUrl.IsEmpty()))
hr = StringCchCopyW(rgResponses[i].wszToken, wstrCert.GetLength()+1, wstrCert)
hr = PassportEncode::Base64Encode(pCertCtxt->pbCertEncoded, pCertCtxt->cbCertEncoded, strCert)
hr = StringCchCopyW(rgResponses[i].wszToken, tokenBlob.GetLength() + 1, tokenBlob)
hr = StringCchCopyW(rgResponses[i].wszCID, wstrCID.GetLength()+1, wstrCID)
hr = SafeCopyMemory(rgResponses[i].pbSessionKey, bpSessionKey.GetLength(), bpSessionKey.GetBuffer(), bpSessionKey.GetLength())
hr = StringCchCopyW(rgResponses[i].wstrTokenURI, token.GetTokenURI().GetLength()+1, token.GetTokenURI())
hr = StringCchCopyW(rgResponses[i].wstrKeyPair, token.GetKeyPair().GetLength()+1, token.GetKeyPair())
g_pPPCRL->GetNegativeCacheManager()->UpdateNegativeCache( m_rgRequests[i].wszServiceTarget, m_rgRequests[i].wszServicePolicy, rgResponses[i].hrRequestStatus, m_pIdentity, (!m_pIdentity->GetAuthUrl().IsEmpty() || !m_pIdentity->GetEndAuthUrl().IsEmpty()))
hr = StringCchCopyW(rgResponses[i].tokenResponseData, tokenResponseData.GetLength() + 1, tokenResponseData)
m_pIdentity->GetCredBag()->ResetDefaultCredSavedProperty(&executionContext, PPCRL_CREDPROPERTY_VALUE_CREDS_INVALID)
DefaultCredsInvalid
"><wst:RequestType>http://schemas.xmlsoap.org/ws/2005/02/trust/Issue</wst:RequestType><wsp:AppliesTo><wsa:EndpointReference><wsa:ServiceName>
CPPCRLRequest::BuildCertRST
</wsse:BinarySecurityToken></wst:Supporting><wsp:PolicyReference URI="
</wsa:ServiceName></wsa:EndpointReference></wsp:AppliesTo><wst:Supporting><wsse:BinarySecurityToken ValueType="http://schemas.microsoft.com/Passport/SoapServices/PPCRL#PKCS10" EncodingType="wsse:Base64Binary">
CreatePKCS10Base64 failed (0x%x).
"></wsp:PolicyReference></wst:RequestSecurityToken>
CPPCRLRequest::GetServiceEndpoint
## Sending to request WLID
##TestHook: Logon_Request_WLIDSTS
hr = m_pIdentity->GetCredBag()->RetrieveCredential(PPCRL_CREDTYPE_NGCKEYNAME, userIdKeyName, TRUE)
hr = ComputeServerKeyId( spUserIdKeyPublic, userIdKeyPublicSizeBytes, serverKeyId)
hr = pNgcFunctions->NgcGetUserIdKeyPublicKey( userIdKeyName, &spUserIdKeyPublic, &userIdKeyPublicSizeBytes)
hr = LiteCryptUtilities::GetPublicKeyComponents( spTransportKeyPublic, transportKeyPublicSizeBytes, &spExponent, &exponentSizeBytes, &spModulus, &modulusSizeBytes)
hr = pNgcFunctions->NgcGetSymmetricPopKeyTransportKey( &accountInfo, nullptr, nullptr, keyTypeRequsted, &spTransportKeyPublic, &transportKeyPublicSizeBytes, &spAttestation, &attestationSizeBytes, &spAikCert, &aikCertSizeBytes, &keyTypeActual)
hr = Base64UrlEncodeWithNoPadding(spModulus, modulusSizeBytes, transportKeyModulus)
hr = Base64UrlEncodeWithNoPadding(spExponent, exponentSizeBytes, transportKeyExponent)
hr = PassportEncode::Base64Encode( spAikCert, aikCertSizeBytes, encodedCert)
hr = PassportEncode::Base64Encode( spAttestation, attestationSizeBytes, encodedClaim)
,"attk":"
,"request_nonce":"
,"attb":"
hr = Base64UrlEncodeWithNoPadding(jwtPayload, encodedJwsPayload)
hr = GetMessageForPinPrompt( pServiceExecutionContext, m_pIdentity, messageForPinPrompt)
No window handle and no ngc ticket either. hr = 0x%x
hr = pNgcFunctions->NgcSignWithUserIdKeyEx( userIdKeyName, reinterpret_cast<const BYTE*>(jwtToken.GetString()), jwtToken.GetLength() * sizeof(CHAR), m_windowHandle, messageForPinPrompt.GetString(), ngcCredProviderFlags, &spEncryptedJwsPayload, &encryptedJwsPayloadSizeBytes)
hr = pNgcFunctions->NgcSignWithUserIdKeySilent( userIdKeyName, ngcTicketToken, reinterpret_cast<const BYTE*>(jwtToken.GetString()), jwtToken.GetLength() * sizeof(CHAR), &spEncryptedJwsPayload, &encryptedJwsPayloadSizeBytes)
hr = HRESULT_FROM_WIN32(ERROR_INVALID_WINDOW_HANDLE)
<wsse:BinarySecurityToken EncodingType="ps:JWT" ValueType="ps:LoginKeyToken" Id="LoginKeyToken">
hr = Base64UrlEncodeWithNoPadding( spEncryptedJwsPayload, encryptedJwsPayloadSizeBytes, jwsPayload)
hr = pNgcFunctions->NgcDecryptWithSymmetricPopKey( m_spAuthSessionKey.GetBuffer(), m_spAuthSessionKey.GetLength(), reinterpret_cast<const BYTE*>(LiteCryptUtilities::SeedLabel::SecureConversationRst2), static_cast<DWORD>(strlen(LiteCryptUtilities::SeedLabel::SecureConversationRst2) * sizeof(CHAR)), reinterpret_cast<const BYTE*>(decodedNonce.GetString()), decodedNonce.GetLength() * sizeof(CHAR), reinterpret_cast<const BYTE*>(initializationVector.GetString()), initializationVector.GetLength() * sizeof(CHAR), reinterpret_cast<const BYTE*>(decodedCipherText.GetString()), decodedCipherText.GetLength() * sizeof(CHAR), &spDecryptedBlob, &decryptedBlobSizeBytes)
hr = PassportEncode::Base64Decode(static_cast<BSTR>(cipherText), cipherText.Length(), decodedCipherText)
hr = sessionKeyManager.DecryptWithSessionKey( serviceExecutionContext.GetSessionKeyExecutionContext(), SessionKey(m_spAuthSessionKey, m_sessionKeyType), CBytePtr(reinterpret_cast<PBYTE>(decodedNonce.GetBuffer()), decodedNonce.GetLength(), false), CStringA(LiteCryptUtilities::SeedLabel::SecureConversationRst2), PPCRL_NGC_DERIVED_KEY_LENGTH_BYTES, initializationVector, decodedCipherText, derivedKeyAlgorithm, clearText)
hr = SafeCopyMemory( clearText.GetBufferSetLength(decryptedBlobSizeBytes), decryptedBlobSizeBytes, spDecryptedBlob, decryptedBlobSizeBytes)
strText.GetLength() > 0
hr = LoadXMLDocumentFromString(strText, cvNamespaces, pDOMXml)
Configured DeviceType is invalid: '%hs'
Could not parse '%s' as time
keyPublicSizeBytes > 0
Could not save clock skew. hr = 0x%x
pKeyPublic != nullptr
CPPCRLBaseRequest::ComputeServerKeyId
hr = SafeCopyMemory( spKeyId, keyIdSizeBytes, spExponent, exponentSizeBytes)
hr = LiteCryptUtilities::GetPublicKeyComponents( pKeyPublic, keyPublicSizeBytes, &spExponent, &exponentSizeBytes, &spModulus, &modulusSizeBytes)
hr = LiteCryptUtilities::ComputeHash( spKeyId, keyIdSizeBytes, nullptr, 0, 0, &spHashBlob, &hashBlobSizeBytes)
hr = SafeCopyMemory( spKeyId + exponentSizeBytes, modulusSizeBytes, spModulus, modulusSizeBytes)
hr = LiteCryptUtilities::Base64EncodeA(pBlob, blobSizeBytes, &base64EncodedBlob)
hr = Base64UrlEncodeWithNoPadding(spHashBlob, hashBlobSizeBytes, keyId)
hr = PassportEncode::Base64Encode(strToEncode, strEncoded)
CPPCRLBaseRequest::Base64UrlEncodeWithNoPadding
hr = pSessionSecretNode->get_text(&bstrSessionSecret)
urn:liveid:clepkey
bstrSessionSecret.Length() > 0
hr = sessionKeyManager.ImportSessionKey( pSessionKeyExecutionContext, pIdentityWrapper->GetIdentityName(m_pIdentity), identityCid, strDecodedSessionKey, sessionKey)
hr = ConvertW2A(bstrSessionSecret, strEncodedSessionKey)
##TestHook: Logon_Request_Add_Password
CAuthRequest::GetRequestAuthToken
<wsse:UsernameToken wsu:Id="user"><wsse:Username>
## Adding password to the auth request
</wsse:Username><wsse:Password>
</wsse:Username>
</wsse:SingleUseCode>
</wsse:Username><wsse:SingleUseCode>
<wsse:SecurityTokenReference><wsse:KeyIdentifier ValueType="ps:LoginKeyToken" EncodingType="#Base64Binary">NGCNonce</wsse:KeyIdentifier></wsse:SecurityTokenReference>
hr = AppendDeviceDaTokenToRequestXml(&serviceExecutionContext, strAuthToken, strTokenId, false )
hr = AppendLoginKeyTokenToRequestXml(&serviceExecutionContext, strAuthToken, NGC_DISPLAY_ALT_CRED_OPTION)
hr = GetOneTimeToken(m_pIdentity, oneTimeToken, true)
Error 0x%x mapped to 0x%x
hr = CPPCRLRequest::ParseResponse(pResponse, responseSizeCharacters, errorCategory, updateTpmKeyState)
Could not retrieve certificate PIN. hr=0x%x
CAuthRequest::GetRequestEIDAuthToken
BuildCertToken failed with hr=0x%x
GetCertContext failed with hr=0x%x
CAuthRequest::ValidateAndCopyRequests
CAuthRequest::VSig_Decrypt_GetRSTR
hr = AddDATokenRequest(rgRequestsOut)
hr = CPPCRLRequest::ValidateAndCopyRequests( dwRequestCount, rgRequests, rgRequestsOut)
Base64Decode failed for the thumbprint. hr=0x%x.
CAuthRequest::GetClientCert
CryptContextAddRef failed with hr=0x%x
CertSetCertificateContextProperty failed with hr=0x%x
Auth request failed with error = 0x%x
CAuthRequest::ShouldResendRequest
Request failed with a resendable error 0x%x after %u retries.
Missing timestamp %x
Missing bstrEncPPXML %x
No Signed Info %x
Missing RSTR %x
signature value node is not found %x
Reference timestamp is missing:%x
Reference RSTR is missing:%x
Reference EncryptedPP is missing:%x
keyinfo/securityTokenReference/Reference URI not found %x
SigKey derived key token missing:%x
SigKey nounce missing:%x
SigKey nounce is missing:%x
hr = PassportEncode::Base64Decode(encodedSignature, rawSignature)
failed to decode nonce for sig key:%x
hr = sessionKeyManager.VerifySignatureWithSessionKey( serviceExecutionContext.GetSessionKeyExecutionContext(), SessionKey(m_spAuthSessionKey, m_sessionKeyType), CBytePtr(reinterpret_cast<PBYTE>(strDecodedNonce.GetBuffer()), strDecodedNonce.GetLength(), false), CStringA(LiteCryptUtilities::SeedLabel::SecureConversationRst2), PPCRL_NGC_DERIVED_KEY_LENGTH_BYTES, signedInfo, encodedSignature, derivedKeyAlgorithm)
hr = pNgcFunctions->NgcVerifyWithSymmetricPopKey( m_spAuthSessionKey.GetBuffer(), m_spAuthSessionKey.GetLength(), reinterpret_cast<const BYTE*>(LiteCryptUtilities::SeedLabel::SecureConversationRst2), static_cast<DWORD>(strlen(LiteCryptUtilities::SeedLabel::SecureConversationRst2) * sizeof(CHAR)), reinterpret_cast<const BYTE*>(strDecodedNonce.GetString()), strDecodedNonce.GetLength() * sizeof(CHAR), reinterpret_cast<const BYTE*>(signedInfo.GetString()), signedInfo.GetLength() * sizeof(CHAR), reinterpret_cast<const BYTE*>(rawSignature.GetString()), rawSignature.GetLength() * sizeof(CHAR))
EncKey derived key token missing:%x
hr = xmlSig.CheckDigestedReferences()
EncKey nounce is missing:%x
EncKey nounce missing:%x
failed to decrypt ppheader:%x
Cipher value is missing for ppheader:%x
failed to parse decrypted pp header as xml:%x
Base64 decrypted Header:%hs
Cipher value is missing:%x
failed to ppHeaderDoc.QueryInterface as xml:%x
Base64 decrypted RSTR:%hs
CServiceRequest::GetCIDNode
missing RequestSecurityTokenResponse node:%x
CID is not set for linked service token request. hr=0x%x
hr = m_pIdentity->GetCredProperty(PPCRL_CREDPROPERTY_CID, wstrCID)
</ps:CID>
<ps:CID>
Updating DA token for linked handles
CServiceRequest::UpdateDATokenForLinkedIdentities
CDeviceAuthRequest::GetRequestAuthToken
CDeviceAuthRequest::ValidateAndCopyRequests
<wsse:BinarySecurityToken ValueType="ps:DeviceXToken" EncodingType="ps:JWT" Id="devicesoftware">
hr = MsaDevice_GetDeviceAuthXToken(&deviceAuthToken)
m_pIdentity != NULL
#devicesoftware
hr = m_pIdentity->GetCredBag()->RetrieveCredential(PPCRL_CREDTYPE_PASSWORD, devicePassword)
CDeviceAuthRequest::GetSystemDeviceOneTimeCredential
</wsse:Password></wsse:UsernameToken>
hr = pServiceWrapper->IsCallerAccountType(SECURITY_LOCAL_SYSTEM_RID, isSystemContext)
Sending DeviceIDs with authentication is disabled by configuration.
Failed to revert to System context, possibly already not impersonating.
Currently running in system context, will not attempt to include a System device DAToken.
hr = pIdentityWrapper->GetOneTimeCredential( hSystemDeviceId, 0, NULL, NULL, NULL, NULL, CStringW(), systemDeviceOneTimeCredential, NULL )
hr = pServiceWrapper->RetrieveDeviceID( g_szStrongAuthAppId, 0, NULL, IDCRL_DEVICE_ID_GET_VALID_DA_TOKEN, NULL, NULL, NULL, hSystemDeviceId )
Unable to store status for '%ls'. hr=0x%x.
CPPCRLRequest::SetStatusForEachResource
<Puid>
CManagementBaseRequest::GetCredentials
GetRawPUIDFromCert failed with 0x%x. bailing out of BuildRequest
InternalRetrieveDeviceCert failed with 0x%x. bailing out of BuildRequest
</Puid>
hr = ConvertW2A(wszPUID, strPUID)
</Membername>
<Membername>
<Password>
hr = m_pIdentity->GetCredBag()->RetrieveCredential(PPCRL_CREDTYPE_PASSWORD, wstrSymmetricCred)
CManagementBaseRequest::Send
</Password>
CHardwareDeviceRequest::GetHardwareInfo
CAddCredentialRequest::BuildRequest
CHardwareDeviceRequest::GetTpmInfo
Device License request generation failed with error value:%x
CHardwareDeviceRequest::GetCredentials
TPM Info generation failed with error value:%x
<DAToken>
hr = m_pIdentity->GetOneTimeCredential( 0, NULL, NULL, NULL, NULL, CStringW(), systemDeviceOneTimeCredential, NULL )
hr = CManagementBaseRequest::GetCredentials(usePuid, isSystemDID, credentialXml)
</DAToken>
CUpdateDeviceRequest::BuildRequest
hr = BuildRequestInternal(false, false)
CUpdateDeviceLicenseRequest::BuildRequest
CUpdateDeviceLicenseRequest::GetCredentials
m_bInitialized == true
CUpdateDeviceLicenseRequest::BuildRequestInternal
hr = GetHardwareInfo(&serviceExecutionContext, hardwareInfoXml)
hr = GetCredentials(fUsePUID, fIsSystemDID, credentialXml)
<DeviceInfo xmlns="http://schemas.microsoft.com/Passport/SoapServices/PPCRL"
hr = GetTpmInfo(&serviceExecutionContext, tpmInfoXml)
hr = SignRequest(&serviceExecutionContext, hardwareInfoXml, signature)
<DeviceInfo
<ps:AuthInfo><ps:BinaryVersion>
</wsse:Security>
<ps:LicenseInstallError>%d</ps:LicenseInstallError>
</ps:BinaryVersion></ps:AuthInfo>
<HardwareChangeState>%d</HardwareChangeState>
</s:Header><s:Body><DeviceUpdatePropertiesRequest xmlns="http://schemas.microsoft.com/Passport/SoapServices/PPCRL" version="2.0">
</DeviceUpdatePropertiesRequest></s:Body></s:Envelope>
<LicenseKeySequence>%d</LicenseKeySequence>
CUpdateDeviceLicenseRequest::GetHardwareInfo
hr = EncryptRequest(strRequest)
hr = CManagementBaseRequest::GetHardwareInfo(pServiceExecutionContext, hardwareInfo)
_sendHwdInfoInRequest
_sendTpmInfoInRequest == true
CUpdateDeviceLicenseRequest::GetTpmInfo
hr = CManagementBaseRequest::GetTpmInfo(pServiceExecutionContext, tpmInfo)
#DeviceInfo
CManagementBaseRequest::BuildRequestInternal
 Device sign failure 0x%x. Request Status 0x%x
<ClientInfo name="IDCRL" version="1.0"><BinaryVersion>
<Authentication>
</BinaryVersion></ClientInfo>
<OldMembername>
</Authentication>
<ReprovisionReason>%d</ReprovisionReason>
</OldMembername>
</NewMembername>
<NewMembername>
</NewPassword>
<NewPassword>
</%s>
<wsse:Security xmlns:wsse="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd">
hr = deviceLicenseFunctions->GetDeviceLicenseRequest(&cbDeviceLicenseReqSize, &spDeviceLicenseReq)
CManagementBaseRequest::GetHardwareInfo
Error in hardware collection and formatting 0x%x
hr = deviceLicenseFunctions->FormatDeviceLicenseRequest(cbDeviceLicenseReqSize,spDeviceLicenseReq, hardwareInfo)
_sendHwdInfoInRequest == true
CManagementBaseRequest::GetTpmInfo
hr = tpmFunctions->GetDeviceTransportKey( pServiceExecutionContext, &spTransportKeyPublic, &transportKeyPublicSizeBytes, &spTransportKeyHandle, &ngcKeyType)
DeviceIdHelpers::IsDeviceTPMEnabled() == true
hr = LiteCryptUtilities::GetPublicKeyComponents( spTransportKeyPublic, transportKeyPublicSizeBytes, &spTransportKeyExponent, &transportKeyexponentSize, &spTransportKeyModulus, &transportKeyModulusSize)
ngcKeyType != UnknownError
hr = PassportEncode::Base64Encode(spTransportKeyModulus, transportKeyModulusSize, transportKeyModulus)
hr = PassportEncode::Base64Encode(spTransportKeyExponent, transportKeyexponentSize, transportKeyExponent)
hr = tpmFunctions->GetTpmKeyBlob(spTransportKeyHandle, &spTransportKeyBlob, &transportKeyBlobSize)
hr = PPCRL_E_DEVICE_NOT_ABLE_TO_ATTEST_TPM
<TPMInfo><KeyValue><RSAKeyValue>
hr = PassportEncode::Base64Encode(spTransportKeyBlob, transportKeyBlobSize, transportKeyBlob)
<Exponent>%hs</Exponent>
<Modulus>%hs</Modulus>
<StorageKeyBlob>%hs</StorageKeyBlob>
</RSAKeyValue>
CManagementBaseRequest::GetTpmAttestationInfo
</KeyValue></TPMInfo>
hr = PassportEncode::Base64Encode(spAttestationClaim, attestationClaimSizeBytes, encodedAttestationClaim)
hr = PassportEncode::Base64Encode(spAikCertChain, aikCertChainSizeBytes, encodedAikCertChain)
hr = PassportEncode::Base64Encode(spEkCert, ekCertSizeBytes, encodedEkCert)
hr = tpmFunctions->GetEKCert(&spEkCert, &ekCertSizeBytes)
<KeyAttestationBlob>%hs</KeyAttestationBlob>
<KeyAttestationCertChain>%hs</KeyAttestationCertChain>
CManagementBaseRequest::UpdateCredentialState
<EndorsementKey>%hs</EndorsementKey>
SystemDeviceId SetLicenseInstallError 0x%x
hr = m_pIdentity->QueryInterface(EDeviceIdentityType, reinterpret_cast<void**>(&pSystemDeviceIdObj))
SystemDeviceId SetLicenseKeyVersionClient %d
SystemDeviceId SetLicenseKeySequenceServer %d
TPM MSA server state change %d -> %d, client state: %d
GlobalDeviceId
CManagementBaseRequest::ParseResponse
WNF event failed 0x%x.
ExtractSoapEnvelope failed with hr:%x
 xmlns:SOAP="http://schemas.xmlsoap.org/soap/envelope/" xmlns:psf="http://schemas.microsoft.com/Passport/SoapServices/SOAPFault" xmlns:ps="http://schemas.microsoft.com/Passport/SoapServices/PPCRL" xmlns:S="http://www.w3.org/2003/05/soap-envelope" xmlns:lic="urn:schemas-microsoft-com:windows:store:licensing:ls"
Keyholder License installation failed (0x%x)
*/puid
Parsed LicenseKeySequenceServer %d
Device License installation failed (0x%x)
error value is missing:%x
Parsed LicenseSignatureKeyVersionServer %d
CManagementBaseRequest::ExtractLicenseInfo
 Device request error 0x%x. Request Type %hs, Request Status 0x%x
hr = PPCRL_RESPONSE_LICENSE_MISSING
hr = PPCRL_RESPONSE_NOTIMESTAMPORRSTR
KeyHolderLicense/lic:License node not found (0x%x)
KeyHolderLicense=%hs
Could not get ServerTime attribute node of server response. HR=0x%x.
CManagementBaseRequest::GetServerTimeFromResponse
hr = SetClockSkew(wstrServerTime)
Could not read ServerTime attribute of server response. HR=0x%x.
CDeviceUserAssociation::BuildRequest
CDeviceUserAssociation::GetServiceEndpoint
<DeviceAssociateRequest xmlns="http://schemas.microsoft.com/Passport/SoapServices/PPCRL" version="2.0">
</s:Header><s:Body>
</FriendlyName>
<FriendlyName>
</DeviceAssociateRequest>
<AssociationType>%d</AssociationType>
<DeviceAssociation><Device>%ls</Device><AssociationType>%d</AssociationType></DeviceAssociation>
<DeviceDisassociateRequest xmlns="http://schemas.microsoft.com/Passport/SoapServices/PPCRL" version="3.0">
CPublishDeviceRequest::BuildRequestBody
</DeviceDisassociateRequest>
<NetworkInfo>
<DeviceUpdatePropertiesRequest xmlns="http://schemas.microsoft.com/Passport/SoapServices/PPCRL" version="2.0"><Update type="update">
</Update></DeviceUpdatePropertiesRequest>
</NetworkInfo>
CUpdateDeviceProperties::BuildRequestBody
m_rgPropNames.GetCount() == m_rgPropValues.GetCount()
<%ls>%ls</%ls>
<DeviceUpdatePropertiesRequest xmlns="http://schemas.microsoft.com/Passport/SoapServices/PPCRL" version="2.0"><Update type="Update">
</DeviceUpdatePropertiesRequest>
</Update>
"Add"
<DeviceUpdatePropertiesRequest xmlns="http://schemas.microsoft.com/Passport/SoapServices/PPCRL" version="2.0"><Update type=
<Reader>
"Remove"
<DeviceQueryPropertiesRequest xmlns="http://schemas.microsoft.com/Passport/SoapServices/PPCRL" version="2.0"><Device>
</Reader>
<EnumerateDevicesRequest xmlns="http://schemas.microsoft.com/Passport/SoapServices/PPCRL" version="2.0"><User>
</Device></DeviceQueryPropertiesRequest>
</EnumerateDevicesRequest>
</User>
</User></ResolveUserRequest>
<ResolveUserRequest xmlns="http://schemas.microsoft.com/Passport/SoapServices/PPCRL" version="2.0"><User>
CPPCRLBaseRequest::MapServiceError
Mapping error. Original err, %s, original suberr 0x%x.
CDeviceUserAssociation::ParseResponse
Mapping error. Original err, %s, original suberr 0x%x became 0x%x.
/S:Envelope/S:Body
 xmlns:SOAP="http://schemas.xmlsoap.org/soap/envelope/" xmlns:psf="http://schemas.microsoft.com/Passport/SoapServices/SOAPFault" xmlns:ps="http://schemas.microsoft.com/Passport/SoapServices/PPCRL" xmlns:S="http://www.w3.org/2003/05/soap-envelope"
Server response indicates time skew, but can't find server time in respose.
*/ServerInfo/@ServerTime
ps:DeviceAssociateResponse/Error/@Code
ps:DeviceAssociateResponse[@Success='true']
ps:DeviceDisassociateResponse[@Success='true']
ps:DeviceUpdatePropertiesResponse[@Success='false']
ps:DeviceUpdatePropertiesResponse[@Success='true']
ps:DeviceQueryPropertiesResponse[@Success='true']
ps:NextUpdate
ps:EnumerateDevicesResponse[@Success='true']
ps:Network
@FriendlyName
ps:Devices/ps:Device
CEnumDevicesRequest::GetResponse
hr = SafeCopyMemory(pCurName, dwNamesSize - (pCurName - reinterpret_cast<PBYTE>(apszNames)), (PCWSTR)pItem->pszDeviceName, dwTempLen)
ps:ResolveUserResponse[@Success='true']
hr = SafeCopyMemory(pCurFName, dwFriendlyNamesSize - (pCurName - reinterpret_cast<PBYTE>(apszFriendlyNames)), (PCWSTR) pItem->pszFriendlyName, dwTempLen)
 xmlns:ds="http://www.w3.org/2000/09/xmldsig#"
ps:CID
 xmlns:wssc="http://schemas.xmlsoap.org/ws/2005/02/sc"
 xmlns:wsse="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd"
 xmlns:wsp="http://schemas.xmlsoap.org/ws/2004/09/policy"
 xmlns:wsu="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd"
 xmlns:saml="urn:oasis:names:tc:SAML:1.0:assertion"
 xmlns:wst="http://schemas.xmlsoap.org/ws/2005/02/trust"
 xmlns:S="http://www.w3.org/2003/05/soap-envelope"
 xmlns:s="http://www.w3.org/2003/05/soap-envelope"
 xmlns:xenc="http://www.w3.org/2001/04/xmlenc#"
 xmlns:tb="http://schemas.microsoft.com/trustbridge/schema#1"
 xmlns:ps="http://schemas.microsoft.com/Passport/SoapServices/PPCRL"
 xmlns:psf="http://schemas.microsoft.com/Passport/SoapServices/SOAPFault"
 xmlns:wlid="http://schemas.microsoft.com/windlowliveid/2007/01/sts"
 xmlns:wsa="http://www.w3.org/2005/08/addressing"
hr = pIdentityWrapper->GetCredProperty(pIdentity, PPCRL_CREDPROPERTY_AUTHMEMBERNAME, accountEmail)
GetMessageForPinPrompt
hr = pStringSrv->GetStringForID(L_CREDUI_CAPTION_VERIFYIDENTITY_T, formatText)
hr = pStringSrv->Initialize(defaultLcid)
ADeviceIdStore::LogToRegistry
onecoreuap\ds\ext\live\identity\ntservice\lib\svccommon\Include\deviceidstore.h
hr = SaveToRegistry(wstrRegPath, wstrKeyName, CStringW(strProtCreds))
/%hs[@Success='true']
CDeviceAuthRequest::VSig_Decrypt_GetRSTR
%hs/ErrorSubcode
/%hs/Error/@Code
/%hs/ServerInfo/@BuildVersion
/%hs/ServerInfo/@ServerTime
/%hs/HWPUIDFlipped
/%hs/DeviceTpmKeyState
/%hs/KeyHolderLicense/lic:License
/%hs/lic:License
/%hs/LicenseSignatureKeyVersion
/%hs/LicenseKeySequence
DeviceUpdateRequest
DeviceUpdateResponse
DeviceAddRequest
DeviceAddResponse
HasRemaining(ulNumToRead)
onecoreuap\ds\ext\Live\identity\Passport\Include\Serialize.h
PassportSerialization::CReadBuffer<void const *>::Read
hr = SafeCopyMemory(pvBuf, ulNumToRead, m_pbBuf, ulNumToRead)
hr = CheckIdentityNameAndPassword(userType)
hr = g_pPPCRL->GetNegativeCacheManager()->CheckNegativeCacheForScenario( NegativeCache::Scenarios::NegativeCacheForDeviceRequests, NegativeCache::SubScenarios::NegativeCacheForDeviceAuthScenario)
hr = pRequest->Initialize(this, fLogicalAuth)
hr = this->QueryInterface(EDeviceIdentityType, reinterpret_cast<void**>(&pDeviceIdentity))
hr = transport.SendRequest(pRequest)
hr = pRequest->BuildRequestEx(L"", 0, dwRequests, rgRequests)
g_pPPCRL->GetNegativeCacheManager()->UpdateNegativeCacheForScenario( NegativeCache::Scenarios::NegativeCacheForDeviceRequests, NegativeCache::SubScenarios::NegativeCacheForDeviceAuthScenario, pRequest->GetRequestStatus())
Request 
%s\Logs\%s
CSingleIdentity::RenewDeviceCert
Response 
hr = pRequest->Initialize(this, "")
CSingleIdentity::BuildUpdateDeviceRequest_Internal
CSingleIdentity::ProvisionIdentity - Failed when sending AddCredential request.hr =0x%x
CSingleIdentity::UpdateDeviceCredentials
hr = serviceExecutionContext.GetServiceWrapper()->IsCallerAccountType(SECURITY_LOCAL_SYSTEM_RID, bIsSystemContext)
CSingleIdentity::BuildProvisionRequest_Internal
hr = m_pAddCredentialRequest->BuildRequest()
hr = m_pAddCredentialRequest->Initialize(this)
hr = g_pPPCRL->GetNegativeCacheManager()->CheckNegativeCacheForScenario( NegativeCache::Scenarios::NegativeCacheForDeviceRequests, NegativeCache::SubScenarios::NegativeCacheForDeviceProvisioningScenario)
CSingleIdentity::ProvisionIdentity
CSingleIdentity::ProvisionIdentity - Failed when sending AddCredential request. hr =0x%x
hr = BuildProvisionRequest_Internal(userType)
Provision 
g_pPPCRL->GetNegativeCacheManager()->UpdateNegativeCacheForScenario( NegativeCache::Scenarios::NegativeCacheForDeviceRequests, NegativeCache::SubScenarios::NegativeCacheForDeviceProvisioningScenario, GetRequestStatus())
ValidateHashOfValidPassword failed with hr=0x%x.
Trying offline authentication against hashed credentials.
Offline authentication succeeded.
Offline password hash was not found. User must first do online login with option LOGON_IDENTITY_CREATE_OFFLINE_HASH to create hash.
Offline authentication failed. Hashed password does not match the supplied password.
CSingleIdentity::GetSessionKeyType
CSingleIdentity - Setting identity cookie '%ls' to '%ls'.
CSingleIdentity - Request for response param '%ls'.
CSingleIdentity - Value of response param is '%ls'.
&pl=%s
&ru=%s
&login=%S
&loginoptions=%s
Auth token is empty.
Auth token is unavailable.
&linkct=%S
&linkh=%d
&linkl=%d
SignedTokenTimeOffset
&cid=%S
 Session key sign failure 0x%x
Host name is NULL in URL : %ls. (0x%x)
Could not get one box SSL port for host %ls
GetPassportSTSHost() returned empty host name. Using default URL %ls.
hr = m_hTokenBag->GetUserExtPropertyValue(wstrPropertyName, wstrValue)
hr = m_hTokenBag->SetUserExtPropertyValue(wstrPropertyName, wstrPropertyValue.Trim())
CSingleIdentity::SerializeExtProperties
" value="
<extProperty name="
<cookie name="browsercookie" cookieurl="%ls" cookiename="%ls" cookievalue="%ls" />
IsMissingCred
wszAuthInfo is NULL.
SetIdentityName failed, hr = 0x%x
StoreToken failed, hr = 0x%x
Unable to write credential. hr=0x%x
Unable to find token bag.
Unable to delete credential. hr=0x%x
CSingleIdentity::RemovePersistedServiceTokens
Unable to find token bag. hr=0x%x
Unable to retrieve credential. hr=0x%x
Unable to write cert to store. hr=0x%x
CSingleIdentity::DeLinkCertObject
Unable to delete persisted certificates. hr=0x%x
CSingleIdentity::RemovePersistedCertificates
CSingleIdentity::GetLinkInfo
hr = GetCredProperty(PPCRL_CREDPROPERTY_LINKEDIDS, wstrLinkedIds)
LinkedIds
hr = GetCredProperty(PPCRL_CREDPROPERTY_LINKID, wstrLinkId)
LinkId
hr = GetCredProperty(PPCRL_CREDPROPERTY_LINKVER, wstrLinkVer)
LinkVer
CSingleIdentity::IsLinked
LinkId=%ls, LinkVer=%ls, LinkedIds=%ls
HRESULT=0x%x
Could not parse linked account list
GetServiceToken for authtoken: failed hr = 0x%x
CSingleIdentity::CopyAuthStateFromLinkedHandle
hr = SetCredProperty(PPCRL_CREDPROPERTY_LINKID, wstrLinkId)
Empty Auth Token
hr = SetCredProperty(PPCRL_CREDPROPERTY_LINKEDIDS, wstrLinkedIds)
hr = SetCredProperty(PPCRL_CREDPROPERTY_LINKVER, wstrLinkVer)
IsSmartCardCert() failed. (0x%x)
CSingleIdentity::GetURLHash
wstrURL='%ls'
0x%08X
Get Auth End Point URL Hash = '%ls', Fed Partner = '%ls'
CSingleIdentity::RenewUserIdKeyAttestation
hr = RenewUserIdKeyAttestation(pExecutionContext, keyRevoked)
NgcUserIdAikRevokedTime
hr = pSystemStore->GetCurrentUserSidString(&spUserSid)
hr = pNgcFunctions->NgcRenewKeyAttestation( PPCRL_MSA_IDP_DOMAIN, nullptr, spUserSid, 0)
NgcUserIdKeyAttestedTime
hr = pNgcFunctions->NgcEnumUserIdKeys( PPCRL_MSA_IDP_DOMAIN, nullptr, static_cast<PCWSTR>(accountCid), static_cast<PCWSTR>(spUserSid), &spKeyInfo, &spEnumState)
hr = this->GetCredProperty(PPCRL_CREDPROPERTY_CID, accountCid)
hr = pServiceWrapper->HandleCreateContext( this->GetIdentityName(), CREATECONTEXT_SET_APP_IDENTITY, &hUserIdentity, c_updateUserIdKeyAttestationApplicationId)
NgcFunctions::NgcGetKeyAttestationForUserIdKey.(hr = 0x%x). Key Type: %d
pUserIdentity != nullptr
hr = pServiceWrapper->GetIdentityHandle(logonId, hUserIdentity, pUserIdentity)
hr = pUserIdentity->GetServiceTicket( pExecutionContext, PPCRL_LOGIN_PROOF_TOKEN_URI, PPCRL_LOGIN_PROOF_TOKEN_POLICY_KEYUPDATE, throttleScenario, loginProofToken)
PURPOSE_KEYUPDATE
hr = pRequest->ComputeServerKeyId( ngcPublicKey, ngcPublicKeySizeBytes, serverKeyId)
loginProofToken.GetLength() != 0
hr = pRequest->BuildRequest( loginProofToken, "Update", nullptr, 0, serverKeyId, spAttestationStatement, attestationStatementSizeBytes, spAikCertChain, aikCertChainSizeBytes)
Update
hr = pRequest->GetRequestStatus()
CSingleIdentity::GetServiceTicket
Base64Encode for session key: failed hr = %x
Unable to Parse the xml: %ls
AuthInfo/AuthToken node not found in auth info xml. 0x%x.
Could not read AuthToken node. HR=0x%x.
hr = CAuthInfo::GetSessionKeyType(bstrValue, sessionKeyType)
Could not read SessionKeyType node. HR=0x%x.
CAuthInfo::DecryptSystemContextString
hr = PassportEncode::Base64Decode(encoded, decoded)
hr = PassportEncode::Base64Encode(encrypted, encoded)
hr = SafeCopyMemory(encrypted.GetBufferSetLength(blob.cbData), blob.cbData, blob.pbData, blob.cbData)
Empty user account has no stored credentials.
Failure - CryptProtectData, HRESULT: 0x%08X
CAuthInfo::RemoveCachedAuthInfo
hr = CTokenInfo::AssembleTokenBlob(pTheCred, PPCRL_CRED_AUTHSTATE_KEYWORD, wstrAuthInfoBlob)
wszVirtualAppName is too long (%Iu chars).
hr = EncryptCredentialsInSystemContext(&executionContext, strTokenBlob.GetBuffer(), strTokenBlob.GetLength() * sizeof(char), credsOut)
hr = EncryptCredentialsInSystemContext(&executionContext, const_cast<PWSTR>(wszPassword), wcslen(wszPassword)*sizeof(wchar_t), credsOut)
out of memory
MemberNameOnly
ExportAuthToken: failed PPCRL_E_NO_MEMBER_NAME_SET hr = 0x%x
Get CID property failed 0x=%x.
ExportAuthToken: No PUID for this identity
Get UserTileURL property failed 0x=%x.
CAuthInfo.Pack: failed hr = 0x%x
SessionKeyType value is malformed, errno = %d
CAuthInfo::GetSessionKeyType
hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA)
Invalid SessionKeyType value, dSessionKeyType = %d
Corrupted credential info.
Token blob is empty.
CTokenInfo::WriteSharedToken
ToBase64: failed hr = 0x%x
CTokenInfo::WriteTokenBlob
::AddPersistedCertificatesToDOM failed with hr = %x
WriteCommonToken: failed with hr=0x%x
AuthInfoBlob is too large.
Out of memory
Invalid service name.
wstrUserName: %ls, wstrServiceName: %ls
CTokenInfo::RemovePersistedTokens
Remove: %ls, user = %ls, service = %ls 
Invalid credential type.
Invalid token.
Base64Encode for session key: failed hr = 0x%x
Unable to Parse the service token info xml
Expire time node not found in service token info xml. 0x%x.
Session key node not found in service token info xml. 0x%x.
Parse expired time failed. HR=0x%x.
wstrUserName: %ls, strServiceName: %hs
Could not read sessionKeyType node. HR=0x%x.
wstrUserName is to long (%Iu chars).
CServiceTokenInfo::WriteToCache
wstrTargetName is too long (%d chars).
Pack service token error. hr = 0x%x
CServiceTokenInfo::RemovePersistedServiceTokens
Write service token error. hr = 0x%x
Remove service token failed = 0x%x.
Invalid output token bag.
Cached
Bad targetname format: %ls
CCertificateInfo::Pack
AddStoredToken failed, hr = 0x%x
Corruped keypair.
Corruped certificate token.
CCertificateInfo::UnPack
Cert info: %ls
Unable to Parse the certificate info xml.
wstrCertInfo %ls
KeyGenFlags node not found in certificate info xml. 0x%x.
Token node not found in certificate info xml. 0x%x.
CCertificateInfo::WriteToCache
Expire time node not found in certificate info xml. 0x%x.
service name is empty.
wstrUserName is empty.
certificate token is null.
Pack certificate error. hr = 0x%x
Bad certificate, skip persist.
Write certificate error. hr = 0x%x
Microsoft_WindowsLive:certificate:
Remove certificate failed = 0x%x.
CCertificateInfo::RemovePersistedCertificates
CCertificateInfo::RetrievePersistedCertificatesHelper
RemovePersistedFileCertificates failed = 0x%x.
Certificate is expired
Bad cred info. Can not extract elements from xml.
Build certificate from cache: StoreToken failed, hr = 0x%x
Build certificate from cache failed, hr = 0x%x
::DeleteCertificatesFromPersistantStore failed with hr = %x
CCertificateInfo::RemovePersistedFileCertificates
found %d certs in global store
::QueryCertificates failed with hr = %x
get_text failed with %x, continuing gracefully
get_item failed with %x, continuing gracefully
getAttribute failed with %x, continuing gracefully
Can't get Xml element from Xml Node
FromBase64 failed with %x, continuing gracefully
Target name was wrong type, continuing gracefully
DeleteCertificatesFromPersistantStore failed with hr=0x%x continuing gracefully
RetrievePersistedCertificatesHelper failed with hr=0x%x continuing gracefully
Retrieve cert %ls.
RetrievePersistedFileCertificates failed with hr=0x%x
RetrievePersistedCertificatesHelper failed with hr=0x%x
Bad cred info. Process attributes error.
Unable to Query StringValue for size: '%ls', hr = %x.
Could not find a suitable separator for %ls, giving up!
String2SHA1Hash
CryptAcquireContextA returned null handle
CryptAcquireContextA failed with 0x%x
CCryptSHA1Hash AddData failed with 0x%x
CCryptSHA1Hash initialize failed with 0x%x
Hash generated by CCryptSHA1Hash is too small
CCryptSHA1Hash GetSize failed with 0x%x
aHash.SetCount(ulHashSizeBytes)
CryptUnprotectData
pExecutionContext->GetServiceWrapper()->Revert(&autoRevert, FALSE)
CryptProtectData
Failure - passwordLength, HRESULT: 0x%08X
FromBase64
hr = PartFromBase64<_T>(pcszSrc, reinterpret_cast<PBYTE>(tempbstr), &cbNeeded, fUsePPVersion)
hr = SafeCopyMemory(*pbstr, cbNeeded, tempbstr, cbNeeded)
onecoreuap\ds\ext\Live\identity\Passport\Include\binhex.h
ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/
?456789:;<=
 !"#$%&'()*+,-./0123
DeleteUserAllExtendedProperties
wstrUserName='%ls'
DeleteUserTileData
_ETAG
Software\Microsoft\IdentityCRL\UserTileData
Persisting credentials of credtype: '%ls' is ignored.
m_pOwningIdentity is not set.
GetAuthTokenBlob (full state) failed 0x=%x.- optional, continue
CAuthInfo::WriteToCache failed 0x=%x.
GetAuthTokenBlob (partial state) failed 0x=%x.- optional, continue
CertThumbprint
TestAndUnsetIsMissingCredValue failed: hr = 0x%x.
'%s' is not a valid cred type.
CIdentityCredentialBag::DeleteStoredCredential
error gettting GetCredTargetName  '%ls', hr = 0x%x.
User name %ls is not persisted.
hr = GetPersistedCredential(wstrCredentialType, wstrCredential, &bDaTokenPresent)
Software\Microsoft\IdentityCRL\OfflineCreds
CIdentityCredentialBag::RecordHashOfValidPassword
CIdentityCredentialBag::ValidateHashOfValidPassword
Unable to set binary value '%ls' under '%ls', hr = %x.
Unable to open key '%s', hr = %x.
No stored password hash to compare against.
Invalid credential hash found in registry - ignoring.
Unable to query binary value '%ls' under key '%ls', hr = %x.
ValidateHashOfValidPassword: Hashes did not match.
ValidateHashOfValidPassword: Hashes match.
CIdentityCredentialBag::HashPasswordFromBag
hr = SafeCopyMemory(bvPasswordKey, sizeof(bvPasswordKey), strPassword.GetBuffer(), min(strPassword.GetLength()+1, sizeof(bvPasswordKey)))
hr = StringCchCopy(pszEventName, strEventName.GetLength() + 1, CStringW::PCXSTR(strEventName))
::FreeLibrary(m_hXmlLite) failed with hr = %x
GetRegistryKeyPath returned null, treating like not admin disabled
Device id is admin disabled
GetRegistryKeyPath returned null, treating like hwid enabled
GetRegistryKeyPath returned null, treating like phycical did disabled
Device id is remote disabled
InternalRetrieveDeviceCert. Certificate failed the CERT_STORE_TIME_VALIDITY_FLAG check. 0x%x.
GetCert failed with hr = 0x%x
InternalRetrieveDeviceCert: CertVerifySubjectCertificateContext failed with hr=0x%x
InternalCheckAuthToken failed with hr = 0x%x
GetAuthTokenBlob failed: hr = 0x%x
Device ID flow is disabled on the server.
DeviceIdHelpers::RenewDeviceCert
AddDeviceInfoToCredMan failed: hr = 0x%x
hr = hIdentity->GetRequestStatus()
hr = hIdentity->QueryInterface(EDeviceIdentityType, reinterpret_cast<void**>(&pDeviceIdentityObj))
Failed to remove existing system device cert. hr = 0x%x
hr = hIdentity->PersistCertificates()
DeviceIdStore::AddCertificateToCertStore: failed with hr = 0x%x
DeLinkCertObject failed with hr = 0x%x
DeviceIdHelpers::GenerateRandomMembername
DeviceIdHelpers::GenerateRandomPassword
PPGenerateRandomNoThrow: failed hr = 0x%x
DeviceIdHelpers::GenerateRandomString
Could not get subject name from certificate. hr = 0x%x
DeviceIdHelpers::GetRawPUIDFromCert
DeviceIdHelpers::IsCallerAdminEnabled
GetTokenInformation failed with hr = 0x%x
ConvertSidToStringSid failed with hr=%x
g_pPPCRL->VerifyInitialized: failed hr = 0x%x
Device id is admin disabled hr = 0x%x
Device id is remote disabled hr = 0x%x
GetDeviceIDAsycProc: RetrieveDeviceID failed. hr = 0x%x
DeviceIdHelpers::GetDeviceIDAsycProc
DeviceIdHelpers::GetDeviceIDAsync
DeviceIdHelpers::Shutdown
hr = DeviceIdStore::Shutdown()
Software\Microsoft\IdentityCRL\NegativeCache
LastSuccessfulRequestTimestamp
NegativeCacheState
%ls\%ls\%ls
LastAccountPersistentFailureTimestamp
StartedTime
RequestCount
FailureType
ErrorCode
NegativeCacheManager::SaveNegativeCachePersistedData keyName: %ls; Error code: 0x%x; Failure count: %d; Timestamp: %llu
Allow application %ls retry. Negative cache was skipped
Application %ls skipped negative cache; Elapsed interval %I64u seconds; FailureCount = %d
NegativeCache data expired - application %ls skipped negative cache.
Application %ls blocked by negative cache. Elapsed interval = %I64u seconds, FailureCount = %d, ErrorCode=0x%x
NegativeCacheForNonInterruptsDisabled is set.
NegativeCacheForDeviceTicketRequestsDisabled is set.
Negative cache cleared - ClearNegativeCacheData called
~ThrottleManager hit exception: 0x%x
ThrottleFlags
ThrottleTotalIntervalSeconds
ThrottleMaxRequests
ThrottledAppId
ThrottledAppMaxRequests
WLIDSVC
SetPrivateKey -::CertSetCertificateContextProperty failed to set key context with hr:%x
SetPrivateKey -::CertSetCertificateContextProperty failed to set CERT_KEY_PROV_INFO_PROP_ID with hr:%x
Cert Map Index: %s
CCertManager::GenerateMapIndex
keySize=%d;keyGenFlags=0x%x
CCertManager::GetServiceName
CreatePKCS10Base64 cannot generate map index %p, %s does not have pending SLC request hr = %x
CCertManager::CreatePKCS10Base64
PutCert cannot generate map index %p, %s does not have pending SLC request hr = %x
CCertManager::PutCert
AssociateCert failed hr = %x
void %p does not have pending SLC request hr = %x
GetCert cannot generate map index %p, %s does not have pending SLC request hr = %x
GetCert: failed CertDuplicateCertificateContext hr = %x
CheckCertTTL failed with 0x%x.
Corruped certificate token string.
CCertManager::BuildCertFromCache
Can not generate map index.
Corruped keypair string.
Can not associate keypair with persisted cert: hr = 0x%x.
Can not import persisted keypair: hr = 0x%x.
Bad cert map index format: %s.
Cert map returns null cert object.
CCertManager::DeLinkCertObject
Can not persist certificate: hr = 0x%x.
::CryptGenKey failed hr = %x
CCertObject::CreatePKCS10Base64
::CryptProtectData failed hr = %x
::CryptExportKey failed hr = %x
::CryptExportPublicKeyInfo failed hr = %x
Base64Encode failed, size: %d.
failed to CryptExportPublicKeyInfo: %x
failed to allocate memory of byte: %d
failed to CryptEncodeObjectEx - szOID_RSA_signingTime: %x
1.2.840.113549.1.9.5
failed to CryptEncodeObjectEx - X509_NAME: %x
MSIDCRL
Base64Encode Failed hr = 0x%08X
CryptSignAndEncodeCertificate Failed                  hr = 0x%08X
AssociateCert: failed to base64decode %s
CCertObject::AssociateCert
SetPrivateKey - failed to set private key=  hr:%x
AssociateCert: failed to CertCreateCertificateContext %s
Requested TTL: '%d' seconds.
CCertObject::CheckCertTTL
Requested TTL: %s, Remaining TTL: %s
Actual Remaining TTL: '%d' seconds.
CCertObject::BuildPKCS10Base64FromCache
Invalid Cert context: pCertInfo is NULL
CryptUnprotectData failed. hr = 0x%x.
Base64Decode failed, size: %d.
Can not initialize crypt provider.
CryptUnprotectData returns success together with a invalid data blob. 
::CryptImportKey failed hr = %x
%ls_%s
%ls_%08x_%p
IDENTITYCRL_CERT_CONTAINER
onecore\internal\sdk\inc\wil\opensource\wil\token_helpers.h
CIdentityStore::SetPersistedSsoGroupUser
hr = SetExtendedPropertyInternal(SSO_GROUP_LIVE_STRING, wstrMemberName)
SSO_GROUP_LIVE
hr = HandleCreateContext(wstrExistingUserName, 0, &handle)
CIdentityStore::GetPersistedUserNameBySsoGroup
hr = HandleHasPersistedCredential(handle, PPCRL_CREDTYPE_PASSWORD, &bHasPersistentCred)
ConvertStringSidToSid(pszSid, &spSid) != FALSE
hr = CreateNewIdentity(hIdentity)
hr = GetDeviceIdInternal( g_szStrongAuthAppId, 0, NULL, 0, &wszDeviceId, NULL, NULL, &pDeviceIdentity )
hr = hIdentity->SetPUID(wszDeviceId)
hr = hIdentity->SetIdentityName( LogonId, wstrUsername )
hr = hIdentity->GetCredBag()->StoreCredential( PPCRL_CREDTYPE_PASSWORD, wszPassword )
hr = pDeviceIdentity->GetCredBag()->RetrieveCredential( PPCRL_CREDTYPE_PASSWORD, wszPassword )
hr = IsAuthDisabledByEnterpriseDeviceAuthPolicy(&serviceExecutionContext, hIdentity)
pszSid.IsEmpty() == false
GetIdentityProperty failed. Ignoring the failure. hr=0x%x
hr = hIdentity->SetIdentityName(LogonId, wstrUsername)
SetCredProperty(CID) failed. Ignoring the failure. hr=0x%x
CUserExtendedProperty::GetExtProperty failed. Ignoring the failure. hr=0x%x
hr = GenRandomNumber(reinterpret_cast<LPBYTE>(&handle), static_cast<DWORD>(sizeof(handle)))
SetCredProperty(PUID) failed. Ignoring the failure. hr=0x%x
LUID=[%d,%d] LoadUserProfile %p
Created new identity 0x%p.
hr = StringCchCopyW(aResponse[index]->userName, nameLengthNumCharacters, (LPCWSTR)wstrName)
hr = hIdentity->GetTokenBag()->CacheAndEncryptPersistedPassword(wstrPassword)
LUID=[%d,%d] UnloadUserProfile %p
CIdentityStore::GetOpenHandles
logonId.LowPart='%d, logonId.HighPart='%d, dwSessionId=%d
Skip GetSignedInUsernames since SSO is disabled
CIdentityStore::GetSignedInUsernames
CIdentityStore::RemoveDeviceIdentity
UserProfileUnload
UserProfileLoad
sid=%s
CSingleIdentity::SetCallerSidOverwrite
QueueWorkItem for CreateNetworkNotificationTask failed HR=0x%x
Failed to WSACreateEvent: 0x%X
Failed to subscribe to network change notification: 0x%X
CreateProcessUserTask for session id %d for %s.
Error -x%lx WTSEnumerateSessions.
UMgrEnumerateSessionUsers has failed with hr: %lx
Version %d.%d of the Windows Socket API could not be found.
Error -x%lx SubscribeToNetworkNotification.
UpdateDone
WindowsLive:name=
WindowsLive:user=
WindowsLive:name=*
WindowsLive:user=*
CredDeleteW: failed with hr=0x%x
CredEnumerateW failed 0x=%x.
hr = pExecutionContext->GetCRegKeyWrapper()->Create(&key, HKEY_USERS, SYSTEM_USER_KEYPATH, nullptr, 0, KEY_ALL_ACCESS, nullptr, nullptr)
hr = HRESULT_FROM_WIN32( pExecutionContextLite->GetWinApiFunctions()->SetNamedSecurityInfoW( L"USERS\\" SYSTEM_USER_KEYPATH, SE_REGISTRY_KEY, DACL_SECURITY_INFORMATION | PROTECTED_DACL_SECURITY_INFORMATION | LABEL_SECURITY_INFORMATION, NULL, NULL, dacl, sacl))
USERS\.default\Software\Microsoft\IdentityCRL
Set permission done.
Skipping WNF notification %ls with timestamp %d
hr = GetWNFStateNameString(stateName, stateNameString)
Handling WNF notification %ls with timestamp %d
hr = HRESULT_FROM_NT(RtlSubscribeWnfStateChangeNotification( &subscription, stateName, changeStamp, pfnEventHandler, nullptr, nullptr, 0, 0 ))
hr = RegisterWnfEvent(WNF_LIC_HARDWAREID_IN_DEVICE_LICENSE_IN_TOLERANCE, MsaWnfEventHandler)
hr = RegisterWnfEvent(WNF_LIC_DEVICE_LICENSE_MISSING, MsaWnfEventHandler)
hr = RegisterWnfEvent(WNF_MSA_TPM_ATTESTATION_ATTEMPT_READY, MsaWnfEventHandler)
hr = RegisterWnfEvent(WNF_LIC_HARDWAREID_IN_DEVICE_LICENSE_OUT_OF_TOLERANCE, MsaWnfEventHandler)
MsaWnfNotifications::PersistLastTimeStamp
WNF_LIC_HARDWAREID_IN_DEVICE_LICENSE_OUT_OF_TOLERANCE
WNF_LIC_HARDWAREID_IN_DEVICE_LICENSE_IN_TOLERANCE
stateNameString.IsEmpty() == false
WNF_MSA_TPM_ATTESTATION_ATTEMPT_READY
CNetworkAddresses::RunPublisher
CloseHandle(m_hPublisherThread) failed with hr=0x%x
CNetworkAddresses::StopPublisher
CNetworkAddresses::_PublisherLoop
CNetworkAddresses::NewRequest
hr = SafeCopyMemory(&dwCount, sizeof(dwCount), pRawData, sizeof(DWORD))
CNetworkAddresses::ParseAddresses
CNetworkAddresses::_GetDeviceAddresses
hr = SafeCopyMemory(pAddrInfo->pAddrData[i].pAddress, pAddrInfo->pAddrData[i].cbAddressLen, pSource, pStoredAddresses[i].AddressLen)
CNetworkAddresses::_RegisterChangeNotification
CNetworkAddresses::ChangeNotificationCallBack
CNetworkAddresses::_PopulateDeviceAddresses
CNetworkAddresses::_DeregisterChangeNotification
hr = SafeCopyMemory(pCur, dwSize - (pCur - Buffer), pCurAddress->Address.lpSockaddr, pCurAddress->Address.iSockaddrLength)
hr = SafeCopyMemory(Buffer, dwSize, &dwCount, sizeof(dwCount))
Iphlpapi.dll
NotifyUnicastIpAddressChange
GetAdaptersAddresses
CNetworkAddresses::LookupAddress
CancelMibChangeNotify2
CNetworkAddresses::CacheAddress
Software\Microsoft\IdentityCRL\LKG
CNetworkAddresses::_SetLastKnownGood
FriendlyName
Addresses
Unable to open registry key '%s', hr = %x.
CNetworkAddresses::_GetLastKnownGood
Unable to query max value size '%s', hr = %x.
hr = GetStateForServerResult(pParams->pServiceExecutionContext, pParams->InterruptCode, pParams->InterruptFlags, state)
DoNotificationUpdate called with cleanupOnly, exiting.
No update needed, exiting.
The call is from moset. Don't overwrite previous notification state, exiting.
Account state changed: strongAssociationBitFlipped=%s InterruptCode=0x%x cachedState=0x%x IsRootLevelInterrupt=%d cachedRootLevelInterrupt=%d
InterruptNotifications::ClearState
hr =pSvcWrapper->Impersonate(&client)
Interrupt code 0x%x is unknown and no URL was specified, cancelling action center update.
Could not find matching state for server result 0x%x, using generic state.
Failed to create Action Center API object, hr = 0x%x.
Failed to set Action Center state, hr = 0x%x.
RetrieveCredential failed, hr = 0x%x.
CAuthInfo::GetCachedAuthInfo failed, hr = 0x%x.
hr = HRESULT_FROM_WIN32(pRegKey->Create(hkcu, PPCRL_REG_ACTIONCENTER_KEYPATH, REG_NONE, REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE, NULL, &disposition))
hr = SetCachePermissions(pServiceExecutionContext)
hr = DelimiterSeperatedToMultiSzString(pTargets, PPCRL_LINEBREAK_DELIMITER, targetMultiSzString)
hr = HRESULT_FROM_WIN32(pRegKey->SetStringValue(PPCRL_REG_ACCOUNT_SETTINGS_URL, pAccountSettingUrl))
hr = DelimiterSeperatedToMultiSzString(pPolicies, PPCRL_LINEBREAK_DELIMITER, policyMultiSzString)
hr = HRESULT_FROM_WIN32(pRegKey->SetDWORDValue(PPCRL_REG_ACTIONCENTER_CODE, static_cast<DWORD>(interruptCode)))
InterruptNotifications::SetCachePermissions
hr = HRESULT_FROM_WIN32(pRegKey->SetDWORDValue(PPCRL_REG_ACTIONCENTER_ROOT_LEVEL_INTERRUPT, (isRootLevelInterrupt ? 1 : 0)))
hr = pExecutionContext->CreateRegKey(&pCacheKey.m_p)
hr = pSvcWrapper->GetTokenSid(&client, userSid)
accessList.AddAllowedAce(userSid, KEY_READ | DELETE, OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE)
hr = HRESULT_FROM_WIN32(pCacheKey->Open(hkcu, PPCRL_REG_ACTIONCENTER_KEYPATH, READ_CONTROL | WRITE_OWNER | WRITE_DAC))
accessList.AddAllowedAce(Sids::System(), KEY_ALL_ACCESS, OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE)
accessList.AddAllowedAce(Sids::Admins(), KEY_ALL_ACCESS, OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE)
InterruptNotifications::ClearCache
InterruptState
hr = HRESULT_FROM_WIN32(pRegKey->Open(GetCurrentUserKey(), PPCRL_REG_IDCRL_PATH, KEY_READ | KEY_WRITE | DELETE))
hr = HRESULT_FROM_WIN32(pRegKey->DeleteSubKey(PPCRL_REG_ACTIONCENTER_KEYNAME))
hr = UrlUtilities::AppendMarket(pWinApiLite, outputUrl)
hr = SystemStoreLite::IsUserDomainConnected(pServiceExecutionContext->GetExternalExecutionContextLite(), pSid, isDomainConnected)
hr = pIdentity->GetCredProperty(CStringW(PPCRL_CREDPROPERTY_ASSOCIATEDFORSTRONGAUTH), associatedForStringAuth)
DeviceIdHelpers::ProvisionDeviceId
wstrAppId=%ls,dwDeviceType=%d,flags=%llx
Physical Device ID is disabled.
App Id is required for ProvisionDeviceId.
DeviceIdHelpers::CreateNewDeviceIdentity Failed hr = %x
hr = DeviceIdHelpers::RetrieveDeviceID(g_szPhysicalAssociationAppId, IDCRL_DEVICE_ID_PHYSICAL | IDCRL_DEVICE_ID_GET_VALID | flags, NULL, WLID_DEVICEID_I_RENEW_DA_TOKEN, NULL, NULL, NULL, hPhysicalDeviceIdentity )
hr = g_pPPCRL->GetIdentityStore()->GetDeviceIdentityMap().AssociatDeviceToApp(hDeviceIdentity->GetUserType(), hDeviceIdentity->GetIdentityName(), wstrAppId)
hDeviceIdentity
DeviceIdHelpers::DeProvisionDeviceId
Failed to Dissaccoiate Device Id from App %s, hr = %x.
CDeviceIdentityBase::GetDeviceIdentity Failed hr = 0x%x
hr = g_pPPCRL->GetIdentityStore()->RemoveDeviceIdentity(pDeviceIdentityObj->GetIdentityName())
hr = pIdentityObj->QueryInterface(EDeviceIdentityType, (void**)&pDeviceIdentityObj)
Succesfully acquired provisioning mutex with no wait.
Unable to create mutex for device provisioning 0x%x.
Succesfully acquired provisioning mutex with a wait.
Unexpected failure to get provisioning mutex (no wait) %d
Mutex released
Unexpected failure to get provisioning mutex (infinite wait) %d
Mutex not released
Failure releasing mutex: %d
dwDeviceType=%d,wstrAppId=%ls,flags=%llx,internalFlags=%llx
IsCallerAccountType failed with hr=0x%x
Failed to read current user SID hr=0x%x
DeviceIdHelpers::CreateNewDeviceIdentityInternal
CreateNewDeviceIdentity
hr = AcquireProvisioningMutex( true, failureThreshold, bMutexAcquired, bAttemptProvisioning)
SOFTWARE\Microsoft\Windows\CurrentVersion\Setup\State
ImageState
IMAGE_STATE_GENERALIZE_RESEAL_TO_AUDIT
IMAGE_STATE_GENERALIZE_RESEAL_TO_OOBE
Reg_QueryString(SOFTWARE\Microsoft\Windows\CurrentVersion\Setup\State) failed hr = %x
hr = PPCRL_E_DEVICEID_DISABLED
SYSTEM\Setup
SystemSetupInProgress
hr = g_pPPCRL->GetIdentityStore()->RemoveDeviceIdentity(hDeviceIdentityLocal->GetIdentityName())
CDeviceIdentityBase::CreateNewDeviceIdentity Failed hr = %x
hr = hDeviceIdentity->QueryInterface(EDeviceIdentityType, (void**)&pDeviceIdentityObj)
hr = g_pPPCRL->GetIdentityStore()->AddAndGetDeviceIdentity(hDeviceIdentityLocal, hDeviceIdentity)
hr = pDeviceHelperWrapper->GetSystemHardwareID(&serviceExecutionContext, IDCRL_DEVICE_ID_FROMCACHE, hSystemDeviceIdentity)
hr = pDeviceIdentityObj->Provision(false, GetDeviceIdentityFlag(dwDeviceType), hRandomIdentity, hrSendResult)
hr = pDeviceHelperWrapper->ReprovisionDevice(&serviceExecutionContext, g_szStrongAuthAppId, 0, hrProvisionFailure == PPCRL_E_DEVICE_KEY_SIGN_FAILURE ? hrProvisionFailure : hrInternal, hSystemDeviceIdentity, hNewSystemDeviceIdentity)
hr = ((CSingleIdentity*)hDeviceIdentity)->QueryInterface(EDeviceIdentityType, (void**)&pDeviceIdentityObj)
hr = g_pPPCRL->GetIdentityStore()->AddAndGetDeviceIdentity(hRandomIdentity, hDeviceIdentity)
hr = g_pPPCRL->GetIdentityStore()->GetDeviceIdentityMap().UpdateValidDeviceIDKey( ((CSingleIdentity*)pDeviceIdentityObj)->GetUserType(), ((CSingleIdentity*)pDeviceIdentityObj)->GetIdentityName())
hDeviceIdentity passed in INVALID.
UpdateValidDeviceIDKey Failed hrInternal = %x
Unexpected RenewDeviceCert returned S_OK and null pointer
UpdateCredential Failed hr = %x
GetValidDeviceIDKey Failed hrInternal = %x
GetDeviceCert Failed hr = %x
hr = g_pPPCRL->GetIdentityStore()->GetDeviceIdentityMap().AssociatDeviceToApp( ((CSingleIdentity*)pDeviceIdentityObj)->GetUserType(), pDeviceIdentityObj->GetIdentityName(), wstrAppId)
hr = DeviceIdHelpers::GetDeviceCertificate(hIdentity, ppCertContext, ppszKeypair)
hr = DeviceIdHelpers::CheckAuthToken(hIdentity, bAuthTokenAvailable)
CDeviceIdentityBase::GetValidDeviceIdentity Failed to get valid Device Identity hr=%x.
AddAndGetDeviceIdentity failed with hr=0x%x
RetrieveDeviceCert: failed hr = 0x%x
hDeviceIdentity passed in NULL.
Unexpected RetrieveDeviceCert returned S_OK and null pointer
GetExternalMemoryManager failed wih . hr = 0x%x
DeviceIdHelpers::DeProvisionDeviceId failed hr=0x%x
hr = DeviceIdHelpers::ProvisionDeviceId(pwszAppId, dwDeviceType, flags, hDeviceIdentity)
AssociatDeviceToApp failed hr=0x%x
flags=%llx,ppIdentity=%p,ppCertContext=%p
hr = DeviceIdHelpers::GetPUID(hDeviceIdentity, ppCertContext?*ppCertContext:NULL, pwszDeviceId)
ppIdentity passed in nullptr.
DeviceIdHelpers::GetSystemDeviceIDForWindows
CSystemStore::ProcessNewDevice failed to reassociate users on reprovision, hr=0x%x
IsCallerAccountType: failed hr = 0x%x
DeviceIdHelpers::UpdateDeviceLicenseInfo
To retrieve system device id, caller must be the local system account on the machine
hr = pDeviceHelper->HandleRenewDeviceId( pServiceExecutionContext, g_szStrongAuthAppId, 0, 0, hIdentityHandle, hNewIdentityHandle, nullptr, nullptr)
pDeviceHelper->IsHwdDeviceIDEnabled()
hr = pDeviceHelper->RetrieveDeviceID( g_szStrongAuthAppId, IDCRL_DEVICE_ID_FROMCACHE, nullptr, NULL, nullptr, nullptr, nullptr, hNewIdentityHandle)
hr = pDeviceHelper->RetrieveDeviceID( g_szStrongAuthAppId, 0, nullptr, IDCRL_DEVICE_ID_GET_VALID_DA_TOKEN, nullptr, nullptr, nullptr, hIdentityHandle)
hr = PPCRL_E_DEVICE_ID_REPROVISIONED
DeviceIdHelpers::HandleReprovisionDevice
hr = pServiceWrapper->IsCallerAccountType(SECURITY_LOCAL_SYSTEM_RID, bIsSystemContext)
hr = pDeviceHelper->ReprovisionDevice(pServiceExecutionContext, g_szStrongAuthAppId, 0, reprovisionReason, hSystemDeviceIdentity, hNewSystemDeviceIdentity)
hr = pDeviceHelper->ReprovisionDevice(pServiceExecutionContext, g_szStrongAuthAppId, 0, reprovisionReason, hExistingDeviceId, hNewDeviceId)
DeviceIdHelpers::ReprovisionDeviceInternal
hr = pDeviceHelper->ReprovisionDevice(pServiceExecutionContext, appId, 0, reprovisionReason, hExistingDeviceId, hNewDeviceId)
AcquireProvisioningMutex( false, 0, mutexAcquired, attemptProvisioning)
hExistingDeviceId != nullptr
hr = pDeviceHelper->DeProvisionDeviceId(appId, deviceType, IDCRL_DEVICE_ID_FORCE_CLOSE, hExistingDeviceId, hrReprovisionReason)
ReprovisionDevice
hr = g_pPPCRL->GetIdentityStore()->GetDeviceIdentityMap().AssociatDeviceToApp(hNewIdentity->GetUserType(), hNewIdentity->GetIdentityName(), appId)
hr = pDeviceHelper->CreateNewDeviceIdentity(deviceType, appId, 0, 0, hExistingDeviceId->GetIdentityName(), hrReprovisionReason, hNewIdentity)
hr = pDeviceHelperWrapper->HandleRenewDeviceId( pServiceExecutionContext, g_szStrongAuthAppId, 0, 0, hSystemDeviceId, hSystemDeviceIdNew, nullptr, nullptr)
hr = pDeviceHelperWrapper->RenewDeviceId(wstrAppId, dwDeviceType, flags, hNewIdentity, ppCertContext, ppszKeypair)
hr = pDeviceHelperWrapper->HandleReprovisionDevice(pServiceExecutionContext, wstrAppId, (hrInternal == PP_E_DEVICE_EXISTS_WITH_STRONG_CREDS || hr == PPCRL_E_DEVICEID_INVALID) ? false : true, (hrInternal == S_OK ) ? hr : hrInternal, hIdentity, hNewIdentity)
UpdateDeviceTpmInfo determined client is bound to Software TPM so hardware attestation will not work
ShouldUpdateTpmInLongTermAttestationFailure - AIK: 0x%x - %d, AutoPilot TPM state: 0x%x - %d, TPM Update required: %d
hr = tpmFunctions->RevokeDeviceAttestationKey()
hr = hIdentity->QueryInterface(EDeviceIdentityType, reinterpret_cast<void**>(&pSystemDeviceIdentity))
UpdateDeviceLicenseInfo
DeviceProvisioningEarlyExitLogic
hrReprovisionReason = 0x%x
CSingleIdentity::SetReprovisionErrorCode
hr = HRESULT_FROM_WIN32(lastError)
CAutoRevertToSelf::Revert
hr = pRequest->GetServiceEndpoint(executionContext, wstrHost, wstrUrlPath, nPort)
this=0x%p, pRequest=0x%p
hr = SendInternal( pRequest, wstrHost, nPort, reinterpret_cast<DWORD_PTR>(pRequest), wstrUrlPath)
hr = SendRequest(pRequest)
CTransport::SendDeviceRequest
this=0x%p, pRequest=0x%p, lpszServerName=%s, nServerPort=%d, lpszUrlPath=%s
hr = pRequest->BuildRequest()
CTransport::SendInternalHelper
CTransport::SendInternal
GetUserAgentString failed (0x%x).
Send to host:%s, port: %d, path:%s
Retrying send/receive w/ revocation check disabled.
SendImplementation failed 0x%x.
Acquiring caller nt token failed 0x%x.
Aquiring caller nt token failed 0x%x.
WinHttpConnect failed 0x%x.
WinHttpOpenRequest failed 0x%x
Failed to set user proxy settings, hr=0x%x..
AddCustomHTTPHeaders failed 0x%x.
Could not decrypt proxy password. HR=(0x%x).
Unable to set WINHTTP_OPTION_PROXY_USERNAME - WinHttpSetOption failed (0x%x).
Ignoring E_INVALIDARG error when resetting INTERNET_OPTION_CLIENT_CERT_CONTEXT - InternetSetOption failed (0x%x).
GetClientCert failed with 0x%x.
DecryptRequest failed with 0x%x.
Unable to set INTERNET_OPTION_CLIENT_CERT_CONTEXT - InternetSetOption failed (0x%x).
WinHttpCloseHandle failed on request
Current time is %s.
InternetCloseHandle failed on connection
OnInternetEvent REQUEST_COMPLETE detected, processing results.
ObtainResponse on 0x%p, m_pIdentity=0x%p 
WinHttpQueryHeaders returns %d.
Out of memory allocating response buffer.
SupportedSchemes %d, FirstScheme %d, Target %d.
The server requires authentication. Status %d.
Error. Status code %d returned.
The proxy requires authentication. Status %d.
WinHttpQueryDataAvailable bytes available %d.
WinHttpQueryHeaders failed 0x%x
WinHttpReadData failed 0x%x
Response size (%ld) is outside acceptable range - discarding.
Read total %d characters.
WinHttpReadData bytes read %d.
Unable to parse response (0x%x).
Empty response received from server.
Problem trying to close down WinInet (0x%x).
this=0x%p, m_pIdentity=0x%p
Headers received from server: %ls
QUERY_RAW_HEADERS %d characters.
StatusCallback: Request failed with WINHTTP_CALLBACK_STATUS_SECURE_FAILURE 0x%x
WinHttpSetTimeouts failed (0x%x).
WinHttpReceiveResponse failed 0x%x.
CSessionAppSettingsMap::SetAppSettings
hr = cConfigLocal.ResetOptions(pOptions)
hr = cConfigLocal.SetOptions(pOptions)
hr = GetRPCClientAppKey(appKey)
CSessionAppSettingsMap::SetAppId
CSessionAppSettingsMap::GetAppId
hr = GetAppSettings(appKey, cConfig)
hr = client.GetSessionId(dwSessionID)
pOptions
CAppConfigSettings::SetOptions
hr = m_cConfig.SetOptions(pOptions)
onecoreuap\ds\ext\live\identity\ntservice\lib\svccommon\Include\AppConfig.h
Removing %hs token in Token Bag '%ls' %p
CIdentityTokenBag::RemoveToken
CIdentityTokenBag::RetrieveSessionKey
http://Passport.NET/purpose
CIdentityTokenBag::SetDefaultUserForTarget
hr = m_keyCache.BroadcastUpdate( &context, WLID_IDENTITY_KEYUPDATE, KEY_UPDATE_VERSION, KeyUpdateNotification)
hr = NotifyKeyUpdate()
hr = m_keyCache.ProcessKeyXml(&context, CStringA(CW2AEX<>(static_cast<LPCWSTR>(wstrProperty), CP_UTF8)) )
hr = ParseDateTimeString(wstrProperty, keyVersionTimeStamp, TRUE)
hr = m_keyCache.GetKeyLatest(&context, g_wszKeyPurpose_LocalCredential, FALSE, userKey)
Invalid timestamp: %ls
hr = SetUserPropertiesToSystemStore( m_wstrIdentityName, identityStorePropertyBag, callerSidOverWrite )
CIdentityTokenBag::DeleteKeyCache
hr = m_keyCache.ProcessKeyXml(&context, pXMLNode )
hr = m_keyCache.GetKeyLatest(&context, wszPurpose, requireMaterial, key)
hr = m_keyCache.GetKeySpecific(&context, wszPurpose, wszVersion, key)
hr = InMemoryEncryptW( g_pPPCRL->GetSessionRandomKey().GetHandle(), clearTextPassword, encryptedPassword )
onecoreuap\ds\ext\live\identity\ntservice\lib\svccommon\trustedpchandler.cpp
TrustedPCHandler::AddTrustedPC
hr = pExecutionContext->GetServiceWrapper()->HandleAssociateDeviceToUser(g_szStrongAuthAppId, hUser, machineName, DeviceAssociationTypes::TrustedPC )
hr = pExecutionContext->GetServiceWrapper()->HandleCreateContext(L"", CREATECONTEXT_SET_APP_IDENTITY, &hUser, c_addTrustedPCApplicationId)
ext-ms-win-ntos-tm-l1-1-0
PersistNewMemberNameCredentials
hr = pRequest->ParseResponse(response.GetBuffer(), response.GetLength(), errorCategory)
hr = pRequest->Initialize(renameAccountData.pNewIdentity, "")
UpdateModernIdentityStore
hr = HandlePersistCredential(renameAccountData.hNewUser, PPCRL_CREDTYPE_PASSWORD, 0)
hr = renameAccountData.pNewIdentity->GetCredProperty(PPCRL_CREDPROPERTY_FIRSTNAME, firstName)
hr = renameAccountData.pNewIdentity->GetCredProperty(PPCRL_CREDPROPERTY_PUIDSTR, puid)
hr = identityStorage.UpdateIdentityNameProperties(puid, renameAccountData.newEmailId, firstName, lastName)
hr = renameAccountData.pNewIdentity->GetCredProperty(PPCRL_CREDPROPERTY_LASTNAME, lastName)
CloudAP
wlidsvc
hr = ExtensionAPI::FormatUserDisplayName(firstName, lastName, &pDisplayName, nullptr)
UpdateSamProperties
Failure - LsaRegisterLogonProcess, HRESULT: 0x%08X
hr = SerializeObject(serializer, propertyBag, &apEncodedBuffer, &encodedBufferLength)
hr = ULongAdd(encodedBufferLength, sizeof(CLOUD_AP_RENAME_ACCOUNT_INPUT) - ANYSIZE_ARRAY, &protocolBufferLength)
Failure - LsaLookupAuthenticationPackage, HRESULT: 0x%08X
LsaCallAuthenticationPackage status = 0x%x.
hr = SafeCopyMemory(apCloudProtocolBuffer->abSerializedProperties, (protocolBufferLength - sizeof(CLOUD_AP_RENAME_ACCOUNT_INPUT) + ANYSIZE_ARRAY), apEncodedBuffer, encodedBufferLength)
RenameLocalConnectedAccount
LsaCallAuthenticationPackage protocolStatus = 0x%x.
hr = UpdateSamProperties(renameAccountData)
hr = DeleteIdentityStore(renameAccountData.hOldUser, true, NULL, cid, isAssociated)
hr = client.GetSessionId(currentSessionId)
hr = HandleConnectIdentity(renameAccountData.hNewUser, &connectFlags, NULL)
WTSEnumerateSessions failed = 0x%x.
Console
WTSDisconnectSession failed = 0x%x.
Console session id = %d, state = %d.
WinStationQueryInformationW failed = 0x%x.
WTSDisconnectSession succeeded for session id = %d.
Failure - CreateTransaction, HRESULT: 0x%08X
RenameDomainConnectedAccount
hr = HandleConnectIdentity(renameAccountData.hNewUser, &connectFlags, hTransaction)
hr = DeleteIdentityStore(renameAccountData.hOldUser, true, hTransaction, cid, isAssociated)
IsDomainConnected
Failure - CommitTransaction, HRESULT: 0x%08X
RenameConnectedAccount
hr = client.GetTokenUser(sid)
hr = client.GetSessionId(sessionId)
hr = IsDomainConnected(renameAccountData.oldEmailId, isDomainConnected)
hr = RenameDomainConnectedAccount(renameAccountData, cid)
pExecutionContext->GetServiceWrapper()->Revert(&autoRevert)
hr = RenameLocalConnectedAccount(pExecutionContext, renameAccountData, cid)
New name not set.
hr = SystemStoreLite::IsConnected(serviceExecutionContext.GetExternalExecutionContextLite(), &isCurrentIdentityConnected, &pConnectedLiveUserName)
renameAccountData.newEmailId.CompareNoCase(renameAccountData.oldEmailId) != 0
hr = HandleCreateContext(renameAccountData.newEmailId, CREATECONTEXT_SET_APP_IDENTITY, &renameAccountData.hNewUser, c_renameAccountApplicationId)
No rename required.
hr = PersistNewMemberNameCredentials(requestType, response, originalSessionKey, originalSessionKeyType, renameAccountData)
hr = g_pPPCRL->GetIdentityStore()->GetSingleIdentity(logonId, renameAccountData.hNewUser, renameAccountData.pNewIdentity)
hr = UpdateModernIdentityStore(&serviceExecutionContext, renameAccountData)
hr = RenameConnectedAccount(&serviceExecutionContext, renameAccountData)
IsTransactionAPIPresent
RpcExceptionCode hr = 0x%x.
[_9*Ohr = _pIdWrapper->GetOneTimeCredential(hIdentity, IDCRL_WEBAUTH_NONE, _appID, tokenPurpose, url, token, &unsignedToken, &timeSkew)
UpdateProofOfPossessionTokenInAuthPackage failed with hr = 0x%x, continuing
hr = UrlUtilities::GetColorSet(&immersiveFunctions, colorCookieData.CookieData)
WebCookieManager::WriteColorSetCookieData
hr = _pServiceWrapper->GetConfigString(c_wsz_cfg_CookieP3PHeader, colorCookieData.P3PHeader)
hr = CClientConfigDataCacheManager::theConfigDataManager().GetServiceURI(c_wszConfigWLDomain, colorCookieDomain)
hr = PublishCookie(colorCookieData, true)
RegCreate failed for path '%s', exiting, hr = 0x%x
SetCookie failed, also failed cleaning up cookie key, ret = 0x%x
hr = SetCookieValue<LPCTSTR>(regCookieKey, PPCRL_REG_COOKIES_NAME, cookie.CookieName, cookie.CookieName.IsEmpty(), &(ICRegKeyWrapper::SetStringValue))
hr = SetCookieValue<LPCTSTR>(regCookieKey, PPCRL_REG_COOKIES_URL, cookie.Url, cookie.Url.IsEmpty(), &(ICRegKeyWrapper::SetStringValue))
hr = SetCookieValue<DWORD>(regCookieKey, PPCRL_REG_COOKIES_FLAGS, cookie.Flags, (cookie.Flags == 0), &(ICRegKeyWrapper::SetDWORDValue))
DeleteValue returned ERROR_FILE_NOT_FOUND, treating as success.
ManageApproverRequest::BuildRegisterRequest
Windows
onecoreuap\ds\ext\live\identity\ntservice\lib\svccommon\manageapproverrequest.cpp
</wsse:BinarySecurityToken></wsse:Embedded></wsse:SecurityTokenReference>
<wsse:SecurityTokenReference><wsse:Embedded wsu:Id="DeviceDAToken"><wsse:BinarySecurityToken ValueType="urn:liveid:device" id="DeviceDAToken">
</ps:ClientVersion>
<ps:ClientVersion>
</ps:PackageSID>
<ps:PackageSID>
<ps:DevicePUID>
<ps:ManageApproverRequest>
<ps:Action>
</ps:DevicePUID>
</ps:Action>
Register
</ps:ChannelID>
<ps:ChannelID>
<ps:ServerKeyIdentifier>
hr = CPPCRLBaseRequest::ComputeServerKeyId( pNgcPublicKey, ngcPublicKeySizeBytes, serverKeyId)
</ps:ManageApproverRequest>
</ps:ServerKeyIdentifier>
ManageApproverRequest::BuildRequest
<ps:AuthInfo>
<ps:UserPUID>
<wsse:BinarySecurityToken id="DeviceDAToken" ValueType="urn:liveid:sha1device">
Unregister
</ps:UserPUID>
hr = CreateDOM(response, k_cvPPCRLSTSNamespaces, pXmlResponse)
ManageApproverRequest::ParseResponse
hr = pNode->selectSingleNode(CComBSTR(c_szManageApproverTOTPSharedKeyPath), &pTotpSharedKey)
hr = pXmlResponse->selectSingleNode(CComBSTR(c_szManageApproverResponsePath), &pNode)
hr = pNode->selectSingleNode(CComBSTR(c_szManageApproverErrorcodePath), &pErrorNode)
hr = pTotpSharedKey->get_text(&_totpSharedKey)
hr = ParseNumericHResult(pNode, CComBSTR(c_szManageApproverErrorSubcodePath), hrSubError)
hr = pErrorNode->get_text(&errorCode)
ManageApproverRequest::SaveTotpKeyToCache
No ErrorSubcode found. Using default errorcode 0x%x.
hr = CAuthInfo::EncryptCredentialsInSystemContext(&executionContext, reinterpret_cast<char*>(static_cast<BYTE*>(spTotpKeyData)), totpKeySizeInBytes, credsOut)
ManageApproverRequest::Base32Decode(_totpSharedKey, _totpSharedKey.Length(), &spTotpKeyData, &totpKeySizeInBytes)
ManageApproverRequest::DeleteTotpKeyFromCache
No TOTPSharedKey returned by MSA Server after successful ManageApproverRequest. Using default errorcode 0x%x.
Invalid input to Base32Decode function.
ManageApproverRequest::Base32Decode
hr = ManageApproverRequest::Base32WCharToVal(pEncodedString[inputIndex], wcharValue)
hr = spBuffer.Allocate(spBufferSizeBytes)
Invalid Base32 Char in TOTP Secret.
ManageApproverRequest::Base32WCharToVal
Update
./cfg:LOGICAL
./cfg:ThrottledApp
./cfg:ThrottledAppMaxRequests
./cfg:ThrottledAppID
CertDuplicateCertificateContext failed with hr=0x%x
 xmlns:cfg="http://schemas.microsoft.com/Passport/PPCRL"
Windows Live ID Token Issuer
pXMLConfigData->QueryInterface(IID_PPV_ARGS(&pXmlDoc2))
CCRLConfig::FillRegConfigData
.//cfg:Configuration
pXmlDoc2->setProperty(CComBSTR(XML_PROP_SELECTION_NAMESPACES), cvNamespaces)
.//cfg:Settings
hr = pXMLConfigData->selectSingleNode(CComBSTR(_T(".//cfg:Configuration")), &pNode)
selectSingleNode failed - pNode is NULL. 0x%x.
hr = pXMLConfigData->selectSingleNode(CComBSTR(_T(".//cfg:Settings")), &pNode)
Could not read value of node cfg:CertificateAuthorityStoreName, using default. 0x%x
./cfg:CertificateAuthorityStoreName
Could not get next node in configuration xml. 0x%x.
get_childNodes failed - pList is NULL. 0x%x.
Could not read value of node %s. 0x%x
Could not read value of node %s. 0x%x, trace and continue
Read ResolveTimeout value of %d.
cfg:ResolveTimeout
cfg:ConnectTimeout
ChangeType failed for ResolveTimeout
ChangeType failed for ConnectTimeout
Read ConnectTimeout value of %d.
Read SendTimeout value of %d.
cfg:SendTimeout
cfg:ReceiveTimeout
ChangeType failed for SendTimeout
ChangeType failed for ReceiveTimeout
Read ReceiveTimeout value of %d.
Read AddressResolutionTTL value of %d.
cfg:AddressResolutionTTL
cfg:ClientTimeOutForRpcCallsNoNetwork
ChangeType failed for AddressResolutionTTL
ChangeType failed for ClientTimeOutForRpcCallsNoNetwork
Read ClientTimeOutForRpcCallsNoNetwork value of %d.
Read ClientTimeoutForRpcCallsWithNetwork value of %d.
cfg:ClientTimeoutForRpcCallsWithNetwork
cfg:ClientTimeoutForUI
ChangeType failed for ClientTimeoutForRpcCallsWithNetwork
ChangeType failed for ClientTimeoutForUI
Read ClientTimeoutForUI value of %d.
Read LivesspMaxTokenSize value of %d.
cfg:LivesspMaxTokenSize
cfg:PictureCoherenceUserTileUpdateInterval
ChangeType failed for LivesspMaxTokenSize
ChangeType failed for PictureCoherenceUserTileUpdateInterval
Read PictureCoherenceUserTileUpdateInterval value of %d.
Read PictureCoherenceUserTileRetryOnFailureInterval value of %d.
cfg:PictureCoherenceUserTileRetryOnFailureInterval
Read DeviceDNSSuffix value of '%s'.
ChangeType failed for PictureCoherenceUserTileRetryOnFailureInterval
DeviceDNSSuffix is not BSTR type, type: %d
DeviceDNSSuffix
Read ConfigServerSslURI value of '%ls'.
cfg:ConfigServerSslURI
cfg:DIDCOMMetaData
ConfigServerSslURI is not BSTR type, type: %d
cfg:Certificate
ParseDIDCOMMetaData failed with 0x%x
AddCertificateToIDCRLStore failed with hr=0x%x
expired
cfg:CertificateAuthority
AddCertificateAuthority failed with hr=0x%x
Read DisableSSO value of %d.
cfg:DisableSSO
cfg:RemeberBadProxyTimeSpan
ChangeType failed for DisableSSO
ChangeType failed for RemeberBadProxyTimeSpan
Read RemeberBadProxyTimeSpan value of %d.
AccountDomain is not BSTR type, type: %d
Read AccountDomain value of '%s'.
AccountDomainPolicy is not BSTR type, type: %d
Read AccountDomainPolicy value of '%s'.
ConnectAccountPolicy is not BSTR type, type: %d
Read ConnectAccountPolicy value of '%s'.
ChangeType failed for MinPasswordLength
Read MinPasswordLength value of %d.
ChangeType failed for MinPasswordCharacterGroups
Read MinPasswordCharacterGroups value of %d.
CookieP3PHeader is not BSTR type, type: %d
Read CookieP3PHeader value of '%s'.
InterruptResolutionDomain is not BSTR type, type: %d
Read InterruptResolutionDomain value of '%s'.
PasswordReset is not BSTR type, type: %d
Read PasswordReset value of '%s'.
Read m_dwThrottleMaxRequests=%d.
Read m_dwThrottleFlags=%x.
Read m_dwHardwareUpdateMaxRequests=%d.
Read m_dwHardwareBindingMaxRequests=%d.
Read m_dwTpmBindingMaxRequests=%d.
Read m_dwHardwareOutOfToleranceUpdateMaxRequests=%d.
ParseThrottledApps failed with 0x%x
Read m_dwThrottleTotalIntervalSeconds=%d.
Read m_dwNegativeCacheMaxRequests=%x.
Read m_dwNegativeCacheFlags=%x.
Read m_dwNegativeCacheIntervalMultiplierForPersistentFailures=%x.
Read m_dwNegativeCacheIntervalSeconds=%x.
Read StrongAuthPolicy value of '%ls'.
Read m_dwRPCIdleStopTimeout=%d.
Read EnableServerPasswordChange value of %d.
StrongAuthPolicy is not BSTR type, type: %d
Read m_dwDeviceProvisioningFailureThreshold=%d.
ChangeType failed for EnableServerPasswordChange
CleanupCertificateAuthority failed with hr=0x%x
Unexpected XML node with name %s
CCRLConfig::GetConfigVersion
.//cfg:ServiceURIs
.//cfg:ConfigVersion
Node value returned from Prefix is 0 length
Node value returned from DATA is NULL or invalid
ParseDIDConfigBoolean for %s failed with %x
ProviderPasswordLength
hr = registryHelper.WriteBufferToRegistry( HKEY_USERS, WLID_REG_SYSTEM_USER_IDCRL_PATH, WLID_REG_PROVIDER_DEFAULT_PASSWORD_LENGTH, REG_DWORD, reinterpret_cast<BYTE*>(&m_ConfigData.m_dwMinPasswordLength), sizeof(m_ConfigData.m_dwMinPasswordLength))
.DEFAULT\Software\Microsoft\IdentityCRL
hr = registryHelper.WriteBufferToRegistry( HKEY_USERS, WLID_REG_SYSTEM_USER_IDCRL_PATH, WLID_REG_PROVIDER_DEFAULT_PASSWORD_CHARACTER_GROUPS, REG_DWORD, reinterpret_cast<BYTE*>(&m_ConfigData.m_dwMinPasswordCharacterGroups), sizeof(m_ConfigData.m_dwMinPasswordCharacterGroups))
ProviderPasswordCharacterGroups
value returned for %s returned is not 1 or 0 length
value returned for %s returned is not 1 length
%s returned is empty!
%s returned is not a valid value
CUserCIDCache::GetCID
CUserCIDCache::AddCID
onecoreuap\ds\ext\live\identity\ntservice\lib\svccommon\usercidcache.cpp
onecoreuap\ds\ext\live\identity\ntservice\lib\svccommon\targetstore.cpp
CTargetStore::SetUserByTarget
CTargetStore::GetUserByTarget
Set target map '%ls' : '%ls'.
Found default user '%ls' for '%ls'.
onecoreuap\ds\ext\live\identity\ntservice\lib\svccommon\otcrequest.cpp
COTCRequest::BuildRequest
Invalid member name, %ls. Returning hr: %x
COTCRequest::ParseResponse
login=%hs&mobilenum=%ls&purpose=%ls&lcid=%d&xml=1&channel=%ls
 xmlns:SOAP="http://www.w3.org/2003/05/soap-envelope" xmlns:psf="http://schemas.microsoft.com/Passport/SoapServices/SOAPFault"
GetTokenInformation failed with %d
LocalAlloc failed with %d
onecoreuap\ds\ext\live\identity\ntservice\lib\svccommon\kiosk.cpp
NetUserModalsGet failed with error code : [%d]
StrongCredentialKeyDataRequest::GetSignatureXml
<wssc:DerivedKeyToken wsu:Id="SignKey" Algorithm="%hs"><wssc:Nonce>
StrongCredentialKeyDataRequest::ParseResponse
#GKDR
StrongCredentialKeyDataRequest::GetSessionKeyToSign
Could not read ServerTime attribute of ServerInfo node. HR=0x%x.
onecoreuap\ds\ext\live\identity\ntservice\lib\svccommon\totphelper.cpp
TotpHelper::GetTOTPCode
Result of HMAC(K,C) for SHA-1 having invalid data.
TotpHelper::ReadTotpSharedSecretFromCache
hr = StringCchCopyW(spLocalTotpCode, localTotpCode.GetLength() + 1, static_cast<LPCWSTR>(localTotpCode))
TotpHelper::GetTimeStep
onecoreuap\ds\ext\live\identity\ntservice\lib\svccommon\getappdatarequest.cpp
GetAppDataRequest::BuildRequest
<ps:AppID clientid="
<ps:GetAppDataRequest xmlns:ps="http://schemas.microsoft.com/Passport/SoapServices/PPCRL" Id="RSTS" version="1.0"><ps:AppIDs>
</ps:AppID></ps:AppIDs></ps:GetAppDataRequest>
GetAppDataRequest::ParseResponse
GetAppDataRequest::GetSignatureXml
GetAppDataRequest::GetSessionKeyToSign
Parsed response: App isFirstParty property value %d
CGetUserKeyDataRequest::BuildRequest
hr = GetOneTimeToken( m_pIdentity, strUserAuthToken)
onecoreuap\ds\ext\live\identity\ntservice\lib\svccommon\getuserkeydatarequest.cpp
hr = BuildRequestBody(strBody)
hr = GetDeviceOneTimeToken(nullptr, strDeviceAuthToken)
<KeyPurpose>%s</KeyPurpose>
<GetKeyDataRequest xmlns="http://schemas.microsoft.com/Passport/SoapServices/PPCRL" version="1.0">      <KeyPurposes>
</GetKeyDataRequest>
</KeyPurposes>
CGetUserKeyDataRequest::AddPurpose
CGetUserKeyDataRequest::ParseResponse
UserIdKeyRegistrationRequest::BuildRequest
hr = GetPublicKeyXml(pPublicKey, publicKeySizeBytes, publicKeyXml)
onecoreuap\ds\ext\live\identity\ntservice\lib\svccommon\useridkeyregistrationrequest.cpp
<ps:ManageLoginKeyRequest Id="KRR" version="1.0"><ps:Action>
hr = GetKeyAttestationXml(pAttestationKeyCert, certSizeBytes, pAttestationClaim, claimSizeBytes, attestationXml)
hr = HRESULT_FROM_WIN32(::BCryptGenRandom(nullptr, random, sizeof(random), BCRYPT_USE_SYSTEM_PREFERRED_RNG))
</ps:ManageLoginKeyRequest>
<wssc:DerivedKeyToken wsu:Id="SignKey" Algorithm="%s"><wssc:Nonce>
hr = PassportEncode::Base64Encode(reinterpret_cast<void*>(random), sizeof(random), encodedRandom)
hr = DeviceIdHelpers::HandleRenewDeviceId(&serviceExecutionContext, g_szStrongAuthAppId, pDeviceIdentity->GetUserType(), 0, pDeviceIdentity, pNewDeviceIdentity, nullptr, nullptr)
hr = GetSessionKeyToSign(sessionKey, pDeviceIdentity, authToken)
hr = LiteCryptUtilities::GetPublicKeyComponents( pPublicKey, publicKeySizeBytes, &spEncodedModulus, &spEncodedExponent)
UserIdKeyRegistrationRequest::GetPublicKeyXml
</ds:Modulus><ds:Exponent>
<ps:KeyValue><ds:RSAKeyValue xmlns:ds="http://www.w3.org/2000/09/xmldsig#"><ds:Modulus>
UserIdKeyRegistrationRequest::GetKeyAttestationXml
</ds:Exponent></ds:RSAKeyValue></ps:KeyValue>
<ps:KeyAttestationKey>
hr = PassportEncode::Base64Encode( reinterpret_cast<void*>(pAttestationKeyCert), certSizeBytes, encodedCert)
hr = PassportEncode::Base64Encode( reinterpret_cast<void*>(pAttestationClaim), claimSizeBytes, encodedClaim)
</ps:KeyAttestationKey>
</ps:KeyAttestationBlob>
<ps:KeyAttestationBlob>
<ps:ManageLoginKeyRequest xmlns:ps="http://schemas.microsoft.com/Passport/SoapServices/PPCRL"
UserIdKeyRegistrationRequest::GetSignatureXml
<ps:ManageLoginKeyRequest
UserIdKeyRegistrationRequest::ParseResponse
hr = pNgcFunctions->NgcSignWithSymmetricPopKey( pSessionKey.GetBuffer(), pSessionKey.GetLength(), reinterpret_cast<const BYTE*>(LiteCryptUtilities::SeedLabel::SecureConversationRst2), static_cast<DWORD>(strlen(LiteCryptUtilities::SeedLabel::SecureConversationRst2) * sizeof(CHAR)), pRandom, randomSizeBytes, reinterpret_cast<const BYTE*>(signedInfo.GetString()), signedInfo.GetLength() * sizeof(CHAR), &spSignatureBlob, &signatureBlobSizeBytes)
hr = pNode->selectSingleNode(CComBSTR(c_szUserIdKeyRegistrationErrorcodePath), &pErrorNode)
hr = pXmlResponse->selectSingleNode(CComBSTR(c_szUserIdKeyRegistrationResponsePath), &pNode)
UserIdKeyRegistrationRequest::GetSessionKeyToSign
hr = ParseNumericHResult(pNode, CComBSTR(c_szUserIdKeyRegistrationErrorSubcodePath), _serverSubError)
ListSessionsRequest::BuildRequest
<ps:ListSessionsRequest>
onecoreuap\ds\ext\live\identity\ntservice\lib\svccommon\listsessionsrequest.cpp
</ps:CheckRegistration>
<ps:CheckRegistration>
</ps:Users>
<ps:Users>
ListSessionsRequest::ParseResponse
</ps:ListSessionsRequest>
hr = pXmlResponse->selectSingleNode(CComBSTR(c_szListSessionsFailureResponsePath), &pNode)
hr = pXmlResponse->selectSingleNode(CComBSTR(c_szListSessionsSuccessResponsePath), &pNode)
hr = ParseNumericHResult(pNode, CComBSTR(c_szListSessionsErrorSubcodePath), hrSubError)
hr = pNode->selectSingleNode(CComBSTR(c_szListSessionsErrorcodePath), &pErrorNode)
hr = ParseNonRegisteredPuids(pNode)
hr = ParseSessions(pNode)
hr = GetSessionData(&pSessionData, &dwSessionCount)
ListSessionsRequest::GetResponse
hr = pNode->selectSingleNode(CComBSTR(c_szSessionsPath), &pSessionsNode)
hr = GetNotRegisteredPuids(&pNotRegisteredPuids, &dwPuidCount)
ps:Sessions/ps:Session
ListSessionsRequest::ParseSessions
hr = pSessions->nextNode(&pSession)
hr = pNode->selectNodes(CComBSTR("ps:Sessions/ps:Session"), &pSessions)
ps:PUID
hr = PPCRL_RESPONSE_BADXML
ps:SessionID
hr = pSession->selectSingleNode(CComBSTR("ps:PUID"), &pPuidAttr)
ps:DisplaySessionID
hr = pSession->selectSingleNode(CComBSTR("ps:SessionID"), &pSessionIDAttr)
ps:State
hr = pSession->selectSingleNode(CComBSTR("ps:DisplaySessionID"), &pDisplaySessionIDAttr)
ps:RequestTime
hr = pSession->selectSingleNode(CComBSTR("ps:State"), &pStateAttr)
ps:ExpirationTime
hr = pSession->selectSingleNode(CComBSTR("ps:RequestTime"), &pRequestTimeAttr)
ps:SessionType
hr = pSession->selectSingleNode(CComBSTR("ps:ExpirationTime"), &pExpirationTimeAttr)
hr = pPuidAttr->get_text(&bstrPuid)
hr = pSession->selectSingleNode(CComBSTR("ps:SessionType"), &pSessionTypeAttr)
hr = pDisplaySessionIDAttr->get_text(&bstrDisplaySessionID)
hr = pSessionIDAttr->get_text(&bstrSessionID)
hr = pRequestTimeAttr->get_text(&bstrRequestTime)
hr = pStateAttr->get_text(&bstrState)
hr = pSessionTypeAttr->get_text(&bstrSessionType)
hr = pExpirationTimeAttr->get_text(&bstrExpirationTime)
hr = pNode->selectNodes(CComBSTR("ps:NotRegistered/ps:PUID"), &pNotRegisteredPuids)
ps:NotRegistered/ps:PUID
hr = pNotRegisteredPuids->nextNode(&pNotRegisteredPuid)
ListSessionsRequest::ParseNonRegisteredPuids
ListSessionsRequest::GetSessionData
hr = pNotRegisteredPuid->get_text(&bstrNonRegisteredPuid)
hr = DuplicateString(sessionItem.sessionId, response[index]->SessionId)
hr = DuplicateString(sessionItem.puid, response[index]->Puid)
hr = DuplicateString(sessionItem.state, response[index]->State)
hr = DuplicateString(sessionItem.displaySessionId, response[index]->DisplaySessionId)
hr = DuplicateString(sessionItem.expirationTime, response[index]->ExpirationTime)
hr = DuplicateString(sessionItem.requestTime, response[index]->RequestTime)
ListSessionsRequest::GetNotRegisteredPuids
hr = DuplicateString(sessionItem.sessionType, response[index]->SessionType)
hr = StringCchCopyW(localArrNotRegPuids[i], m_arrNotRegPuids[i].GetLength() + 1, static_cast<LPCWSTR>(m_arrNotRegPuids[i]))
hr = localArrNotRegPuids.Allocate(static_cast<DWORD>(m_arrNotRegPuids.GetCount()))
ApproveSessionRequest::BuildApproveSessionRequest
hr = AppendLoginKeyTokenToRequestXml(pExecutionContext, JWTXml, NGC_DONOT_DISPLAY_ALT_CRED_OPTION)
onecoreuap\ds\ext\live\identity\ntservice\lib\svccommon\approvesessionrequest.cpp
<ps:OneTimeCredentials xmlns:ps="http://schemas.microsoft.com/Passport/SoapServices/PPCRL">
<wsse:UsernameToken Id="user"><wsse:Username>
<ps:ApproveSessionRequest>
</ps:OneTimeCredentials>
</ps:SessionID>
<ps:SessionID>
</ps:SessionState>
<ps:SessionState>
</ps:SessionType>
<ps:SessionType>
ApproveSessionRequest::ParseApproveSessionResponse
</ps:ApproveSessionRequest>
hr = pNode->selectSingleNode(CComBSTR(c_szApproveSessionErrorcodePath), &pErrorNode)
hr = pXmlResponse->selectSingleNode(CComBSTR(c_szApproveSessionResponsePath), &pNode)
hr = pXmlResponse->selectSingleNode(k_bstrSoapFault, &pErrorNode)
hr = ParseNumericHResult(pNode, CComBSTR(c_szApproveSessionErrorSubcodePath), hrSubError)
ApproveSessionRequest::BuildApproveSessionNonceRequest
hr = ParseNumericHResult( pErrorNode, k_bstrSoapFaultInternalErrorCode, hrSubError )
</wsse:KeyIdentifier></wsse:SecurityTokenReference>
<wsse:SecurityTokenReference><wsse:KeyIdentifier ValueType="ps:LoginKeyToken" EncodingType="#Base64Binary">
ApproveSessionRequest::ParseApproveSessionNonceResponse
<wsse:Security xmlns="http://schemas.xmlsoap.org/ws/2004/04/trust">
hr = pNonceNode->get_text(&nonce)
hr = pXmlResponse->selectSingleNode(CComBSTR(c_szApproveSessionNonceResponsePath), &pNonceNode)
m_pIdentity != nullptr
isSystemContext == FALSE
hr = hSystemDeviceId->GetServiceToken(SERVICE_TARGET_PASSPORT, ppcrlAuthToken)
systemDeviceIdentifier.IsEmpty() == false
hr = CAuthRequest::ParseResponse(pResponse, responseSizeCharacters, errorCategory, false )
CDeviceAuthRequest2::ParseResponse
hr = CPPCRLRequest::ExtractSessionKey(pServiceExecutionContext, pXmlRSTResponse, sessionKeyObfuscated)
Triggered DeviceLicenseUpdate ServerInternalErrorCode 0x%x
hr = hSystemDeviceId->QueryInterface(EDeviceIdentityType, reinterpret_cast<void**>(&pSystemDeviceIdentity))
CDeviceAuthRequest2::ExtractSessionKey
hr = sessionKeyManager.PackSessionKeys(sessionKeyObfuscated, sessionKeyTpm, sessionKey)
rgRequestsOut.SetCount(requestCount)
m_pIdentity->HasAuthToken()
pDeviceIdentity->HasAuthToken()
hr = SaveToRegistry(wstrRegPath, wstrKeyName, CStringW(wstrKeyName))
hr = PersistCredential()
DeviceUpdatePropertiesRequest
DeviceUpdatePropertiesResponse
/S:Envelope/S:Body/ps:DeviceUpdatePropertiesResponse/Error/@Code
/S:Envelope/S:Body/ps:DeviceUpdatePropertiesResponse[@Success='true']
/S:Envelope/S:Body/ps:DeviceUpdatePropertiesResponse/ServerInfo/@ServerTime
/S:Envelope/S:Body/ps:DeviceUpdatePropertiesResponse/ErrorSubcode
/S:Envelope/S:Body/ps:DeviceUpdatePropertiesResponse/DeviceTpmKeyState
/S:Envelope/S:Body/ps:DeviceUpdatePropertiesResponse/ServerInfo/@BuildVersion
/S:Envelope/S:Body/ps:DeviceUpdatePropertiesResponse/lic:License
/S:Envelope/S:Body/ps:DeviceUpdatePropertiesResponse/HWPUIDFlipped
/S:Envelope/S:Body/ps:DeviceUpdatePropertiesResponse/LicenseKeySequence
/S:Envelope/S:Body/ps:DeviceUpdatePropertiesResponse/KeyHolderLicense/lic:License
CDeviceIdentityBase::CreateNewDeviceIdentity
/S:Envelope/S:Body/ps:DeviceUpdatePropertiesResponse/LicenseSignatureKeyVersion
createdDeviceLock != nullptr
hr = g_pPPCRL->GetIdentityStore()->GetDeviceIdentityMap().GetAssociatedDeviceName(GetUserType(dwType), wstrAppId, true, wstrDeviceIdName, bDeviceIdValid)
CDeviceIdentityBase::GetValidDeviceIdentity
No Device Id associated with App Id = %s found
No Valid Device Id exists.
hr = g_pPPCRL->GetIdentityStore()->GetDeviceIdentityMap().GetValidDeviceIDKey(GetUserType(dwType), wstrDeviceIdName)
hr = hIdentity->QueryInterface(EDeviceIdentityType, reinterpret_cast<void**>(&pDeviceIdentity))
hr = pBase->InitHandle(bAllowCreate, wstrDeviceIdName)
pBase != NULL
hr = InitMetaData()
GetDeviceInfo failed with hr = 0x%x
hr = DeviceIdStore::GetRegistryKey(GetUserType(m_dwType), m_wstrDeviceIDKey)
hr = hIdentity->GetCredBag()->StoreCredential(PPCRL_CREDTYPE_PASSWORD, wszPwd)
hr = CreateDeviceIdentityHandle(wszName, m_dwType, hIdentity)
CDeviceIdentityBase::Delete
hr = DeviceIdHelpers::GetRawPUIDFromCert(pCertContext, strPUID)
hr = DeviceIdHelpers::AuthDevice( hIdentity, m_cMetadata.m_cDeviceData, allowSystemRenew, hrLocal)
hr = DeleteHelper()
CDeviceIdentityBase::Provision
CDeviceIdentityBase::Authenticate
hr = hIdentity->ProvisionIdentity(GetUserType(dwType), hrSendResult)
IsProvisioningExplicit(dwType, bIsProvisioningExplicit)
GenerateRandomPassword failed with hr = 0x%x
GenerateRandomMembername failed with hr = 0x%x
hr = CreateDeviceIdentityHandle( wstrNewMembername, m_dwType, hNewIdentityLocal)
CreateInstance failed with hr = 0x%x
hr = hNewIdentity->GetCredBag()->StoreCredential(PPCRL_CREDTYPE_PASSWORD, wstrPwd)
hr = g_pPPCRL->GetIdentityStore()->AddAndGetDeviceIdentity(hNewIdentityLocal, hNewIdentity)
CDeviceIdentityBase::BindDeviceToHardware
Retry Provisioning  failed with hr = 0x%x
hr = Authenticate(true , nullptr )
hr = g_pPPCRL->GetThrottleManager()->CheckCurrentLimit(this, EPPCRLRequestTypeAddCredential, throttleScenario, false)
hr = pBindHardwareRequest->BuildRequest()
hr = pBindHardwareRequest->Initialize(this)
hr = GetRequestStatus()
hr = pBindHardwareRequest->Send()
CDeviceIdentityBase::UpdateDeviceLicenseInfo
BoundToHardware 
hr = g_pPPCRL->GetThrottleManager()->CheckCurrentLimit(this, EPPCRLRequestTypeUpdateDevice, throttleScenario, false)
hr = g_pPPCRL->GetNegativeCacheManager()->CheckNegativeCacheForScenario( NegativeCache::Scenarios::NegativeCacheForDeviceRequests, NegativeCache::SubScenarios::NegativeCacheForDeviceUpdateLicenseScenario)
hr = pUpdateDeviceLicenseRequest->BuildRequest()
hr = pUpdateDeviceLicenseRequest->Initialize(this)
g_pPPCRL->GetNegativeCacheManager()->UpdateNegativeCacheForScenario( NegativeCache::Scenarios::NegativeCacheForDeviceRequests, NegativeCache::SubScenarios::NegativeCacheForDeviceUpdateLicenseScenario, GetRequestStatus())
hr = pUpdateDeviceLicenseRequest->Send()
*ppCertContext != NULL
hr = DeviceIdHelpers::InternalRetrieveDeviceCert(this, true, m_cMetadata.m_cDeviceData.GetIsSystem(), ppCertContext, ppszKeypair )
hr = GetDeviceCreds().GetMembername(m_cMetadata.m_cDeviceData, wszName)
CDeviceIdentityBase::UpdateCredential
GetDeviceInfoFromPersistantStore failed with hr = 0x%x
!m_fGeneratedCred
hr = g_pPPCRL->GetNegativeCacheManager()->CheckNegativeCacheForScenario( NegativeCache::Scenarios::NegativeCacheForDeviceRequests, NegativeCache::SubScenarios::NegativeCacheForDeviceUpdateScenario)
hr =this->UpdateDeviceCredentials( GetUserType(m_dwType), m_cMetadata.m_cDeviceData.GetIsSystem(), wszPassword, nullptr)
hr = DeviceIdHelpers::GenerateRandomPassword(wszPassword)
hr = this->GetCredBag()->StoreCredential(PPCRL_CREDTYPE_PASSWORD, wszPassword)
g_pPPCRL->GetNegativeCacheManager()->UpdateNegativeCacheForScenario( NegativeCache::Scenarios::NegativeCacheForDeviceRequests, NegativeCache::SubScenarios::NegativeCacheForDeviceUpdateScenario, GetRequestStatus())
hr = this->GetCredBag()->RetrieveCredential(PPCRL_CREDTYPE_PASSWORD, wszPassword)
CDeviceIdentityBase::PersistCredential
hr = DeviceIdStore::AddHardwareInfoToPersistantStore( m_wstrDeviceIDKey, this->GetIdentityName(), m_ctHardwareBoundTime, m_tpmKeyStateClient, m_tpmKeyStateServer, m_licenseKeySequenceServer, m_licenseInstallError, m_licenseKeyVersionClient)
hr = DeviceIdStore::AddDeviceInfoToPersistantStore( m_wstrDeviceIDKey, this->GetIdentityName(), nullptr, wszPassword, m_ctLastUpdatedTime, m_ctDAInvalidationTime, m_bIsHardwareBound == false)
No DA Token present for %ls
Device DA validity check for %ls, %I64d, %I64d
Invalidating DA token for %ls obtained prior LastUpdatedTime: %I64d, %I64d
Invalidating DA token for %ls with session key in registry
Invalidating DA token for %ls obtained prior GlobalDevice LastUpdatedTime:  %I64d, %I64d
Invalidating DA token for %ls obtained prior DA InvalidationTime: %I64d, %I64d
CLogicalDeviceIdentity Protocol metadata lookup failed
Invalidating DA token for %ls to get obfuscated session key. Current session key type is %d
hr = DeviceIdStore::DeleteDeviceCredMan(m_cMetadata.m_strCredManAppName)
CLogicalDeviceIdentity::DeleteHelper
CPhysicalDeviceIdentity::DeleteHelper
CPhysicalDeviceIdentity Protocol metadata lookup failed
CSystemDeviceIdentity Delete certificate failed with hr 0x%x, continuing...
CSystemDeviceIdentity::DeleteHelper
CStringLockManager<class CRefReadWriteLockEx>::ReleaseLock
CSystemDeviceIdentity Remove Persisted Certificate failed with hr 0x%x, continuing...
onecoreuap\ds\ext\Live\identity\Include\StringLock.h
onecoreuap\ds\ext\live\identity\ntservice\lib\svccommon\provisionidentitywithtransfertokenrequest.cpp
S-1-5-18
DeviceIdStore::AddMembernameToDOM
pElement is null.
Could not remove previously cached auth info for app: %s. 0x%x.
Attempt to delete cached credentials for app %s resulted in nothing to do.
wstrDeviceIDKey=%s,wstrDeviceIDName=%s
Failed to Open registry with hr = 0x%x for key %s
wstrDeviceIDKey=%s,wstrDeviceIDName=%s,wstrPropertyname=%s,dwValue=%d
Failed to Set the DWORD property in registry hr = 0x%x for key %s
DeviceIdStore::SetDWORDDeviceProperty
DeviceIdStore::AddAppIdToPersistantStore
wstrDeviceKey=%ls,wstrDeviceName=%ls
Failed to Create registry with hr = 0x%x for key %s
Failed to Read registry with hr = 0x%x for key %s
szBuffer
wstrDeviceKey=%s,wstrDeviceName=%s,wstrAppId=%s
Unable to write App ID value, hr = 0x%x.
DeviceIdStore::DeleteAppIdFromPersistantStore
No Valid Device Id exists for key %s
DeviceIdStore::GetValidDeviceID
wstrDIDKey=%s,wstrValidDeviceIdName=%s
Failed to update registry with valid device id name hr = 0x%x for key %s
DeviceIdStore::UpdateValidDeviceID
EnumKey for %s failed with hr=%x
DeviceIdStore::GetStoredCertThumbprint
CAuthInfo.WriteDeviceToCache: failed hr = 0x%x
hr = GetExtendedPropertyInternal(c_wszExtendedPropertyKeyContainerName, wstrKeyContainer)
hr = GetExtendedPropertyInternal(c_wszExtendedPropertyCertThumb, wstrThumbprint)
wstrAttributeName=%s
SetExtendedProperty: failed with hr = 0x%x
Error moving to first attribute, error is %08.8lx
DeviceIdStore::GetAttribute
DeviceIdStore::LoadPersistedXml
Error getting value, error is %08.8lx
hr = lpStream->Write((void const*)CStringA(wstrXMLData), (ULONG)ulSize, (ULONG*)&ulBytesWritten)
Error creating xml reader, error is %08.8lx
hr = lpStream->Seek(liBeggining, STREAM_SEEK_SET, NULL)
Error setting input for reader, error is %08.8lx
Error setting XmlReaderProperty_DtdProcessing, error is %08.8lx
xmllite.dll
::LoadLibrary(xmllite.dll) failed with hr = %x
CreateXmlReader
DeviceIdStore::GetDeviceInfoUsingXmlLite
wstrDeviceIDKey=%ls,wstrUsername=%ls
Error getting local name, error is %08.8lx
::LoadPersistedXml failed with hr = %x
hr = GetAttribute(pXmlReader, g_bstrDeviceDAInvalidationTime, wstrDAInvalidationTime)
hr = GetAttribute(pXmlReader, g_bstrDeviceLastUpdatedTime, wstrLastUpdatedTime)
hr = GetAttribute(pXmlReader, g_bstrDevicePwdVersion, passwordVersion)
hr = GetAttribute(pXmlReader, g_bstrDeviceUsername, wstrTargetName)
GetAttribute LicenseKeySequence failed with 0x%x.
GetAttribute LicenseInstallError failed with 0x%x.
GetAttribute licenseKeyVersionClient failed with 0x%x.
hr = GetAttribute(pXmlReader, g_bstrDeviceTpmKeyStateClient, wstrTpmKeyStateClient)
hr = GetAttribute(pXmlReader, g_bstrDeviceHardwareBoundTime, wstrHwdBoundTime)
wstrTargetName is empty string.
hr = GetAttribute(pXmlReader, g_bstrDeviceTpmKeyStateServer, wstrTpmKeyStateServer)
DeviceIdStore::AddDeviceInfoToPersistantStore
wstrDeviceIDKey=%ls,wszUserName=%ls,wszOldUserName=%ls
::LoadPersistedDOM failed with hr = %x
hr = pDocumentElement->setAttribute(g_bstrDeviceLastUpdatedTime, cvAttributeValue)
::get_documentElement failed with hr = %x
hr = pDocumentElement->setAttribute(g_bstrDeviceDAInvalidationTime, cvAttributeValue)
Base64Encode failed, size: %d. hr = %x
pPasswordElement is null.
ctHWBoundTime=%ls
::SaveDOM failed with hr = %x
hr = DeviceIdStore::LoadPersistedDOM(wstrDeviceIDKey, wstrDeviceIDName, true, pDOM)
DeviceIdStore::AddHardwareInfoToPersistantStore
pNodeMembername is null.
hr = pDOM->selectSingleNode(CComBSTR(wstrXPath), &pNodeMembername)
SetAttribute LicenseKeySequence failed with 0x%x.
hr = pNodeMembername->selectSingleNode(CComBSTR(wstrXPath), &pNodeHwdInfo)
SetAttribute LicenseInstallError failed with 0x%x.
hardwareInfoElement is null.
SetAttribute LicenseKeyVersionClient failed with 0x%x.
licenseKeyVersionClientElement is null.
DecryptPassword
hr = DeviceIdStore::SaveDOM(wstrDeviceIDKey, wstrDeviceIDName, pDOM)
DecryptPasswordAndRewriteIfNeeded
hr = ConvertW2A(wszEncodedEncryptedData, strEncodedEncryptedData)
Rewriting device password for deviceIdKey="%ls", username="%ls", passwordVersion="%ls".
hr = DecryptPassword(pEncodedEncryptedPassword, clearPassword)
hr = DeviceIdStore::AddDeviceInfoToPersistantStore(deviceIdKey, pUsername, nullptr, clearPassword, lastUpdatedTime, daInvalidationTime, true)
::GetDocumentElement failed with hr = %x
Invalid DA Invalidation Time set = %ls, errno = %d
Invalid Last Bound Time set = %ls, errno = %d
Invalid Hwd Bound Time set = %ls, errno = %d
Encrypted password node is missing from store.
Invalid LicenseInstallError %ls
get_text failed with hr = %x
hr = DecryptPasswordAndRewriteIfNeeded(wstrDeviceIDKey, wstrUsername, bstrEncryptedPassword, passwordVersion.bstrVal, ctLastUpdatedTime, ctDAInvalidationTime, wstrPwd)
Encrypted password is empty in store.
Invalid Last Updated Time set = %ls, errno = %d
User name in registry key and xml do not match.
hr = DecryptPasswordAndRewriteIfNeeded(wstrDeviceIDKey, wstrUsername, wstrPassword, passwordVersion, ctLastUpdatedTime, ctDAInvalidationTime, wstrPwd)
GetCertThumbprint failed with hr = 0x%x
//%s[@%s='%s']/%s[@%s='%s']
DeviceIdStore::AddCertificatesToPersistantStore
StoreCertThumbprint failed with hr = 0x%x
pCertNodeMembername
RetrieveCertificateFromCertStoreInternal: failed with hr=0x%x
GetCertThumbFromCredMan: failed with hr = 0x%x
RetrieveCertificateFromCertStore: failed with hr = 0x%x
DeviceIdStore::DeleteCertificatesFromPersistantStore
eUserType=%d,wszUsername=%s
found %d certs for user
Failed to get current user SID hr = %x
wstrRegPath=%s,wstrKeyName=%s,wstrData=%s
DeviceIdStore::SaveDOM
Unable to write Device ID value, hr = 0x%x.
DeviceIdStore::SaveToRegistry
Failed to query interface. 0x%x
GetDeviceInfoUsingXmlLite failed with hr = %x
cvTargetName is not valid string.
<Data></Data>
hr = GetRegistryKey(deviceType,deviceKey)
deviceType=%d,resetValue=%d
QueryDWORDValue for %s failed with hr=%x
SetDWORDValue for %s failed with hr=%x
DeviceIdStore::SetDeviceLicenseUpdateFailure
DeviceIdStore::GetDeviceRegistryKey
deviceType=%d,deviceName=%ls
Failed to Open registry with hr = 0x%x for key %ls
hr = GetRegistryPath(deviceType, deviceName, deviceRegKeyPath)
DeviceIdStore::PersistDeviceSessionKey
deviceName=%ls
hr = GetDeviceRegistryKey(PPCRL_DEVICE_LOGICAL, deviceName, deviceRegKey)
hr = ConvertA2W(sessionKey, sessionKeyW)
DeviceIdStore::GetDeviceSessionKey
lRet == ERROR_SUCCESS
hr = ConvertW2A(wstrSessionKey, sessionKey)
ERROR_SUCCESS == lRet || ERROR_MORE_DATA == lRet
TPM ID buffer size query was unsuccessful, hr = 0x%x
TPM ID buffer allocation failed.
CXboxSignatureProvider::GetEcdsaSignatureFromHardware
hr = messageHash.Initialize(BCRYPT_SHA256_ALG_HANDLE, nullptr, 0)
hr = messageHash.AddData(pbMessage, cbMessage)
onecoreuap\ds\ext\live\identity\ntservice\lib\svccommon\hardwarecookiesig.cpp
hr = messageHash.GetValue(digest, sizeof(digest))
hr = messageHash.GetSize(&cbDigest)
hr = MsaDevice_GenerateEcsdaP256Signature(digest, sizeof(digest), spbSignature, cbSignature)
hr = spbSignature.Allocate(cbSignature)
CKeyCache::GetKeyLatestFromRegistryUpdateMemoryHelper
Unexpected error in UpdateKeyInRegistry: hr = 0x%x
Adding a key material for purpose: '%hs', version='%hs'
hr = GetKeyLatestNoLock(pExecutionContext, strPurpose, FALSE, latestKey)
CKeyCache::GetKeySpecificFromRegistryUpdateMemory
CKeyCache::GetKeyLatestFromRegistryUpdateMemory
Unexpected error in GetKeyFromRegistry. m_puid is not set
CKeyCache::GetKeyFromRegistry
CKeyCache::EncryptKeyMaterial
CKeyCache::UpdateKeyInRegistry
CKeyCache::DecryptKeyMaterial
hr = ProcessKeyXml(pExecutionContext, pPurposesNode)
hr = pPurposeList->nextNode(&pPurposeNode)
hr = pXMLNode->selectNodes(c_bstrKeyPurpose, &pPurposeList)
hr = pKeyList->nextNode(&pKey)
hr = pPurposeNode->selectNodes(c_bstrKeyData, &pKeyList)
hr = pKeyPropList->nextNode(&pKeyProp)
hr = pKey->selectNodes(c_bstrKeyProperty, &pKeyPropList)
hr = UpdateKeyCache(pExecutionContext, strPurpose, strVersion, strMaterial)
hr = pKeyProp->get_text(&bstrText)
hr = GetKeyLatestNoLock(pExecutionContext, strPurpose, FALSE, oCurKey)
CKeyCache::DeleteKeyCache
hr = UpdateAppId(eUserType, wstrAppId)
hr = GetAppIdDeviceMap(eUserType, spAppIdDeviceMap)
hr = spAppIdDeviceMap->GetAssociatedDeviceName(wstrAppId, bValidate, wstrDeviceName, bDeviceIdValid, bClearMap)
hr = DeviceIdStore::GetRegistryKey(eUserType, wstrRegKey)
CDeviceIdentityMap::AssociatDeviceToApp
CDeviceIdentityMap::ClearAppIdDeviceMap
AssociateDeviceToApp::Adding device %ls to sid %ls and app %ls. Valid Device Id is %ls
hr = spAppIdDeviceMap->UpdateAppDeviceAssociation(wstrAppId, wstrDeviceName)
DisassociateDeviceToApp::Removing device %ls from sid %ls and app %ls. Valid DeviceId is %ls
CDeviceIdentityMap::DisassociateDeviceToApp
CDeviceIdentityMap::GetValidDeviceIDKey
DeviceIdStore::GetRegistryKey(eUserType, wstrRegKey)
spAppIdDeviceMap->UpdateValidDeviceIDKey(wstrValidDeviceId, hrReason)
CDeviceIdentityMap::UpdateValidDeviceIDKey
%s_%s
Device ID (%s) is deleted from the persistent store hr = %x
DeviceIdStore::GetMembernameFromPersistantStore failed hr = %x
CAppIdDeviceMap::UpdateAppDeviceAssociation
hr = DeviceIdStore::AddAppIdToPersistantStore(m_wstrDeviceKey, wstrDeviceName, wstrAppId)
Reason
CAppIdDeviceMap::UpdateValidDeviceIDKey
CRandomDeviceCreds::GetMembername
onecoreuap\ds\ext\live\identity\ntservice\lib\svccommon\randomdevicecreds.cpp
onecoreuap\ds\ext\live\identity\passport\lib\crypt\random.cpp
bad allocation
&#39;
&#38;&#35;
queryStringName != nullptr && queryStringName[0] != L'\0'
hr = UrlEscapeW(queryStringValue, pBuffer, &requiredCharacters, escapeFlags)
"<>';()
0000000000000000
<Signature xmlns="http://www.w3.org/2000/09/xmldsig#"><SignedInfo>
<Reference>
<Transforms><Transform Algorithm="http://www.w3.org/2001/10/xml-exc-c14n#"></Transform></Transforms><DigestMethod Algorithm="http://www.w3.org/2000/09/xmldsig#sha1"></DigestMethod><DigestValue>
<Transforms><Transform Algorithm="http://www.w3.org/2000/09/xmldsig#enveloped-signature"></Transform><Transform Algorithm="http://www.w3.org/2001/10/xml-exc-c14n#"></Transform></Transforms><DigestMethod Algorithm="http://www.w3.org/2000/09/xmldsig#sha1"></DigestMethod><DigestValue>
Microsoft Base Cryptographic Provider v1.0
</X509SKI></X509Data>
<X509Data><X509SKI>
<Transforms><Transform Algorithm="http://www.w3.org/2000/09/xmldsig#enveloped-signature"></Transform><Transform Algorithm="http://www.w3.org/2001/10/xml-exc-c14n#"></Transform></Transforms><DigestMethod Algorithm="
CXmlSig2::BuildDigestedReferences
hr = ComputeReferenceDigest(xmlRef, strEncodedDigest)
hr = referenceHash.Initialize( hAlgProv, NULL, 0)
hr = referenceHash.AddData( (const PBYTE)(xmlRef.m_pcszCanonicalizedText), xmlRef.m_cchLenCanonicalizedText)
hr = ComputeSHADigest(xmlRef, strEncodedDigest)
hr = referenceHash.GetValue( bpDigest.GetBufferSetLength(dwSize, FALSE), dwSize)
hr = BuildDigestedReferences()
CXmlSig2::ComputeReferenceDigest
hr = ComputeRawSignature(strSigValue)
CSignatureComputingXmlSig2::ComputeSignature
CXmlHMACSHASig2::CheckSignedInfo
hr = GetHMACDigest(strComputedSigValue)
hr = signedInfoHash.AddData( const_cast<PUCHAR>(reinterpret_cast<const UCHAR*>(static_cast<LPCSTR>(m_strC14NSignedInfo))), m_strC14NSignedInfo.GetLength() *sizeof(CHAR))
hr = signedInfoHash.Initialize( hAlgProv, m_pbSecretKey.GetBuffer(), m_pbSecretKey.GetLength())
hr = signedInfoHash.GetValue( bpSigValue.GetBufferSetLength(dwSize, FALSE), dwSize)
hr = signedInfoHash.GetSize(&dwSize)
CXmlHMACSHASig2::VerifySignature
hr = CheckSignedInfo()
hr = g_algProvCache.GetAlgorithmProv( BCRYPT_SHA256_ALGORITHM, 0, hAlgProv)
hr = CheckDigestedReferences()
hr = signedInfoHash.Initialize( hAlgProv, NULL, 0)
CXmlEcdsaSha256HardwareSigBase2::ComputeRawSignature
hr = signedInfoHash.GetValue( bpHash.GetBufferSetLength(cbHash, FALSE), cbHash)
hr = signedInfoHash.GetSize(&cbHash)
hr = GetECDSASignatureFromHardware( bpHash.GetBuffer(), cbHash, rgbSignature, sizeof(rgbSignature))
SummaryCount
NumAllocationFailures
NumLargeEventFailures
MinEntriesFlushed
NumBucketLimitReached
TotalEntriesFlushed
MaxEntriesFlushed
NumFlushes
MaxEntriesStored
MicrosoftTelemetryAssertTriggeredUM
ntdll.dll
Current environment is %s
hr = SerializeObjectWithVersion( propertybagSerializer, identityPropertyBag, CurrentSerializationVersion, &apIdentityPropertyBuffer, &encodedSize)
IdentityStorage::WriteProperties
hr = registryHelper.WriteBufferToRegistry(NULL, GetEnvironmentSpecificRegistryKey(ModernDataPropertyRootKey), pDefaultId, REG_BINARY, apIdentityPropertyBuffer, encodedSize)
DeleteBufferFromRegistry failed = 0x%x
hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND)
hr = ReadCredentialInformation(GetEnvironmentSpecificRegistryKey(ModernDataPropertyRootKey), pUserId, propertybagSerializer, registryHelper, identityPropertyBag)
IdentityStorage::GetIdentityProperties
Failure - SetCount, HRESULT: 0x%08X
IdentityStorage::ReadCredentialInformation
hr = HRESULT_FROM_WIN32(LOCAL_STATUS)
RegEnumKeyEx for %s failed with hr=%x
hr = registryHelper.GetRootKey(pRegistryFunctions, HKEY_CURRENT_USER, &useKeyCurrentUser, &hkeyCurrentUser)
IdentityStorage::RemoveConnectedUser
Failure calling RecurseDeleteKey for Immersive node with path '%s', hr = 0x%x.
RegOpenCurrentUser() failed, hr = 0x%0x
hr = GetIdentityProperties(pUserId, identityPropertyArray)
IdentityStorage::UpdateIdentityNameProperties
hr = DeleteTicketsForUser(pUserId)
hr = WriteProperties(pUserId, identityPropertyArray)
CryptProtectData failed. error=0x%x.
SerializeObjectWithVersion
hr = SafeCopyMemory(apLocalResultBuffer + sizeof(version), bufferSize - sizeof(version), pEncryptedOut.pbData, pEncryptedOut.cbData)
hr = SafeCopyMemory(apLocalResultBuffer, bufferSize, &version, sizeof(version))
hr = registryHelper.ReadBufferFromRegistry( NULL, registryKey, registryValueName, RRF_RT_REG_BINARY, &apVersionAndObjectBuffer, &encodedSize)
SerializeObjectWithVersion() completed with hr = 0x%x.
Found invalid version returning ERROR_FILE_NOT_FOUND to caller.
hr = GetVersionAndObjectBuffer( apVersionAndObjectBuffer, encodedSize, &serializationVersion, &pObjectBuffer, &serializedBufferSize)
Caught exception in FreeObject(), hr = 0x%x.
DecryptAndDeserializeObject failed with 0x%x.
GetVersionAndObjectBuffer
FreeObject() in SerializationDefinition.h completed with hr = 0x%x.
GetVersionAndObjectBuffer() completed with hr = 0x%x.
Invalid data passed to GetVersionAndObjectBuffer.
CryptUnprotectData failed. HR=0x%x.
DecryptAndDeserializeObject
Software\Microsoft\IdentityCRL\Immersive\%s\Property
Software\Microsoft\IdentityCRL\Immersive\%s
UserTicket
hr = StringCbCopyA(spCopy, bytesNeeded, inlineUxParam)
MsaUserExtDefaultImpl::GetPlatformQualifier
hr = StringCbCopyA(spCopy, bytesNeeded, s_holoIdentity)
hr = StringCbCopy(spCopy, bytesNeeded, identity)
MsaUserExtImpl::GetPlatformQualifier
Windows9
PPICommunal
Hololens
onecoreuap\ds\ext\live\identity\lib\phoneutils\phoneutils.cpp
UrlContextInfo::GetPlatformIdentifiers
hr = MsaUserExtImpl::GetPlatformQualifier(&spPlatform)
URL query string platform is: %ls, uiflavor is: %ls
No specialized identifier for current platform.
TranslateScenarioIDByPolicy is translating uxScenarioId from %d to CONNECT_UX_SCENARIO::UX_SCENARIO_NO_MSA_UPSELL based on policy
GetConnectedAccountGroupPolicy failed with 0x%x
LsaGetSSOAccountType returned ssoAccountType: %d and webAccountProviderGuid = {%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}
LsaLookupUserAccountType failed with: 0x%x
IsEmbeddedModeAllowed(&isEmbeddedModeEnabled)
hr = pExecutionContext->GetSystemStoreLiteFunctions()->IsConnected(&isConnected, nullptr)
hr = IsUserAADJoined(isAADJoinedUser)
 SessionKeyManager::ImportSessionKey
hr = GetSessionKeyFunctions(sessionKey.GetSessionKeyType(), &pSessionKeyFunctions)
hr = pSessionKeyFunctions->ImportSessionKey( pSessionKeyExecutionContext, identityName, identityCid, sessionKeyBlob, sessionKeyId)
hr = UnPackSessionKeys( sessionKey, sessionKey1Blob, &pSessionKeyFunction1, sessionKey2Blob, &pSessionKeyFunction2)
sessionKey.IsEmpty() == false
Session key signing failed with error: %x. Continuing with single session key
hr = pSessionKeyFunction1->GetDerivedKey( pSessionKeyExecutionContext, logonUserToken, sessionKey1Blob, context, label, derivedKeySizeBytes, pSignatureKey)
hr = pSessionKeyFunction1->SignMessage( pSessionKeyExecutionContext, pSignatureKey, context, label, derivedKeySizeBytes, message, signature)
hr = pSessionKeyFunction2->VerifySignature( pSessionKeyExecutionContext, sessionKey2Blob, pSignatureKey, label, derivedKeySizeBytes, message, signature)
hr = pSessionKeyFunction1->GetDerivedKey( pSessionKeyExecutionContext, nullptr, sessionKey1Blob, context, label, derivedKeySizeBytes, pSignatureKey)
hr = pSessionKeyFunction1->VerifySignature( pSessionKeyExecutionContext, pSignatureKey, context, label, derivedKeySizeBytes, message, signature)
hr = pSessionKeyFunction2->DecryptMessage( pSessionKeyExecutionContext, sessionKey2Blob, pEncryptionKey, label, derivedKeySizeBytes, initializationVector, cipherText, plainText)
hr = pSessionKeyFunction1->GetDerivedKey( pSessionKeyExecutionContext, nullptr, sessionKey1Blob, context, label, derivedKeySizeBytes, pEncryptionKey)
hr = pSessionKeyFunction1->DecryptMessage( pSessionKeyExecutionContext, pEncryptionKey, context, label, derivedKeySizeBytes, initializationVector, cipherText, plainText)
hr = GetSessionKeyFunctions(sessionKey.GetSessionKeyType(), pSessionKeyFunctions1)
hr = GetSessionKeyFunctions(sessionKey1Type, pSessionKeyFunctions1)
hr = GetSessionKeyFunctions(sessionKey2Type, pSessionKeyFunctions2)
sessionKey2SizeBytes == (bpSessionKey.GetLength() - (4 * sizeof(DWORD)) - sessionKey1SizeBytes)
hr = PP_E_SESSIONKEY_INVALIDDATA
SessionKeyManager::PackSessionKeys
hr = SafeCopyMemory(pSessionKey, sizeof(DWORD), &sessionKey1Type, sizeof(DWORD))
hr = spSessionKey.Allocate(sessionKeySizeBytes)
hr = SafeCopyMemory(pSessionKey, sessionKey1SizeBytes, bpSessionKey1.GetBuffer(), sessionKey1SizeBytes)
hr = SafeCopyMemory(pSessionKey, sizeof(DWORD), &sessionKey1SizeBytes, sizeof(DWORD))
hr = SafeCopyMemory(pSessionKey, sizeof(DWORD), &sessionKey2SizeBytes, sizeof(DWORD))
hr = SafeCopyMemory(pSessionKey, sizeof(DWORD), &sessionKey2Type, sizeof(DWORD))
hr = SafeCopyMemory(pSessionKey, sessionKey2SizeBytes, bpSessionKey2.GetBuffer(), sessionKey2SizeBytes)
SymmetricSessionKeyFunctions::ImportSessionKey
hr = LiteCryptUtilities::DeriveKeyWithSP800108( sessionKey.GetBuffer(), sessionKey.GetLength(), context.GetBuffer(), context.GetLength(), label.GetString(), derivedKey.GetBufferSetLength(derivedKeySizeBytes), derivedKeySizeBytes)
SymmetricSessionKeyFunctions::GetDerivedKey
hr = xmlSig.GetHMACDigest(signature)
SymmetricSessionKeyFunctions::SignMessage
hr = xmlSig.VerifySignature()
hr = LiteCryptUtilities::DecryptContent( key.GetBuffer(), key.GetLength(), reinterpret_cast<const BYTE*>(initializationVector.GetString()), initializationVector.GetLength(), reinterpret_cast<const BYTE*>(cipherText.GetString()), cipherText.GetLength(), &spDecryptedBlob, &decryptedBlobSizeBytes)
SymmetricSessionKeyFunctions::DecryptMessage
hr = CWLIDCCHelper::ConvertToWide(&memoryManager, sessionKeyProtected, &spSessionKeyProtectedBlob)
hr = GetDeviceRegistryPath(pExecutionContextLite, keyIdentifier, deviceRegKeyPath)
ObfuscatedSessionKeyFunctions::PersistSessionKey
hr = GetDeviceSessionKeyFromStore(pExecutionContextLite, deviceName, sessionKeyProtected)
ObfuscatedSessionKeyFunctions::RetrieveSessionKey
HRESULT_FROM_WIN32(hr = pWinApiLite->GetLastError())
hr = PassportEncode::Base64Decode( sessionKeyProtected.GetString(), sessionKeyProtected.GetLength(), sessionKeyDecoded)
hr = GetDeviceRegistryPath(pExecutionContextLite, deviceName, deviceRegKeyPath)
ObfuscatedSessionKeyFunctions::GetDeviceSessionKeyFromStore
ObfuscatedSessionKeyFunctions::GetDeviceRegistryPath
hr = CWLIDCCHelper::ConvertToAnsi(&memoryManager, wstrSessionKey, &spSessionKeyBlob)
hr = pSystemStoreLiteFunctions->GetCurrentUserSidString(&spCurrentUserSid)
TpmSessionKeyFunctions::ImportSessionKey
hr = pNgcFunctions->NgcImportSymmetricPopKey( &accountInfo, nullptr, NGC_DEVICE_KEY_TRANSPORT_KEY, reinterpret_cast<const BYTE*>(sessionKey.GetString()), sessionKey.GetLength() * sizeof(CHAR), &decryptedSessionKey, &decryptedSessionKeySizeBytes)
hr = PassportEncode::Base64Encode(spSignatureBlob, signatureBlobSizeBytes, signature)
hr = pNgcFunctions->NgcVerifyWithSymmetricPopKey( key.GetBuffer(), key.GetLength(), reinterpret_cast<const BYTE*>(label.GetString()), static_cast<DWORD>(label.GetLength()), context.GetBuffer(), context.GetLength(), reinterpret_cast<const BYTE*>(message.GetString()), message.GetLength() * sizeof(CHAR), reinterpret_cast<const BYTE*>(rawSignature.GetString()), rawSignature.GetLength() * sizeof(CHAR))
hr = PassportEncode::Base64Decode(signature, rawSignature)
hr = pNgcFunctions->NgcDecryptWithSymmetricPopKey( key.GetBuffer(), key.GetLength(), reinterpret_cast<const BYTE*>(label.GetString()), static_cast<DWORD>(label.GetLength()), context.GetBuffer(), context.GetLength(), reinterpret_cast<const BYTE*>(initializationVector.GetString()), initializationVector.GetLength() * sizeof(CHAR), reinterpret_cast<const BYTE*>(cipherText.GetString()), cipherText.GetLength() * sizeof(CHAR), &spDecryptedBlob, &decryptedBlobSizeBytes)
hr = SafeCopyMemory(pBuffer, bufferSize, pData, dataSize)
Invalid bufferSize %d. HR=0x%x.
CryptProtectMemory failed. HR=0x%x.
Invalid padding %d. HR=0x%x.
CredSerializationHelper::DeSerializeCredentials
CredSerializationHelper::UnprotectCredentialString
CredUnprotect failed. HR=0x%x.
DeserializeObject failed. HR=0x%x.
UnprotectCredentialString failed. HR=0x%x.
CredIsProtected failed. HR=0x%x.
@666[
hr = FamilyNotifications::GetFlagValue(pExecutionContextLite, spFlags, familySafetySetting)
Treating family safety flag non-existence as 0 value.
hr = pSystemStoreLiteFunctions->GetCurrentUserSidString(&spSid)
hr = FamilyNotifications::GetFlagFromSystemStore(pExecutionContextLite, spSid, familySafetySetting)
Sending WNF notification because the Family Safety bit is 1.
FamilyNotifications::NotifyIfAccountIsFamilyRelated
hr = FamilyNotifications::GetUserSid(pExecutionContextLite, pUserName, spSid)
hr = FamilyNotifications::GetFamilyIDFromSystemStore(pExecutionContextLite, spSid, spExistingFamilyID)
Sending WNF notification because a Family ID value is present.
hr = FamilyNotifications::GetFlagFromSystemStore(&context, spSid, existingFamilySafetySetting)
Sending WNF notification because the Family Safety bit flipped from 0 to 1.
hr = FamilyNotifications::GetFlagValue(&context, flags, familySafetySettingFromResponse)
FamilySafety setting in the STS response returned TRUE.
hr = FamilyNotifications::GetFamilyIDFromSystemStore(&context, spSid, spExistingFamilyID)
hr = FamilyNotifications::CompareFamilyIDValues(familyID, spExistingFamilyID, familyIDChanged)
CExternalMemoryManager: Warning, memory block at 0x%p left to Uninitialize.
MsaUserExtImpl::CheckIfAppTrusted(scope, pAppId, &isTrusted)
hr = UrlAppendQueryString(url, PPCRL_URL_QS_MARKET, market)
UrlUtilities::GetColorSet
hr = PassportEncode::Base64Encode(spColorSet, colorSetSizeInBytes, encodedColorSet)
hr = SerializeObject(serializationHelper, tokenParameter, &spEncodedBuffer, &encodedBufferLength)
MicrosoftAccount:target=SSO_POP_Device
DeleteProofOfPossessionToken
hr = CredSerializationHelper::EncryptBufferForSameLogon(pContext->GetWinApiFunctions(), spEncodedBuffer, encodedBufferLength, &spEncryptedBuffer, &encryptedBufferLength)
hr = ChunkAndWriteProofOfPossessionTokenCacheEntry(userName, tokenData, spEncryptedBuffer, encryptedBufferLength)
hr = pDocument->setProperty(CComBSTR(XML_PROP_SELECTION_NAMESPACES), cvNamespaces)
hr = pDocument->load(varStream, &bIsOk)
CertGetCertificateChain failed with hr=0x%x
onecoreuap\ds\ext\live\identity\lib\utilities\certtoken.cpp
pbThumbprint=0x%p
GetCertContext
Base64Encode failed with hr=0x%x
fSetPIN is set to true but szPIN = NULL 
EnumerateCertsFromAllDevices failed with hr=0x%x
CryptAcquireCertificatePrivateKey failed with hr=0x%x
CryptSetProvParam failed with hr=0x%x
IsSmartCardCert_Helper failed with hr=0x%x
<X509Certificate>
</X509Certificate>
BuildCertToken
<X509Data>
" IssueInstant="
" Issuer="http://schemas.microsoft.com/ws/2005/05/identity/issuer/self"
</X509Data>
<saml:Assertion xmlns:saml="urn:oasis:names:tc:SAML:1.0:assertion" AssertionID="
<saml:Advice>
</saml:Advice>
 MajorVersion="1"
 MinorVersion="1">
" NotOnOrAfter="
<saml:Conditions 
NotBefore="
<saml:AttributeStatement>
<saml:Subject><saml:SubjectConfirmation><saml:ConfirmationMethod>urn:oasis:names:tc:SAML:1.0:cm:bearer</saml:ConfirmationMethod><KeyInfo xmlns="http://www.w3.org/2000/09/xmldsig#">
</saml:Conditions>
<saml:Attribute AttributeName="EmailAddress" AttributeNamespace="http://schemas.microsoft.com/ws/2005/05/identity/claims">
<saml:AttributeValue>
<wsse:SecurityTokenReference xmlns:wsse="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd"><wsse:KeyIdentifier ValueType="http://docs.oasis-open.org/wss/2005/xx/oasis-2005xx-wss-soap-message-security-1.1#ThumbprintSHA1">
</KeyInfo></saml:SubjectConfirmation></saml:Subject>
</saml:Assertion>
</saml:AttributeValue></saml:Attribute>
</saml:AttributeStatement>
IsSmartCardCert_Helper
hr = IsSmartCardCert_Helper(pCertContext, fSmartCardCert)
Thumbprint=%s
CryptGetUserKey failed with hr=0x%x
CryptGetKeyParam failed with hr=0x%x
IsSmartCardCert
hr = spQualifiedUser.Allocate(qualifiedSize)
hr = StringCchPrintf( spQualifiedUser, MAX_PATH, L"%ls\\%ls", machineName, pUserName )
Unable to open volatile key. (0x%0x)
WriteBufferToRegistry failed to write tick count. (0x%0x)
dest != nullptr
CWLIDCCHelper::ConvertToAnsi
CWLIDCCHelper::ConvertToWide
RegDeleteKeyValue() failed. (0x%0x)
RegSetKeyValue() failed. (0x%0x)
MSIDCRL
LiteCryptUtilities::HmacHashHelper
LiteCryptUtilities::ImportRawKeyIntoCSP
hr=E_OUTOFMEMORY
hr = UrlEscapeW(spInputWideCharBuffer, spEscapedWideCharBuffer, &escapedWideCharBufferLength, URL_ESCAPE_PERCENT|URL_ESCAPE_ASCII_URI_COMPONENT|URL_ESCAPE_AS_UTF8|URL_ESCAPE_SEGMENT_ONLY )
LiteCryptUtilities::DeriveKeyMaterialWithPSha1
hr = StringCchLengthA(pLabel, INTERNET_MAX_URL_LENGTH, &labelLength)
hr = SafeCopyMemory(spKeyBlob, keyBlobSize, &bhKey, sizeof(BLOBHEADER))
hr = SafeCopyMemory(spKeyBlob + sizeof(BLOBHEADER) + sizeof(DWORD), rawKeyLength, pRawKey, rawKeyLength)
hr = SafeCopyMemory(spLabelAndSeed, labelLength, pLabel, labelLength)
hr = SafeCopyMemory(static_cast<BYTE*>(spLabelAndSeed) + labelLength, seedLength, pSeed, seedLength)
hr = HmacHashHelper(hProv, spSecretKey, CALG_SHA1, spAHashPrevious, aHashBlobSize, nullptr, 0, &spAHashBlob, &aHashBlobSize )
hr = HmacHashHelper(hProv, spSecretKey, CALG_SHA1, spAHashBlob, aHashBlobSize, spLabelAndSeed, labelAndSeedLength, &spResultHashBlob, &resultHashSize )
hr = ImportRawKeyIntoCSP( hProv, pSecret, secretLength, keyImportAlgId, importFlags, &spSecretKey)
hr = HmacHashHelper(hProv, spSecretKey, CALG_SHA1, spLabelAndSeed, labelAndSeedLength, nullptr, 0, &spAHashBlob, &aHashBlobSize )
hr = SafeCopyMemory(spDerivedKeyBlob+currentKeyFilledLength, adjustedDerviedKeyLength-currentKeyFilledLength, spResultHashBlob, bytesToCopy)
hr = spBuffer.Allocate(rawPayloadSizeBytes)
hr = StringCchCopyA(spBuffer, rawPayloadSizeBytes, pPayLoadString)
hr = StringCchLengthA(pPayLoadString, STRSAFE_MAX_CCH, &rawPayloadSizeCharacters)
hr = HRESULT_FROM_WIN32(pNgcFunctions->BCryptGenRandom(nullptr, randomBytes, sizeof(randomBytes), BCRYPT_USE_SYSTEM_PREFERRED_RNG))
hr = Base64EncodeA(randomBytes, sizeof(randomBytes), &spEncodedRandom)
hr = StringCchPrintfExA( spUnsignedEncapsulatedPayload, bufferSizeCharacters, nullptr, &remainingSizeCharacters, STRSAFE_FILL_BEHIND_NULL, pEncapsulationTempate, currentTime, SHA256_ALGORITHM, pPayLoadString, static_cast<LPCSTR>(spEscapedRandom))
hr = StringCchLengthA(pEncapsulationTempate, STRSAFE_MAX_CCH, &templateSizeCharacters)
hr = StringCchLengthA(spEscapedRandom, STRSAFE_MAX_CCH, &nonceSizeCharacters)
hr = UrlEscapeStringA(spEncodedHash, &spEscapedHash)
hr = pNgcFunctions->NgcSignWithSymmetricPopKey( pSessionKey, sessionKeyLength, reinterpret_cast<const BYTE*>(LiteCryptUtilities::SeedLabel::SecureConversation), static_cast<DWORD>(strlen(LiteCryptUtilities::SeedLabel::SecureConversation) * sizeof(CHAR)), randomBytes, sizeof(randomBytes), reinterpret_cast<PBYTE>(static_cast<CHAR*>(spUnsignedEncapsulatedPayload)), static_cast<DWORD>(unsignedEncapsulatedPayloadSize), &spHashValue, &hashSize)
hr = Base64EncodeA(spHashValue, hashSize, &spEncodedHash)
hr = StringCchCatA(spBuffer, bufferSizeCharacters, spUnsignedEncapsulatedPayload)
&hash=
hr = UrlEscapeStringA(encodedHash, &spEscapedHash)
hr = StringCchLengthA(spEscapedHash, STRSAFE_MAX_CCH, &hashSize)
&dd=1
hr = StringCchCatA(spBuffer, bufferSizeCharacters, "&"PPCRL_OTC_DOUBLE_DERIVATION)
hr = StringCchCatA(spBuffer, bufferSizeCharacters, "&"PPCRL_OTC_HASH"=")
hr = StringCchCatA(spBuffer, bufferSizeCharacters, spEscapedHash)
hr = StringCchPrintfExA( spUnsignedEncapsulatedPayload, bufferSizeCharacters, nullptr, &remainingSizeCharacters, STRSAFE_FILL_BEHIND_NULL, pEncapsulationTempate, currentTime, SHA256_ALGORITHM, pPayLoadString)
hr = pXboxSignatureProvider->GetEcdsaSignatureFromHardware( reinterpret_cast<PBYTE>(static_cast<CHAR*>(spUnsignedEncapsulatedPayload)), static_cast<DWORD>(unsignedEncapsulatedPayloadSize), &spSignatureValue, &signatureSize)
LiteCryptUtilities::XboxEncapsulateString
ct=%I64u&hashalg=%s&%s
hr = StringCchLengthA(spEscapedSignature, STRSAFE_MAX_CCH, &hashSize)
hr = StringCchCatA(spBuffer, bufferSizeCharacters, spEscapedSignature)
hr = Base64EncodeA(spSignatureValue, signatureSize, &spEncodedSignature)
hr = UrlEscapeStringA(spEncodedSignature, &spEscapedSignature)
hr = Base64EncodeA( pModulus, pKeyBlob->cbModulus, &spEncodedModulus)
hr = SafeCopyMemory(spExponentBlob, pKeyBlob->cbPublicExp, pExponent, pKeyBlob->cbPublicExp)
hr = Base64EncodeA( pExponent, pKeyBlob->cbPublicExp, &spEncodedExponent)
SP800_108_CTR_HMAC
hr = HRESULT_FROM_WIN32(::BCryptOpenAlgorithmProvider( &spDeriveAlg, BCRYPT_SP800108_CTR_HMAC_ALGORITHM, nullptr, 0))
hr = SafeCopyMemory(spModulusBlob, pKeyBlob->cbModulus, pModulus, pKeyBlob->cbModulus)
LiteCryptUtilities::DeriveKeyWithSP800108
LiteCryptUtilities::DecryptContent
hr = HRESULT_FROM_WIN32(::BCryptOpenAlgorithmProvider( &spAlgorithm, BCRYPT_AES_ALGORITHM, nullptr, 0))
hr = HRESULT_FROM_WIN32(::BCryptGenerateSymmetricKey( spDeriveAlg, &spDeriveKey, nullptr, 0, static_cast<PUCHAR>(const_cast<BYTE*>(pSecret)), secretSizeBytes, 0))
hr = HRESULT_FROM_WIN32(::BCryptKeyDerivation( spDeriveKey, &keyDerivationDescription, pDerivedKey, derivedKeySizeBytes, &keySizeBytes, 0))
hr = HRESULT_FROM_WIN32(::BCryptSetProperty( spAlgorithm, BCRYPT_CHAINING_MODE, reinterpret_cast<PUCHAR>(BCRYPT_CHAIN_MODE_CBC), static_cast<ULONG>(sizeof(BCRYPT_CHAIN_MODE_CBC)), 0))
hr = HRESULT_FROM_WIN32(::BCryptGenerateSymmetricKey( spAlgorithm, &spKey, nullptr, 0, static_cast<PUCHAR>(const_cast<BYTE*>(pEncryptionKey)), encryptionKeySizeBytes, 0))
ChainingModeCBC
ChainingMode
hr = HRESULT_FROM_WIN32(::BCryptDecrypt( spKey, static_cast<PUCHAR>(const_cast<BYTE*>(pEncryptedBlob)), encryptedBlobSizeBytes, nullptr, static_cast<PUCHAR>(const_cast<BYTE*>(pInitializationVector)), initializationVectorSizeBytes, nullptr, 0, &resultSizeBytes, BCRYPT_BLOCK_PADDING))
hr = HRESULT_FROM_WIN32(::BCryptDecrypt( spKey, static_cast<PUCHAR>(const_cast<BYTE*>(pEncryptedBlob)), encryptedBlobSizeBytes, nullptr, static_cast<PUCHAR>(const_cast<BYTE*>(pInitializationVector)), initializationVectorSizeBytes, spDecryptedBlob, resultSizeBytes, &resultSizeBytes, BCRYPT_BLOCK_PADDING))
hr = HRESULT_FROM_WIN32(::BCryptHashData( spHash, static_cast<PUCHAR>(const_cast<BYTE*>(pMessage)), messageSizeBytes, 0))
hr = HRESULT_FROM_WIN32(::BCryptFinishHash( spHash, reinterpret_cast<PUCHAR>(static_cast<BYTE*>(spHashBlob)), hashBlobSizeBytes, 0))
LSA_IDPEXT_ENDPOINT
WLIDCRegisterUserIdkey
IdleCallback
IsGroupIdle
CanStopService
IsServiceShuttingDown
ServiceStop
ServiceRunTimeInMSecs
ServiceStartTimeInMSecs
ServiceStopTimeInMSecs
WLIDSvcFailedToStart
NgcSignWithUserIdKeyEx
PartA_PrivTags
NgcGetUserIdKeyPublicKey
PartA_PrivTags
NgcEnumUserIdKeys
PartA_PrivTags
ContainerStatus
NgcCreateUserIdKeyEx
NgcCreateUserIdKey
NgcEnumContainers
PartA_PrivTags
ContainerStatus
NgcCreateContainer
NgcDeleteContainerEx
NgcDeleteContainer
AcquireTokens
PartA_PrivTags
wilActivity
threadId
ProvisionIdentityWithTransferToken
PartA_PrivTags
wilActivity
threadId
ProvisionIdentityWithTransferToken
PartA_PrivTags
PartA_PrivTags
wilActivity
hresult
fileName
lineNumber
module
failureType
message
threadId
callContext
originatingContextId
originatingContextName
originatingContextMessage
currentContextId
currentContextName
currentContextMessage
ProvisionIdentityWithTransferToken
PartA_PrivTags
wilActivity
hresult
threadId
GetAppData
PartA_PrivTags
wilActivity
threadId
GetAppData
PartA_PrivTags
PartA_PrivTags
wilActivity
hresult
fileName
lineNumber
module
failureType
message
threadId
callContext
originatingContextId
originatingContextName
originatingContextMessage
currentContextId
currentContextName
currentContextMessage
GetAppData
PartA_PrivTags
wilActivity
hresult
threadId
GetAppDataRequest_InvalidTimestamp
RequestCreationTime
ServerTime
ClockSkew_BeforeRequest
ClockSkew_AfterResponse
RequestCounter
GetTotpCodeFailure
ApproveSessionFailure
ListSessionsFailure
ManageApproverFailure
TpmKeyStatusUserIdKeyRegister
PartA_PrivTags
ClientKeyState
ActivityIntermediateStop
PartA_PrivTags
wilActivity
hresult
threadId
HandleGetProofOfPossessionTokens
PartA_PrivTags
wilActivity
threadId
ActivityStoppedAutomatically
ActivityError
PartA_PrivTags
wilActivity
hresult
fileName
lineNumber
module
failureType
message
threadId
callContext
originatingContextId
originatingContextName
originatingContextMessage
currentContextId
currentContextName
currentContextMessage
ActivityError
PartA_PrivTags
wilActivity
hresult
fileName
lineNumber
module
failureType
message
threadId
callContext
originatingContextId
originatingContextName
originatingContextMessage
currentContextId
currentContextName
currentContextMessage
failureId
failureCount
function
HandleGetProofOfPossessionTokens
PartA_PrivTags
PartA_PrivTags
wilActivity
hresult
fileName
lineNumber
module
failureType
message
threadId
callContext
originatingContextId
originatingContextName
originatingContextMessage
currentContextId
currentContextName
currentContextMessage
HandleGetProofOfPossessionTokens
PartA_PrivTags
wilActivity
hresult
threadId
ForceSigninRetryGetKey
GetSpecificKeyCacheMiss
IsRequestForRoamingCredential
Flags
GetSpecificKeyCacheHit
IsRequestForRoamingCredential
Flags
GetLatestKeyCacheMiss
IsRequestForRoamingCredential
Flags
GetLatestKeyCacheHit
IsRequestForRoamingCredential
Flags
ForceSigninRetry
SignInAssociatedUser_DARenewalFailure
PersistedDAFreshness
ClockSkew
daCreatedTime
currentTime
PartA_PrivTags
ActivityIntermediateStop
PartA_PrivTags
wilActivity
hresult
threadId
MaxAcquireNgcLoop
ActivityError
PartA_PrivTags
wilActivity
hresult
fileName
lineNumber
module
failureType
message
threadId
callContext
originatingContextId
originatingContextName
originatingContextMessage
currentContextId
currentContextName
currentContextMessage
failureId
failureCount
function
AcquireTokens
PartA_PrivTags
PartA_PrivTags
wilActivity
hresult
fileName
lineNumber
module
failureType
message
threadId
callContext
originatingContextId
originatingContextName
originatingContextMessage
currentContextId
currentContextName
currentContextMessage
failureId
failureCount
function
AcquireTokens
PartA_PrivTags
wilActivity
hresult
threadId
ActivityStoppedAutomatically
FallbackError
PartA_PrivTags
wilResult
hresult
fileName
lineNumber
module
failureType
message
threadId
callContext
originatingContextId
originatingContextName
originatingContextMessage
currentContextId
currentContextName
currentContextMessage
FallbackError
PartA_PrivTags
wilResult
hresult
fileName
lineNumber
module
failureType
message
threadId
callContext
originatingContextId
originatingContextName
originatingContextMessage
currentContextId
currentContextName
currentContextMessage
failureId
failureCount
function
AcquireTokens
AccountType
WLIDSvcNoCredsV2
PartA_PrivTags
AuthRequest
requestFlags
currentTickCount
dwRequestCount
isUserRequest
IsConnected
clearDefaultCredHr
isTempProfile
hrGetProfileType
AccountType
hrReportingAccountType
wasPreviouslyMissingCred
hrCredManLog
CorrelationId
lsaUserAccountType
hrLsaLookupAccountType
UpsellNgc
Result
IsHardware
TpmKspReadStatus
TpmStatus
WLIDSvcFailedToStart
failureReason
WLIDSvcCredEnumerate
PartA_PrivTags
Target
IsCred
Count
ReturnValue
TickCount
WLIDSvcCredWrite
PartA_PrivTags
Target
IsCred
CredType
ReturnValue
TickCount
WLIDSvcCredDelete
PartA_PrivTags
Target
IsCred
CredType
ReturnValue
TickCount
SaveDownloadedConfig
PartA_PrivTags
wilActivity
threadId
DownloadAndReloadConfig
PartA_PrivTags
wilActivity
threadId
InitializePathsAndMutableConfigs
PartA_PrivTags
wilActivity
threadId
LoadConfiguration
PartA_PrivTags
wilActivity
threadId
SaveDownloadedConfig
PartA_PrivTags
PartA_PrivTags
wilActivity
hresult
fileName
lineNumber
module
failureType
message
threadId
callContext
originatingContextId
originatingContextName
originatingContextMessage
currentContextId
currentContextName
currentContextMessage
failureId
failureCount
function
SaveDownloadedConfig
PartA_PrivTags
wilActivity
hresult
threadId
DownloadAndReloadConfig
PartA_PrivTags
PartA_PrivTags
wilActivity
hresult
fileName
lineNumber
module
failureType
message
threadId
callContext
originatingContextId
originatingContextName
originatingContextMessage
currentContextId
currentContextName
currentContextMessage
failureId
failureCount
function
DownloadAndReloadConfig
PartA_PrivTags
wilActivity
hresult
threadId
ConfigDownloadData
PartA_PrivTags
OldConfigVersion
NewConfigVersion
WlidsvcConfigXml
NetworkCallElapsedTime
IsCallInSystemContext
WinHttpErrorCode
WinHttpSecureStatusErrorCode
HttpStatusCode
HeadersSizeChars
ConfigImmutableCopy
InstalledConfigVersion
InitializePathsAndMutableConfigs
PartA_PrivTags
PartA_PrivTags
wilActivity
hresult
fileName
lineNumber
module
failureType
message
threadId
callContext
originatingContextId
originatingContextName
originatingContextMessage
currentContextId
currentContextName
currentContextMessage
failureId
failureCount
function
InitializePathsAndMutableConfigs
PartA_PrivTags
wilActivity
hresult
threadId
ActivityError
PartA_PrivTags
wilActivity
hresult
fileName
lineNumber
module
failureType
message
threadId
callContext
originatingContextId
originatingContextName
originatingContextMessage
currentContextId
currentContextName
currentContextMessage
LoadConfiguration
PartA_PrivTags
PartA_PrivTags
wilActivity
hresult
fileName
lineNumber
module
failureType
message
threadId
callContext
originatingContextId
originatingContextName
originatingContextMessage
currentContextId
currentContextName
currentContextMessage
failureId
failureCount
function
LoadConfiguration
PartA_PrivTags
wilActivity
hresult
threadId
ActivityFailure
PartA_PrivTags
wilActivity
hresult
threadId
currentContextName
currentContextMessage
ActivityFailure
PartA_PrivTags
wilActivity
hresult
fileName
lineNumber
module
failureType
message
threadId
callContext
originatingContextId
originatingContextName
originatingContextMessage
currentContextId
currentContextName
currentContextMessage
InvalidXMLChar
InvalidXMLChar
DeviceIdRequestFailure
RequestType
SubErrorCode
RequestStatus
DeviceID
DeviceName
ServerBuildInfo
DeviceLicenseInstall
RequestStatus
DeviceID
DeviceName
ServerBuildInfo
WnfDeviceLicenseInstalled
PartA_PrivTags
WnfGlobalDeviceProvisioning
DeviceKeyholderLicenseInstall
RequestStatus
DeviceID
DeviceName
ServerBuildInfo
WnfHWDeviceUpdated
DeviceIdTpmAttestationFailure
RequestStatus
DeviceID
DeviceName
ServerBuildInfo
DeviceIdTpmAikCertFailure
RequestStatus
DeviceID
DeviceName
ServerBuildInfo
HardwareCollectionFailure
RequestStatus
DeviceID
DeviceName
ServerBuildInfo
TpmKeyStatus
PartA_PrivTags
ClientKeyState
ServerKeyState
RequestStatus
DeviceID
DeviceName
ServerBuildInfo
DeviceSignFailure
RequestStatus
DeviceID
DeviceName
ServerBuildInfo
InvalidDeviceDA
RequestStatus
DeviceID
DeviceName
ServerBuildInfo
RequestRetryFailures
RequestType
MaxRequestRetryCountOnFailure
WnfHWDeviceUpdatedSts
DeviceIdTpmImportFailure
RequestStatus
DeviceID
DeviceName
ServerBuildInfo
GetSecurityTokenResponseDataText
PartA_PrivTags
ServerErrors
PartA_PrivTags
hrInternal
ServerBuildInfo
SessionKeySignFailure
RequestStatus
DeviceID
DeviceName
ServerBuildInfo
EncryptCredsInSysCtx
PartA_PrivTags
L"CryptProtectData"
DecryptSysCtxCreds
PartA_PrivTags
L"CryptUnprotectData"
GetCachedAuthInfo
PartA_PrivTags
UserName
NgcAttestationFailure
RequestStatus
DeviceID
DeviceName
ServerBuildInfo
TpmKeyStatusUserIdKeyUpdate
PartA_PrivTags
ClientKeyState
ImportAuthState
PartA_PrivTags
UserName
HardwareDeviceProvisioning
DeviceName
HardwareDeviceHWCollectionTime
HardwareDeviceProvisioningTime
WLIDSvcCredRecovery
PartA_PrivTags
WLIDSvcCredRead
PartA_PrivTags
Target
IsCred
CredType
ReturnValue
TickCount
WLIDSvcNegativeCache
cacheKey
FailureCount
RequestTimestamp
FailureType
NegativeCacheBlockActionType
LastSuccessfulRequestTimestamp
LastAccountPersistentFailureTimestamp
WLIDSvcThrottled
Count
qThrottleScenario
Application
RequestType
HitLimit
PartA_PrivTags
UserProfileUnload
PartA_PrivTags
wilActivity
threadId
Profile
UserProfileLoad
PartA_PrivTags
wilActivity
threadId
UserProfileUnload
PartA_PrivTags
PartA_PrivTags
wilActivity
hresult
fileName
lineNumber
module
failureType
message
threadId
callContext
originatingContextId
originatingContextName
originatingContextMessage
currentContextId
currentContextName
currentContextMessage
UserProfileUnload
PartA_PrivTags
wilActivity
hresult
threadId
UserProfileLoad
PartA_PrivTags
PartA_PrivTags
wilActivity
hresult
fileName
lineNumber
module
failureType
message
threadId
callContext
originatingContextId
originatingContextName
originatingContextMessage
currentContextId
currentContextName
currentContextMessage
Profile
UserProfileLoad
PartA_PrivTags
wilActivity
hresult
threadId
Profile
UserProfileLoad
PartA_PrivTags
PartA_PrivTags
wilActivity
hresult
fileName
lineNumber
module
failureType
message
threadId
callContext
originatingContextId
originatingContextName
originatingContextMessage
currentContextId
currentContextName
currentContextMessage
UserProfileLoad
PartA_PrivTags
wilActivity
hresult
threadId
UMgrEnumerateSessionUsers_Failed
PartA_PrivTags
UpdateDeviceLicenseInfo
PartA_PrivTags
wilActivity
threadId
DeviceProvisioningEarlyExitLogic
PartA_PrivTags
wilActivity
threadId
CurrentUserSid
CurrentTickCount
ThreadCount
FailureCount
FailureThreshold
TpmUpdateRequired
PartA_PrivTags
hrAIKCert
IsWindowsAIKCertAvailable
TpmRequiredForAutoPilot
reprovisionDevice
tpmKeyStateServer
tpmKeyStateClient
tpmUpdateTickCount
UpdateDeviceTpmInfo
Count
attestationResult
attestationHrWnf
PartA_PrivTags
Wnf_Msa_AttestationResult_PublishFailure
PartA_PrivTags
hrPublish
hrWnf
attestationResult
DeviceReprovision
DeviceID
DeviceName
NewDeviceID
NewDeviceName
IsCallInSystemContext
LockAcquisition
Context
MutexAcquired
AttemptProvisioning
UpdateDeviceLicenseInfo
PartA_PrivTags
PartA_PrivTags
wilActivity
hresult
fileName
lineNumber
module
failureType
message
threadId
callContext
originatingContextId
originatingContextName
originatingContextMessage
currentContextId
currentContextName
currentContextMessage
failureId
failureCount
function
UpdateDeviceLicenseInfo
PartA_PrivTags
wilActivity
hresult
threadId
DeviceProvisioningEarlyExitLogic
PartA_PrivTags
PartA_PrivTags
wilActivity
hresult
fileName
lineNumber
module
failureType
message
threadId
callContext
originatingContextId
originatingContextName
originatingContextMessage
currentContextId
currentContextName
currentContextMessage
failureId
failureCount
function
CurrentUserSid
CurrentTickCount
ThreadCount
FailureCount
FailureThreshold
ReturnValue
SendResult
DeviceProvisioningEarlyExitLogic
PartA_PrivTags
wilActivity
hresult
threadId
CurrentUserSid
CurrentTickCount
ThreadCount
FailureCount
FailureThreshold
ReturnValue
SendResult
DeviceProvisioningEarlyExitLogic
CurrentUserSid
CurrentTickCount
ThreadCount
FailureCount
FailureThreshold
DeviceProvisioningEarlyExitLogic
PartA_PrivTags
PartA_PrivTags
wilActivity
hresult
fileName
lineNumber
module
failureType
message
threadId
callContext
originatingContextId
originatingContextName
originatingContextMessage
currentContextId
currentContextName
currentContextMessage
failureId
failureCount
function
DeviceProvisioningEarlyExitLogic
PartA_PrivTags
wilActivity
hresult
threadId
MutexReleaseFailure
LastError
DeviceDeprovision
DeviceID
DeviceName
AppGuid
IsDeviceIdClosed
IsCallInSystemContext
SendError
AcquireTokenEsimBootstrap
PartA_PrivTags
NetworkCallDetails
NetworkCallElapsedTime
SendReceiveSuccess
IsCallInSystemContext
WinHttpErrorCode
WinHttpSecureStatusErrorCode
HttpStatusCode
HeadersSizeChars
RequestType
EnterpriseDeviceAuthPolicyState
PartA_PrivTags
NetworkCallDetails
Count
qMinNetworkCallElapsedTime
rMaxNetworkCallElapsedTime
sTotalNetworkCallElapsedTime
qSendReceiveSuccess
IsCallInSystemContext
WinHttpErrorCode
WinHttpSecureStatusErrorCode
HttpStatusCode
HeadersSizeChars
RequestType
EnterpriseDeviceAuthPolicyState
PartA_PrivTags
RenameAccount
IsConnected
SetClockSkewFailure
ServerTime
ClockSkew_BeforeRequest
ClockSkew_AfterResponse
GetAppDataRequestFailure
hrInternal
SessionKeySignFailureGetAppData
RequestStatus
DeviceID
DeviceName
ServerBuildInfo
DeviceIdForceSignIn
RequestStatus
DeviceID
DeviceName
ServerBuildInfo
DeviceIdForceKeyRoll
RequestStatus
DeviceID
DeviceName
ServerBuildInfo
DeviceIdLoadFailure
DeviceName
IsCallInSystemContext
IsXmlLiteUsed
SubErrorCode
KeyCacheCorruption
KeyCacheDecryptFailure
DeviceIdInvalidated
DeviceName
NewDeviceName
IsCallInSystemContext
TlgAggregateSummary
PartA_PrivTags
UtcAggParams
Period
MaxEvents
Provider
UtcAggVal
Value
UtcAggVal
Value
UtcAggVal
Value
UtcAggVal
Value
UtcAggVal
Value
UtcAggVal
Value
UtcAggVal
Value
UtcAggVal
Value
UtcAggVal
Value
DeviceIdTpmSignFailure
MSAClientTraceLoggingProvider
MSAClientTraceLoggingProvider
Microsoft.Windows.TlgAggregateInternal
RSDSG
WLIDSvc.pdb
.text
.text$di
.text$lp00SPGO
.text$mn
.text$mn$00
.text$x
.text$yd
.rdata$brc
.rdata$T$brc
.idata$5
.00cfg
.CRT$XCA
.CRT$XCL
.CRT$XCU
.CRT$XCZ
.CRT$XIA
.CRT$XIC
.CRT$XIZ
.CRT$XPA
.CRT$XPZ
.CRT$XTA
.CRT$XTZ
.gehcont
.gfids
.giats
.rdata
.rdata$r
.rdata$voltmd
.rdata$zETW0
.rdata$zETW1
.rdata$zETW2
.rdata$zETW9
.rdata$zzzdbg
.rtc$IAA
.rtc$IZZ
.rtc$TAA
.rtc$TZZ
.tls$
.tls$ZZZ
.xdata
.xdata$x
.didat$2
.didat$3
.didat$4
.didat$6
.didat$7
.edata
.idata$2
.idata$3
.idata$4
.idata$6
.data$brc
.data$r$brc
.data$rs$brc
.data
.pdata
.didat$5
.rsrc$01
.rsrc$02
$&"B 
F @"" R
2xLxN
4N6B4
XDBFBHBJBNBPBRBTDV8
#&T(x$
.J2$.
"LBJ"nBJ"bBJ"bBJ"J6
HH"L I
z"n&$( *Z&f,F&
.H0$2
<n>B<
68N`6Z<
&F"::H"
">HPR
d&B(B*4,R.40<264
v"D$D&D(B*D,2
4 <"6$"
(X,f*
4(622@4(622(0z,X<
D(F2BJ@z,
b(`j^jXBT
v~xnzy
``jFl
:(<@:,<T:*>$@$>j:
&t P"D
,&.J,
 ($z 
 v"Z$v"
&^(x&p
v B"|
0>2"4
*:,z*}
:l> :@@8D
HxLTJ0
l"B$r"B$j"B$B
(F$<"
R.z4(.
4b84:r8
4:.H<$>2B62L.
b :$B& $\(
 |"n 
(R*F,..
0 (n2:6L8 6\:
(:&0,".
0r&*2(4
:B<*$d"
08@HPX`hpx
"($(&((X*b(
.z0(,$.
,><F@BD
FX(xH>
*D,@.
PBRBT@V
JVFXD
"F$*&*(2,
vLhN"LN
DLJ(D
2B4B8B:N0
NJPDRBTZVHX@ZB\"F
^J`DbBdZfHh4j6l
>8@60z.
F4H,J,HTF(L(N*P"R(T
f&h"j
D.@.<.8.0fF
v:t0&`
:"B$ "\&5
T b"R
($* (
(&"t*B,F*
.v*d,F*Q
604d84<F>
B"4vD6HXJ
*lNF*
*p":P
R$"rT4XNZ
 :$\&
.^0n.|(~.
.|(v.j2
.|(n.
(|.h(
.z(n.t(
&8("$
*n,:.H,
"X$F&
"<*v, *N.82
2"$ d
P"8&%
"D$4&r$
"(2,2.I
 T"D$
 <(v* (N,80
"F$4&t$
H($*2.40H
4V 2.r $8
AutoPilotGetOobeSettingsOverride
NdrServerCall2
NdrServerCallAll
RpcServerInterfaceGroupDeactivate
RpcServerInterfaceGroupCreateW
RpcServerInterfaceGroupActivate
ConvertStringSecurityDescriptorToSecurityDescriptorW
RpcServerInterfaceGroupClose
RegisterServiceCtrlHandlerExW
SetServiceStatus
MesEncodeFixedBufferHandleCreate
MesBufferHandleReset
MesHandleFree
MesDecodeBufferHandleCreate
UuidCreate
I_RpcBindingInqLocalClientPID
CryptProtectData
CryptUnprotectData
CryptProtectMemory
CryptUnprotectMemory
LookupAccountNameW
ConvertSidToStringSidW
GetProfileType
LogonUserExExW
LsaRegisterLogonProcess
LsaConnectUntrusted
LsaLookupAuthenticationPackage
LsaCallAuthenticationPackage
LsaDeregisterLogonProcess
BCryptGenRandom
CertGetCertificateContextProperty
CertGetNameStringA
CryptVerifyMessageSignature
CertEnumCertificatesInStore
CertDuplicateCertificateContext
CertDeleteCertificateFromStore
UnloadUserProfile
CredEnumerateW
BCryptCloseAlgorithmProvider
OpenSCManagerW
OpenServiceW
ChangeServiceConfigW
CertFreeCertificateContext
RpcRevertToSelf
RpcImpersonateClient
CertGetNameStringW
NCryptOpenStorageProvider
NCryptGetProperty
CredFree
CertCreateCertificateContext
CertVerifySubjectCertificateContext
CloseServiceHandle
NCryptFreeObject
CredDeleteW
CredWriteW
WinHttpGetIEProxyConfigForCurrentUser
WinHttpGetProxyForUrl
WinHttpSetOption
WinHttpSendRequest
WinHttpReceiveResponse
ConvertStringSidToSidW
NCryptOpenKey
NCryptExportKey
NCryptCreateClaim
CertCloseStore
NCryptSetProperty
CertOpenStore
CertFindCertificateInStore
CertAddCertificateContextToStore
WinHttpCloseHandle
WinHttpCrackUrl
WinHttpCreateUrl
CertGetIssuerCertificateFromStore
WinHttpOpen
WinHttpConnect
WinHttpOpenRequest
WinHttpQueryHeaders
WinHttpQueryDataAvailable
WinHttpReadData
CertSetCertificateContextProperty
CredReadW
RpcStringFreeW
UuidToStringW
CryptExportPublicKeyInfo
CryptEncodeObjectEx
CryptSignAndEncodeCertificate
LookupAccountSidW
LoadUserProfileW
WSACloseEvent
WSACreateEvent
NotifyAddrChange
CancelIPChangeNotify
WinHttpAddRequestHeaders
WinHttpSetStatusCallback
WinHttpQueryAuthSchemes
LsaGetLogonSessionData
LsaFreeReturnBuffer
WinHttpSetTimeouts
CertCompareCertificate
NetUserModalsGet
NetApiBufferFree
BCryptGetProperty
BCryptCreateHash
BCryptDestroyHash
BCryptHashData
BCryptFinishHash
CryptImportPublicKeyInfo
BCryptOpenAlgorithmProvider
CryptDestroyHash
CryptDestroyKey
CryptReleaseContext
CryptGenRandom
CryptAcquireContextW
LsaLookupUserAccountType
CryptDecrypt
CryptDuplicateKey
CryptEncrypt
CryptAcquireContextA
CryptContextAddRef
CryptGenKey
CryptHashData
CryptCreateHash
CryptGetHashParam
CryptExportKey
CryptImportKey
CryptSignHashW
CryptSetHashParam
CryptVerifySignatureW
SetNamedSecurityInfoW
RegOpenKeyTransactedW
RegCreateKeyTransactedW
RegDeleteKeyTransactedW
RegDeleteKeyW
SHGetKnownFolderPath
SHCreateDirectoryExW
PolicyManager_GetPolicyInt
PolicyManager_GetAccountsPolicy_AllowMicrosoftAccountConnection
QueryUserToken
WinStationGetCurrentSessionCapabilities
WinStationQueryInformationW
WTSQueryUserToken
WTSEnumerateSessionsW
WTSFreeMemory
WTSDisconnectSession
UMgrQueryUserToken
UMgrQueryUserContext
UMgrEnumerateSessionUsers
UMgrFreeSessionUsers
MsaDevice_UseXTokenBasedSessionKey
MsaDevice_FreeDeviceAuthXToken
MsaDevice_UseXTokenBasedRequestSigning
MsaDevice_IsRstrUnencryptedInServiceRequestReponseOverSSL
MsaDevice_GetDeviceAuthXToken
MsaDevice_OverrideTokenPersistence
MsaDevice_IsDeviceProvisionedDuringAuthentication
MsaDevice_GenerateEcsdaP256Signature
MsaUser_GetDeviceTelemetryInformation
MsaUser_GetUserRegistrySecurityDescriptor
MappingFreeServices
IsGameStreamingServer
NgcDeleteContainer
NgcDeleteContainerEx
NgcCreateContainer
NgcEnumContainers
NgcCreateUserIdKey
NgcCreateUserIdKeyEx
NgcGetKeyAttestationForUserIdKey
NgcRenewKeyAttestation
NgcDeleteUserIdKey
NgcEnumUserIdKeys
NgcFreeEnumState
NgcSignWithSymmetricPopKey
NgcDecryptWithSymmetricPopKey
NgcVerifyWithSymmetricPopKey
NgcGetUserIdKeyPublicKey
NgcGetSymmetricPopKeyTransportKey
NgcGetSymmetricPopKeyTransportKeyName
NgcSignWithUserIdKey
NgcSignWithUserIdKeyEx
NgcSignWithUserIdKeySilent
NgcImportSymmetricPopKey
NgcPackAuthBuffer
NgcGetLogonDecryptionKeyName
NgcGetPkcs7ChainBlobFromCertificateBlob
NgcTriggerTask
ClipOpen
ClipGenerateDeviceLicenseRequest
ClipInstallLicense
ClipClose
CreateTransaction
CommitTransaction
GetDeviceIDString
LoadImageW
GetSystemMetrics
GetThreadDesktop
GetUserObjectInformationW
GetUserLanguages
CredIsProtectedW
CredUnprotectW
NdrMesTypeDecode3
NdrMesTypeEncode3
NdrMesTypeFree3
NdrMesTypeAlignSize3
RpcStringFreeA
UuidToStringA
CertFreeCertificateChain
CertGetCertificateChain
CryptAcquireCertificatePrivateKey
BCryptDestroyKey
BCryptKeyDerivation
BCryptDecrypt
CryptBinaryToStringA
BCryptSetProperty
BCryptGenerateSymmetricKey
CryptSetProvParam
CryptGetUserKey
CryptGetKeyParam
GetUserColorPreference
GetColorFromPreference
MsaUser_FormatUserDisplayName
MsaUser_CheckIfAppTrusted
MsaUser_CallerIsLoggedOnUser
MsaUser_GetInlineUxParameterValue
MsaUser_GetDeviceTypeParameterValue
MsaUser_GetPlatformQualifier
IsEmbeddedModeAllowed
PhoneAPIUninitialize
PhoneAPIInitialize
PhoneGetLines
PhoneGetProviderLineServiceInfo
PhoneGetProviderLineInfo
MappingFreePropertyBag
MappingRecognizeText
MappingGetServices
I_RpcMapWin32Status
NdrClientCall3
I_RpcExceptionFilter
RpcBindingFree
RpcBindingCreateW
RpcBindingBind
WLIDSVC.dll
ServiceMain
SvchostPushServiceGlobals
memmove_s
_initterm
_initterm_e
api-ms-win-crt-string-l1-1-0.dll
api-ms-win-crt-runtime-l1-1-0.dll
__CxxFrameHandler4
__std_terminate
strrchr
_o___acrt_iob_func
_o___std_exception_copy
_o___std_exception_destroy
_o___std_type_info_destroy_list
_o___stdio_common_vfprintf
_o___stdio_common_vsnprintf_s
_o___stdio_common_vsprintf
_o___stdio_common_vsprintf_s
_o___stdio_common_vswprintf
_o___stdio_common_vswprintf_s
_o__callnewh
_o__cexit
_o__configure_narrow_argv
_o__crt_atexit
_o__difftime64
_o__errno
_o__execute_onexit_table
_o__get_errno
_o__gmtime64_s
_o__i64tow_s
_o__initialize_narrow_environment
_o__initialize_onexit_table
_o__invalid_parameter_noinfo
_o__itoa_s
_o__localtime64_s
_o__mbscmp
_o__mbsicmp
_o__mbsinc
_o__mbslwr_s
_o__mbsstr
_o__mbsupr_s
_o__mkgmtime64
_o__mktime64
_o__purecall
_o__recalloc
_o__register_onexit_function
_o__resetstkoflw
_o__seh_filter_dll
_o__set_errno
_o__wcsicmp
_o__wcslwr_s
_o__wcstoui64
_o__wcsupr_s
_o__wtoi
_o__wtol
_o_calloc
_o_free
_o_iswspace
_o_malloc
_o_memcpy_s
_o_terminate
_o_toupper
_o_towupper
_o_wcscpy_s
_o_wcsftime
_o_wcstol
_o_wcstoul
__C_specific_handler
__current_exception
__current_exception_context
memset
__CxxFrameHandler3
_CxxThrowException
api-ms-win-crt-private-l1-1-0.dll
CloseHandle
LocalFree
EventWriteTransfer
DebugBreak
GetLastError
SizeofResource
LockResource
LoadResource
FindResourceExW
ReleaseMutex
WaitForSingleObject
CoUninitialize
CoInitializeEx
TlsAlloc
TlsFree
FormatMessageW
GetCurrentThreadId
HeapAlloc
GetProcessHeap
HeapFree
GetModuleHandleExW
GetModuleFileNameA
GetModuleHandleW
GetProcAddress
IsDebuggerPresent
OutputDebugStringW
SetLastError
SetEvent
ResetEvent
ReleaseSemaphore
WaitForSingleObjectEx
OpenSemaphoreW
GetCurrentProcessId
CreateMutexExW
CreateSemaphoreExW
EventRegister
EventUnregister
EventSetInformation
GetTickCount64
CreateEventExW
Sleep
HeapSize
HeapReAlloc
HeapDestroy
InitializeCriticalSection
DeleteCriticalSection
RaiseException
EnterCriticalSection
LeaveCriticalSection
MultiByteToWideChar
WideCharToMultiByte
RtlCaptureContext
RtlLookupFunctionEntry
RtlVirtualUnwind
UnhandledExceptionFilter
SetUnhandledExceptionFilter
GetCurrentProcess
TerminateProcess
IsProcessorFeaturePresent
QueryPerformanceCounter
GetSystemTimeAsFileTime
DisableThreadLibraryCalls
InitializeSListHead
CoCreateInstance
CoGetCallerTID
RegCloseKey
AcquireSRWLockExclusive
ReleaseSRWLockExclusive
AcquireSRWLockShared
ReleaseSRWLockShared
SetThreadpoolTimer
WaitForThreadpoolTimerCallbacks
CloseThreadpoolTimer
InitializeCriticalSectionEx
CreateThreadpoolTimer
RegOpenKeyExW
RegGetValueW
RegSetValueExW
RegQueryValueExW
RegCreateKeyExW
RegEnumKeyExW
LoadLibraryExW
RegDeleteValueW
RegSetKeySecurity
LocalAlloc
RegOpenCurrentUser
RegDeleteKeyExW
RegDeleteTreeW
RegQueryInfoKeyW
RegEnumValueW
CreateEventW
WaitForMultipleObjectsEx
GetCurrentThread
GetFileVersionInfoExW
GetFileVersionInfoSizeExW
GetModuleFileNameW
GetThreadPreferredUILanguages
GetTokenInformation
GetVersionExW
CreateWellKnownSid
IsValidSid
OpenThread
OpenThreadToken
RevertToSelf
ImpersonateLoggedOnUser
GetProcessIdOfThread
GetUserDefaultLocaleName
OpenProcessToken
VerQueryValueW
GetSecurityDescriptorDacl
GetSecurityDescriptorSacl
FreeLibrary
GetSystemDirectoryW
LoadLibraryW
CreateMutexW
ExpandEnvironmentStringsW
AllocateAndInitializeSid
InitializeSecurityDescriptor
GetLengthSid
InitializeAcl
AddAccessAllowedAce
SetSecurityDescriptorDacl
SetSecurityDescriptorGroup
SetSecurityDescriptorOwner
IsValidSecurityDescriptor
AccessCheck
FreeSid
DuplicateToken
CopySid
EqualSid
GetSidSubAuthorityCount
GetSidSubAuthority
InitializeSid
GetSidLengthRequired
CoTaskMemAlloc
CLSIDFromProgID
CoTaskMemFree
SetThreadToken
GetProductInfo
SetTokenInformation
CompareStringOrdinal
CLSIDFromString
InitOnceBeginInitialize
InitOnceComplete
FileTimeToSystemTime
FileTimeToLocalFileTime
TlsSetValue
EventActivityIdControl
DuplicateTokenEx
RegFlushKey
ImpersonateSelf
CopyFileW
CreateStreamOnHGlobal
DeleteFileW
PathCchCombine
CreateFileW
WriteFile
GetFileSizeEx
ReadFile
InitializeSRWLock
SystemTimeToFileTime
StringFromGUID2
TlsGetValue
GetSecurityDescriptorGroup
GetSecurityDescriptorOwner
GetSecurityDescriptorControl
MakeAbsoluteSD
AddAce
GetAclInformation
GetSidIdentifierAuthority
CharLowerBuffW
TryAcquireSRWLockExclusive
GetModuleHandleExA
api-ms-win-core-handle-l1-1-0.dll
api-ms-win-core-heap-l2-1-0.dll
api-ms-win-eventing-provider-l1-1-0.dll
api-ms-win-core-debug-l1-1-0.dll
api-ms-win-core-errorhandling-l1-1-0.dll
api-ms-win-core-libraryloader-l1-2-0.dll
api-ms-win-core-synch-l1-1-0.dll
api-ms-win-core-com-l1-1-0.dll
api-ms-win-core-processthreads-l1-1-0.dll
api-ms-win-core-localization-l1-2-0.dll
api-ms-win-core-heap-l1-1-0.dll
api-ms-win-core-sysinfo-l1-1-0.dll
api-ms-win-core-synch-l1-2-0.dll
api-ms-win-core-string-l1-1-0.dll
api-ms-win-core-processenvironment-l1-1-0.dll
api-ms-win-core-string-l2-1-0.dll
api-ms-win-core-rtlsupport-l1-1-0.dll
api-ms-win-core-processthreads-l1-1-1.dll
api-ms-win-core-profile-l1-1-0.dll
api-ms-win-core-interlocked-l1-1-0.dll
api-ms-win-core-registry-l1-1-0.dll
api-ms-win-core-threadpool-l1-2-0.dll
api-ms-win-core-version-l1-1-0.dll
api-ms-win-security-base-l1-1-0.dll
api-ms-win-core-libraryloader-l1-2-1.dll
api-ms-win-core-sysinfo-l1-2-0.dll
api-ms-win-core-timezone-l1-1-0.dll
api-ms-win-core-file-l1-1-0.dll
api-ms-win-core-file-l2-1-2.dll
api-ms-win-core-path-l1-1-0.dll
ApiSetQueryApiSetPresence
UrlEscapeW
api-ms-win-core-apiquery-l1-1-0.dll
api-ms-win-core-url-l1-1-0.dll
GetComputerNameW
DeleteTimerQueueTimer
CreateTimerQueueTimer
DeleteTimerQueueEx
CreateTimerQueue
api-ms-win-core-kernel32-legacy-l1-1-0.dll
api-ms-win-core-threadpool-legacy-l1-1-0.dll
lstrcmpiW
GetUserDefaultUILanguage
lstrcmpA
api-ms-win-core-localization-obsolete-l1-2-0.dll
api-ms-win-core-string-obsolete-l1-1-0.dll
wcsstr
wcschr
wcsspn
wcscspn
wcsncmp
RtlDeleteResource
RtlInitializeResource
RtlAcquireResourceExclusive
RtlReleaseResource
RtlAcquireResourceShared
RtlGetDeviceFamilyInfoEnum
RtlPublishWnfStateData
RtlNtStatusToDosError
RtlUnsubscribeWnfNotificationWaitForCompletion
RtlSubscribeWnfStateChangeNotification
ntdll.dll
RtlReleaseSRWLockExclusive
RtlAcquireSRWLockExclusive
RtlWakeAllConditionVariable
RtlSleepConditionVariableSRW
_time64
api-ms-win-crt-time-l1-1-0.dll
ResolveDelayLoadedAPI
DelayLoadFailureHook
CreateThread
CoGetMalloc
WindowsDeleteString
WindowsGetStringRawBuffer
api-ms-win-core-delayload-l1-1-1.dll
api-ms-win-core-delayload-l1-1-0.dll
api-ms-win-core-winrt-string-l1-1-0.dll
StrStrIW
api-ms-win-core-shlwapi-obsolete-l1-1-0.dll
GetPersistedRegistryLocationW
api-ms-win-stateseparation-helpers-l1-1-0.dll
wcscmp
memcmp
memcpy
memmove
.?AVbad_array_new_length@std@@
.?AVResultException@wil@@
.?AVCPassportException@@
.?AVCAtlException@ATL@@
.?AVexception@std@@
.?AVbad_alloc@std@@
.?AVbad_optional_access@std@@
.?AVtype_info@@
D:PAI(A;CIIOID;KA;;;CO)(A;CIID;KA;;;SY)(A;CIID;KA;;;BA)(A;CIID;KR;;;BU)S:AI(ML;CI;NWNR;;;ME)
SetRegistryPermissionDone
ps:Error/@Code
ps:ErrorSubcode
/S:Envelope/S:Body/ps:ManageApproverResponse
/S:Envelope/S:Body/ps:ManageApproverResponse/ps:TOTPSharedKey
ErrorSubcode
Error/@Code
/S:Envelope/S:Body/ps:GetKeyDataResponse
/S:Envelope/S:Body/ps:GetKeyDataResponse/ServerInfo/@ServerTime
/S:Envelope/S:Body/ps:GetKeyDataResponse/ps:KeyPurposes
Error/@Code
/S:Envelope/S:Body/ps:GetAppDataResponse/ServerInfo/@ServerTime
ErrorSubcode
/S:Envelope/S:Body/ps:GetAppDataResponse/ps:Apps/ps:App/ps:Property
/S:Envelope/S:Body/ps:GetAppDataResponse
Error/@Code
/S:Envelope/S:Body/ps:GetKeyDataResponse/ServerInfo/@ServerTime
ErrorSubcode
/S:Envelope/S:Body/ps:GetKeyDataResponse/ps:KeyPurposes
/S:Envelope/S:Body/ps:GetKeyDataResponse
ps:Error/@Code
ps:ErrorSubcode
/S:Envelope/S:Body/ps:ManageLoginKeyResponse
ps:Error/@Code
ps:ErrorSubcode
/S:Envelope/S:Body/ps:ListSessionsResponse/ps:Sessions
/S:Envelope/S:Body/ps:ListSessionsResponse/ps:NotRegistered
/S:Envelope/S:Body/ps:ListSessionsResponse[@Success='true']
/S:Envelope/S:Body/ps:ListSessionsResponse[@Success='false']
/S:Envelope/S:Header/psf:pp/psf:signChallenge
ps:Error/@Code
ps:ErrorSubcode
/S:Envelope/S:Body/ps:ApproveSessionResponse
<wsse:BinarySecurityToken EncodingType="ps:JWT" ValueType="ps:LoginProofToken" Id="LoginProofToken" PurposeType="PURPOSE_TRANSFER_TOKEN">
ew|>&=4_
VS_VERSION_INFO
StringFileInfo
040904B0
CompanyName
Microsoft Corporation
FileDescription
Microsoft
 Account Service
FileVersion
10.0.22621.586 (WinBuild.160101.0800)
InternalName
Wlidsvc.dll
LegalCopyright
 Microsoft Corporation. All rights reserved.
OriginalFilename
Wlidsvc.dll
ProductName
Microsoft
 Windows
 Operating System
ProductVersion
10.0.22621.586
VarFileInfo
Translation
en-US
