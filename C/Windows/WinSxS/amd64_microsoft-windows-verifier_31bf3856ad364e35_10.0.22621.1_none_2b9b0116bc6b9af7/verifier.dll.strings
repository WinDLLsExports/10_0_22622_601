!This program cannot be run in DOS mode.
TQbC5?1C5?1C5?1
M>0@5?1C5>1
M;0D5?1
M<0@5?1
M?0B5?1
M70g5?1
1B5?1
M=0B5?1RichC5?1
.text
`.rdata
@.data
.pdata
@.rsrc
@.reloc
T$xE3
D$HE3
t$ WATAUAVAWH
 A_A^A]A\_
L$PA;
x ATAVAWH
s\fD9 t
fD9 t
sAfD9#t;A
fD9#t
 A_A^A\
|$ AVH
D$@H+
UVWATAUAVAWH
H99u)H
PA_A^A]A\_^]
UAVAWH
l$(H!T$ 
A_A^]
WAVAWH
H;H0uZH
A_A^_
WATAUAVAWH
0A_A^A]A\_
UVWATAUAVAWH
`A_A^A]A\_^]
WATAUAVAWH
0A_A^A]A\_
x AUAVAWH
 A_A^A]
x ATAVAWH
 A_A^A\
x AVH
@USVWAWH
H!EHH!E8H
@A__^[]
H;W0u
u<H9]8
L9{0vQH
T$HH+
B0H9G(ueL
D!R8D
G0H9B(uYL
D!R8D
C(H9G(u]H
C0H9G0uS
WAVAWH
uLH!D$0H
D$xE3
tjH9w0vdH
@A_A^_
@8 u"
H9C@t
H9C`t
H9P t
B(t-A
UVWAVAWH
T$hH;
A_A^_^]
WATAUAVAWH
0A_A^A]A\_
H98ucH
VWATAVAWH
0A_A^A\_^
x AVH
B0L;@0v
J(M)J0
H9P0s
t)H9P
UWATAUAVH
H9ugu
H9N(t
A^A]A\_]
t$ WH
t$ WH
@SVWH
ds7E3
xykD$pd3
t$ WH
HkD$8d
H+D$8H=
H;p0u
T$@E3
tLH9x
WAVAWH
 A_A^_
L$ SVWH
D$PAVr2H
UVWATAUAVAWH
pA_A^A]A\_^]
SVWATAUAVAWH
D9%4J
AVrfL
A_A^A]A\_^[
WATAUAVAWH
 A_A^A]A\_
D$`f9
pKSxt?
\$0E3
|$ UH
t$ WH
L$`H3
L$ SVWAVH
(A^_^[
L$ E3
|$ UH
H95sz
H958z
H95}y
UVWAVAWH
D$(E3
L$HH3
PA_A^_^]
q:_0#
L$HE3
t$ WATAUAVAWH
L9y0t
x'@8t$0u L
L$HE3
A_A^A]A\_
x AVH
VWATAVAWH
|$0H;
L$8I;
A_A^A\_^
q0R^G'
SUVWAVH
PA^_^][
\$ UVWAVAWH
p3S2M&
A_A^_^]
\$ UVWAVAWH
p3S2M&
A_A^_^]
x ATAVAWH
H!|$ L
H9|$8
@A_A^A\
t$ WH
UVWATAUAVAWH
L;p@u
A_A^A]A\_^]
L;vPt
pSU:{
pSU:{
D$`E3
L$`H3
Z8..]
H9\$ht
xSH9\$`tLH
x AVH
o(v0H
L$PE3
u^D84%
l$ VWAVH
H@H9L$Pu&L
t$(E3
L$@L;
AHH9C
H9\$H
WATAUAVAWH
fD9)t
:fD;*s Mk
:u<E3
 A_A^A]A\_
SVWAVAWH
A_A^_^[
\$@H;
L9D$PuJ
x ATAVAWH
A_A^A\
WAVAWH
@A_A^_
WAVAWH
yd9-$#
@A_A^_
VWATAVAWH
t*LcK
D$hE3
A_A^A\_^
D$8E3
VWAVH
@A^_^
H!|$0
H!|$(H!|$ L
t(H!|$0
H!|$(H!|$ E3
u&H!D$0H
H!D$(L
H!D$ 
H;BHu 
@USVWATAUAVAWH
t5@8|$@t.H
H;1r%H
A_A^A]A\_^[]
WATAUAVAWH
fD9,Zu
A_A^A]A\_
@SUVWAVAWH
t=D9=
A_A^_^][
WAVAWH
0A_A^_
WAVAWH
A_A^_
@USVATAUAVAWH
@A_A^A]A\^[]
x ATAVAWH
fE9$~u
 A_A^A\
WAVAWH
 A_A^_
pAV^O&
UVWATAUAVAWH
fD9rXvDeH
H;Cxt
fD9+u
@A_A^A]A\_^]
fA9FXw
@USVWATAVAWH
@8|$ t
A_A^A\_^[]
x AVH
@SUVWAVH
A^_^][
UVWATAUAVAWH
S8L;z
6H9Q8u)
AH3CH
C8M;x
C8H9B8u#
BH3CH
C(H9r
@A_A^A]A\_^]
VWAVH
 A^_^
t$ WATAUAVAWH
JHD;kHv
CL9C<r
z8M;g
NHt,I
C<;C@v
 A_A^A]A\_
A8H9X
t"f9y
VWATAUAVH
H9s8t
H9y@t
0A^A]A\_^
x ATAVAWH
 A_A^A\
pAV^O&
D$`eH
qY]>z
x AVH
pY]>z
pY]>z
UVWAVAWH
A_A^_^]
t$ WH
|$ AVH
VWATAVAWH
H!|$0H
H!|$(E3
H!|$ 
A_A^A\_^
WATAUAVAWH
9]8t0
u&HcE8
HHH9J
A_A^A]A\_
WATAUAVAWH
HHH9J
A_A^A]A\_
V~&?q
L$0E3
L$HE3
x AVH
x AVH
x AVH
x AVH
x AVH
WAVAWH
@A_A^_
L$HE3
WATAUAVAWH
A_A^A]A\_
WAVAWH
0A_A^_
x AVH
WAVAWH
@A_A^_
L$xE3
ID$XL
L$xE3
x ATAVAWH
0A_A^A\
q[[<r7
t$ WATAUAVAWH
D$pt(D
p[[<r7
0A_A^A]A\_
WAVAWH
0A_A^_
WAVAWH
0A_A^_
WAVAWH
0A_A^_
x ATAVAWH
 A_A^A\
A9P@u
p AWH
qZQp*
pZQp*
x AVH
qsVvW
p AWH
psVvW
D$0A;
x ATAVAWH
\$PE3
A_A^A\
x ATAVAWH
\$PE3
A_A^A\
PHH9Q
x AWH
x AVH
k@H!s@H
s8L!s8
t=H9x
I9x0u
H9~hu
x ATAVAWH
H9p0t
0A_A^A\
x AWH
?H9sHu
H9s0u
?H9sHu
H9s0u
x AVH
H9i(u
qRWZ"'p
H;x(u\H
pRWZ"'p
x AVH
D$hE3
L$ UVWATAUAVAWH
D!}OM
U?uzH
H;Y(u
u@D!|$0H
A_A^A]A\_^]
UVWATAUAVAWH
tA!|$0H
A_A^A]A\_^]
x AVH
D$HE3
@USVWAVH
`A^_^[]
VWAVH
0A^_^
x ATAVAWH
@A_A^A\
x AVH
SUVWATAUAVAWH
H9t$8
D$xeL
L9t$8t
A_A^A]A\_^][
WAVAWH
 A_A^_
D$(E3
D$(E3
\Z{>Y
D$(E3
\Z{>Y
D$(E3
D$(E3
D$(E3
D$(E3
D$(E3
D$(E3
SVWAVAWH
D$(E3
t$(E3
0A_A^_^[
SVWATAVAWH
D$8E3
t$8E3
XA_A^A\_^[
D$(E3
D$(E3
D$(E3
D$(E3
D$(E3
\$ VWAVH
x AVH
D$(E3
H;Z0t
SVWAVAWH
H!\$H
D$HE3
t$HE3
`A_A^_^[
D$(E3
@VWATAUAVAWH
A_A^A]A\_^
D$hE3
t$hE3
p AWH
D$8E3
p AWH
D$HE3
D$(E3
D$(E3
D$(E3
D$(E3
x AVH
D$(E3
D$(E3
WAVAWH
 A_A^_
D$8E3
D$8E3
x AVH
D$(E3
D$(E3
D$(E3
D$(E3
D$(E3
D$(E3
D$(E3
D$(E3
D$(E3
D$(E3
\Z{>Y
D$(E3
\Z{>Y
D$(E3
D$(E3
D$(E3
D$(E3
p AWH
D$8E3
D$8E3
p AWH
D$8E3
D$8E3
D$(E3
D$(E3
p AWH
D$8E3
D$8E3
D$(E3
qxY2r
pxY2r
D$(E3
D$(E3
D$(E3
D$(E3
D$(E3
D$(E3
p AWH
D$8E3
D$8E3
p AWH
D$8E3
D$8E3
D$(E3
D$(E3
p AWH
D$8E3
D$8E3
D$(E3
qxY2r
pxY2r
D$(E3
D$(E3
D$(E3
D$(E3
D$(E3
qp\Rt
pp\Rt
D$(E3
D$(E3
D$(E3
D$(E3
D$(E3
\Z{>Y
D$(E3
\Z{>Y
D$(E3
D$(E3
D$(E3
qp\Rt
pp\Rt
D$(E3
D$(E3
D$(E3
D$(E3
D$(E3
\Z{>Y
D$(E3
\Z{>Y
D$(E3
Z:&/I
x AVH
Z:&/I
WAVAWH
D$XE3
@A_A^_
t$ WH
x AVH
D$8E3
x AVH
D$8E3
D$(E3
L$0Hc
D$(E3
q"QVm
x AVH
p"QVm
D$HE3
WAVAWH
@A_A^_
x AVH
x AVH
x AVH
x AVH
x AVH
x AVH
x AVH
x AVH
x AVH
D$HE3
x AVH
L$(E3
x AVH
L$0Hc
x AVH
x AVH
WAVAWH
@A_A^_
WAVAWH
L$hE3
A_A^_
WAVAWH
D$XE3
@A_A^_
qRQxZ
x ATAVAWH
pRQxZ
A_A^A\
q1VP6
x AVH
p1VP6
x AVH
L$0Hc
q!ZTb'
x AVH
p!ZTb'
x AVH
x AVH
x AVH
x AVH
H!t$(H!t$ 
t!H!t$ D
x AVH
x AVH
D$(E3
D$(E3
D$HE3
D$(E3
D$(E3
WAVAWH
A_A^_
qKSxt?
WAVAWH
pKSxt?
A_A^_
WAVAWH
0A_A^_
WAVAWH
0A_A^_
x AVH
T2w6p
x AVH
T2w6p
x AVH
qr^PB
x AVH
pr^PB
D$(E3
D$(E3
D$(E3
q(Z:Z.
x AWH
p(Z:Z.
D$(E3
p AWH
p AWH
p AWH
D$HE3
p AWH
D$HE3
p AWH
D$HE3
s WAVAWH
y1D9=V
L$HI;
A_A^_
VWATAVAWH
pA_A^A\_^
q@QTN'
SVWATAUAVAWH
p@QTN'
pA_A^A]A\_^[
WATAUAVAWH
D9-/`
A_A^A]A\_
u4M9.
l$(E3
x ATAVAWH
L9&uK
@A_A^A\
x AVH
WATAUAVAWH
A_A^A]A\_
L$0E3
L$0E3
VWATAVAWH
A_A^A\_^
D$8E3
p AWH
t#H!X
D$XE3
VWAVH
`A^_^
WAVAWH
@A_A^_
q@\xV.
WAVAWH
A_A^_
x AVH
Thread
FaultInjectionIncludeDlls
FaultInjectionExcludeDlls
FaultInjectionTimeOut
FaultInjectionProbability
AVRF: fault injecting call made from %p 
AVRF:FINJ: invalid fault injection class %X 
Not used.
Current thread using the heap
Last thread that used the heap
Heap handle
multithreaded access in HEAP_NO_SERIALIZE heap
heap handle with incorrect signature
\KernelObjects\HighCommitCondition
Page heap: pid 0x%X: page heap enabled with flags 0x%X.
Process heap handle
attempt to destroy process heap
Size requested
extreme size request
Address
HeapRoot
Page heap: freeing a null pointer
Page heap count
Actual count
process heap list count is wrong
Corruption Address
Block size
Heap block
corrupted header
block already freed
corruption address
corrupted infix pattern for freed block
Heap owning the block
Heap used in the call
corrupted heap pointer or using wrong heap
corrupted suffix pattern
corrupted prefix pattern
Corrupted stamp
corrupted start stamp
corrupted end stamp
Exception code
exception raised while verifying block
corrupted heap block
heap signature
heap block
virtual storage list entry
list head
list count
AVRF: Reached the end of heap list without finding heap index %x. Total number of heaps %x
heap list entry
AVRF: EntryContents.Blink = %p, expected %p
VerifierRegisterLayer
AVRF: Spy [%s, %u]: %X
VerifierRegisterBasicsLayers
VerifierUnregisterLayer
VerifierUnregisterBasicsLayers
This verifier stop is continuable. 
After debugging it use `go' to continue.
This verifier stop is not continuable. Process will be terminated 
when you use the `go' debugger command.
===========================================================
VERIFIER STOP %p: pid 0x%X: %s 
%p : %s
%p : %s
%p : %s
%p : %s
===========================================================
===========================================================
AVRF: Noncontinuable verifier stop %Ix encountered. Terminating process ... 
AVRF: Terminate process after verifier stop failed with %X 
AVRF: Invalid LayerDescriptor or BreakDecriptor passed for Stop code 0x%X
AVRF: Invalid Stop code 0x%X passed to VerifierStopMessageEx
AVRF: Failed to initialize logging and stop support
AVRF:bogus string length, overflow
AVRF:Failed to save message into stop list
StopProcessing
stop code
advapi32.dll
RegCreateKeyExW
RegCloseKey
RegQueryValueExW
RegSetValueExW
RegDeleteValueW
SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\
GlobalFlag
AVRF: settings: result %u 
0x%08X
VerifierFlags
{9760941A-8DA5-4dbe-843B-0EBD376CAB02}
Handles
Basics
{159D60EC-F459-456b-A27B-1076AD59F8F4}
Locks
{EDDA96DB-D216-467d-BE3C-8603745EDA43}
{8A70B8A4-4FA6-41c3-85EE-595FCB3E1051}
Memory
{F86B022F-E589-4e8f-B0DD-6B7AF9D71A59}
Exceptions
{970bd287-2e5a-4a06-9084-9e394d4c2697}
DirtyStacks
Miscellaneous
{02A5B40C-2F22-4409-BB37-7EF0D3F34A88}
DangerousAPIs
{de35a0c0-d3b8-11d9-8cd5-0800200c9a66}
TimeRollOver
{F15FC24E-53A0-444D-8D28-F7697EDD9C83}
Threadpool
{5FE32372-CE71-43f9-B75D-6AD4B1B08D6A}
InputOutput
{81EEC8DA-0E61-4942-8037-9A6C4A86510D}
{6335D1CF-7955-414e-8C6A-1A40AC9357AC}
SRWLock
ntdll.dll
LdrGetProcedureAddressForCaller
AVRF: AVrfpLdrGetProcedureAddress (%p, %s) -> new address %p
PageHeapSizeRangeStart
PageHeapSizeRangeEnd
PageHeapRandomProbability
PageHeapDllRangeStart
PageHeapDllRangeEnd
PageHeapTargetDlls
PageHeapVirtualMemoryPercent
PageHeapCommitMemoryPercent
ThreadTrackerSize
HeapTrackerSize
VspaceTrackerSize
DllLoadUnloadTrackerSize
CritsectDeleteTrackerSize
OutbuffTrackerSize
ThreadpoolTrackerSize
ForcePendingIOTrackerSize
EventTrackerSize
DelayFreeSizeMB
AVRF: Ignoring payload restriction mitigation options since App Verifier or Pageheap are enabled. 
AVRF: failed to initialize call trackers (%X). 
AVRF: failed to initialize FreeMemoryCallBacks (%X). 
AVRF: VerifierRegisterBasicsLayers failed.
AVRF: VerifierLoadEssentialStrings failed, status %#x
AVRF: NtQuerySystemInformation (SystemBasicInformation) failed, status %#x
OANOCACHE
AVRF: failed to define OANOCACHE variable (%X). 
AVRF: Failed to initialize verifier.dll provider for %ws with flags 0x%X.
AVRF: verifier.dll provider initialized for %ws with flags 0x%X
AVRF: Exception during verifier.dll init for %ws with flags 0x%X.
PayloadRestrictions.dll
MitLibInitialize
MitLibUninitialize
ntdll.dll
NtSuspendProcess
NtResumeProcess
AVRF: failed to create verifier heap. 
AVRF: failed to initialize verifier stop logic (%X). 
RtlReportException
AVRF: Exception %x from address %p
Dirtying stack range %p - %p for thread %p 
AVRF: failed to allocated a verifier TLS slot.
Context record. Use .cxr to display it.
Exception record. Use .exr to display it.
Code performing invalid access
Invalid address being accessed
first chance access violation for current stack trace
AVRF: failed to add free memory callback @ %p 
AVRF: attempt to delete invalid free memory callback @ %p 
Stack low limit address
DLL name address. Use du to dump it.
DLL memory range size
DLL memory base address
Unloading DLL inside current thread's stack address range
AVRF: Couldn't read %s @ %p
AVRF: Read just %Ix out of %Ix bytes of %s @ %p
RtlInitializeSRWLock
RtlReleaseSRWLockExclusive
RtlReleaseSRWLockShared
RtlAcquireSRWLockExclusive
RtlAcquireSRWLockShared
RtlCreateMemoryBlockLookaside
RtlExtendMemoryBlockLookaside
RtlAllocateMemoryBlockLookaside
RtlFreeMemoryBlockLookaside
NtAllocateVirtualMemory
NtFreeVirtualMemory
NtMapViewOfSection
NtUnmapViewOfSection
NtUnmapViewOfSectionEx
NtCreateSection
NtOpenSection
NtCreateFile
NtOpenFile
NtCreateKey
NtOpenKey
RtlTryEnterCriticalSection
RtlEnterCriticalSection
RtlLeaveCriticalSection
RtlInitializeCriticalSection
RtlInitializeCriticalSectionAndSpinCount
RtlDeleteCriticalSection
RtlInitializeResource
RtlDeleteResource
RtlAcquireResourceShared
RtlAcquireResourceExclusive
RtlReleaseResource
RtlConvertSharedToExclusive
RtlConvertExclusiveToShared
NtCreateEvent
NtOpenEvent
NtClose
RtlAllocateHeap
RtlReAllocateHeap
RtlFreeHeap
NtReadFile
NtReadFileScatter
NtWriteFile
NtWriteFileGather
NtWaitForSingleObject
NtWaitForMultipleObjects
RtlSetThreadPoolStartFunc
NtSetEvent
NtClearEvent
NtPulseEvent
NtQueryEvent
NtResetEvent
NtSetEventBoostPriority
NtAlertResumeThread
NtAlertThread
NtGetContextThread
NtImpersonateThread
NtQueryInformationThread
NtQueueApcThread
NtResumeThread
NtSetContextThread
NtSetInformationThread
NtSuspendThread
NtTerminateThread
NtGetNextThread
NtQueryInformationProcess
NtSetInformationProcess
NtTerminateProcess
NtGetNextProcess
NtAllocateUserPhysicalPages
NtExtendSection
NtReadVirtualMemory
NtWriteVirtualMemory
NtFlushVirtualMemory
NtLockVirtualMemory
NtUnlockVirtualMemory
NtProtectVirtualMemory
NtQuerySection
NtFreeUserPhysicalPages
NtGetWriteWatch
NtResetWriteWatch
NtFlushInstructionCache
NtDeleteKey
NtDeleteValueKey
NtEnumerateKey
NtEnumerateValueKey
NtFlushKey
NtNotifyChangeKey
NtNotifyChangeMultipleKeys
NtQueryKey
NtQueryValueKey
NtQueryMultipleValueKey
NtReplaceKey
NtRenameKey
NtCompactKeys
NtCompressKey
NtRestoreKey
NtSaveKey
NtSaveKeyEx
NtSaveMergedKeys
NtSetValueKey
NtUnloadKeyEx
NtSetInformationKey
NtLockRegistryKey
_vsnprintf
_vsnwprintf
_snprintf
_snwprintf
LdrLoadDll
LdrUnloadDll
RtlInitializeCriticalSectionEx
TpAllocWork
TpAllocTimer
TpAllocWait
TpAllocIoCompletion
TpReleaseIoCompletion
TpAllocAlpcCompletion
TpSimpleTryPost
TpCallbackLeaveCriticalSectionOnCompletion
TpCallbackDetectedUnrecoverableError
RtlQueueWorkItem
RtlCreateHeap
RtlRegisterWait
RtlDeregisterWaitEx
RtlDeregisterWait
RtlCreateTimerQueue
RtlDeleteTimerQueueEx
RtlDeleteTimerQueue
RtlCreateTimer
RtlDeleteTimer
RtlUpdateTimer
RtlCancelTimer
RtlSetTimer
NtDeviceIoControlFile
NtFsControlFile
NtRemoveIoCompletion
NtRemoveIoCompletionEx
RtlExitUserThread
RtlSetIoCompletionCallback
NtSetInformationFile
NtCancelIoFile
NtCancelIoFileEx
RtlDeleteSecurityObject
RtlDestroyHeap
NtNotifyChangeDirectoryFile
NtDuplicateObject
RtlTryAcquireSRWLockExclusive
RtlAcquireReleaseSRWLockExclusive
RtlTryAcquireSRWLockShared
RtlSleepConditionVariableSRW
RtlConvertSRWLockExclusiveToShared
RtlFreeUnicodeString
RtlFreeSid
RtlExitUserProcess
RtlSetSecurityObject
RtlSetSecurityObjectEx
RtlDisownModuleHeapAllocation
NtAllocateVirtualMemoryEx
LdrGetProcedureAddress
HeapCreate
HeapDestroy
CloseHandle
ExitThread
TerminateThread
SuspendThread
TlsAlloc
TlsFree
TlsGetValue
TlsSetValue
CreateThread
WaitForSingleObject
WaitForMultipleObjects
WaitForSingleObjectEx
WaitForMultipleObjectsEx
GlobalAlloc
GlobalReAlloc
LocalAlloc
LocalReAlloc
CreateFileA
CreateFileW
FreeLibraryAndExitThread
GetTickCount
IsBadReadPtr
IsBadHugeReadPtr
IsBadWritePtr
IsBadHugeWritePtr
IsBadCodePtr
IsBadStringPtrA
IsBadStringPtrW
VirtualFree
VirtualFreeEx
CreateEventA
CreateEventW
OpenEventA
OpenEventW
MultiByteToWideChar
WideCharToMultiByte
UnmapViewOfFile
UnmapViewOfFileEx
SetThreadAffinityMask
SetThreadPriority
GlobalFree
LocalFree
VirtualAlloc
HeapAlloc
HeapReAlloc
HeapFree
SetProcessWorkingSetSizeEx
SetProcessWorkingSetSize
RegCreateKeyA
RegCreateKeyW
RegCreateKeyExA
RegOpenKeyA
RegOpenKeyW
RegOpenKeyExA
RegOpenKeyExW
RegNotifyChangeKeyValue
RegSetValueA
RegSetValueW
RegSetValueExA
malloc
calloc
realloc
??2@YAPEAX_K@Z
??3@YAXPEAX@Z
??_U@YAPEAX_K@Z
??_V@YAXPEAX@Z
_strdup
_wcsdup
_mbsdup
_aligned_malloc
_aligned_realloc
_aligned_recalloc
_aligned_free
_aligned_offset_malloc
_aligned_offset_realloc
_aligned_offset_recalloc
_fullpath
_wfullpath
_getcwd
_wgetcwd
_getdcwd
_wgetdcwd
_o_malloc
_o_calloc
_o_realloc
_o_free
_o__aligned_malloc
_o__aligned_realloc
_o__aligned_recalloc
_o__aligned_free
_o__aligned_offset_malloc
_o__aligned_offset_realloc
_o__aligned_offset_recalloc
_o__strdup
_o__wcsdup
_o__fullpath
_o__wfullpath
_o__getcwd
_o__wgetcwd
_o__getdcwd
_o__wgetdcwd
CoInitialize
CoInitializeEx
CoUninitialize
RoInitialize
RoUninitialize
CoTaskMemAlloc
CoTaskMemRealloc
CoTaskMemFree
PostThreadMessageW
PostThreadMessageA
PostMessageW
PostMessageA
PostQuitMessage
RegisterPowerSettingNotification
UnregisterPowerSettingNotification
SetClipboardData
SysAllocString
SysReAllocString
SysAllocStringLen
SysReAllocStringLen
SysAllocStringByteLen
SysFreeString
VariantClear
SetupDiCreateDevRegKeyA
SetupDiCreateDevRegKeyW
SetupDiOpenDevRegKey
kernel32.dll
msvcrt.dll
ucrtbase.dll
ole32.dll
user32.dll
setupapi.dll
oleaut32.dll
kernelbase.dll
combase.dll
AVRF: internal error: we do not have a replacement for %s !!! 
Critical section debug info address
Lock count
Critical section address
critical section over-released or corrupted
Number of critical sections owned by current thread.
%p (CS = %p, DebugInfo = %p), left %p, right %p, parent %p
================================================
Critical section tree root = %p
================================================
AVrfpInsertCritSectInSplayTree( %p )
AVrfpFindCritSectInSplayTree( %p )
AVrfpDeleteCritSectFromSplayTree( %p )
AVrfpInitializeCriticalSectionCommon (%p, %x, %x))
AVRF: InitializeCriticalSection (%p) - no tree node.
AVRF: InitializeCriticalSection (%p) - out of memory - DebugInfo is not valid.
AVrfpRtlDeleteCriticalSection (%p)
AVrfpRtlInitializeResource (%p), CS = %p
AVrfpRtlDeleteResource (%p), CS = %p
Number of critical sections owned by curent thread.
current thread doesn't own locks
AVRF: AVrfpCheckStaticInitializedCriticalSection (%p) - no tree node.
AVRF: checking CS @ %p (debug info @ %p)
vfbasics.dll
AVRF: %ws: null entry point.
AVRF: %ws @ %p: entry point @ %p .
mfplat.dll
nsi.dll
threadpoolwinrt.dll
rtworkq.dll
AVRF: low memory: will not verify entry point for %ws .
AVRF: hooked dll entry point for dll %ws 
AVRF: dll entry @ %p (%ws, %x) 
AVRF: failed to get dll base of user32.dll.
AVRF: TLS slot %x allocated by code at %p.
AVRF: AVrfpLdrLoadDll (%p, %ws)
AVRF: AVrfpLdrUnLoadDll (%p)
winlogon.exe
sppsvc.exe
OESpamFilter.dll
MSWSOCK.DLL
gdiplus.dll
TTTraceWriter.dll
TTDWriter.dll
licwmi.dll
dpcdll.dll
licdll.dll
Sbscrdll.dll
USER32.DLL
DNSAPI.DLL
mswsock.dll
SPOOLSS.DLL
localspl.dll
NETAPI32.DLL
netlogon.dll
asfsipc.dll
framedyn.dll
iac25_32.ax
rpcss.dll
ODBC32.dll
catsrv.dll
GDI32.DLL
iuengine.dll
UxTheme.dll
WINHTTP.DLL
adsldp.dll
adsldpc.dll
detours.dll
deviceaccess.dll
dhcpcore.dll
dhcpcore6.dll
diagperf.dll
esent.dll
firewall.cpl
firewallapi.dll
fxsst.dll
ieframe.dll
iessetup.dll
jscript.dll
logger.ocx
mpssvc.dll
mscories.dll
msfeeds.dll
Perftrack.dll
pwrshsip.dll
radardt.dll
rometadata.dll
ShimEng.dll
taskschd.dll
trkwks.dll
UNTFS.dll
Urlmon.dll
VSSAPI.DLL
wab32.dll
wbemcons.dll
webclnt.dll
wercplsupport.dll
winspool.drv
wintypes.dll
WLDAP32.dll
wmp.dll
****************************************************************************
**                                                                        **
** Potential deadlock detected!                                           **
** Type !avrf -dlck in the debugger for more information.                 **
Deadlock detection: Must release resources in reverse-order
Resource %p acquired before resource %p -- 
Current thread (%p) is trying to release it first
AVRF: Overflow for BytesAllocated (%p) + Size(%p) 
AVRF: deadlock: stop: %p %p %p %p
Application verifier deadlock/resource issue
EnumThreadWindows
RealGetWindowClassW
PeekMessageW
IsGUIThread
wudfhost.exe
UNKNOWN
(null)
\Software\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\
\REGISTRY\USER\
\Registry\Machine\Software\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\
VerifierAppLaunchCount
PageHeapFlags
AVRF: %ws Failed to close event 0x%p with Status 0x%X
AVRF: %ws Failed to close handle 0x%p with Status 0x%X
AVRF: %ws Failed to close event 0x%p with Status 0x%X in event completion callback
AVRF: %ws Failed to clear event 0x%p with Status 0x%X
AVRF: %ws Failed to create event with Status 0x%X
AVRF: %ws Failed to register wait callback with Status 0x%X
AVRF: conditional breakpoint %X hit.
Event
Thread
Process
Section
EventOrProcess
AVrfpFreeVirtualMemNotify: NtQueryVirtualMemory( %p ) failed %x
Buffer size
Buffer start address
Unexpected exception raised while initializing output buffer.
AVRF: (%x, %x) AVrfpInitOutputBuffer filling Buffer 0x%p, size 0x%x
Shutdown
ProcessName
VerifierFlags
Startup
ProcessName
VerifierFlags
Microsoft-Windows-Verifier
verifier.pdb
.text
.text$mn
.text$mn$00
.text$x
.rdata$brc
.idata$5
.00cfg
.gehcont
.gfids
.giats
.rdata
.rdata$voltmd
.rdata$zETW0
.rdata$zETW1
.rdata$zETW2
.rdata$zETW9
.rdata$zzzdbg
.xdata
.edata
.idata$2
.idata$3
.idata$4
.idata$6
.data$brc
.data
.pdata
.rsrc$01
.rsrc$02
VERIFIER.dll
AVrfAPILookupCallback
VerifierAddFreeMemoryCallback
VerifierCheckPageHeapAllocation
VerifierCreateRpcPageHeap
VerifierDeleteFreeMemoryCallback
VerifierDestroyRpcPageHeap
VerifierDisableFaultInjectionExclusionRange
VerifierDisableFaultInjectionTargetRange
VerifierEnableFaultInjectionExclusionRange
VerifierEnableFaultInjectionTargetRange
VerifierEnumerateResource
VerifierForceNormalHeap
VerifierGetInfoForException
VerifierGetMemoryForDump
VerifierGetPropertyValueByName
VerifierGetProviderHelper
VerifierIsAddressInAnyPageHeap
VerifierIsCurrentThreadHoldingLocks
VerifierIsDllEntryActive
VerifierIsPerUserSettingsEnabled
VerifierQueryRuntimeFlags
VerifierRedirectStopFunctions
VerifierSetFaultInjectionProbability
VerifierSetFlags
VerifierSetRuntimeFlags
VerifierStopMessage
RtlDllShutdownInProgress
RtlCompareUnicodeString
NtQuerySystemTime
RtlAllocateHeap
RtlRandom
NtQueryPerformanceCounter
RtlInitUnicodeString
RtlCaptureStackBackTrace
RtlEnterCriticalSection
RtlInitializeCriticalSection
RtlLeaveCriticalSection
DbgPrint
RtlDeleteCriticalSection
NtFreeVirtualMemory
RtlGetUserInfoHeap
RtlDestroyHeap
RtlValidateHeap
RtlInitializeGenericTableAvl
RtlInitializeSRWLock
DbgPrintEx
NtQueryVirtualMemory
RtlDeleteElementGenericTableAvl
NtQuerySystemInformation
NtOpenEvent
RtlUpcaseUnicodeChar
NtQueryInformationProcess
RtlReleaseSRWLockExclusive
RtlLookupElementGenericTableAvl
RtlAcquireSRWLockExclusive
NtAllocateVirtualMemory
RtlInsertElementGenericTableAvl
RtlAcquireSRWLockShared
RtlReleaseSRWLockShared
NtReadVirtualMemory
RtlEnumerateGenericTableAvl
RtlInitializeCriticalSectionEx
RtlSizeHeap
RtlSetUserFlagsHeap
NtQueryEvent
NtProtectVirtualMemory
RtlSetUserValueHeap
RtlFreeHeap
RtlFlushSecureMemoryCache
RtlSetHeapInformation
RtlCreateHeap
RtlUnlockHeap
RtlLockHeap
RtlRaiseException
LdrLockLoaderLock
LdrUnlockLoaderLock
RtlCaptureContext
RtlReportException
NtTerminateProcess
LdrGetProcedureAddress
LdrUnloadDll
LdrLoadDll
RtlDecodePointer
RtlInitAnsiString
RtlEncodePointer
RtlFreeAnsiString
LdrFindResource_U
RtlUnicodeStringToAnsiString
LdrAccessResource
LdrQueryImageFileKeyOption
LdrQueryImageFileExecutionOptions
RtlImageNtHeader
EtwEventWriteTransfer
RtlSetEnvironmentVariable
EtwEventUnregister
EtwEventRegister
NtWriteVirtualMemory
RtlLookupFunctionEntry
RtlVirtualUnwind
RtlUnhandledExceptionFilter
ntdll.dll
__C_specific_handler
_vsnwprintf
_wcsicmp
_vsnprintf
sscanf_s
wcstoul
wcsstr
_stricmp
RtlQueryHeapInformation
NtOpenThread
NtSuspendThread
NtClose
LdrQueryProcessModuleInformation
RtlNtStatusToDosError
NtResumeThread
RtlAddVectoredExceptionHandler
RtlEqualUnicodeString
LdrGetDllHandle
RtlDeleteResource
RtlAcquireResourceShared
NtDelayExecution
RtlAcquirePebLock
RtlReleaseResource
RtlInitializeResource
RtlAcquireResourceExclusive
RtlRemoveVectoredExceptionHandler
NtQueryInformationThread
RtlFindClearBitsAndSet
NtQueryObject
RtlReleasePebLock
RtlInterlockedPushEntrySList
RtlSplay
RtlDelete
RtlInitializeSListHead
RtlpWaitForCriticalSection
RtlInitializeCriticalSectionAndSpinCount
RtlTryEnterCriticalSection
RtlConvertExclusiveToShared
RtlRaiseStatus
RtlConvertSharedToExclusive
RtlInterlockedPopEntrySList
LdrFindEntryForAddress
iswspace
RtlEnumerateGenericTableWithoutSplayingAvl
_wcsnicmp
RtlQueryDepthSList
NtCreateEvent
RtlDeregisterWait
NtSetEvent
RtlRegisterWait
NtOpenProcessTokenEx
RtlAppendUnicodeStringToString
RtlAppendUnicodeToString
NtOpenKey
RtlConvertSidToUnicodeString
NtQueryInformationToken
NtDeleteValueKey
NtSetValueKey
NtQueryValueKey
NtGetContextThread
RtlDeregisterWaitEx
RtlWalkFrameChain
NtClearEvent
RtlFreeUnicodeString
RtlSetThreadPoolStartFunc
RtlCheckForOrphanedCriticalSections
NtWaitForMultipleObjects
NtCreateKey
NtWaitForSingleObject
NtCreateSection
NtUnmapViewOfSection
NtOpenSection
NtMapViewOfSection
memcpy
memmove
memset
Expected least significant bit
Expected minimum lock count
VS_VERSION_INFO
StringFileInfo
040904B0
CompanyName
Microsoft Corporation
FileDescription
Standard application verifier provider dll
FileVersion
10.0.22621.1 (WinBuild.160101.0800)
InternalName
verifier.dll
LegalCopyright
 Microsoft Corporation. All rights reserved.
OriginalFilename
verifier.dll
ProductName
Microsoft
 Windows
 Operating System
ProductVersion
10.0.22621.1
VarFileInfo
Translation
<AVRF: Terminate process after verifier stop failed with %X 
kThis verifier stop is not continuable. Process will be terminated 
when you use the `go' debugger command.
LThis verifier stop is continuable.
After debugging it use `go' to continue.
9AVRF: Formatting message failed in VerifierStopMessageEx
LAVRF: Noncontinuable verifier stop %p encountered. Terminating process ... 
=======================================
VERIFIER STOP %p: pid 0x%X: %S 
%p : %S
%p : %S
%p : %S
%p : %S
=======================================
=======================================
=======================================
VERIFIER STOP %p: pid 0x%X: %s 
%p : %s
%p : %s
%p : %s
%p : %s
=======================================
=======================================
SizeStart
SizeEnd
RandRate
Backward
Unalign
Traces
Protect
NoSync
NoLock
Faults
FaultRate
TimeOut
AddrStart
AddrEnd
Random
4TRUE for full page heap. FALSE for normal page heap.iPage heap allocations for target dlls only. Name of the binaries with extension (.dll or something else).%Page heap allocations for size range.
Beginning of the size range.
Ending of the size range.uDecimal integer in range [0..100] representing probability to make page heap allocation vs. a normal heap allocation.
Catch backwards overruns.
No alignment for allocations.
Collect stack tracescProtect heap internal structures. Can be used to detect random corruptions but execution is slower.LCheck for unsynchronized access. Do not use this flag for an MPheap process."Disable critical section verifier.
Fault injection.Probability (1..10000) for heap calls failuresQTime during process initialization (in milliseconds) when faults are not allowed.'Page heap allocations for address range
Beginning of the address range
Ending of the address range'Page heap allocations with probability.
DFailed within the address range where the specified dlls are loaded.
Doesn't fail within those dlls.
Grace period as Milliseconds.
Wait API.
Heap allocation.
Virtual memory allocation.
Registry API.
File API.
Event Manipulation.
Map View.
Ole API."Disable automatic stack expansion.
Traces6Maximum number of traces in the handle history buffer.
Delay"Delay until rollover in (seconds).
AsyncCheck9Check asynchronous calls that require a persistent thread
DllMainCheck<Check LoadLibrary/FreeLibrary calling when DllMain is active
ExecWritePage4Checking the usage of executable and writable memory
FillReadBuffereFills I/O buffer with a pattern before initiating the I/O, to catch bugs around uninitialized buffers
ForcePendingIOVProbability in parts per million for forcing STATUS_PENDING in place of STATUS_SUCCESS
ExcludeDllsVExcludes these dlls (comma separated) from leak detection. Max size is 2047 characters
ExcludeUCRT1Exclude allocations via UCRT from leak detection.
Checks for errors in lock usage. This might cause access violations when errors are located. A debugger is required to see the test results.
Checks that applications and components use RPC correctly. Common mistakes and problems while using RPC are flagged. A debugger is required to see the test results.
Checks that applications and components use COM correctly. Common mistakes and problems while using COM are flagged. A debugger is required to see the test results.
Checks that applications and components use TLS (Thread Local Storage) APIs correctly. Common mistakes and problems while using TLS APIs are flagged. A debugger is required to see the test results.#Helps catch uninitialized variablesaDetects first chance access violation exceptions. A debugger is required to see the test results.
Checks for handle errors. This might cause access violations when errors are located. A debugger is required to see the test results.GChecks the heap errors. A debugger is required to see the test results.
Checks for adequate stack size by stopping stack growth. This causes a stack overflow error if the original stack size is too small. You can prevent this from happening by increasing the stack commit size.TChecks usage of virtual memory APIs. A debugger is required to see the test results.$Checks usage of dangerous API usage.
Forces the GetTickCount API to roll over faster than they normally would. This allows applications to test their handling of timer rollover more easily.GChecks for dirty threadpool thread and other threadpool related issues.
Low Resource Simulation also known as Fault Injection, tries to simulate an environment under low resources, such as out of memory.'Checks issues related to I/O transfers.VChecks that when a dll is unloaded there are no outstanding resources allocated by it.
Checks for errors in SRW locks usage. Invalid SRW lock usage can result in application crashes or hangs. A debugger is required to see the test results.
"Dangerous call to TerminateThread.,Thread ID for the caller of Terminatethread.
Not used.
Not used.
Not used.
This stop is generated if a thread (thread ID is parameter1) is terminated explicitly using
TerminateThread.This function is very dangerous because it introduces data corruption and
deadlocks (as per MSDN).
2Potential stack overflow in low memory conditions.
Not used.
Not used.
Not used.
Not used.
This stop is generated if the initial stack commit size of a thread is such that a stack
overflow can be raised in low memory conditions if stack cannot be extended.
8ExitProcess called while multiple threads still running.
Number of threads running.
Not used.
Not used.
Not used.
This stop is generated if a thread calls ExitProcess while there are several threads running.
In such a case, internally TerminateThread will be called for each thread and this can create
deadlocks or data corruptions.
%LoadLibrary is called during DllMain.
Dll Name (use du to dump).
Dll base address.
Not used.
Not used.
xThis stop is generated if the code inside DllMain calls LoadLibrary or FreeLibary. It's the
behavior forbidden by MSDN.
%FreeLibrary is called during DllMain.
Dll Name (use du to dump).
Dll base address.
Not used.
Not used.
xThis stop is generated if the code inside DllMain calls LoadLibrary or FreeLibary. It's
the behavior forbidden by MSDN.
KSetProcessWorkingSetSize is called with MinimumWorkingSetSize = 0xFFFFFFFF.
Not used.
Not used.
Not used.
Not used.
/Please use MinimumWorkingSetSize = (SIZE_T) -1.
KSetProcessWorkingSetSize is called with MaximumWorkingSetSize = 0xFFFFFFFF.
Not used.
Not used.
Not used.
Not used.
/Please use MaximumWorkingSetSize = (SIZE_T) -1.
MSetProcessWorkingSetSizeEx is called with MinimumWorkingSetSize = 0xFFFFFFFF.
Not used.
Not used.
Not used.
Not used.
/Please use MinimumWorkingSetSize = (SIZE_T) -1.
MSetProcessWorkingSetSizeEx is called with MaximumWorkingSetSize = 0xFFFFFFFF.
Not used.
Not used.
Not used.
Not used.
/Please use MaximumWorkingSetSize = (SIZE_T) -1.
/Thread that is exiting owns a critical section.HThread ID of the thread that is exiting while owning a critical section.GCritical section address. Run !cs -s <address> to get more information.+Critical section debug information address.WCritical section initialization stack trace. Run dps <address> to dump the stack trace.
This stop is generated if a thread (thread ID is parameter1) is terminated,
suspended or is in a state (worker thread finished a work item) in which it
cannot hold a critical section. The current thread is the culprit.
To debug this stop use the following debugger commands:
$ kb - to get the current stack trace. If the current thread is the owner of
the critical section it is probably calling ExitThread.
The current thread should have released the critical section before exiting.
If the current thread is calling TerminateThread or SuspendThread then it
should not do this for a thread holding a critical section.
$ !cs -s parameter2 - dump information about this critical section.
$ ln parameter2 - to show symbols near the address of the critical section.
This should help identify the leaked critical section.
$ dps parameter4 - to dump the stack trace for this critical section initialization.
4Unloading DLL containing an active critical section.GCritical section address. Run !cs -s <address> to get more information.WCritical section initialization stack trace. Run dps <address> to dump the stack trace.
DLL name address.
DLL base address.
This stop is generated if a DLL has a global variable containing a critical section
and the DLL is unloaded but the critical section has not been deleted. To debug
this stop use the following debugger commands:
$ du parameter3 - to dump the name of the culprit DLL.
$ .reload dllname or .reload dllname = parameter4 - to reload the symbols for that DLL.
$ !cs -s parameter1 - dump information about this critical section.
$ ln parameter1 - to show symbols near the address of the critical section.
This should help identify the leaked critical section.
$ dps parameter2 - to dump the stack trace for this critical section initialization.
9Freeing heap block containing an active critical section.GCritical section address. Run !cs -s <address> to get more information.WCritical section initialization stack trace. Run dps <address> to dump the stack trace.
Heap block address.
Heap block size.
This stop is generated if a heap allocation contains a critical section,
the allocation is freed and the critical section has not been deleted.
To debug this stop use the following debugger commands:
$ !cs -s parameter1 - dump information about this critical section.
$ ln parameter1 - to show symbols near the address of the critical section.
This should help identify the leaked critical section.
$ dps parameter2 - to dump the stack trace for this critical section initialization.
$ parameter3 and parameter4 might help understand where this heap block was
allocated (the size of the allocation is probably significant).
1Double initialized or corrupted critical section.GCritical section address. Run !cs -s <address> to get more information.DAddress of the debug information structure found in the active list.LFirst initialization stack trace. Run dps <address> to dump the stack trace.MSecond initialization stack trace. Run dps <address> to dump the stack trace.
Usually this stop is generated if a critical section has been initialized more
than one time. In this case parameter3 and parameter4 are the stack trace
addresses for two of these initializations. Some other times it is possible
to get this stop if the critical section or its debug information structure
has been corrupted. In this second case it is possible that parameter3 and
parameter4 are invalid and useless. To debug this stop:
$ !cs -s -d parameter2 - dump information about this critical section.
$ ln parameter1 - to show symbols near the address of the critical section.
This might help identify the critical section if this is a global variable.
$ dps parameter3 and dps parameter4 - to identify the two code paths for
initializing this critical section.
2Free memory containing an active critical section.GCritical section address. Run !cs -s <address> to get more information.+Critical section debug information address.WCritical section initialization stack trace. Run dps <address> to dump the stack trace.
Not used.
This stop is generated if the memory containing a critical section was freed
but the critical section has not been deleted using DeleteCriticalSection.
To debug this stop use the following debugger commands:
$ !cs -s -d parameter2 - dump information about this critical section.
$ dps parameter3 - to identify the code path for initializing this critical section.
In most cases the lock verifier detects immediately leaked critical sections
contained in a heap allocation, a DLL range, a virtual memory allocation
or a MapViewOfFile mapped memory range and issues different stops in these cases.
So there are very few cases left for this verifier stop. The lock must be
in a memory range freed by kernel-mode code or freed cross-process by APIs
like VirtualFreeEx. Most typically this stop will  be encountered if a previous stop
(e.g. LOCK_IN_FREED_HEAP or LOCK_IN_UNLOADED_DLL) was continued by
hitting `g' in the debugger console.
Corrupted critical section.GCritical section address. Run !cs -s <address> to get more information.;Invalid debug information address of this critical section.:Address of the debug information found in the active list.FInitialization stack trace. Run dps <address> to dump the stack trace.
This stop is generated if the DebugInfo field of the critical section is
pointing freed memory. Usually another valid DebugInfo structure is
found in the active critical section list. Without corruption the two
pointers should be identical. To debug this stop use the following debugger commands:
$ !cs -s -d parameter3 - dump information about this critical section
based on the current contents of the debug info structure
found in the active list (this structure is rarely corrupted so usually
this information is trustworthy).
$ !cs -s parameter1 - dump information about this critical section based
on the current contents of the critical section structure (the structure
is corrupted already so sometimes this information is NOT trustworthy).
$ dps parameter4 - to identify the code path for initializing this critical section.
Dump the critical section at address parameter1 and look for the corruption
pattern. With good symbols for ntdll.dl you can use the following commands:
$ dt ntdll!_RTL_CRITICAL_SECTION LOCK_ADDRESS
$ dt ntdll!_RTL_CRITICAL_SECTION_DEBUG DEBUG_ADDRESS
&Invalid critical section owner thread.GCritical section address. Run !cs -s <address> to get more information.
Owning thread.
Expected owning thread.$Critical section debug info address.
This stop is generated if the owner thread ID is invalid in the current
context. For example, the critical section is being released by a thread 
other than the one that acquired it. To debug this stop:
$ !cs -s parameter1 - dump information about this critical section.
$ ln parameter1 - to show symbols near the address of the critical section.
This should help identify the critical section.
)Invalid critical section recursion count.GCritical section address. Run !cs -s <address> to get more information.
Recursion count.
Expected recursion count.$Critical section debug info address.
This stop is generated if the recursion count field of the critical section
structure is invalid in the current context. To debug this stop:
$ !cs -s parameter1 - dump information about this critical section.
$ ln parameter1 - to show symbols near the address of the critical section.
This should help identify the critical section.
2Deleting critical section with invalid lock count.GCritical section address. Run !cs -s <address> to get more information.
Lock count.
Expected lock count.
Owning thread.
This stop is generated if a critical section is owned by a thread if it is deleted
or if the critical section is uninitialized. To debug this stop:
$ !cs -s parameter1 - dump information about this critical section.
If the owning thread is 0 the critical section has not been initialized.
$ ln parameter1 - to show symbols near the address of the critical section.
This should help identify the critical section.
,Critical section over-released or corrupted.GCritical section address. Run !cs -s <address> to get more information.
Lock count.
Expected lock count.$Critical section debug info address.
This stop is generated if a critical section is released more times than the
current thread acquired it. To debug this stop:
$ !cs -s parameter1 - dump information about this critical section.
$ !cs -s -d parameter4 - dump information about this critical section.
$ ln parameter1 - to show symbols near the address of the critical section.
This should help identify the critical section.
!Critical section not initialized.GCritical section address. Run !cs -s <address> to get more information.$Critical section debug info address.
Not used.
Not used.
This stop is generated if a critical section is used without being
initialized or after it has been deleted. To debug this stop:
$ ln parameter1 - to show symbols near the address of the critical section.
This should help identify the critical section.
(Critical section is already initialized.GCritical section address. Run !cs -s <address> to get more information.$Critical section debug info address.AFirst initialization stack trace. Use dps to dump it if non-NULL.
Not used.
This stop is generated if a critical section is reinitialized by the
current thread. To debug this stop:
$ !cs -s parameter1 or !cs -s -d parameter2 - dump information about this critical section.
$ ln parameter1 - to show symbols near the address of the critical section.
This might help identify the critical section if this is a global variable.
$ dps parameter3 - to identify the code path for the first initialization of this
critical section.
$ kb - to display the current stack trace, that is reinitializing this critical section.
=Freeing virtual memory containing an active critical section.GCritical section address. Run !cs -s <address> to get more information.LCritical section initialization stack trace. Use dps to dump it if non-NULL.
Memory block address.
Memory block size.
This stop is generated if the current thread is calling VirtualFree on a
memory block that contains an active critical section. The application should call
DeleteCriticalSection on this critical section before if frees this memory.
$ kb - to display the current stack trace, that is calling VirtualFree.
The probable culprit is the DLL that calls VirtualFree.
$ !cs -s parameter1 - dump information about this critical section.
$ dps parameter2 - to identify the code path for the initialization
of this critical section.
>Unmapping memory region containing an active critical section.GCritical section address. Run !cs -s <address> to get more information.LCritical section initialization stack trace. Use dps to dump it if non-NULL.
Memory block address.
Memory block size.
This stop is generated if the current thread is calling UnmapViewOfFile
on a memory block that contains an active critical section. The application
should call DeleteCriticalSection on this critical section before if unmaps this memory.
$ kb - to display the current stack trace, that is calling UnmapViewOfFile .
The probable culprit is the DLL that calls UnmapViewOfFile.
$ !cs -s parameter1 - dump information about this critical section.
$ dps parameter2 - to identify the code path for the initialization of
this critical section.
2Current thread does not own any critical sections.GCritical section address. Run !cs -s <address> to get more information.4Number of critical sections owned by current thread.
Not used
Not used
This stop is generated if the current thread is calling LeaveCriticalSection but,
according to the internal verifier bookkeeping, it doesn't own any critical section.
If parameter2 is zero, probably this is a bug in the current thread.
It either tries to leave a critical section that it didn't enter, or maybe
it is calling LeaveCriticalSection more times than it called EnterCriticalSection
for the same critical section.
If parameter2 is not zero (it is a negative integer number) the internal
verifier data structures are probably corrupted.
6Using critical section that is private to another DLL.GCritical section address. Run !cs -s <address> to get more information.
Not used.
Not used
Not used
This stop is generated if the current thread tries to use a private lock that lives
inside another DLL. For example a.dll tries to enter a critical section
defined inside ntdll.dll. Private locks cannot be used across DLLs.
 The SRW Lock is not initialized.
SRW Lock
Not used
Not used
Not used
This stop is generated if a thread is trying to use the SRW lock
(Param1) that is not initialized.
$ kb - to get the current stack trace. This is where the SRW lock is being used.
The SRW lock should be initialized using InitializeSRWLock before it can be used.
$The SRW Lock is already initialized.
SRW Lock
5ThreadId of the thread that initialized the SRW lock.gAddress of the initialization stack trace. Use dps <address> to see where the SRW lock was initialized.
Not used
This stop is generated if the SRW lock (Param1) is being re-initialized.
If the SRW lock is being actively used by other threads, re-initializing the
lock will result in unpredictable behavior by the application (may stop responding
or crash). The initialization stack trace may show an acquire if the SRW lock
was statically initialized.
$ kb - to get the current stack trace. This is where the SRW lock is being
re-initialized. 
$ dps Param3 - to get the SRW lock initialization stack trace. This stack trace 
may show an acquire if the lock was statically initialized.
+Mismatched Acquire-Release on the SRW lock.
SRW Lock2ThreadId of the thread that acquired the SRW lock.]Address of the acquire stack trace. Use dps <address> to see where the SRW lock was acquired.
Not used
This stop is generated if the SRW lock (Param1) is being released with
a wrong release API.
If the SRW lock was acquired for shared access and is being released using the
exclusive release API or the SRW lock was acquired for exclusive access and is
being release using the shared release API.
This can result in unpredictable behavior by the application such as crashing or
not responding to input.
$ kb - to get the current stack trace. This is where the SRW lock is being
released using the wrong API. 
$ dps Param3 - to get the SRW lock acquire stack trace.
>The SRW lock is being acquired recursively by the same thread.
SRW LockcAddress of the first acquire stack trace. Use dps <address> to see where the SRW lock was acquired.
Not used
Not used
This stop is generated if the SRW lock (Param1) is being acquired
recursively by the same thread.
This will result in a deadlock and the thread would block indefinitely.
Recursive acquisition of an SRW lock in exclusive mode will cause a deadlock.
Recursive acquisition of an SRW lock in shared mode will cause a deadlock when
there is a thread waiting for exclusive access. Consider the example below:
- Thread A acquires the SRW lock in shared mode
- Thread B tries to acquire the SRW lock in exclusive mode and waits
- Thread A tries to acquire the SRW lock in shared mode recursively. This will
  be successful as long as there is no exclusive waiter (in this case B). Since
  SRW locks do not have writer starvation, thread A waits behind thread B.
  Now, Thread B is waiting for Thread A which is inturn waiting for Thread B
  causing a circular wait and hence a deadlock.
$ kb - to get the current stack trace. This is where the SRW lock is being
acquired recursively. 
$ dps Param2 - to get the stack trace for the first acquire.
@The thread that is exiting or being terminated owns an SRW lock.
SRW Lock;ThreadId of the thread that is exiting or being terminated.]Address of the acquire stack trace. Use dps <address> to see where the SRW lock was acquired.
Not used
This stop is generated if the thread (Param2) that owns the SRW lock (Param1)
is exiting or being terminated.
This will result in an orphaned SRW lock and the threads trying to acquire this
lock would block indefinitely.
$ kb - to get the current stack trace. This is where the thread is exiting or 
is being terminated.
$ dps Param3 - to get the SRW lock acquire stack trace.
<The SRW lock being released was not acquired by this thread.
SRW Lock
Current ThreadId.2ThreadId of the thread that acquired the SRW lock.]Address of the acquire stack trace. Use dps <address> to see where the SRW lock was acquired.
This stop is generated if the SRW lock (Param1) is being released by the
thread (Param2) that didn't acquire the lock.
This represents bad programming practice that is hard to get right and can lead 
to unpredictable behavior by the application.
$ kb - to get the current stack trace. This is where the thread is releasing the 
SRW lock that it didn't acquire.
$ dps Param4 - to get the SRW lock acquire stack trace.
3The memory being freed contains an active SRW lock.
SRW Lock"Address of the memory being freed.2ThreadId of the thread that acquired the SRW lock.]Address of the acquire stack trace. Use dps <address> to see where the SRW lock was acquired.
This stop is generated if the memory address (Param1) being freed contains 
an active SRW lock that is still in use.
This can result in unpredictable behavior by the application such as crashing or
not responding to input.
$ kb - to get the current stack trace. This is where the memory is being freed
that contains an active SRW lock.
$ dps Param4 - to get the SRW lock acquire stack trace.
3The DLL being unloaded contains an active SRW lock.
SRW LockPAddress of the name of the DLL being unloaded. Use du <address> to see the name.2ThreadId of the thread that acquired the SRW lock.]Address of the acquire stack trace. Use dps <address> to see where the SRW lock was acquired.
This stop is generated if the DLL being unloaded (Param2) contains 
an active SRW lock (Param1) that is still in use.
This can result in unpredictable behavior by the application such as crashing or
not responding to input.
$ kb - to get the current stack trace. This is where the DLL is being unloaded
that contains an active SRW lock.
$ du Param2 - to find the name of the DLL that is being unloaded.
$ dps Param4 - to get the SRW lock acquire stack trace.
1Invalid handle exception for current stack trace.
Exception code.)Exception record. Use .exr to display it.'Context record. Use .cxr to display it.
Not used.
This stop is generated if the function on the top of the stack passed an
invalid handle to system routines. Usually a simple kb command will reveal
what is the value of the handle passed (must be one of the parameters -
usually the first one). If the value is null then this is clearly wrong.
If the value looks ok you need to use !htrace debugger extension to get a
history of operations pertaining to this handle value. In most cases it
must be that the handle value is used after being closed.
/Invalid TLS index used for current stack trace.
Invalid TLS index.!Expected lower part of the index.
Not used.
Not used.
This stop is generated if the function on the top of the stack passed an invalid TLS
index to TLS system routines. Usually a simple kb command will reveal what is wrong.
The typical bug here is to assume a certain value for a TLS index instead of
calling TlsAlloc. This can happen either by thinking that you always get
value N therefore there is no need to call TlsAlloc or more frequently
due to an uninitialized variable.
3Invalid parameters for WaitForMultipleObjects call.!Address of object handles vector.
Number of handles.
Not used.
Not used.
This stop is generated if the function on the top of the stack called
WaitForMultipleObjects with NULL as the address of the array of handles
to wait for or with zero as the number of handles. A simple kb command
will reveal the function calling this API incorrectly.
=NULL handle passed as parameter. A valid handle must be used.
Not used.
Not used.
Not used.
Not used.
hThis stop is generated if the function on the top of the stack passed a
NULL handle to system routines.
&Waiting on a thread handle in DllMain.
Thread handle.
Not used.
Not used.
Not used.
This stop is generated if the current thread is currently running code inside
the DllMain function of one of the DLLs loaded in the current process and
it calls WaitForSingleObject or WaitForMultipleObjects to wait on a thread handle
in the same process. This would most likely lead to a deadlock because the thread
handle will not get signaled unless that second thread is exiting. When the second
thread will call ExitThread it will try to acquire the DLL loader lock then call
DllMain (DLL_THREAD_DETACH) for all DLLs in the current process. But the loader lock
is owned by the first thread (the one that is waiting on the thread handle) so the
two threads will deadlock.
!Incorrect object type for handle.
Handle value.&Object type name. Use du to display it/Expected object type name. Use du to display it
Not used.
This stop is generated if the current thread is calling an API with a handle to
an object with an incorrect object type. E.g. calling SetEvent with a semaphore
handle as parameter will generate this stop. To debug this stop:
$ kb - to display the current stack trace. The culprit is probably the DLL
that is calling into verifier.dll;
$ du parameter2 - to display the actual type of the handle. The handle value
is parameter1. In the example above, this will display: Semaphore.
$ du parameter3 - to display the object type expected by the API. In the example above,
this name will be: Event.
$ !htrace parameter1 might be helpful because it will display the stack
trace for the recent open/close operations on this handle.
:Unloading DLL that allocated TLS index that was not freed.
TLS index2Address of the code that allocated this TLS index.$DLL name address. Use du to dump it.
DLL base address.
This stop is generated if a DLL that allocated a TLS index is being unloaded
before freeing that TLS index. To debug this stop:
$ du parameter3 - display the name of the culprit DLL;
$ .reload xxx.dll=parameter4 - reload symbols for the culprit DLL (if needed).
xxx.dll is the name of the DLL displayed in the above step;
$ u parameter2 - disassemble the code that allocated the TLS. This should
point to the function that allocated the TLS but forgot to free it
before the DLL was unloaded.
!Corrupted verifier TLS structure.
TEB address.
Expected TEB address.
Thread ID.
Expected thread ID.
This stop is generated if the internal verifier structures used to
store the state of TLS slots for thread are corrupted. Very likely this is
due to some random corruption in the process.
Using an invalid TLS index.
TLS index
Not Used.
Not Used.
Not Used.
This stop is generated if an invalid TLS index is used. In most cases, it's because
code is still using this index when TlsFree is called.
Here is an example for the threadpool thread.
T1: Dll loads and TlsAlloc
T1: Queue callback
T1: Skipped waited/cancelled callback
T1: TlsFree
T2: Callback runs and calls TlsSetValue
T1: Dll unloads
@Freeing virtual memory block with invalid size or start address.
Allocation base address.
Memory region size.
Not used.
Not used.
This stop is generated if the app verifier detects a VirtualFree or a DLL unload
with an invalid start address or size of the memory allocation.
In the case of DLL unload this probably means a memory corruption inside the loaded DLL list.
To debug this stop look at the current stack trace and the memory address and size
that is about to be freed and try to determine why they are invalid.
Incorrect virtual alloc call.#Pointer to allocation base address.
Pointer to memory region size.
Not used
Not used
This stop is generated if the app verifier detects a VirtualAlloc call with an invalid
start address or size of the memory allocation. To debug this stop look at the current
stack trace (kb) and the memory address and size that is about to be allocated and try
to determine why they are invalid.
Incorrect map view call. Pointer to mapping base address.
Pointer to view size.
Not used.
Not used.
This stop is generated if the app verifier detects a MapViewOfFile call
with an invalid base address or size of the mapping. To debug this stop
look at the current stack trace (kb) and the memory address and size that
is about to be mapped and try to determine why they are invalid.
Probing invalid address.
Start address.
Memory block size.
Invalid address.
Not used.
This stop is generated if the app verifier detects an IsBadXXXPtr call with an
invalid address (e.g. a kernel-mode address, instead of a normal user-mode address)
for the memory buffer to be probed. To debug this stop look at the current stack
trace (kb) and try to determine why the caller of the IsBadXXXPtr function ended
up with an invalid address. Many times, the address is plain bogus, e.g.
an uninitialized pointer.
MSDN library lists a few reasons why applications should not use the IsBadXXXPtr APIs:
In a preemptive multitasking environment, it is possible for some other thread to change
the process's access to the memory being tested.
Dereferencing potentially invalid pointers can disable stack expansion in other threads.
A thread exhausting its stack, when stack expansion has been disabled, results in
the immediate termination of the parent process, with no pop-up error window or
diagnostic information.
Threads in a process are expected to cooperate in such a way that one will not free
memory that the other needs. Use of this function does not negate the need to do this.
If this is not done, the application may fail in an unpredictable manner.
Because of all these reasons, we recommend to never use these APIs.
Probing free memory.
Start address.
Memory block size.
Address of free memory page.
Not used.
This stop is generated if the app verifier detects an IsBadXXXPtr call for a
memory allocation that is free. This is very bad because it is possible that,
in some other cases, this memory was already reused for some other allocation.
Since the current code path (kb) doesn't own that memory, it could end up
corrupting someone else's memory, with disastrous effects.
To debug this stop look at the current stack trace (kb) and try to determine
why the caller of the IsBadXXXPtr function ended up probing free memory.
The address could be plain bogus (e.g. uninitialized pointer) or maybe
already freed memory. If the memory was already freed by one of the
VirtualFree or UnmapViewOfFile APIs, `!avrf -vs -a parameter3' will search
for a log of stack traces of the code paths that allocated/freed that address
and display these stack traces if they are available. This might show the stack
trace that freed up this memory. More often, the memory is an already freed
heap allocation. To check for that possibility, `!avrf -hp -a parameter3' will
search for a log of stack traces of the code paths that allocated/freed that
address from/to the heap and display these stack traces if they are available.
MSDN library lists a few reasons why applications should not use the IsBadXXXPtr APIs:
In a preemptive multitasking environment, it is possible for some other thread
to change the process's access to the memory being tested.
Dereferencing potentially invalid pointers can disable stack expansion in
other threads. A thread exhausting its stack, when stack expansion has been
disabled, results in the immediate termination of the parent process,
with no pop-up error window or diagnostic information.
Threads in a process are expected to cooperate in such a way that one
will not free memory that the other needs. Use of this function does
not negate the need to do this. If this is not done, the application
may fail in an unpredictable manner.
Because of all these reasons, we recommend to never use these APIs.
Probing a guard page.
Start address.
Memory block size.
Address of guard page.
Not used.
This stop is generated if the app verifier detects an IsBadXXXPtr call for a
memory allocation that contains at least one GUARD_PAGE. This is very bad
because it is very possible that this GUARD_PAGE is the end of the current
stack of a thread. As documented in the MSDN library: Dereferencing potentially
invalid pointers can disable stack expansion in other threads. A thread exhausting
its stack, when stack expansion has been disabled, results in the immediate
termination of the parent process, with no pop-up error window or diagnostic
information. To debug this stop look at the current stack trace (kb) and try
to determine why the caller of the IsBadXXXPtr function ended up probing a GUARD_PAGE.
MSDN library lists a few reasons why applications should not use the IsBadXXXPtr APIs:
In a preemptive multitasking environment, it is possible for some other thread
to change the process's access to the memory being tested.
Dereferencing potentially invalid pointers can disable stack expansion in
other threads. A thread exhausting its stack, when stack expansion has been
disabled, results in the immediate termination of the parent process,
with no pop-up error window or diagnostic information.
Threads in a process are expected to cooperate in such a way that one
will not free memory that the other needs. Use of this function does
not negate the need to do this. If this is not done, the application
may fail in an unpredictable manner.
Because of all these reasons, we recommend to never use these APIs.
Probing NULL address.
Not used.
Not used.
Not used.
Not used.
This stop is generated if the app verifier detects an IsBadXXXPtr call with a
NULL address. To debug this stop look at the current stack trace (kb) and
try to determine why the caller of the IsBadXXXPtr function ended up with
the NULL address. This is typically the sign of someone not checking the
return value of one of the memory allocation functions. For example the code
below is incorrect:
int main (void)
PVOID p;
p = malloc (1024);
Use (p);
return 0;
void Use (PVOID p)
if (IsBadReadPtr (p)) {
return;
// p is safe to be used here.
This code should be re-written as this:
int main (void)
PVOID p;
p = malloc (1024);
if (NULL == p)) {
return -1;
Use (p);
return 0;
void Use (PVOID p)
// p is safe to be used here.
MSDN library lists a few reasons why applications should not use the IsBadXXXPtr APIs:
In a preemptive multitasking environment, it is possible for some other thread
to change the process's access to the memory being tested.
Dereferencing potentially invalid pointers can disable stack expansion in
other threads. A thread exhausting its stack, when stack expansion has been
disabled, results in the immediate termination of the parent process,
with no pop-up error window or diagnostic information.
Threads in a process are expected to cooperate in such a way that one
will not free memory that the other needs. Use of this function does
not negate the need to do this. If this is not done, the application
may fail in an unpredictable manner.
Because of all these reasons, we recommend to never use these APIs.
8Probing memory block with invalid start address or size.
Start address.
Memory block size.
Not used.
Not used.
This stop is generated if the app verifier detects an IsBadXXXPtr call with an
invalid start address (e.g. a kernel-mode address, instead of a normal user-mode
address) or invalid size for the memory buffer to be probed. To debug this stop
look at the current stack trace (kb) and try to determine why the caller of
the IsBadXXXPtr function ended up with an invalid address or size.
Many times, the address or size are plain bogus, e.g. an uninitialized variables.
MSDN library lists a few reasons why applications should not use the IsBadXXXPtr APIs:
In a preemptive multitasking environment, it is possible for some other thread
to change the process's access to the memory being tested.
Dereferencing potentially invalid pointers can disable stack expansion in
other threads. A thread exhausting its stack, when stack expansion has been
disabled, results in the immediate termination of the parent process,
with no pop-up error window or diagnostic information.
Threads in a process are expected to cooperate in such a way that one
will not free memory that the other needs. Use of this function does
not negate the need to do this. If this is not done, the application
may fail in an unpredictable manner.
Because of all these reasons, we recommend to never use these APIs.
1Unloading DLL with invalid size or start address.
DLL memory base address.
DLL memory range size.$DLL name address. Use du to dump it.
Not used.
This stop is generated if the app verifier detects a DLL unload with an invalid
start address or size of the DLL memory range. This probably means a memory
corruption inside the internal ntdll.dll loaded DLL list.
AFreeing memory block inside current thread's stack address range.
Allocation base address.
Memory region size.
Stack low limit address.
Stack high limit address.
This stop is generated if the app verifier detects a VirtualFree for a block of
memory that is actually part of the current thread's stack (!).
To debug this stop look at the current stack trace (kb) and try to understand
why the function that called VirtualFree thought that the memory block was
dynamically allocated or mapped but that was actually memory allocated from the stack.
7Incorrect FreeType parameter for VirtualFree operation.(Incorrect value used by the application.
Expected correct value 1.
Expected correct value 2.
Not used.
This stop is generated if the app verifier detects a VirtualFree with an
incorrect value for the FreeType parameter. The only two acceptable values for
this parameter are MEM_DECOMMIT and MEM_RELEASE. If VirtualFree is called
with any other value except these two, VirtualFree will fail to free the memory.
To debug this stop look at the current stack trace (kb): the caller of VirtualFree
is probably the culprit.
9Trying to free virtual memory block that is already free.
Memory block address.
Not used.
Not used.
Not used.
This stop is generated if the app verifier detects a VirtualFree for an address
that is already free. To debug this stop look at the current stack trace (kb)
and try to determine why the memory is already free but the application is
trying to free it again. `!avrf -vs -a parameter1' will search for a log of
stack traces of the code paths that allocated/freed that address and display
these stack traces if they are available. This might show the stack trace that
freed up this memory.
AIncorrect Size parameter for VirtualFree (MEM_RELEASE) operation.'Incorrect size used by the application.
Expected correct size (0).
Not used.
Not used.
This stop is generated if the app verifier detects a VirtualFree (MEM_RELEASE)
with a non-zero value for the dwSize parameter. When using MEM_RELEASE ,
the only acceptable value for this parameter is 0. If VirtualFree is called
with any other value except 0, VirtualFree will fail to free the memory.
To debug this stop look at the current stack trace (kb): the caller of
VirtualFree is probably the culprit.
7Unexpected exception raised in DLL entry point routine.
DLL name (use du to dump it).)Exception record. Use .exr to display it.'Context record. Use .cxr to display it.
Verifier dll descriptor
This stop is generated if a DLL's entry point (DllMain) function is raising
an exception. One example why this is bad is: if DllMain(DLL_PROCESS_ATTACH) is
raising an exception, the Windows DLL loader will:
- Catch and hide the exception;
- Unload the DLL without calling its DllMain(DLL_PROCESS_DETACH).
So in many cases the DLL allocated some resources already, then it raised the
exception, and it will not have a chance to release these resources on
DllMain (DLL_PROCESS_DETACH).
To debug this stop:
$ du parameter1 - to display the DLL name;
$ .exr parameter2 - to display the exception information;
$ .cxr parameter3 followed by kb - to display the exception context information
and the stack trace for the time when the exception was raised;
$ parameter4 is the address of an internal verifier structure and doesn't
have any significance for most of the verifier users.
/Unexpected exception raised in thread function.
Exception code.)Exception record. Use .exr to display it.'Context record. Use .cxr to display it.
Not used.
This stop is generated if a thread function is raising an exception. This
is bad because the whole process will be killed.
To debug this stop:
$ parameter1 might be significant for the type of exception. E.g. an
exception code C0000005 means Access Violation;
$ .exr parameter2 - to display the exception information;
$ .cxr parameter3 followed by kb - to display the exception context information;
1Unexpected exception raised while probing memory.
Exception code.
)Exception record. Use .exr to display it.'Context record. Use .cxr to display it.
Not used
This stop is generated if we get an exception during an IsBadXXXPtr call. This means
that the memory buffer we are probing doesn't actually have the protection
assumed by the caller, or that the memory was freed already, etc. See the
discussion above about other stop code (PROBE_INVALID_ADDRESS,
PROBE_FREE_MEM, PROBE_GUARD_PAGE, PROBE_NULL, PROBE_INVALID_START_OR_SIZE) for
more examples of why using the IsBadXXXPtr APIs is not recommended.
To debug this stop:
$ parameter1 will typically be C0000005 and that means Access Violation;
$ .exr parameter2 - to display the exception information;
$ .cxr parameter3 followed by kb - to display the exception context information
and stack trace at the time when the exception was raised;
Trying to reset NULL address.
Not used.
Not used.
Not used.
Not used.
This stop is generated if the app verifier detects a VirtualFree (MEM_RESET) call
with a NULL first parameter.  MEM_RESET should be used only for already
allocated memory, so NULL is not a valid first parameter in this case.
FFreeing heap memory block inside current thread's stack address range.
Allocation base address.
Memory region size.
Stack low limit address.
Stack high limit address.
This stop is generated if the app verifier detects a HeapFree, for a block of
memory that is actually part of the current thread's stack (!).
To debug this stop look at the current stack trace (kb) and try to understand
why the function that called HeapFree thought that the memory block was dynamically
allocated or mapped but that was actually memory allocated from the stack.
DUnmapping memory region inside current thread's stack address range.
Allocation base address.
Memory region size.
Stack low limit address.
Stack high limit address.
This stop is generated if the app verifier detects an UnmapViewOfFile, for a block of
memory that is actually part of the current thread's stack (!).
To debug this stop look at the current stack trace (kb) and try to understand
why the function that called UnmapViewOfFile thought that the memory block was dynamically
allocated or mapped but that was actually memory allocated from the stack.
Incorrect RTL_RESOURCE address.
Address.
Not used.
Not used.
Not used.
This stop is generated if the application is trying to use NULL or some other
incorrect address (e.g. a kernel-mode address) as the address of a valid
object. RtlInitializeResource (NULL) is an incorrect API call that will trigger
this kind of verifier stop.
param1 is the incorrect address used and the culprit is on the stack
trace (display it with kb).
!Invalid critical section address.
Address.
Not used.
Not used.
Not used.
This stop is generated if the application is trying to use NULL or some other
incorrect address (e.g. a kernel-mode address) as the address of a valid
object. EnterCriticalSection(NULL) is an incorrect API call that will trigger
this kind of verifier stop.
param1 is the incorrect address used and the culprit is on the stack
trace (display it with kb).
1Attempt to execute code in non-executable memory.
Address being accessed.
Code performing invalid access.)Exception record. Use .exr to display it.'Context record. Use .cxr to display it.
This stop is generated if the application is trying to run code from
an address that is non-executable or free.
To debug this stop:
$ u parameter2 - to unassemble the culprit code
$ .exr parameter3 - to display the exception information;
$ .cxr parameter4 followed by kb - to display the exception context information
and the stack trace for the time when the exception was raised.
=Unexpected exception raised while initializing output buffer.
Buffer start address.
Buffer size.)Exception record. Use .exr to display it.'Context record. Use .cxr to display it.
This stop is generated if we get an exception while initializing a buffer specified
as output parameter for a Win32 or CRT API. This typically means that the specified
output buffer size is incorrect.
To debug this stop:
$ .exr parameter3 - to display the exception information;
$ .cxr parameter4 followed by kb - to display the exception context information
and stack trace at the time when the exception was raised.
9Unexpected exception when trying to find heap block size.&Address of the heap block being freed.
Heap handle.)Exception record. Use .exr to display it.'Context record. Use .cxr to display it.
This stop is generated if we get an exception while calling HeapSize for a heap block
that is being freed. This typically means that the specified heap block address is
incorrect or the heap is corrupted.
To debug this stop:
$ .exr parameter3 - to display the exception record;
$ .cxr parameter4 followed by kb - to display the exception context information
and stack trace at the time when the exception was raised.
0Freeing memory block with invalid start address.$Address of memory block being freed.&Expected correct memory block address.
Not used.
Not used.
This stop is generated if the program calls VirtualFree (MEM_RELEASE)
with an lpAddress parameter that is not the base address returned by
the VirtualAlloc or VirtualAllocEx function when the region of pages
was reserved;
To debug this stop:
$ kb - to display the current stack trace, that is calling VirtualFree.
The probable culprit is the DLL that calls VirtualFree.
2Unmapping memory block with invalid start address.'Address of memory block being unmapped.&Expected correct memory block address.
Not used.
Not used.
This stop is generated if the program calls UnmapViewOfFile with
an lpBaseAddress parameter that is not identical to the value returned
by a previous call to the MapViewOfFile or MapViewOfFileEx function.
To debug this stop:
$ kb - to display the current stack trace, that is calling UnmapViewOfFile.
The probable culprit is the DLL that calls UnmapViewOfFile.
<unexpected exception raised in threadpool callback function.
Exception code(Exception record. Use .exr to display it&Context record. Use .cxr to display it
Not used
This stop is generated if a callback function in the threadpool thread is raising an exception.
To debug this stop:
$ parameter1 might be significant for the type of exception. E.g. an
exception code C0000005 means Access Violation.
$ .exr parameter2 - to display the exception information.
$ .cxr parameter3 followed by kb - to display the exception context information.
code in non-executable memory
Address being accessed
Code performing invalid access)Exception record. Use .exr to display it.'Context record. Use .cxr to display it.
This stop is generated if the application is trying to run code from
an address that is non-executable or free.
To debug this stop:
$ u parameter2 - to unassemble the culprit code
$ .exr parameter3 - to display the exception information
$ .cxr parameter4 followed by kb - to display the exception context information
and the stack trace for the time when the exception was raised.
Creating executable heap.
Not used.
Not used.
Not used.
Not used.
gThis stop is generated if the application is creating an executable heap.
This can be a security risk.
Allocating executable memory.$Page protection specified by caller.
Not used.
Not used.
Not used.
hThis stop is generated if the application is allocating executable memory.
This can be a security risk.
@Attempt to execute code in non-executable memory (first chance).
Address being accessed.
Code performing invalid access.)Exception record. Use .exr to display it.'Context record. Use .cxr to display it.
This stop is generated if the application is trying to run code from
an address that is non-executable or free.
To debug this stop:
$ u parameter2 - to unassemble the culprit code
$ .exr parameter3 - to display the exception information;
$ .cxr parameter4 followed by kb - to display the exception context information
and the stack trace for the time when the exception was raised.
8The priority of this threadpool thread has been changed.6Callback function where the priority has been changed.
Context.=Threadpool Object allocation stack trace, use dps to dump it.
Current Priority.^threadpool thread (%x) having executed Callback (%p) has an altered thread priority (%i -> %i)ZThis stop is generated if the thread priority is changed when it's returned to threadpool.
8The affinity of this threadpool thread has been changed.6Callback function where the affinity has been changed.
Context.=Threadpool Object allocation stack trace, use dps to dump it.
Current affinity.cthreadpool thread (%x) having executed Callback (%p) has an altered thread affinity mask (%p -> %p)ZThis stop is generated if the thread affinity is changed when it's returned to threadpool.
2Unprocessed msg in the msg pool of current thread.*Callback function that posted the message.
Context.=Threadpool Object allocation stack trace, use dps to dump it.
`Threadpool thread id. Please use !avrf -tp <threadid> to see the messages posted to this thread.\threadpool thread (%x) having executed Callback (%p) has outstanding window message (%x: %x)
This stop is generated if any message left as unprocessed when this threadpool thread
is returned to the pool. It's dangerous since it will be processed in a totally different
context. Please use Please use !avrf -tp <Param4> to see the messages posted to this thread.
/Unclosed window belonged to the current thread.
Callback function.
Context.=Threadpool Object allocation stack trace, use dps to dump it.
Threadpool thread id.ithreadpool thread (%x) having executed Callback (%p) has valid hwnd (%x: %s) which could receive messageshThis stop is generated if any window is kept alive when this threadpool thread
is returned to the pool.
+ExitThread() called on a threadpool thread.
Callback function.
Context.=Threadpool Object allocation stack trace, use dps to dump it.
Not Used.
This stop is generated if ExitThread is called on a threadpool thread. It's forbidden since 
it will make system unstable. It can cause resource leaks, an AV or the app may stop responding
to input.
KThread is in impersonation state when it's returned to a threadpool thread.4Callback function where the thread was impersonated.
Context.=Threadpool Object allocation stack trace, use dps to dump it.
Not Used.
This stop is generated if call back function change the thread token to impersonate another
user and forgot to reset it before returning it back to the threadpool.
JA function which requires persistent thread is called within the callback.
Callback function.
Context.=Threadpool Object allocation stack trace, use dps to dump it.
Not Used.
Some Microsoft Windows APIs need to be called inside a dedicated or persistent thread.
In the threadpool you should generally avoid using thread local storage and queuing
asynchronous calls that require a persistent thread, such as the RegNotifyChangeKeyValue
function. However, such functions can be queued to a persistent worker thread using
QueueUserWorkItem with the WT_EXECUTEINPERSISTENTTHREAD option. A kb in debugger will
reveal the caller.
%Thread is in dirty transaction state.<Callback function where the transaction context was changed.
Context.=Threadpool Object allocation stack trace, use dps to dump it.
Transaction Handle.
eThis stop is generated if call back function forgot to close or reset the current transaction handle.
?This threadpool state has unbalanced CoInit and CoUnInit calls.<Callback function that left the thread in a dirty com state.
Context.=Threadpool Object allocation stack trace, use dps to dump it.
Balanced Call counts.
RThis stop is generated if call back function calls CoInit and CoUnInit unbalanced.
The parameters for the timer object are inconsistent. Period should be 0 when WT_EXECUTEONLYONCE is specified when creating the timer
Period specified.
Flags specified.
Not Used.
Not Used.
This stop is generated if the period to signal the timer is not zero when the timer is set to signal only once with the WT_EXECUTEONLYONCE flag
KThe loader lock has been held by the threadpool thread within the callback.
Callback function.
Context.=Threadpool Object allocation stack trace, use dps to dump it.
Not Used.
This stop is generated if the loader lock is held within the callback and is not released when the thread is returned to the threadpool.
KThe preferred language is set by the threadpool thread within the callback.
Callback function.
Context.=Threadpool Object allocation stack trace, use dps to dump it.
Not Used.
This stop is generated if the preferred language is set within the callback and is not cleared when the thread is returned to the threadpool.
LThe background priority is set by the threadpool thread within the callback.
Callback function.
Context.=Threadpool Object allocation stack trace, use dps to dump it.
Not Used.
This stop is generated if the background priority is set within the callback and is not disabled when the thread is returned to the threadpool.
0TerminateThread() called on a threadpool thread.
Not Used.
Not Used.
Not Used.
Not Used.
This stop is generated if TerminateThread is called on a threadpool thread. It's forbidden since 
it will make system unstable. It can cause resource leaks, an AV or the app may stop responding
to input.
BThe stack was unwinded when asynchronous I/O operation is pending.*Address of stack variable used in the I/O.
Current stack pointer.$Original thread that issued the I/O.
$Stack Trace when the I/O was issued.
This stop is generated if the application issued an I/O operation
that uses a stack variable and has not waited for the I/O to complete,
thus leading to stack corruption.
To debug this stop:
$ dps parameter4 to display the stack trace when the I/O was issued.
Parameter1 indicates the stack based address and parameter3 the thread
that issued the I/O.
CThe stack was corrupted when asynchronous I/O operation is pending..Address of the stack variable used in the I/O.
Current stack pointer.$Original thread that issued the I/O.$Stack Trace when the I/O was issued.
This stop is generated if the application issued an I/O operation
that uses a stack variable and has not waited for the I/O to complete,
thus leading to stack corruption.
To debug this stop:
$ dps parameter4 to display the stack trace when the I/O was issued.
Parameter1 indicates the stack based address and parameter3 the thread
that issued the I/O.
1Using a freed address in a pending I/O operation.
Address used in the I/O.
Address being freed.$Original thread that issued the I/O.$Stack Trace when the I/O was issued.
This stop is generated if the application issued an I/O operation
and freed the memory used in the I/O before the I/O completed
thus leading to memory corruption etc.
To debug this stop:
$ dps parameter4 to display the stack trace when the I/O was issued.
Parameter1 indicates the address used in the I/O. Parameter2 indicates the address
being freed and parameter3 the thread that issued the I/O.
YAn I/O status block (OVERLAPPED) is reused while associated I/O request is still pending.-Address of the I/O status block (OVERLAPPED).$Original thread that issued the I/O.$Stack Trace when the I/O was issued.
Not Used.
This stop is generated if the application reused an I/O status block (OVERLAPPED) while an I/O request
using that I/O status block (OVERLAPPED) is still pending.
To debug this stop:
$ dps parameter3 to display the stack trace when the original I/O was issued.
Parameter1 indicates the address used in the I/O and parameter2 the thread that issued the I/O.
KUsing an unsupported flag, FILE_ATTRIBUTE_NOT_CONTENT_INDEXED on CreateFile
Return Address.
Not used.
Not used.
Not used.9CreateFile while writing %hs%ws with flags %08x %08x %08x
Old version of the MSDN erroneously documented CreateFile as supporting FILE_ATTRIBUTE_NOT_CONTENT_INDEXED.
If this flag is intended it should be set using other API functions such as SetFileAttributes.
$ ln Parameter1 to find the caller of CreateFile.
A heap allocation was leaked.oAddress of the leaked allocation. Run !heap -p -a <address> to get additional information about the allocation.VAddress to the allocation stack trace. Run dps <address> to view the allocation stack.EAddress of the owner dll name. Run du <address> to read the dll name.
Base of the owner dll. Run .reload <dll_name> = <address> to reload the owner dll. Use 'lm' to get more information about the loaded and unloaded modules.
jThis stop is generated if the owner dll of the allocation was dynamically unloaded while owning resources.
A HANDLE was leaked.}Value of the leaked handle. Run !htrace <handle> to get additional information about the handle if handle tracing is enabled.VAddress to the allocation stack trace. Run dps <address> to view the allocation stack.EAddress of the owner dll name. Run du <address> to read the dll name.
Base of the owner dll. Run .reload <dll_name> = <address> to reload the owner dll. Use 'lm' to get more information about the loaded and unloaded modules.
This stop is generated if the owner dll of the handle was dynamically unloaded while owning
resources.
To debug this stop:
Run !htrace parameter1 to get additional information about the handle.
An HKEY was leaked.
Value of the leaked HKEY.VAddress to the allocation stack trace. Run dps <address> to view the allocation stack.EAddress of the owner dll name. Run du <address> to read the dll name.
Base of the owner dll. Run .reload <dll_name> = <address> to reload the owner dll. Use 'lm' to get more information about the loaded and unloaded modules.
mThis stop is generated if the owner dll of the registry key was dynamically
unloaded while owning resources.
!A virtual reservation was leaked.
Leaked reservation address.VAddress to the allocation stack trace. Run dps <address> to view the allocation stack.EAddress of the owner dll name. Run du <address> to read the dll name.
Base of the owner dll. Run .reload <dll_name> = <address> to reload the owner dll. Use 'lm' to get more information about the loaded and unloaded modules.
tThis stop is generated if the owner dll of the virtual reservation was dynamically
unloaded while owning resources.
A BSTR was leaked.iAddress of the leaked BSTR. Run !heap -p -a <address> to get additional information about the allocation.VAddress to the allocation stack trace. Run dps <address> to view the allocation stack.EAddress of the owner dll name. Run du <address> to read the dll name.
Base of the owner dll. Run .reload <dll_name> = <address> to reload the owner dll. Use 'lm' to get more information about the loaded and unloaded modules.
jThis stop is generated if the owner dll of the SysString was dynamically
unloaded while owning resources.
*A power notification was not unregistered./Address of the power notification registration.XAddress to the registration stack trace. Run dps <address> to view the allocation stack.EAddress of the owner dll name. Run du <address> to read the dll name.
Base of the owner dll. Run .reload <dll_name> = <address> to reload the owner dll. Use 'lm' to get more information about the loaded and unloaded modules.
xThis stop is generated if the dll registered for power notification and was dynamically
unloaded without unregistering.
A COM allocation was leaked.sAddress of the leaked COM allocation. Run !heap -p -a <address> to get additional information about the allocation.VAddress to the allocation stack trace. Run dps <address> to view the allocation stack.EAddress of the owner dll name. Run du <address> to read the dll name.
Base of the owner dll. Run .reload <dll_name> = <address> to reload the owner dll. Use 'lm' to get more information about the loaded and unloaded modules.
oThis stop is generated if the owner dll of the COM allocation was dynamically
unloaded while owning resources.
l45{J(
hBm+}
sRL%d#
}8tj^
4j|d-
:WN|M
Z";1U
enZhc
]uqk_ 
Washington1
Redmond1
Microsoft Corporation1.0,
%Microsoft Windows Production PCA 20110
210902182341Z
220901182341Z0p1
Washington1
Redmo
Microsoft Corporation1
Microsoft Windows0
2y80T
I0G1-0+
$Microsoft Ireland Operations Limited1
229879+4675800
M0K0I
Chttp://www.microsoft.com/pkiops/crl/MicWinProPCA2011_2011-10-19.crl0a
U0S0Q
Ehttp://www.microsoft.com/pkiops/certs/MicWinProPCA2011_2011-10-19.crt0
Et,@8
Zof1G
WaNja
T^r|B
uOi@Y
Washington1
Redmond1
Microsoft Corporation1200
)Microsoft Root Certificate Authority 20100
111019184142Z
261019185142Z0
Washington1
Redmond1
Microsoft Corporation1.0,
%Microsoft Windows Production PCA 20110
O0M0K
Ehttp://crl.microsoft.com/pki/crl/products/MicRooCerAut_2010-06-23.crl0Z
N0L0J
>http://www.microsoft.com/pki/certs/MicRooCerAut_2010-06-23.crt0
TlP0X
R!s4Z
Washington1
Redmond1
Microsoft Corporation1.0,
%Microsoft Windows Production PCA 2011
,uBjYu2fkp3RTg/Ew2Cp/JoUfSAVnlK5AFYfEliqsQFE=0Z
"Microsoft Window
 http://www.microsoft.com/windows0
mt`{JK
%jV}@
C.&O-
20220506222115.577Z0
Washington1
Redmond1
Microsoft Corporation1)0'
 Microsoft Operations Puerto Rico1&0$
Thales TSS ESN:F7A6-E251-150A1%0#
Microsoft Time-Stamp Service
Washington1
Redmond1
Microsoft Corporation1&0$
Microsoft Time-Stamp PCA 20100
220302185119Z
230511185119Z0
Washington1
Redmond1
Microsoft Corporation1)0'
 Microsoft Operations Puerto Rico1&0$
Thales TSS ESN:F7A6-E251-150A1%0#
Microsoft Time-Stamp Service0
_"SV4
`UaO 
[5xo1
X0V0T
Nhttp://www.microsoft.com/pkiops/crl/Microsoft%20Time-Stamp%20PCA%202010(1).crl0l
`0^0\
Phttp://www.microsoft.com/pkiops/certs/Microsoft%20Time-Stamp%20PCA%202010(1).crt0
VM>RV
?yzb<
MqcY z
a8]3v
0u&,X
Washington1
Redmond1
Microsoft Corporation1200
)Microsoft Root Certificate Authority 20100
210930182225Z
300930183225Z0|1
Washington1
Redmond1
Microsoft Corporation1&0$
Microsoft Time-Stamp PCA 20100
q\Q17
&S|9a
!]_0t
U0S0Q
3http://www.microsoft.com/pkiops/Docs/Repository.htm0
O0M0K
Ehttp://crl.microsoft.com/pki/crl/products/MicRooCerAut_2010-06-23.crl0Z
N0L0J
>http://www.microsoft.com/pki/certs/MicRooCerAut_2010-06-23.crt0
>NGdx
fg:SM
xSu$W
as.,k{n?,
J>f;O
!TkjE
Washington1
Redmond1
Microsoft Corporation1)0'
 Microsoft Operations Puerto Rico1&0$
Thales TSS ESN:F7A6-E251-150A1%0#
Microsoft Time-Stamp Service
Washington1
Redmond1
Microsoft Corporation1&0$
Microsoft Time-Stamp PCA 20100
20220506180251Z
20220507180251Z0t0:
1,0*0
1(0&0
Washington1
Redmond1
Microsoft Corporation1&0$
Microsoft Time-Stamp PCA 2010
Washington1
Redmond1
Microsoft Corporation1&0$
Microsoft Time-Stamp PCA 2010
WHRHx
2y9qj
