!This program cannot be run in DOS mode.
7b#y7m[
7Richk[
.text
`.data
.idata
@.didat
.rsrc
@.reloc
USER32.dll
ole32.dll
OLEAUT32.dll
CRYPT32.dll
SHELL32.dll
WININET.dll
urlmon.dll
) i3%
M,UDX
IEFRAME.dll
msIso.dll
Dw=|:s
PROPSYS.dll
Feed Arbitration Lock Event [ Process : 0x%08x ]
Feed Arbitration Unlock Event [ Process : 0x%08x ]
Feed Arbitration Unlock Event [ Write Request : %s ]
Feed Arbitration Validity Mutex [ Write Request : %s ]
Feed Arbitration Shared Memory [ User : %s ]
Feed Arbitration Shared Memory Mutex [ User : %s ]
%s\%s
*.feed-ms
forcesync
msfeedssync.exe
Microsoft_RssPlatform_*
FeedMinInterval
Software\Microsoft\Feeds
M,UD~
%s:%s
RssPlatformCred
Microsoft_RssPlatform_%s
MaxFeedSize
https://ieonlinews.microsoft.com/
<!DOCTYPE
If-Modified-Since
If-None-Match
Accept-Language
Device-Touch-Type
Device-Manufacturer
Device-Model
Current
Content-Type
Last-Modified
/rss/channel/cf:noMoreUpdates
X-UA-Compatible
/rss/channel
/rss/channel/*[local-name() = 'expiration' and namespace-uri() = 'http://www.microsoft.com/schemas/rss/monitoring/2007']
/rss/channel/*[local-name() = 'X-UA-Compatible' and namespace-uri() = 'http://www.microsoft.com/schemas/rss/monitoring/2007']
@Qm6t
RSS Eventing Connection Database Mutex %08x
RSS Eventing Event Event %08x
Feed Eventing Shared Memory %s
Feed Eventing Shared Memory Mutex %s
BackgroundSync
DefaultInterval
MaxItemCount
feedplat:
feedplat
u\m%C
http://www.w3.org/2005/Atom
http://purl.org/rss/1.0/modules/syndication/
http://www.microsoft.com/schemas/rss/monitoring/2007
HtmlEscape
<BASE HREF="
<STYLE>
}</STYLE>
mon:descriptionStyles
version="1.0" encoding="UTF-8"
title
alternate
entry
entry-content
content
entry-summary
summary
updated
published
vcard
author
email
bookmark
atom:link
category
scheme
hourly
daily
weekly
monthly
yearly
sy:updatePeriod
sy:updateFrequency
mon:expiration
endtime
IE=%u
charset
mon:X-UA-Compatible
binary/octet-stream
text/html
Set-Cookie
IE 11.0
Windows-RSS-Platform/%s (%s; Windows NT %d.%d)
User-Agent
Cookie
Current Time: 
Save Next To Sync: 
Next Download Time: 
Last Run Time: 
MinScheduleInterval
Next Scheduled Time: 
Modified Feed: 
Next To Sync Feed: 
Next To Sync Time: 
Modified Time: 
guidFeed: 
ftLastDownloadTime: 
Compare Time: 
Save Last Run Time: 
DownloadThreadCount
System_Feed_Scheduler_Mutex
msfeeds.txt
**** Task Info ******
**** Schedule Cache ******
>>> entry %d >>>
guidFeed: %s
APIPath: %s
fss: %u
uiInterval: %u
uiTTL: %u
ftLastDownloadTime: %d/%d/%d %d:%d:%d:%d
uiLastErrorInterval: %u
fDownloaded: %u
<<<<<<
SyncStatus
Feeds Schedules Rebuild Required
fDownloaded
uiInterval
ftLastDownloadTime
uiLastErrorInterval
SyncSetting
uiTTL
Schedule
FeedDataCache
item[string(.)='%s']
LastRunTime
NextToSync
Feeds Store Mutex %s
Local\Feeds Store Mutex LoRIE
BitsJobs
BitsQueue
item[@id='%d' and string(.)='%s']
ItemCounts
Count
UnreadCount
BackgroundTaskScheduler
description
image/url
language
copyright
skipDays
skipHours
lastBuildDate
pubDate
comments
atom:updated
length
EnclosureLocalFilename
EnclosureDownloadUrl
EnclosureDownloadMimeType
MaxItemCharacterCount
cf:treatAs
enclosure
ItemData
rss/channel
http://www.microsoft.com/schemas/rss/core/2005/internal
cfi:id
cfi:effectiveId
false
cfi:read
cfi:downloadurl
cfi:lastdownloadtime
cfi:path
Not Downloaded
cfi:downloadstatus
In Progress
Downloaded
Error
cfi:lastdownloaderror
Failed
Invalid Feed Format
Normalization Failed
Persistance Failed
Download Blocked
Canceled
Unsupported Auth
Background Download Disabled
Not Exist
Unsupported MSXML
Unsupported DTD
Size Limit Exceeded
Access Denied
Auth Failed
Auth Denied
ItemData/item
Item Data
Local\MsFeeds_IEORC_d8863854-886e-4a8e-b2e5-e580ab17661c
Exception
ReturnNt
ReturnHr
LogNt
LogHr
FailFast
%hs(%u)\%hs!%p: 
%hs!%p: 
(caller: %p) 
%hs(%d) tid(%x) %08X %ws
Msg:[%ws] 
CallContext:[%hs] 
[%hs(%hs)]
[%hs]
kernelbase.dll
RaiseFailFastException
onecore\internal\sdk\inc\wil\opensource\wil\resource.h
WilError_03
ntdll.dll
RtlDllShutdownInProgress
RtlDisownModuleHeapAllocation
WilFailureNotifyWatchers
RtlAreLongPathsEnabled
\UNC\
\\?\UNC\
::$DATA
{00000000-0000-0000-0000-000000000000}
\\?\Volume
Local\SM0:%lu:%lu:%hs
{5588ACFD-6436-411B-A5CE-666AE6A92D3D}
{5588ACFD-6436-411B-A5CE-666AE6A92D3D}\WebSlices
.feed-ms
FeedsStore.feedsdb-ms
Feeds Cache
~t.d:c"q?m*s/f<l>g|p
MIME\Database\Content Type\
MIME\Database\Content Type\%s
Extension
shortcut icon
about:blank
entry-content
entry-title
property
feedurl
TITLE
hslice
WS not installed
WS not running
WS disabled
WS scopes not configured
WS PKEYs not registered
%ProgramFiles%\Internet Explorer\ie9props.propdesc
CurrentVersion
Software\Microsoft\Windows Search
WSearch
file:///%s
SystemIndex
Microsoft.IE.TargetUrl
Microsoft.IE.TargetUrlHostName
Microsoft.IE.TargetUrlPath
Microsoft.IE.VisitCount
Microsoft.IE.SelectionCount
Microsoft.IE.Title
Microsoft.IE.FeedItemLocalId
ierss://
%04lu/%02lu/%02lu %02lu:%02lu:%02lu
(System.EndDate < '%s')
%s{%s}/%s?0%ld
%s{%s}/%s
%s{%s}/
?0%ld
iehistory://
file:%s
http://
https://
file:
ftp://
System.Link.TargetUrlHostName
System.Link.TargetUrlPath
System.Link.TargetUrl
System.History.TargetUrlHostName
System.Link.TargetParsingPath
System.Title
System.History.VisitCount
System.History.SelectionCount
System.Link.DateVisited
System.Search.Rank
System.RecordedTV.ProgramDescription
System.ItemPathDisplay
System.ItemUrl
System.Media.UserWebUrl
System.OriginalFileName
System.Contact.WebPage
System.AcquisitionID
System.RecordedTV.ChannelNumber
System.ContentStatus
System.SourceItem
System.Category
System.ContentType
System.ItemNameDisplay
System.Subject
System.ItemFolderPathDisplay
System.FileName
System.Author
System.ItemFolderNameDisplay
System.Document.WordCount
System.Document.PageCount
System.Link.FeedItemLocalId
System.DateModified
System.DateCreated
Application=Windows
SELECT TOP %u 
SELECT 
 FROM SystemIndex..SCOPE() 
(CONTAINS(
RANK BY COERCION(Absolute, %u)) 
 AND 
) RANK BY COERCION(ABSOLUTE,1)
 OR (
 SCOPE='%s://{%s}/' 
 SCOPE='%s' 
 WHERE 
 ORDER BY 
 ASC 
 DESC 
 ORDER BY System.Search.Rank DESC
Dw=c:s
Dw=]:s
Dw=y:s
Dw=|:s
iwz$m
iwz$m
iwz$m
("%s" = '%s')
iehistory
ierss
o:$~%
touch
non-touch
TouchType
Manufacturer/Model
ROOT\CIMV2
SELECT Manufacturer, Model FROM Win32_ComputerSystem
Manufacturer
Model
Local\IEHistJournalFm_24c20119-753b-4f33-887d-f2381810562d_
Local\IEHistJournalMx_1699bb90-bebe-4437-b6e8-a6b7123fa38e_
Local\IEHistJournalGlobal_3bf1c317-e96b-46f6-ba88-50c001d497aa
FileVersion
SuggestedSites.dat
SHA256
HistoryJournalCertificate
HKCU\
MSIEHistoryJournal
1.3.6.1.4.1.311.76.12.1
[)Pyk5I
https://
about:home
about:Start
about:Tabs
about:blank
Microsoft Enhanced RSA and AES Cryptographic Provider
ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/
TL%0%I
^{xn1
"}U2:
2r|Bj 5
ZF^!W-JM
v&=tM
Z)4U1m
|ma[_
SelectionLanguage
SelectionNamespaces
ProhibitDTD
AllowDocumentFunction
XPath
xmlns:cf='http://www.microsoft.com/schemas/rss/core/2005' xmlns:cfi='http://www.microsoft.com/schemas/rss/core/2005/internal' xmlns:atom='http://www.w3.org/2005/Atom'
FILETIME_remainder
LOCAL
UNDEFINED
Control Panel\International\Calendars\TwoDigitYearMax
 !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`ABCDEFGHIJKLMNOPQRSTUVWXYZ{|}~
urn:microsoft:feed-normalization
downloadUrl
xmlns:xsl='http://www.w3.org/1999/XSL/Transform'
//xsl:import[@href='res://msfeeds.dll/SharedNormalizer.xsl']
SharedNormalizer.xsl
*[local-name(.)='rss' and namespace-uri(.)='']/@version[number(.)=2.0]
*[local-name(.)='rss' and namespace-uri(.)='']/@version[number(.)=0.91]
*[local-name(.)='rss' and namespace-uri(.)='']/@version[number(.)=0.92]
*[local-name(.)='feed' and namespace-uri(.)='http://purl.org/atom/ns#']/@version[number(.)=0.3]
*[local-name(.)='feed' and namespace-uri(.)='http://www.w3.org/2005/Atom']
*[local-name(.)='RDF' and namespace-uri(.)='http://www.w3.org/1999/02/22-rdf-syntax-ns#']/*[local-name(.)='channel' and namespace-uri(.)='http://purl.org/rss/1.0/']
-%04d%02d%02d%02d%02d%02d
-Slice
-Norm
Rss2Normalizer.xsl
Rss1Normalizer.xsl
Atom03Normalizer.xsl
Atom1Normalizer.xsl
LogTraffic
Software\Microsoft\Internet Explorer\Feeds
NormalizeDateToInetDate
NormalizeDateToIso8601
CombineUrls
CleanHtmlToPlainText
CleanHtmlToSafeHtml
CleanXhtmlToPlainText
CleanXhtmlToSafeXhtml
ValidateUrl
NormalizeUri
style
position:fixed
class
__feedview__
&quot;
#document-fragment
http://www.w3.org/1999/xhtml
&amp;
slc.dll
SLGetWindowsInformation
shell32-license-UseBingAsDefaultSearchProvider
Internet-Browser-License-LicensedPartnerID
zh-cn
!x-sys-default-locale
ka-GE
kk-KZ
hy-AM
ru-RU
ro-MD
ky-KG
tg-Cyrl-TJ
tk-TM
uz-Cyrl-UZ
uz-Latn-UZ
tr-TR
be-BY
az-Cyrl-AZ
az-Latn-AZ
zh-CN
http://hao.360.cn/?src=lm&ls=n55dfe5b796
http://hao.qq.com/?unc=Af31022
http://go.microsoft.com/fwlink/?LinkId=625119
%s&clocalename=%s
http://go.microsoft.com/fwlink/?LinkId=625115
SLGetWindowsInformationDWORD
uk-UA
{8C3078A0-9AAB-4371-85D1-656CA8E46EE8}
Software\Microsoft\Internet Explorer\SearchScopes
EUPPSYNCLOCK
{5312EE61-79E3-4A24-BFE1-132B85B23C3A}
SOFTWARE\Microsoft\Cryptography
MachineGuid
&OCID=
&pc=UE00
EUPP_
_EUPP_
bing.
%s_%s
{0633EE93-D776-472f-A0FF-E1416B8B2E3A}
https://www.bing.com/favicon.ico
https://api.bing.com/qsml.aspx?query={searchTerms}&market={language}&maxwidth={ie:maxWidth}&rowheight={ie:rowHeight}&sectionHeight={ie:sectionHeight}&FORM=IESS02
https://www.bing.com/search?q={searchTerms}&src=IE-SearchBox&FORM=IENTSR
https://www.bing.com/search?q={searchTerms}&src=IE-SearchBox&FORM=IENTTR
https://api.bing.com/qsml.aspx?query={searchTerms}&market={language}&maxwidth={ie:maxWidth}&rowheight={ie:rowHeight}&sectionHeight={ie:sectionHeight}&FORM=IENTSS
https://go.microsoft.com/fwlink/?LinkID=403856&language={language}&scale={scalelevel}&contrast={contrast}
https://www.bing.com/search?q={searchTerms}&src=IE-SearchBox&FORM=IESR02
&pc=WCUG
&pc=EPSPC
&pc=UE15
&pc=UE04
{461B4783-36F5-45B9-883E-35BA5ED4A823}
https://www.haosou.com/s?src=win10&ie=utf-8&q={searchTerms}
{2562B2EF-500D-49FC-A350-5BC0D4C56EE3}
https://www.sogou.com/tx?hdq=sogou-wsse-6abba5d8ab1f4f32&query={searchTerms}
{64AF4D11-6492-4C25-B014-B6C6CEE3B0C5}
https://www.baidu.com/s?tn=80035161_2_dg&wd={searchTerms}
http://www.baidu.com/favicon.ico
https://suggest.yandex.com.tr/suggest-ff.cgi?srv=ie11&uil=tr&part={searchTerms}&clid=2233630
https://suggest.yandex.ua/suggest-ff.cgi?srv=ie11&part={searchTerms}&clid=2233627
https://suggest.yandex.kz/suggest-ff.cgi?srv=ie11&part={searchTerms}&clid=2233627
https://suggest.yandex.by/suggest-ff.cgi?srv=ie11&part={searchTerms}&clid=2233627
https://suggest.yandex.ru/suggest-ff.cgi?srv=ie11&part={searchTerms}&clid=2233627
https://yandex.com.tr/search/?text={searchTerms}&clid=2233630
https://yandex.ua/search/?text={searchTerms}&clid=2233627
https://yandex.kz/search/?text={searchTerms}&clid=2233627
https://yandex.by/search/?text={searchTerms}&clid=2233627
https://yandex.ru/search/?text={searchTerms}&clid=2233627
http://www.yandex.com.tr/favicon.ico
http://www.yandex.com/favicon.ico
Yandex
AVRES000
about:home
%.*s%s%s=%s%.*s
IE-Address
MIE-Address
IE-SearchBox
MIE-SearchBox
IE-ContextMenu
MIE-ContextMenu
{searchTerms
{count
{startIndex
{startPage
{language
{outputEncoding
UTF-8
{inputEncoding
{referrer:source
{ie:maxwidth
{ie:sectionheight
{ie:rowheight
Missing
http://go.microsoft.com/fwlink/?LinkId=392206
FORM=IESR4A
FORM=IESR4N
FORM=IESR3A
FORM=IESR3N
FORM=IENAE1
FORM=IENAD1
FORM=IENAE2
FORM=IENAD2
FORM=IEMAE2
FORM=IEMAD2
FORM=IEMAE1
FORM=IEMAD1
FORM=IESR02
FORM=IESS4A
FORM=IESS4N
FORM=IESS3A
FORM=IESS3N
FORM=IENSE1
FORM=IENSD1
FORM=IENSE2
FORM=IENSD2
FORM=IEMSE2
FORM=IEMSD2
FORM=IEMSE1
FORM=IEMSD1
FORM=IESS02
FORM=IESR4S
FORM=IESR3S
FORM=IENDS1
FORM=IENDS2
FORM=IEMDS2
FORM=IEMDS1
FORM=IESS4S
FORM=IESS3S
FORM=IENSS1
FORM=IENSS2
FORM=IEMSS2
FORM=IEMSS1
bing.com
&pc=%s
msn.cn
msn.com
about:newsfeed
about:tabs
<request/>
Internet Explorer
product
Microsoft
trademark
euppid
hashvalue
thumbprint
source
<?xml version="1.0" encoding="utf-8"?>
status
publiccertificate
signvalue
NOTFOUND
IE_EUPP
Content-Type: text/xml; charset=utf-8
&clientkey=
&mac=
https://ieonline.microsoft.com/EUPP/v1/service?action=setfirstruncomplete&appid=Microsoft_IE_EUPP
https://ieonline.microsoft.com/EUPP/v1/service?action=downloadcert&appid=Microsoft_IE_EUPP
https://ieonline.microsoft.com/EUPP/v1/service?action=needfirstrun&appid=Microsoft_IE_EUPP
https://ieonline.microsoft.com/EUPP/v1/service?action=signvalue&appid=Microsoft_IE_EUPP
IE Enhanced User Preference Protection
Trust
1.3.6.1.4.1.311.13.1
%%%02x
ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/
shell:%s
{SUB_PRD}
{SUB_PVER}
{SUB_OS}
{SUB_OVER}
{SUB_OLCID}
{SUB_CLCID}
{SUB_CLSID}
{SUB_RFC1766}
AcceptLanguage
Software\Microsoft\Internet Explorer\International
%#04lx
gY?&%:E
onecoreuap\inetcore\lib\tracelogging\legacydll.cpp
Windows.Devices.Input.TouchCapabilities
api-ms-win-core-winrt-string-l1-1-0.dll
WindowsCreateString
WindowsDeleteString
api-ms-win-core-winrt-l1-1-0.dll
RoGetActivationFactory
ServicesActive
IEXPLORE.EXE
MSFEEDSSYNC.EXE
SYSPREP.EXE
EXPLORER.EXE
LOADER42.EXE
WWAHOST.EXE
IEUTLAUNCH.EXE
TE.EXE
Te.ProcessHost.exe
FAKEVIRTUALSURFACETESTAPP.EXE
MSOOBE.EXE
NETPLWIZ.EXE
USERACCOUNTBROKER.EXE
MSHTMPAD.EXE
FirstLogonAnim.exe
RESTOREOPTIN.EXE
DCIScanner
microsoftedge.exe
microsoftedgecp.exe
microsoftedgebchost.exe
microsoftedgedevtools.exe
microsoftedgesh.exe
pickerhost.exe
browser_broker.exe
jshost.exe
authhost.exe
\VarFileInfo\Translation
\StringFileInfo\%04X%04X\%s
\StringFileInfo\040904B0\%s
\StringFileInfo\040904E4\%s
\StringFileInfo\04090000\%s
@IEHomepageChanged
sessionID
userInputID
UTCReplace_AppSessionGuid
newPrimaryHomepage
oldHomepage
homepageChangeReason
EuppProtectionEvent
sessionID
userInputID
UTCReplace_AppSessionGuid
eventID
Microsoft.Windows.App.Browser
RSDS30
msfeeds.pdb
.rdata$brc
.rdata$T$brc
.CRT$XCA
.CRT$XCU
.CRT$XCZ
.CRT$XIA
.CRT$XIAA
.CRT$XIZ
.CRT$XLA
.CRT$XLZ
.gfids
.giats
.rdata
.rdata$sxdata
.rdata$voltmd
.rdata$zETW0
.rdata$zETW1
.rdata$zETW2
.rdata$zETW9
.rdata$zzzdbg
.text
.text$di
.text$mn
.text$mn$00
.text$yd
.tls$
.tls$ZZZ
.xdata$x
.didat$2
.didat$3
.didat$4
.didat$6
.didat$7
.edata
.data$brc
.data
.idata$5
.00cfg
.idata$2
.idata$3
.idata$4
.idata$6
.didat$5
.rsrc$01
.rsrc$02
E(SVW
)_^[]
@SVWj6
9A$u1
QQSVW
xFSSj4
QQSVW
97tGj
VQhHG
QQSVW
QQSVW
Yj?X+E
SVWjH
VVSPVh
SVWPh,K
SVWPh
SVWPh
SVWj@Y
SVWj@Y
G ;G$}
N<_^]
<6j\Xf;D<
j\Yf;
x%jHXf;E
D$HPj
D$8Pj
D$hQP
L$$_^[3
x%jHXf;E
x*j@Xf;E
9\$,|
\$$PW
xCj\j
j.Xf;
D$PPQ
D$8P3
SVWh@
QQSVW
QQSVW
D$$tF
xCj\j
 SVW3
 SVW3
x!jHXf;E
VWj@Xf
3j@Xf
x#j@Xf;E
SVWh@
F$Ph|K
QQSVW
D$$Pj
D$4PQ
t}j0j
SVWPj
Xf;D$
QQSVW
QRQjdZ
QRQjeZ
QRQjjZ
QRQjkZ
QRQjnZ
QRQjoZ
QRQjpZ
QRQjqZ
SVWPj
_uGB;
_u@B;
QVRjlZ
QRQjmZ
QVRjfZ
QRQjgZ
QVRjhZ
QRQjiZ
t<h8n
QQSVW
9^Ht 
D$ Pj
QQSVW
Xf;D$
QQSVW
QQSVW
QRQjtZ
QRQjuZ
J$:H0s
QVhPp
PPh q
PQRj+
t$@RQ
D$0PS
D$ Ph
QRQjrZ
QRQjsZ
x+hlP
QQSVW
QQSVW
SVWhp
QSVWjLY
QQSVW
SVWhT
tBWWj
j\Zf;
u'j\Z
j\Zf;Ty
VWPi3 
)_^[]
QQSVW
SVWh 
SVWhpX
QSVWhpX
QSVWhpX
SVWhpX
SVhpX
QSVW3
x+VVVj
t<hpW
D$$PQQR
T$$9T$ 
D$$PRQ
T$$;T$ 
x>Vh0Z
QSVWj Y
SVWjH
t#WPS
QWVjxZ
QRQjyZ
QQSVW
QQSVW
tBVj@
R9^htM
y79s0t2
sD9s\tX9s8|S
u+9{4v
QQSVW
8VWj6
SRVQh
 _^[]
SWRQVj
(_^[]
u+9t$(uT
N$;N(s,A
QRQjwZ
D$XPQ
D$\#D$X
L$X"L$\
D$8#L$pQW
L$HQP
D$$t1j
T$$;T$
D$0SV
D$(PQ
D$,PQ
L$$9L$
xrVSh
D$ PQ
QQSVW3
VVj4W
QQQQhB
SVWh<
j@Xf;
j@Xf;
)_^[]
QQSVW
QQSVW
QQSVW
QQSVW
QQSVW
QQSVW
SVWPj
WPh8b
VWj@Xf
SPhPb
SVWPj
uHPhxI
SSSShB
u'VhxI
SSSSh@
SVWP3
PPPPu5hB
9KTt+
KT_^[
QQSVW
D$,Pj
D$(j@Yf;
QQSVWj@Xf
QQSVW
SVWPhLc
j\Yf;LF
)_^[]
)_^[]
D$ PQ
D$ PQ
D$(PQ
L$(Qh(Y
Xf;D$(
L$(QhxY
Xf;D$(u;
L$\_^[3
D$XPh
D$ PQ
D$8PQ
PQQQQW
u h d
D$4htM
CDPh,K
D$ PQ
D$4h,K
BDPh,K
QQSVW
D$ Pj
E(;G(t
QQSV3
QQSVW
SVWj@Xf
QQSVj,j@
QQSVW
VWj,j
VWj,j
tkj$W
xQj,j@
tkj,WS
t$ WS
9_TuS
;C\t@
)_^[]
QSVWj@
D$dFXf
D$tXf
L$PYj
SVWPj
x&f;]
QQSVW
u9SPQP
!\$43
to!\$
D$`RRh
D$ PQj
xu8\$
D$ PQ
D$HPQ
9\$(t
D$@!\$(!\$,QQ
L$PPQQ
D$(QPQ
t$8PQ
|$$Qj
D$(Ph
;L$l|r
;D$hrc3
9T$t|[
9T$pvS+D$hR
w$hLk
w h l
w h8l
SVWRQ
VWhLl
E(SV3
u'h@m
j\_f9~`u
f9^bu
t,j\Yf;H
Yf9>u
`f9>u6
s4j\W
PSVW3
j:Yf9H
j:Yf9H
u`j.^f90
j.^f90
tij.^f;
u'f9s
j.^f93u&
j:Xf9G
j\^f;
uof92
t*hP?
93uFV
&PWSV
|$hWQ
t$hVQ
j`h8>
wj\[f;
j\Zf;
rXj~Xf;DV
\t%j~Xf;
QQSVW
w`WVQ
j\Xf;
SVWj\3
j\Xf;FLu
j\Xf;F`u
x5SSh
t/j.Yf;
D$$PQ
L$ Aj
L$$Z;L$
t`!19p
t`!19p
thh p
xNVh`
t_VPW
QSQQj
SVWhTq
SVWhHq
D$ Pj
Xf;D$ u
T$0RSPQ
Xf;D$0u
L$8QP
L$(QP
L$$QP
L$0QP
L$,QP
D$$+D$(
L$,+L$0
D$4Ph
t2h,p
j Yf;
tPVSP
j Y;u
SVWPh
t!h@r
uIjtY
{D9{Ht
PPPPPh
^91u2V
VW8XM
9C<t-
D$@S3
L$L_^[3
)_^[]
)_^[]
Ij/j\
uWj}W
j\j/Z
f90ulW
QQSVW
C\+C`Q
x&Qht}
Hxh,~
v%h|~
u~9Ctt
uV9Ctt
sx9Ctt
x1Qh,~
;^psG
QVWj$Y
QVWj$Y
L$$;L$
QRRRRRRh
L$HQRh4
Xf9D$@
L$8QRhP
Xf9D$0u]
D$ Pj
QQSVW
j4hX>
PQj/QQ
PQj0QQ
QQSVW
x_h'g
t/VSWP
;D$4t/
L$T"F
L$ZQRj
L$Th0T
tt:;u
QQQQQQQQQQQQQQQj
T$0RQQRQRRRRRRQQ
L$TRj
RQQRQj
L$TQj
L$_QQQ
L$jQRj
RQQRQRRRj
L$aQQQ
L$lQRj
j`hX?
PQWVj
E$SVW
u#C;]
PPj P
QQVWj
pHVVh8
PVVVhH
t(SWj
4SVW3
PSSQS
QQPVQS
SSPVRQSh
PWRQVh
QQSVW
bw6t$
PWWWWW
WWj0Pj
t@Vj 
~<9~4t
~49~8t
~89~$t
~$9~,t
~,9~0t
~09~ t
Q(SVW
t:PQPV
QQSVW
$SVWh
]_^[]
]_^[]
<zf;D9
<zf;D9
<zf;D9
<zf;D9
<zf;D9
<zf;D9
<zf;D9
<zf;D9
]_^[]
<zf;D9
<zf;D9
<zf;D9
<zf;D9
<zf;D9
<zf;D9
<zf;D9
]_^[]
QQVRj
D$hSV
T$0j 
D$&9D$
f;D$.ug
L$(PQ
QQSVW
F$S9F
r<Sj@
N$QSP
@PVPh
$!< u.3
j;Yf;
j;Zf9U
j2XPQ
j;_f;
u+j0Xj1Zf;E
^f92u
w\RPh
)_^[]
)_^[]
)_^[]
)_^[]
)_^[]
L$$_^3
SVWu:
SVWuM
QSVWj
QQSV3
cw>tv
QSVWh
8K t,
8f;>u
8f;>u
2f;0u
QQSVW
QQSVj
PQQQj
_^[Y]
s(_^[
L$TYPj
L$t^3
|$(Hug
D$$Ph
uBVhx
QQSVW
D$ W3
D$$VP
tZf97u
QQSVW
QQSVW
SWRht
QSSSP
E 90tL
L$<_^[3
9PRQt
)_^[]
T$<PRj
D$(Pj
)_^[]
)_^[]
)_^[]
D$,@%
uKSWj
D9(Xf
D;8Xf
D;HXf
D9(Xf
D;8Xf
D;HXf
QQSVW
f9\78t
D88Ph
^f92u
)_^[]
j}_f;
u-j}X
QQQQSPQh
QQVPj
t7SPV
QQSVW
L$<Qj 
L$ h0
TSVWQ
SSSSh
QPQQQ
SVWQQQQj
t'SWj
QQSVWQ
<SVW3
t5j [9]
(SVWj
>w(tV
t$< u
D$8vT2
D$|PV
QQSVW
u7f9A
{u*Qh
M QRSP
jx_f;
jX_f;
j0Zf;
QSVW3
^Vj Vj
udSh<
u6Sht
tojAZ;
Y__^[
QRPh4A
QRPhTA
QRPhtA
TranslateMessage
PeekMessageW
DispatchMessageW
MsgWaitForMultipleObjects
StringFromGUID2
CoTaskMemFree
StgOpenStorageEx
StgCreateStorageEx
PropVariantClear
CoTaskMemAlloc
CoCreateInstance
CoUninitialize
CoInitializeEx
CLSIDFromString
CoCreateGuid
CryptUnprotectData
CryptProtectData
SHGetInstanceExplorer
ShellExecuteW
SHGetFolderPathW
FindFirstUrlCacheContainerW
CreateUrlCacheContainerW
InternetQueryOptionW
FindNextUrlCacheContainerW
FindCloseUrlCache
CoInternetCombineUrlEx
CreateAsyncBindCtx
CreateURLMonikerEx
CoInternetCreateSecurityManager
URLDownloadToCacheFileW
IESetProtectedModeCookie
IEGetProtectedModeCookie
SendMessageTimeoutW
CharNextW
LoadStringW
CryptHashCertificate2
CertOpenStore
CertEnumCertificatesInStore
CertCloseStore
CertGetCertificateContextProperty
CertGetCertificateChain
CertVerifyCertificateChainPolicy
CertFreeCertificateChain
CertGetIntendedKeyUsage
CertGetEnhancedKeyUsage
CertFreeCertificateContext
CryptStringToBinaryA
CertDeleteCertificateFromStore
CertCreateCertificateContext
CertAddCertificateContextToStore
CryptImportPublicKeyInfo
CryptBinaryToStringA
CryptStringToBinaryW
CertGetNameStringW
CertFindCertificateInStore
CryptHashCertificate
SHCreateDirectoryExW
CommitUrlCacheEntryW
CreateUrlCacheEntryW
FindFirstUrlCacheEntryW
GetUrlCacheEntryInfoW
FindNextUrlCacheEntryW
DeleteUrlCacheEntryW
InternetCrackUrlW
InternetTimeFromSystemTimeW
InternetCanonicalizeUrlW
InternetOpenW
InternetConnectW
HttpOpenRequestW
InternetCloseHandle
HttpSendRequestW
HttpQueryInfoW
InternetReadFile
CoInternetIsFeatureEnabled
CoInternetCombineUrl
CoInternetCombineIUri
PSGetPropertyKeyFromName
PSRegisterPropertySchema
PSCreateMemoryPropertyStore
msfeeds.dll
DllCanUnloadNow
DllGetClassObject
MsfeedsCreateInstance
oeY<9
[_9*O
_vsnwprintf
memcpy_s
srand
_itow_s
_ultow_s
wcspbrk
iswalpha
wcschr
wcsncmp
_XcptFilter
_amsg_exit
malloc
_initterm
msvcrt.dll
_lock
_unlock
__dllonexit
_onexit
_except_handler4_common
ReadFile
CreateEventExW
EnterCriticalSection
GetCurrentProcess
RegisterWaitForSingleObject
InitializeCriticalSectionAndSpinCount
LeaveCriticalSection
SetFilePointer
WaitForSingleObject
CreateFileW
OpenEventW
ReleaseMutex
UnmapViewOfFile
DuplicateHandle
CreateEventW
GetLastError
SetEvent
CloseHandle
CreateMutexExW
UnregisterWaitEx
DeleteCriticalSection
GetCurrentProcessId
CreateFileMappingW
MapViewOfFile
OpenMutexW
OpenProcess
MultiByteToWideChar
SystemTimeToTzSpecificLocalTime
CreateDirectoryW
CompareFileTime
FindFirstFileW
FindNextFileW
RemoveDirectoryW
FindClose
GetFileAttributesW
SetFileAttributesW
DeleteFileW
MoveFileExW
SystemTimeToFileTime
GetSystemTimeAsFileTime
GetSystemTime
FileTimeToSystemTime
LocalAlloc
LocalFree
HeapFree
DisableThreadLibraryCalls
HeapAlloc
GetProcessHeap
OpenFileMappingW
ResetEvent
GetModuleFileNameW
GlobalAlloc
GlobalFree
GlobalLock
LocalReAlloc
GlobalUnlock
GetVersionExW
WriteFile
WaitForMultipleObjects
CreateMutexW
Sleep
CreateThread
FileTimeToLocalFileTime
QueryPerformanceFrequency
GetFileSize
WideCharToMultiByte
QueryPerformanceCounter
GetModuleFileNameA
CreateSemaphoreExW
SetLastError
ReleaseSemaphore
GetModuleHandleExW
GetCurrentThreadId
FormatMessageW
OutputDebugStringW
WaitForSingleObjectEx
OpenSemaphoreW
GetProcAddress
GetModuleHandleW
DebugBreak
IsDebuggerPresent
UnhandledExceptionFilter
SetUnhandledExceptionFilter
TerminateProcess
ReleaseSRWLockExclusive
AcquireSRWLockExclusive
WakeAllConditionVariable
SleepConditionVariableSRW
GetTickCount
RaiseFailFastException
RaiseException
KERNEL32.dll
StrCmpIW
StrCmpW
PathFindFileNameW
SHStrDupW
PathFileExistsW
ChrCmpIW
StrStrIW
StrCmpNIW
StrChrW
SHRegGetValueW
StrToInt64ExW
StrRChrW
SHCreateStreamOnFileW
StrTrimW
HashData
SHLWAPI.dll
RpcServerInqCallAttributesW
RPCRT4.dll
CreateUri
CreateUriWithFragment
CreateIUriBuilder
iertutil.dll
TraceEvent
TraceMessage
CredDeleteW
CredFree
CredEnumerateW
CredReadW
CredWriteW
EventUnregister
UnregisterTraceGuids
RegisterTraceGuidsW
GetTraceEnableLevel
GetTraceEnableFlags
GetTraceLoggerHandle
EventSetInformation
EventRegister
RegSetValueExW
RegCreateKeyExW
RegCloseKey
RegGetValueW
RegOpenKeyExW
ConvertSidToStringSidW
OpenProcessToken
GetTokenInformation
EventWriteTransfer
EventWriteEx
CryptAcquireContextW
CryptGenRandom
CryptReleaseContext
CryptEncrypt
CryptGetKeyParam
CryptCreateHash
CryptHashData
CryptDeriveKey
CryptDestroyHash
CryptDestroyKey
CryptSetHashParam
CryptGetHashParam
CryptSetKeyParam
RegOpenKeyExA
RegQueryValueExA
ADVAPI32.dll
MLANG.dll
PathRemoveExtensionW
PathIsPrefixW
PathFindExtensionW
api-ms-win-core-shlwapi-legacy-l1-1-0.dll
NetGetJoinInformation
wkscli.dll
NetApiBufferFree
netutils.dll
CoWaitForMultipleHandles
CoSetProxyBlanket
PropVariantCopy
api-ms-win-core-com-l1-1-0.dll
TelIsTelemetryTypeAllowed
DiagnosticDataSettings.dll
lstrlenW
lstrlenA
StrToIntA
lstrcmpiA
GetUserDefaultLocaleName
GetSystemDefaultLocaleName
OpenGlobalizationUserSettingsKey
KERNELBASE.dll
_wcsicmp
_vsnprintf
wcstok_s
_wtoi
_wcsnicmp
_vsnwprintf_s
wcsncpy_s
wcsnlen
strnlen
isalnum
rand_s
sprintf_s
NtClose
ntdll.dll
CompareStringW
SetFileTime
GetFileSizeEx
GetFullPathNameW
LCMapStringW
SetEndOfFile
FlushFileBuffers
GetFileTime
FlushViewOfFile
GetTimeZoneInformation
GetDiskFreeSpaceExW
InitializeCriticalSection
QueueUserWorkItem
IsDBCSLeadByteEx
GetStringTypeExA
IsDBCSLeadByte
GetTempPathW
GetLocalTime
GetProductInfo
GetUserPreferredUILanguages
GetSystemInfo
LoadLibraryW
FreeLibrary
LocaleNameToLCID
GetSystemDefaultLCID
GetUserDefaultLCID
ResolveDelayLoadedAPI
DelayLoadFailureHook
SHGetValueW
StrStrW
PathIsNetworkPathW
SHCreateStreamOnFileEx
StrToIntExW
StrCmpNW
StrCmpNIA
StrStrNIW
UrlEscapeW
UrlUnescapeW
StrCmpNA
PathIsURLW
UrlCanonicalizeW
UrlCreateFromPathW
UrlApplySchemeW
UuidCreateSequential
UuidEqual
CryptVerifySignatureW
OpenSCManagerW
OpenServiceW
CloseServiceHandle
QueryServiceConfigW
GetFileVersionInfoSizeExW
GetFileVersionInfoExW
VerQueryValueW
api-ms-win-downlevel-version-l1-1-0.dll
VerSetConditionMask
FindResourceExW
SizeofResource
LoadResource
LockResource
VerifyVersionInfoW
GetVersionExA
InitOnceExecuteOnce
IsWow64Process
GetCurrentDirectoryW
_ftol2_sse
memcmp
memcpy
memmove
memset
SHAREDNORMALIZER.XSL
RSS2NORMALIZER.XSL
RSS1NORMALIZER.XSL
ATOM03NORMALIZER.XSL
ATOM1NORMALIZER.XSL
TYPELIB
VS_VERSION_INFO
StringFileInfo
040904B0
CompanyName
Microsoft Corporation
FileDescription
Microsoft Feeds Manager
FileVersion
11.00.22621.1 (WinBuild.160101.0800)
InternalName
msfeeds
LegalCopyright
 Microsoft Corporation. All rights reserved.
OriginalFilename
msfeeds.dll
ProductName
Internet Explorer
ProductVersion
11.00.22621.1
OleSelfRegister
VarFileInfo
Translation
<?xml version="1.0"?>
<xsl:stylesheet version="1.0"
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:atom="http://www.w3.org/2005/Atom"
    xmlns:cf="http://www.microsoft.com/schemas/rss/core/2005" 
    xmlns:msfeednorm="urn:microsoft:feed-normalization"
    exclude-result-prefixes="msfeednorm"
    >
<!-- IMPORTANT: This shared XSL gets imported using our code by copying all the xsl:stylesheet's children, 
so all of the above namespace declarations must be present in each other XSL where this is imported into. -->
<!-- Download URL is inserted from the normalization code -->
  <xsl:param name="downloadUrl" />
<!-- 
Namespaces commonly used in RSS feeds 
<xsl:variable name="_NSatom1" select="'http://www.w3.org/2005/Atom'" />
<xsl:variable name="_NSatom03" select="'http://purl.org/atom/ns#'" />
<xsl:variable name="_NSsy" select="'http://purl.org/rss/1.0/modules/syndication/'" />
<xsl:variable name="_NScontent" select="'http://purl.org/rss/1.0/modules/content/'" />
<xsl:variable name="_NSrdf" select="'http://www.w3.org/1999/02/22-rdf-syntax-ns#'" />
<xsl:variable name="_NSrss" select="'http://purl.org/rss/1.0/'" />
<xsl:variable name="_NSdc" select="'http://purl.org/dc/elements/1.1/'" />
<xsl:variable name="_NSdcterms" select="'http://purl.org/dc/terms/'" />
<xsl:variable name="_NSslash" select="'http://purl.org/rss/1.0/modules/slash/'" />
<xsl:variable name="_NSwfw" select="'http://wellformedweb.org/CommentAPI/'" />
<xsl:variable name="_NScf" select="'http://www.microsoft.com/schemas/rss/core/2005'" />
<xsl:variable name="_NScfi" select="'http://www.microsoft.com/schemas/rss/core/2005/internal'" />
<xsl:variable name="_NSxhtml" select="'http://www.w3.org/1999/xhtml'" />
<xsl:variable name="_NSmon" select="'http://www.microsoft.com/schemas/rss/monitoring/2007'" />
Conversion and utility/helper templates
<!-- Find if current node is a first one of its kind; returns strings 'true' when first or 'false' when not -->
<xsl:template name="_IsFirstChildOfItsKind">
  <xsl:param name="value" />
  <xsl:variable name="_nameSpace" select="namespace-uri($value)" />
  <xsl:variable name="_localName" select="local-name($value)" />
  <xsl:variable name="_currentId" select="generate-id($value)"/>
  <xsl:variable name="_firstId" select="generate-id($value/../*[namespace-uri(.) = $_nameSpace and local-name(.) = $_localName])"/>
  <xsl:choose>
    <xsl:when test="$_currentId = $_firstId">
      <xsl:value-of select="'true'" />
    </xsl:when>
    <xsl:otherwise>
      <xsl:value-of select="'false'" />
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>
<!-- Convert updateFrequency and updatePeriod to ttl -->
  <xsl:template name="_ConvertUpdatesToTtl">
    <xsl:param name="updateFrequency" />
    <xsl:param name="updatePeriod" />
    <xsl:variable name="_updateFrequencyNum" select="number($updateFrequency)"/>
    <xsl:variable name="_updatePeriodTmp">
      <xsl:choose>
        <xsl:when test="$updatePeriod = 'hourly'">60</xsl:when>
        <xsl:when test="$updatePeriod = 'daily'">1440</xsl:when>
        <xsl:when test="$updatePeriod = 'weekly'">10080</xsl:when>
        <xsl:when test="$updatePeriod = 'monthly'">40320</xsl:when>
        <xsl:when test="$updatePeriod = 'yearly'">483840</xsl:when>
        <xsl:otherwise>-1</xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="_updatePeriodNum" select="number($_updatePeriodTmp)" />
    <xsl:if test="$_updateFrequencyNum > 0 and $_updatePeriodNum > 0">
      <ttl>
        <xsl:value-of select="$_updatePeriodNum div $_updateFrequencyNum" />
      </ttl>
    </xsl:if>
  </xsl:template>
<!-- Convert author strings to Atom format (very simple implementation) -->
  <!-- NOTE: Assumes that value has been properly scrubbed and only needs to be parsed -->
  <xsl:template name="_ConvertAuthorToAtomAuthor">
    <xsl:param name="value" />
    <xsl:if test="string($value)">
      <atom:author>
        <xsl:choose>
          <!-- No email -->
          <xsl:when test="contains($value, '@') = false">
            <atom:name><xsl:value-of select="$value" /></atom:name>
          </xsl:when>
          <!-- Name and email -->
          <xsl:when test="contains($value, '(') and contains($value, ')')">
            <xsl:variable name="_BeforeOpenParen" select="substring-before($value, '(')" />
            <xsl:variable name="_AfterCloseParen" select="substring-after($value, ')')" />
            <xsl:variable name="_WithinParens" select="substring-after(substring-before($value, ')'), '(')" />
            <xsl:choose>
              <!-- Simple check for some possible weird cases -->
              <xsl:when test="contains($_BeforeOpenParen, ')') or contains($_AfterCloseParen, '(') or contains($_WithinParens, '(')">
                <atom:name><xsl:value-of select="$value" /></atom:name>
              </xsl:when>
              <!-- Email within parens -->
              <xsl:when test="contains($_WithinParens, '@')">
                <atom:name><xsl:value-of select="concat($_BeforeOpenParen, $_AfterCloseParen)" /></atom:name>
                <atom:email><xsl:value-of select="$_WithinParens" /></atom:email>
              </xsl:when>
              <!-- Name within parens -->
              <xsl:otherwise>
                <atom:name><xsl:value-of select="$_WithinParens" /></atom:name>
                <xsl:choose>
                  <!-- Email before parens -->
                  <xsl:when test="contains($_BeforeOpenParen, '@')">
                    <atom:email><xsl:value-of select="$_BeforeOpenParen" /></atom:email>
                  </xsl:when>
                  <!-- Email after parens -->
                  <xsl:otherwise>
                    <atom:email><xsl:value-of select="$_AfterCloseParen" /></atom:email>
                  </xsl:otherwise>
                </xsl:choose>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:when>
          <!-- Only email -->
          <xsl:otherwise>
            <atom:email><xsl:value-of select="$value" /></atom:email>
          </xsl:otherwise>
        </xsl:choose>
      </atom:author>
    </xsl:if>
  </xsl:template>
<!-- Convert Atom author strings to RSS 2.0 format with email and name -->
  <xsl:template name="_ConvertAtomAuthorToAuthor">
    <xsl:param name="name" />
    <xsl:param name="email" />
    <xsl:choose>
      <xsl:when test="string($name) and string($email)"><xsl:value-of select="concat($email, ' (', $name, ')')" /></xsl:when>
      <xsl:when test="string($email)"><xsl:value-of select="string($email)" /></xsl:when>
      <xsl:otherwise><xsl:value-of select="string($name)" /></xsl:otherwise>
    </xsl:choose>
  </xsl:template>
<!-- Map type values to Atom 1.0 type -->
<!-- Note that our sanitization code can parse but cannot output XHTML, so xhtml gets converted to html -->
  <xsl:template name="_NormalizeAtomTextTypeAttr">
    <xsl:param name="value" />
    <xsl:choose>
      <xsl:when test="not(string($value)) or normalize-space($value) = ''"><xsl:attribute name="type">text</xsl:attribute></xsl:when>
      <xsl:when test="$value = 'text/plain' or $value = 'text'"><xsl:attribute name="type">text</xsl:attribute></xsl:when>
      <xsl:when test="$value = 'text/html' or $value = 'html'"><xsl:attribute name="type">html</xsl:attribute></xsl:when>
      <xsl:when test="$value = 'application/xhtml+xml' or $value = 'xhtml'"><xsl:attribute name="type">html</xsl:attribute></xsl:when>
    </xsl:choose>
  </xsl:template>
<!-- Validate bool -->
  <xsl:template name="_ValidateBool">
    <xsl:param name="value" />
    <xsl:choose>
      <xsl:when test="normalize-space($value) = 'true'">true</xsl:when>
      <xsl:when test="normalize-space($value) = 'false'">false</xsl:when>
    </xsl:choose>
  </xsl:template>
<!-- Build a list of nodes that are referenced from the cf:sort or cf:group -->
  <xsl:template name="_BuildCfReferenceList">
    <xsl:param name="value" />
    <!-- We format the node references as "'namespace-uri':local-name;" -->
    <xsl:for-each select="$value/cf:listinfo/cf:sort">
      <xsl:choose>
        <xsl:when test="@element">'<xsl:value-of select="@ns"/>':<xsl:value-of select="@element" />;</xsl:when>
        <xsl:otherwise>'<xsl:value-of select="@ns"/>':<xsl:value-of select="@label" />;</xsl:otherwise>
      </xsl:choose>
    </xsl:for-each>
    <xsl:for-each select="$value/cf:listinfo/cf:group">
      <xsl:choose>
        <xsl:when test="@element">'<xsl:value-of select="@ns"/>':<xsl:value-of select="@element" />;</xsl:when>
        <xsl:otherwise>'<xsl:value-of select="@ns"/>':<xsl:value-of select="@label" />;</xsl:otherwise>
      </xsl:choose>
    </xsl:for-each>
  </xsl:template>
<!-- Ensure XHTML is the default namespace; needs to run prior to sanitization; exact preserving of namespace prefixes
is not important because sanitization will drop all the unknown elements anyway -->
  <xsl:template name="_NormalizeXhtmlNamespacePrefix">
    <xsl:param name="value" />
    <xsl:for-each select="$value">
      <xsl:choose>
        <xsl:when test="self::text() or self::comment() or self::processing-instruction()">
          <xsl:copy />
        </xsl:when>
        <!-- xhtml is default namespace: just copy and process children -->
        <xsl:when test="namespace-uri(.) = $_NSxhtml and not(contains(name(.), ':'))">
          <xsl:copy>
            <xsl:for-each select="@*"><xsl:copy /></xsl:for-each>
            <xsl:call-template name="_NormalizeXhtmlNamespacePrefix">
              <xsl:with-param name="value" select="*|text()" />
            </xsl:call-template>
          </xsl:copy>
        </xsl:when>
        <xsl:otherwise>
          <xsl:choose>
            <!-- xhtml element in non-default namespace: fix namespace and process children -->
            <xsl:when test="namespace-uri(.) = $_NSxhtml">
              <xsl:element name="{local-name(.)}" namespace="{$_NSxhtml}">
                <xsl:for-each select="@*"><xsl:copy /></xsl:for-each>
                <xsl:call-template name="_NormalizeXhtmlNamespacePrefix">
                  <xsl:with-param name="value" select="*|text()" />
                </xsl:call-template>
              </xsl:element>
            </xsl:when>
            <!-- non-xhtml element in default namespace: fix namespace and process children -->
            <xsl:otherwise>
              <xsl:element name="{concat('x:', local-name(.))}" namespace="{namespace-uri(.)}">
                <xsl:for-each select="@*"><xsl:copy /></xsl:for-each>
                <xsl:call-template name="_NormalizeXhtmlNamespacePrefix">
                  <xsl:with-param name="value" select="*|text()" />
                </xsl:call-template>
              </xsl:element>
            </xsl:otherwise>
          </xsl:choose>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:for-each>
  </xsl:template>
<!-- Combine base and relative URLs -->
  <xsl:template name="_CombineUrls">
    <xsl:param name="baseUrl" />
    <xsl:param name="relUrl" />
    <xsl:choose>
      <xsl:when test="string($baseUrl)">
        <xsl:value-of select="msfeednorm:CombineUrls(string($baseUrl), string($relUrl))"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="string($relUrl)"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>
<!-- Check for URL and combine it with base (complete the URL) -->
  <xsl:template name="_CompleteUrl">
    <xsl:param name="Url" />
    <xsl:param name="baseUrl" />
    <xsl:if test="string($Url)">
      <xsl:value-of select="msfeednorm:CombineUrls(string($baseUrl), string($Url))"/>
    </xsl:if>
  </xsl:template>
<!-- Complete URL in order: baseUrl1 + baseUrl2 + Url -->
  <xsl:template name="_CompleteUrlTwoBase">
    <xsl:param name="Url" />
    <xsl:param name="baseUrl1" />
    <xsl:param name="baseUrl2" />
    <xsl:variable name="combinedBase">
      <xsl:call-template name="_CombineUrls">
        <xsl:with-param name="baseUrl" select="$baseUrl1" />
        <xsl:with-param name="relUrl" select="$baseUrl2" />
      </xsl:call-template>
    </xsl:variable>
    <xsl:call-template name="_CompleteUrl">
      <xsl:with-param name="Url" select="$Url" />
      <xsl:with-param name="baseUrl" select="$combinedBase" />
    </xsl:call-template>
  </xsl:template>
<!-- Figure out the base URL for the feed -->
  <xsl:template name="_GetFeedBaseUrl">
    <xsl:param name="downloadUrl" />
    <xsl:param name="rootNode" />
    <xsl:choose>
      <xsl:when test="string($rootNode/@xml:base)">
        <xsl:call-template name="_CombineUrls">
          <xsl:with-param name="baseUrl" select="$downloadUrl" />
          <xsl:with-param name="relUrl" select="$rootNode/@xml:base" />
        </xsl:call-template>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="string($downloadUrl)" />
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>
Sanitization and validation templates
<!-- Invoke sanitization and/or transformation based on the from and to types -->
  <xsl:template name="_CleanByType">
    <xsl:param name="value" />
    <xsl:param name="fromType" />
    <xsl:param name="toType" />
    <xsl:param name="baseUrl" />
    <xsl:variable name="fromTypeN" select="normalize-space($fromType)" />
    <xsl:variable name="toTypeN" select="normalize-space($toType)" />
    <xsl:choose>
      <xsl:when test="not(string($fromTypeN)) or $fromTypeN = 'text' or $fromTypeN = 'text/plain'">
        <xsl:choose>
          <!-- text->text: just copy -->
          <xsl:when test="not(string($toTypeN)) or $toTypeN = 'text' or $toTypeN = 'text/plain'">
            <xsl:value-of select="$value" />
          </xsl:when>
          <!-- text->html: escape -->
          <xsl:when test="$toTypeN = 'html' or $toTypeN = 'text/html'">
            <xsl:value-of select="msfeednorm:HtmlEscape(string($value))" />
          </xsl:when>
        </xsl:choose>
      </xsl:when>
      <xsl:when test="$fromTypeN = 'html' or $fromTypeN = 'text/html'">
        <xsl:choose>
          <!-- html->text: drop all html and unescape -->
          <xsl:when test="not(string($toTypeN)) or $toTypeN = 'text' or $toTypeN = 'text/plain'">
            <xsl:value-of select="msfeednorm:CleanHtmlToPlainText(string($value))" />
          </xsl:when>
          <!-- html->html: drop unsafe html -->
          <xsl:when test="$toTypeN = 'html' or $toTypeN = 'text/html'">
            <xsl:value-of select="msfeednorm:CleanHtmlToSafeHtml(string($baseUrl), string($value))" />
          </xsl:when>
        </xsl:choose>
      </xsl:when>
      <xsl:when test="$fromTypeN = 'xhtml' or $fromTypeN = 'application/xhtml+xml'">
        <xsl:variable name="normXhtml">
          <xsl:call-template name="_NormalizeXhtmlNamespacePrefix">
            <xsl:with-param name="value" select="$value/*" />
          </xsl:call-template>
        </xsl:variable>
        <xsl:choose>
          <!-- xhtml->text: drop all html and unescape -->
          <xsl:when test="not(string($toTypeN)) or $toTypeN = 'text' or $toTypeN = 'text/plain'">
            <xsl:value-of select="msfeednorm:CleanXhtmlToPlainText($normXhtml)" />
          </xsl:when>
          <!-- xhtml->html: drop unsafe html -->
          <xsl:when test="$toTypeN = 'html' or $toTypeN = 'text/html'">
            <xsl:value-of select="msfeednorm:CleanXhtmlToSafeXhtml(string($baseUrl), $normXhtml)" />
          </xsl:when>
        </xsl:choose>
      </xsl:when>
      <!-- Note that any unknown type value will yield empty output -->
    </xsl:choose>
  </xsl:template>
Generic output templates
<!-- Output attribute with plain text value -->
  <xsl:template name="_OutputTextAttribute">
    <xsl:param name="tagName" />
    <xsl:param name="nameSpace" select="''" />
    <xsl:param name="value" />
    <xsl:variable name="_validatedValue">
      <xsl:call-template name="_CleanByType">
        <xsl:with-param name="value" select="$value" />
        <xsl:with-param name="fromType" select="'text'" />
        <xsl:with-param name="toType" select="'text'" />
      </xsl:call-template>
    </xsl:variable>
    <xsl:if test="string($_validatedValue)">
      <xsl:attribute name="{$tagName}" namespace="{$nameSpace}"><xsl:value-of select="$_validatedValue" /></xsl:attribute>
    </xsl:if>
  </xsl:template>
<!-- Output attribute with bool value -->
  <xsl:template name="_OutputBoolAttribute">
    <xsl:param name="tagName" />
    <xsl:param name="nameSpace" select="''" />
    <xsl:param name="value" />
    <xsl:variable name="_validatedValue">
      <xsl:call-template name="_ValidateBool"><xsl:with-param name="value" select="$value" /></xsl:call-template>
    </xsl:variable>
    <xsl:if test="string($_validatedValue)">
      <xsl:attribute name="{$tagName}" namespace="{$nameSpace}"><xsl:value-of select="$_validatedValue" /></xsl:attribute>
    </xsl:if>
  </xsl:template>
<!-- Output attribute with URL value -->
  <xsl:template name="_OutputUrlAttribute">
    <xsl:param name="tagName" />
    <xsl:param name="nameSpace" select="''" />
    <xsl:param name="value" />
    <xsl:variable name="_validatedValue" select="msfeednorm:ValidateUrl(normalize-space($value))" />
    <xsl:if test="string($_validatedValue)">
      <xsl:attribute name="{$tagName}" namespace="{$nameSpace}"><xsl:value-of select="$_validatedValue" /></xsl:attribute>
    </xsl:if>
  </xsl:template>
  <xsl:template name="_OutputUriAttribute">
    <xsl:param name="tagName" />
    <xsl:param name="nameSpace" select="''" />
    <xsl:param name="value" />
    <xsl:variable name="_validatedValue" select="msfeednorm:NormalizeUri(normalize-space($value))" />
    <xsl:if test="string($_validatedValue)">
      <xsl:attribute name="{$tagName}" namespace="{$nameSpace}"><xsl:value-of select="$_validatedValue" /></xsl:attribute>
    </xsl:if>
  </xsl:template>
<!-- Output attribute with mime-type value -->
  <xsl:template name="_OutputMimeTypeAttribute">
    <xsl:param name="tagName" />
    <xsl:param name="nameSpace" select="''" />
    <xsl:param name="value" />
    <xsl:variable name="_validatedValue" select="normalize-space($value)" />
    <xsl:if test="string($_validatedValue)">
      <xsl:attribute name="{$tagName}" namespace="{$nameSpace}"><xsl:value-of select="$_validatedValue" /></xsl:attribute>
    </xsl:if>
  </xsl:template>
<!-- Output attribute with non-negative number value -->
  <xsl:template name="_OutputPositiveNumberAttribute">
    <xsl:param name="tagName" />
    <xsl:param name="nameSpace" select="''" />
    <xsl:param name="value" />
    <xsl:variable name="_validatedValue" select="number($value)" />
    <xsl:if test="(string($_validatedValue) != 'NaN') and ($_validatedValue >= 0)">
      <xsl:attribute name="{$tagName}" namespace="{$nameSpace}"><xsl:value-of select="$_validatedValue" /></xsl:attribute>
    </xsl:if>
  </xsl:template>
<!-- Output element with plain text value -->
  <xsl:template name="_OutputTextElement">
    <xsl:param name="tagName" />
    <xsl:param name="nameSpace" select="''" />
    <xsl:param name="value" />
    <xsl:param name="type" select="'text'" />
    <xsl:param name="outputTypeAttribute" select="'false'" />
    <xsl:variable name="_validatedValue">
      <xsl:call-template name="_CleanByType">
        <xsl:with-param name="value" select="$value" />
        <xsl:with-param name="fromType" select="$type" />
        <xsl:with-param name="toType" select="'text'" />
      </xsl:call-template>
    </xsl:variable>
    <xsl:if test="string($_validatedValue)">
      <xsl:element name="{$tagName}" namespace="{$nameSpace}">
        <xsl:if test="$outputTypeAttribute = 'true'">
          <xsl:attribute name="cf:type" namespace="{$_NScf}">text</xsl:attribute>
        </xsl:if>
        <xsl:value-of select="$_validatedValue" />
      </xsl:element>
    </xsl:if>
  </xsl:template>
<!-- Output element with URL value -->
  <xsl:template name="_OutputUrlElement">
    <xsl:param name="tagName" />
    <xsl:param name="nameSpace" select="''" />
    <xsl:param name="value" />
    <xsl:variable name="_validatedValue" select="msfeednorm:ValidateUrl(normalize-space($value))" />
    <xsl:if test="string($_validatedValue)">
      <xsl:element name="{$tagName}" namespace="{$nameSpace}"><xsl:value-of select="$_validatedValue" /></xsl:element>
    </xsl:if>
  </xsl:template>
<!-- Output element with inet date value -->
  <xsl:template name="_OutputDateElement">
    <xsl:param name="tagName" />
    <xsl:param name="nameSpace" select="''" />
    <xsl:param name="value" />
    <xsl:param name="outFormat" select="'inetDate'" />
    <xsl:variable name="_validatedValue">
      <xsl:choose>
        <xsl:when test="$outFormat = 'inetDate'">
          <xsl:value-of select="msfeednorm:NormalizeDateToInetDate(normalize-space($value))"/>
        </xsl:when>
        <xsl:when test="$outFormat = 'iso8601'">
          <xsl:value-of select="msfeednorm:NormalizeDateToIso8601(normalize-space($value))"/>
        </xsl:when>
      </xsl:choose>
    </xsl:variable>
    <xsl:if test="string($_validatedValue)">
      <xsl:element name="{$tagName}" namespace="{$nameSpace}"><xsl:value-of select="$_validatedValue" /></xsl:element>
    </xsl:if>
  </xsl:template>
<!-- Output element with a non-negative number value -->
  <xsl:template name="_OutputPositiveNumberElement">
    <xsl:param name="tagName" />
    <xsl:param name="nameSpace" select="''" />
    <xsl:param name="value" />
    <xsl:variable name="_validatedValue" select="number($value)" />
    <xsl:if test="(string($_validatedValue) != 'NaN') and ($_validatedValue >= 0)">
      <xsl:element name="{$tagName}" namespace="{$nameSpace}"><xsl:value-of select="$_validatedValue" /></xsl:element>
    </xsl:if>
  </xsl:template>
<!-- Output RSS 2.0 author or managingEditor element and convert into atom:author -->
  <xsl:template name="_OutputAuthorOrEditor">
    <xsl:param name="tagName" />
    <xsl:param name="value" />
    <xsl:param name="convertToAtom" select="'false'" />
    <xsl:variable name="_validatedValue" select="normalize-space($value)" />
    <xsl:if test="string($_validatedValue)">
      <xsl:element name="{$tagName}"><xsl:value-of select="$_validatedValue" /></xsl:element>
      <xsl:if test="$convertToAtom = 'true'">
        <xsl:call-template name="_ConvertAuthorToAtomAuthor"><xsl:with-param name="value" select="$_validatedValue" /></xsl:call-template>
      </xsl:if>
    </xsl:if>
  </xsl:template>
<!-- Output atom:author or atom:contributor (have identical handling) -->
  <xsl:template name="_OutputAtomAuthorOrContributor">
    <xsl:param name="tagName" />
    <xsl:param name="name" />
    <xsl:param name="email" />
    <xsl:param name="uri" />
    <xsl:variable name="_validatedName" select="normalize-space($name)" />
    <xsl:variable name="_validatedEmail" select="normalize-space($email)" />
    <xsl:if test="string($_validatedName) or string($_validatedEmail)">
      <xsl:element name="{$tagName}" namespace="{$_NSatom1}">
        <xsl:if test="string($_validatedName)">
          <atom:name><xsl:value-of select="$_validatedName" /></atom:name>
        </xsl:if>
        <xsl:if test="string($_validatedEmail)">
          <atom:email><xsl:value-of select="$_validatedEmail" /></atom:email>
        </xsl:if>
        <xsl:variable name="_validatedUri" select="msfeednorm:NormalizeUri(normalize-space($uri))" />
        <xsl:if test="string($_validatedUri)">
          <atom:uri><xsl:value-of select="$_validatedUri" /></atom:uri>
        </xsl:if>
      </xsl:element>
    </xsl:if>
  </xsl:template>
Common feed format output templates
<!-- xml:lang -->
  <xsl:template name="_OutputXmlLang">
    <xsl:param name="value" />
    <xsl:call-template name="_OutputTextAttribute">
      <xsl:with-param name="tagName" select="'xml:lang'" />
      <xsl:with-param name="value" select="$value" />
    </xsl:call-template>
  </xsl:template>
<!-- xml:base -->
  <xsl:template name="_OutputXmlBase">
    <xsl:param name="value" />
    <xsl:call-template name="_OutputUrlAttribute">
      <xsl:with-param name="tagName" select="'xml:base'" />
      <xsl:with-param name="value" select="$value" />
    </xsl:call-template>
  </xsl:template>
<!-- title -->
  <xsl:template name="_OutputTitle">
    <xsl:param name="value" />
    <xsl:param name="type" />
    <xsl:call-template name="_OutputTextElement">
      <xsl:with-param name="tagName" select="'title'" />
      <xsl:with-param name="value" select="$value" />
      <xsl:with-param name="type" select="$type" />
      <xsl:with-param name="outputTypeAttribute" select="'true'" />
    </xsl:call-template>
  </xsl:template>
<!-- link -->
  <xsl:template name="_OutputLink">
    <xsl:param name="value" />
    <xsl:call-template name="_OutputUrlElement">
      <xsl:with-param name="tagName" select="'link'" />
      <xsl:with-param name="value" select="$value" />
    </xsl:call-template>
  </xsl:template>
<!-- plain-text description -->
  <xsl:template name="_OutputTextDescription">
    <xsl:param name="value" />
    <xsl:param name="type" />
    <xsl:call-template name="_OutputTextElement">
      <xsl:with-param name="tagName" select="'description'" />
      <xsl:with-param name="value" select="$value" />
      <xsl:with-param name="type" select="$type" />
      <xsl:with-param name="outputTypeAttribute" select="'true'" />
    </xsl:call-template>
  </xsl:template>
<!-- pubDate -->
  <xsl:template name="_OutputPubDate">
    <xsl:param name="value" />
    <xsl:call-template name="_OutputDateElement">
      <xsl:with-param name="tagName" select="'pubDate'" />
      <xsl:with-param name="value" select="$value" />
    </xsl:call-template>
  </xsl:template>
<!-- language -->
  <xsl:template name="_OutputLanguage">
    <xsl:param name="value" />
    <xsl:call-template name="_OutputTextElement">
      <xsl:with-param name="tagName" select="'language'" />
      <xsl:with-param name="value" select="$value" />
    </xsl:call-template>
  </xsl:template>
<!-- copyright -->
  <xsl:template name="_OutputCopyright">
    <xsl:param name="value" />
    <xsl:param name="type" />
    <xsl:call-template name="_OutputTextElement">
      <xsl:with-param name="tagName" select="'copyright'" />
      <xsl:with-param name="value" select="$value" />
      <xsl:with-param name="type" select="$type" />
      <xsl:with-param name="outputTypeAttribute" select="'true'" />
    </xsl:call-template>
  </xsl:template>
<!-- lastBuildDate -->
  <xsl:template name="_OutputLastBuildDate">
    <xsl:param name="value" />
    <xsl:call-template name="_OutputDateElement">
      <xsl:with-param name="tagName" select="'lastBuildDate'" />
      <xsl:with-param name="value" select="$value" />
    </xsl:call-template>
  </xsl:template>
<!-- managingEditor -->
  <xsl:template name="_OutputManagingEditor">
    <xsl:param name="value" />
    <xsl:param name="convertToAtom" select="'false'" />
    <xsl:call-template name="_OutputAuthorOrEditor">
      <xsl:with-param name="tagName" select="'managingEditor'" />
      <xsl:with-param name="value" select="$value" />
      <xsl:with-param name="convertToAtom" select="$convertToAtom" />
    </xsl:call-template>
  </xsl:template>
<!-- webMaster -->
  <xsl:template name="_OutputWebMaster">
    <xsl:param name="value" />
    <xsl:call-template name="_OutputTextElement">
      <xsl:with-param name="tagName" select="'webMaster'" />
      <xsl:with-param name="value" select="$value" />
    </xsl:call-template>
  </xsl:template>
<!-- category -->
  <xsl:template name="_OutputCategory">
    <xsl:param name="value" />
    <xsl:param name="domain" />
    <xsl:variable name="_validatedValue" select="normalize-space($value)" />
    <xsl:if test="string($_validatedValue)">
      <xsl:element name="category">
        <xsl:call-template name="_OutputTextAttribute">
          <xsl:with-param name="tagName" select="'domain'" />
          <xsl:with-param name="value" select="$domain" />
        </xsl:call-template>
        <xsl:value-of select="$_validatedValue" />
      </xsl:element>
    </xsl:if>
  </xsl:template>
<!-- generator -->
  <xsl:template name="_OutputGenerator">
    <xsl:param name="value" />
    <xsl:param name="uri" />
    <xsl:param name="version" />
    <xsl:variable name="_validatedValue" select="normalize-space($value)" />
    <xsl:if test="string($_validatedValue)">
      <xsl:element name="generator">
        <xsl:call-template name="_OutputUriAttribute">
          <xsl:with-param name="tagName" select="'cf:uri'" />
          <xsl:with-param name="nameSpace" select="$_NScf" />
          <xsl:with-param name="value" select="$uri" />
        </xsl:call-template>
        <xsl:call-template name="_OutputTextAttribute">
          <xsl:with-param name="tagName" select="'cf:version'" />
          <xsl:with-param name="nameSpace" select="$_NScf" />
          <xsl:with-param name="value" select="$version" />
        </xsl:call-template>
        <xsl:value-of select="$_validatedValue" />
      </xsl:element>
    </xsl:if>
  </xsl:template>
<!-- docs -->
  <xsl:template name="_OutputDocs">
    <xsl:param name="value" />
    <xsl:call-template name="_OutputUrlElement">
      <xsl:with-param name="tagName" select="'docs'" />
      <xsl:with-param name="value" select="$value" />
    </xsl:call-template>
  </xsl:template>
<!-- cloud -->
  <xsl:template name="_OutputCloud">
    <xsl:param name="value" />
    <!-- We always output this element and clean any attribute it has into text -->
    <cloud>
      <xsl:for-each select="$value/@*">
        <xsl:attribute name="{name(.)}"><xsl:value-of select="normalize-space(.)"/></xsl:attribute>
      </xsl:for-each>
    </cloud>
  </xsl:template>
<!-- ttl -->
  <xsl:template name="_OutputTtl">
    <xsl:param name="value" />
    <xsl:call-template name="_OutputPositiveNumberElement">
      <xsl:with-param name="tagName" select="'ttl'" />
      <xsl:with-param name="value" select="$value" />
    </xsl:call-template>
  </xsl:template>
<!-- image -->
  <xsl:template name="_OutputImage">
    <xsl:param name="url" />
    <xsl:param name="title" />
    <xsl:param name="titleType" select="'text'" />
    <xsl:param name="link" />
    <xsl:param name="width" />
    <xsl:param name="height" />
    <xsl:param name="description" />
    <xsl:param name="subnodesToCopy" />
    <xsl:variable name="_validatedUrl" select="msfeednorm:ValidateUrl(normalize-space($url))" />
    <xsl:if test="string($_validatedUrl)">
      <image>
        <url><xsl:value-of select="$_validatedUrl" /></url>
        <xsl:call-template name="_OutputTextElement">
          <xsl:with-param name="tagName" select="'title'" />
          <xsl:with-param name="value" select="$title" />
          <xsl:with-param name="type" select="$titleType" />
        </xsl:call-template>
        <xsl:call-template name="_OutputUrlElement">
          <xsl:with-param name="tagName" select="'link'" />
          <xsl:with-param name="value" select="$link" />
        </xsl:call-template>
        <xsl:call-template name="_OutputPositiveNumberElement">
          <xsl:with-param name="tagName" select="'width'" />
          <xsl:with-param name="value" select="$width" />
        </xsl:call-template>
        <xsl:call-template name="_OutputPositiveNumberElement">
          <xsl:with-param name="tagName" select="'height'" />
          <xsl:with-param name="value" select="$height" />
        </xsl:call-template>
        <xsl:call-template name="_OutputTextElement">
          <xsl:with-param name="tagName" select="'description'" />
          <xsl:with-param name="value" select="$description" />
        </xsl:call-template>
        <xsl:if test="boolean($subnodesToCopy)">
          <xsl:for-each select="$subnodesToCopy">
            <xsl:copy-of select="." />
          </xsl:for-each>
        </xsl:if>
      </image>
    </xsl:if>
  </xsl:template>
<!-- rating -->
  <xsl:template name="_OutputRating">
    <xsl:param name="value" />
    <xsl:call-template name="_OutputTextElement">
      <xsl:with-param name="tagName" select="'rating'" />
      <xsl:with-param name="value" select="$value" />
    </xsl:call-template>
  </xsl:template>
<!-- textInput -->
  <xsl:template name="_OutputTextInput">
    <xsl:param name="title" />
    <xsl:param name="name" />
    <xsl:param name="link" />
    <xsl:param name="description" />
    <xsl:param name="subnodesToCopy" />
    <xsl:variable name="_validatedName" select="normalize-space($name)" />
    <xsl:variable name="_validatedLink" select="msfeednorm:ValidateUrl(normalize-space($link))" />
    <xsl:if test="string($_validatedName) and string($_validatedLink)">
      <textInput>
        <name><xsl:value-of select="$_validatedName" /></name>
        <link><xsl:value-of select="$_validatedLink" /></link>
        <xsl:call-template name="_OutputTextElement">
          <xsl:with-param name="tagName" select="'title'" />
          <xsl:with-param name="value" select="$title" />
        </xsl:call-template>
        <xsl:call-template name="_OutputTextElement">
          <xsl:with-param name="tagName" select="'description'" />
          <xsl:with-param name="value" select="$description" />
        </xsl:call-template>
        <xsl:if test="boolean($subnodesToCopy)">
          <xsl:for-each select="$subnodesToCopy">
            <xsl:copy-of select="." />
          </xsl:for-each>
        </xsl:if>
      </textInput>
    </xsl:if>
  </xsl:template>
<!-- skipHours -->
  <xsl:template name="_OutputSkipHours">
    <xsl:param name="value" />
    <xsl:if test="$value/hour[number(.)>=0 and number(.)&lt;=23]">
      <skipHours>
        <xsl:for-each select="$value/hour">
          <xsl:variable name="_numberHour" select="number(.)" />
          <xsl:if test="$_numberHour >= 0 and $_numberHour &lt;= 23">
            <hour><xsl:value-of select="$_numberHour" /></hour>
          </xsl:if>
        </xsl:for-each>
      </skipHours>
    </xsl:if>
  </xsl:template>
<!-- skipDays -->
  <xsl:template name="_OutputSkipDays">
    <xsl:param name="value" />
    <xsl:if test="$value/day[string(.) = 'Monday' or string(.) = 'Tuesday' or string(.) = 'Wednesday' or string(.) = 'Thursday' or string(.) = 'Friday' or string(.) = 'Saturday' or string(.) = 'Sunday']">
      <skipDays>
        <xsl:for-each select="$value/day">
          <xsl:variable name="_stringDay" select="string(.)" />
          <xsl:if test="$_stringDay = 'Monday' or $_stringDay = 'Tuesday' or $_stringDay = 'Wednesday' or $_stringDay = 'Thursday' or $_stringDay = 'Friday' or $_stringDay = 'Saturday' or $_stringDay = 'Sunday'">
            <day><xsl:value-of select="$_stringDay" /></day>
          </xsl:if>
        </xsl:for-each>
      </skipDays>
    </xsl:if>
  </xsl:template>
<!-- author -->
  <xsl:template name="_OutputAuthor">
    <xsl:param name="value" />
    <xsl:param name="convertToAtom" select="'false'" />
    <xsl:call-template name="_OutputAuthorOrEditor">
      <xsl:with-param name="tagName" select="'author'" />
      <xsl:with-param name="value" select="$value" />
      <xsl:with-param name="convertToAtom" select="$convertToAtom" />
    </xsl:call-template>
  </xsl:template>
<!-- comments -->
  <xsl:template name="_OutputComments">
    <xsl:param name="value" />
    <xsl:call-template name="_OutputUrlElement">
      <xsl:with-param name="tagName" select="'comments'" />
      <xsl:with-param name="value" select="$value" />
    </xsl:call-template>
  </xsl:template>
<!-- enclosure -->
  <xsl:template name="_OutputEnclosure">
    <xsl:param name="url" />
    <xsl:param name="length" />
    <xsl:param name="type" />
    <xsl:variable name="_validatedUrl" select="msfeednorm:ValidateUrl(normalize-space($url))" />
    <xsl:if test="string($_validatedUrl)">
      <enclosure>
        <xsl:attribute name="url"><xsl:value-of select="$_validatedUrl"/></xsl:attribute>
        <xsl:call-template name="_OutputPositiveNumberAttribute">
          <xsl:with-param name="tagName" select="'length'" />
          <xsl:with-param name="value" select="$length" />
        </xsl:call-template>
        <xsl:call-template name="_OutputMimeTypeAttribute">
          <xsl:with-param name="tagName" select="'type'" />
          <xsl:with-param name="value" select="$type" />
        </xsl:call-template>
      </enclosure>
    </xsl:if>
  </xsl:template>
<!-- guid -->
  <xsl:template name="_OutputGuid">
    <xsl:param name="value" />
    <xsl:param name="isPermaLink" />
    <xsl:param name="channelGuid" select="'false'" />
    <xsl:variable name="_validatedValue">
      <xsl:choose>
        <xsl:when test="normalize-space($isPermaLink) = 'true' or not(string($isPermaLink))">
          <xsl:value-of select="msfeednorm:ValidateUrl(normalize-space($value))" />
        </xsl:when>
        <xsl:otherwise>
          <xsl:value-of select="string($value)" />
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:if test="string($_validatedValue)">
      <xsl:choose>
        <xsl:when test="$channelGuid = 'false'">
          <xsl:element name="guid">
            <xsl:call-template name="_OutputBoolAttribute">
              <xsl:with-param name="tagName" select="'isPermaLink'" />
              <xsl:with-param name="value" select="$isPermaLink" />
            </xsl:call-template>
            <xsl:value-of select="$_validatedValue" />
          </xsl:element>
        </xsl:when>
        <xsl:otherwise>
          <xsl:element name="cf:guid" namespace="{$_NScf}">
            <xsl:call-template name="_OutputBoolAttribute">
              <xsl:with-param name="tagName" select="'isPermaLink'" />
              <xsl:with-param name="value" select="$isPermaLink" />
            </xsl:call-template>
            <xsl:value-of select="$_validatedValue" />
          </xsl:element>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:if>
  </xsl:template>
<!-- source -->
  <xsl:template name="_OutputSource">
    <xsl:param name="value" />
    <xsl:param name="url" />
    <xsl:variable name="_validatedValue" select="normalize-space($value)" />
    <xsl:if test="string($_validatedValue)">
      <xsl:element name="source">
        <xsl:call-template name="_OutputUrlAttribute">
          <xsl:with-param name="tagName" select="'url'" />
          <xsl:with-param name="value" select="$url" />
        </xsl:call-template>
        <xsl:value-of select="$_validatedValue" />
      </xsl:element>
    </xsl:if>
  </xsl:template>
<!-- rich-text description -->
  <xsl:template name="_OutputDescription">
    <xsl:param name="value" />
    <xsl:param name="type" />
    <xsl:param name="baseUrl" />
    <!-- Description is always html -->
    <description cf:type="html">
      <xsl:call-template name="_CleanByType">
        <xsl:with-param name="value" select="$value" />
        <xsl:with-param name="fromType" select="$type" />
        <xsl:with-param name="toType" select="'html'" />
        <xsl:with-param name="baseUrl" select="$baseUrl" />
      </xsl:call-template>
    </description>
  </xsl:template>
<!-- atom:summary -->
  <xsl:template name="_OutputAtomSummary">
    <xsl:param name="value" />
    <xsl:param name="type" />
    <xsl:param name="xmlBase" />
    <xsl:param name="baseUrl" />
    <atom:summary>
      <xsl:call-template name="_OutputXmlBase"><xsl:with-param name="value" select="$xmlBase" /></xsl:call-template>
      <xsl:call-template name="_NormalizeAtomTextTypeAttr"><xsl:with-param name="value" select="$type" /></xsl:call-template>
      <xsl:call-template name="_CleanByType">
        <xsl:with-param name="value" select="$value" />
        <xsl:with-param name="fromType" select="$type" />
        <xsl:with-param name="toType" select="$type" />
        <xsl:with-param name="baseUrl" select="$baseUrl" />
      </xsl:call-template>
    </atom:summary>
  </xsl:template>
<!-- description and summary (if it exists) -->
  <xsl:template name="_OutputDescriptionAndSummary">
    <xsl:param name="description" />
    <xsl:param name="descriptionType" />
    <xsl:param name="descriptionBaseUrl" />
    <xsl:param name="summary" />
    <xsl:param name="summaryType" />
    <xsl:param name="summaryXmlBase" />
    <xsl:param name="summaryBaseUrl" />
    <xsl:call-template name="_OutputDescription">
      <xsl:with-param name="value" select="$description" />
      <xsl:with-param name="type" select="$descriptionType" />
      <xsl:with-param name="baseUrl" select="$descriptionBaseUrl" />
    </xsl:call-template>
    <xsl:if test="string($summary)">
      <xsl:call-template name="_OutputAtomSummary">
        <xsl:with-param name="value" select="$summary" />
        <xsl:with-param name="type" select="$summaryType" />
        <xsl:with-param name="xmlBase" select="$summaryXmlBase" />
        <xsl:with-param name="baseUrl" select="$summaryBaseUrl" />
      </xsl:call-template>
    </xsl:if>
  </xsl:template>
<!-- atom:link -->
  <xsl:template name="_OutputAtomLink">
    <xsl:param name="href" />
    <xsl:param name="rel" />
    <xsl:param name="type" />
    <xsl:param name="title" />
    <xsl:param name="hreflang" />
    <xsl:param name="length" />
    <xsl:param name="xmlBase" />
    <xsl:variable name="_validatedHref" select="msfeednorm:ValidateUrl(normalize-space($href))" />
    <xsl:if test="string($_validatedHref)">
      <atom:link>
        <xsl:attribute name="href"><xsl:value-of select="$_validatedHref" /></xsl:attribute>
        <xsl:call-template name="_OutputTextAttribute">
          <xsl:with-param name="tagName" select="'rel'" />
          <xsl:with-param name="value" select="$rel" />
        </xsl:call-template>
        <xsl:call-template name="_OutputMimeTypeAttribute">
          <xsl:with-param name="tagName" select="'type'" />
          <xsl:with-param name="value" select="$type" />
        </xsl:call-template>
        <xsl:call-template name="_OutputTextAttribute">
          <xsl:with-param name="tagName" select="'title'" />
          <xsl:with-param name="value" select="$title" />
        </xsl:call-template>
        <xsl:call-template name="_OutputTextAttribute">
          <xsl:with-param name="tagName" select="'hreflang'" />
          <xsl:with-param name="value" select="$hreflang" />
        </xsl:call-template>
        <xsl:call-template name="_OutputPositiveNumberAttribute">
          <xsl:with-param name="tagName" select="'length'" />
          <xsl:with-param name="value" select="$length" />
        </xsl:call-template>
        <xsl:call-template name="_OutputXmlBase">
          <xsl:with-param name="value" select="$xmlBase" />
        </xsl:call-template>
      </atom:link>
    </xsl:if>
  </xsl:template>
<!-- atom:author -->
  <xsl:template name="_OutputAtomAuthor">
    <xsl:param name="name" />
    <xsl:param name="email" />
    <xsl:param name="uri" />
    <xsl:call-template name="_OutputAtomAuthorOrContributor">
      <xsl:with-param name="tagName" select="'atom:author'" />
      <xsl:with-param name="name" select="$name" />
      <xsl:with-param name="email" select="$email" />
      <xsl:with-param name="uri" select="$uri" />
    </xsl:call-template>
  </xsl:template>
<!-- atom:contributor -->
  <xsl:template name="_OutputAtomContributor">
    <xsl:param name="name" />
    <xsl:param name="email" />
    <xsl:param name="uri" />
    <xsl:call-template name="_OutputAtomAuthorOrContributor">
      <xsl:with-param name="tagName" select="'atom:contributor'" />
      <xsl:with-param name="name" select="$name" />
      <xsl:with-param name="email" select="$email" />
      <xsl:with-param name="uri" select="$uri" />
    </xsl:call-template>
  </xsl:template>
<!-- atom:published -->
  <xsl:template name="_OutputAtomPublished">
    <xsl:param name="value" />
    <xsl:call-template name="_OutputDateElement">
      <xsl:with-param name="tagName" select="'atom:published'" />
      <xsl:with-param name="nameSpace" select="$_NSatom1" />
      <xsl:with-param name="value" select="$value" />
      <xsl:with-param name="outFormat" select="'iso8601'" />
    </xsl:call-template>
  </xsl:template>
<!-- atom:updated -->
  <xsl:template name="_OutputAtomUpdated">
    <xsl:param name="value" />
    <xsl:call-template name="_OutputDateElement">
      <xsl:with-param name="tagName" select="'atom:updated'" />
      <xsl:with-param name="nameSpace" select="$_NSatom1" />
      <xsl:with-param name="value" select="$value" />
      <xsl:with-param name="outFormat" select="'iso8601'" />
    </xsl:call-template>
  </xsl:template>
<!-- slash:comments -->
  <xsl:template name="_OutputSlashComments">
    <xsl:param name="value" />
    <xsl:call-template name="_OutputPositiveNumberElement">
      <xsl:with-param name="tagName" select="'slash:comments'" />
      <xsl:with-param name="nameSpace" select="$_NSslash" />
      <xsl:with-param name="value" select="$value" />
    </xsl:call-template>
  </xsl:template>
<!-- wfw:commentRss -->
  <xsl:template name="_OutputWfwCommentRSS">
    <xsl:param name="value" />
    <xsl:call-template name="_OutputUrlElement">
      <xsl:with-param name="tagName" select="'wfw:commentRss'" />
      <xsl:with-param name="nameSpace" select="$_NSwfw" />
      <xsl:with-param name="value" select="$value" />
    </xsl:call-template>
  </xsl:template>
<!-- cf:treatAs -->
  <xsl:template name="_OutputCfTreatAs">
    <xsl:param name="value" />
    <xsl:call-template name="_OutputTextElement">
      <xsl:with-param name="tagName" select="'cf:treatAs'" />
      <xsl:with-param name="nameSpace" select="$_NScf" />
      <xsl:with-param name="value" select="$value" />
    </xsl:call-template>
  </xsl:template>
<!-- cf:listinfo -->
  <xsl:template name="_OutputCfListinfo">
    <xsl:param name="value" />
    <cf:listinfo>
      <xsl:for-each select="$value/cf:sort">
        <xsl:variable name="_ValidatedSortElem" select="normalize-space(@element)" />
        <xsl:variable name="_ValidatedSortLabel" select="normalize-space(@label)" />
        <xsl:if test="string($_ValidatedSortElem) or string($_ValidatedSortLabel)">
          <cf:sort>
            <xsl:if test="string($_ValidatedSortElem)">
              <xsl:attribute name="element"><xsl:value-of select="$_ValidatedSortElem"/></xsl:attribute>
            </xsl:if>
            <xsl:if test="string($_ValidatedSortLabel)">
              <xsl:attribute name="label"><xsl:value-of select="$_ValidatedSortLabel"/></xsl:attribute>
            </xsl:if>
            <xsl:call-template name="_OutputTextAttribute">
              <xsl:with-param name="tagName" select="'ns'" />
              <xsl:with-param name="value" select="@ns" />
            </xsl:call-template>
            <xsl:call-template name="_OutputTextAttribute">
              <xsl:with-param name="tagName" select="'data-type'" />
              <xsl:with-param name="value" select="@data-type" />
            </xsl:call-template>
            <xsl:call-template name="_OutputBoolAttribute">
              <xsl:with-param name="tagName" select="'default'" />
              <xsl:with-param name="value" select="@default" />
            </xsl:call-template>
          </cf:sort>
        </xsl:if>
      </xsl:for-each>
      <xsl:for-each select="$value/cf:group">
        <xsl:variable name="_ValidatedGroupElem" select="normalize-space(@element)" />
        <xsl:variable name="_ValidatedGroupLabel" select="normalize-space(@label)" />
        <xsl:if test="string($_ValidatedGroupElem) or string($_ValidatedGroupLabel)">
          <cf:group>
            <xsl:if test="string($_ValidatedGroupElem)">
              <xsl:attribute name="element"><xsl:value-of select="$_ValidatedGroupElem"/></xsl:attribute>
            </xsl:if>
            <xsl:if test="string($_ValidatedGroupLabel)">
              <xsl:attribute name="label"><xsl:value-of select="$_ValidatedGroupLabel"/></xsl:attribute>
            </xsl:if>
            <xsl:call-template name="_OutputTextAttribute">
              <xsl:with-param name="tagName" select="'ns'" />
              <xsl:with-param name="value" select="@ns" />
            </xsl:call-template>
          </cf:group>
        </xsl:if>
      </xsl:for-each>
    </cf:listinfo>
  </xsl:template>
<!-- mon:expiration -->
  <xsl:template name="_OutputMonExpiration">
    <xsl:param name="value" />
    <xsl:call-template name="_OutputDateElement">
      <xsl:with-param name="tagName" select="'mon:expiration'" />
      <xsl:with-param name="nameSpace" select="$_NSmon" />
      <xsl:with-param name="value" select="$value" />
      <xsl:with-param name="outFormat" select="'iso8601'" />
    </xsl:call-template>
  </xsl:template>
<!-- output the extension nodes -->
  <xsl:template name="_OutputExtension">
    <xsl:param name="value" />
    <xsl:param name="references" />
    <xsl:if test="namespace-uri($value) != $_NScfi">
      <xsl:variable name="nodeRefName">'<xsl:value-of select="namespace-uri($value)"/>':<xsl:value-of select="local-name($value)"/>;</xsl:variable>
      <xsl:choose>
        <xsl:when test="string($references) and contains($references, $nodeRefName)">
          <xsl:call-template name="_OutputTextElement">
            <xsl:with-param name="value" select="$value" />
            <xsl:with-param name="tagName" select="name($value)" />
            <xsl:with-param name="nameSpace" select="namespace-uri($value)" />
          </xsl:call-template>
        </xsl:when>
        <xsl:otherwise>
          <xsl:copy-of select="$value" />
        </xsl:otherwise>
      </xsl:choose>
    </xsl:if>
  </xsl:template>
</xsl:stylesheet>
<?xml version="1.0" ?>
<xsl:stylesheet version="1.0" 
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform" 
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:dcterms="http://purl.org/dc/terms/"
  xmlns:cf="http://www.microsoft.com/schemas/rss/core/2005"
  xmlns:msfeednorm="urn:microsoft:feed-normalization"
  exclude-result-prefixes="dcterms msfeednorm"
<!-- Shared templates -->
  <xsl:import href="res://msfeeds.dll/SharedNormalizer.xsl" />
<!-- Output XML UTF-8 -->
  <xsl:output method="xml" encoding="utf-8" />
<!-- Figure out the type for RSS 2.0 text fields -->
  <xsl:template name="_GetRSS2TypeValue">
    <xsl:param name="type" />
    <xsl:param name="default" />
    <xsl:choose>
      <xsl:when test="normalize-space($type) = 'html'">html</xsl:when>
      <xsl:when test="normalize-space($type) = 'text'">text</xsl:when>
      <xsl:when test="not(string($type)) or normalize-space($type) = ''"><xsl:value-of select="$default" /></xsl:when>
      <xsl:otherwise>invalid</xsl:otherwise>
      <!-- Note that unknown value for a type will yield empty output -->
    </xsl:choose>
  </xsl:template>
<!-- Entry point -->
  <xsl:template match="/rss">
    <rss>
      <!-- Copy all namespaces -->
      <xsl:for-each select="namespace::*"><xsl:copy /></xsl:for-each>
      <!-- Ensure version is 2.0 -->
      <xsl:attribute name="version">2.0</xsl:attribute>
      <!-- Process channel -->
      <channel>
        <xsl:apply-templates select="channel" />
      </channel>
    </rss>
  </xsl:template>
<!-- Channel processing -->
  <xsl:template match="channel">
    <!-- Copy all namespaces -->
    <xsl:for-each select="namespace::*">
      <xsl:copy />
    </xsl:for-each>
    <xsl:call-template name="_OutputXmlBase"><xsl:with-param name="value" select="@xml:base" /></xsl:call-template>
    <xsl:call-template name="_OutputXmlLang"><xsl:with-param name="value" select="@xml:lang" /></xsl:call-template>
    <xsl:if test="not(language)">
      <xsl:call-template name="_OutputLanguage"><xsl:with-param name="value" select="@xml:lang" /></xsl:call-template>
    </xsl:if>
    <!-- Figure out the base URL value; xml:base overrides the download URL -->
    <xsl:variable name="baseChannelUrl">
      <xsl:call-template name="_GetFeedBaseUrl">
        <xsl:with-param name="downloadUrl" select="$downloadUrl" />
        <xsl:with-param name="rootNode" select="." />
      </xsl:call-template>
    </xsl:variable>
    <!-- Build a list of referenced nodes from cf:sort and cf:group -->
    <xsl:variable name="cfReferences">
      <xsl:call-template name="_BuildCfReferenceList"><xsl:with-param name="value" select="." /></xsl:call-template>
    </xsl:variable>
    <!-- Process channel elements -->
    <xsl:apply-templates select="*" mode="channel">
      <xsl:with-param name="baseChannelUrl" select="$baseChannelUrl" />
    </xsl:apply-templates>
    <!-- Process items -->
    <xsl:apply-templates select="item">
      <xsl:with-param name="baseChannelUrl" select="$baseChannelUrl" />
      <xsl:with-param name="references" select="$cfReferences" />
    </xsl:apply-templates>
  </xsl:template>
  <xsl:template match="*" mode="channel">
    <xsl:param name="baseChannelUrl" />
    <xsl:variable name="isFirst">
      <xsl:call-template name="_IsFirstChildOfItsKind"><xsl:with-param name="value" select="." /></xsl:call-template>
    </xsl:variable>
    <xsl:choose>
      <xsl:when test="namespace-uri(.) = '' and local-name(.) = 'title' and $isFirst = 'true'">
        <xsl:variable name="type">
          <xsl:call-template name="_GetRSS2TypeValue">
            <xsl:with-param name="type" select="@cf:type" />
            <xsl:with-param name="default" select="'text'" />
          </xsl:call-template>
        </xsl:variable>
        <xsl:call-template name="_OutputTitle">
          <xsl:with-param name="value" select="." />
          <xsl:with-param name="type" select="$type" />
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = '' and local-name(.) = 'link' and $isFirst = 'true'">
        <xsl:variable name="linkUrl">
          <xsl:call-template name="_CompleteUrl">
            <xsl:with-param name="baseUrl" select="$baseChannelUrl" />
            <xsl:with-param name="Url" select="." />
          </xsl:call-template>
        </xsl:variable>
        <xsl:call-template name="_OutputLink"><xsl:with-param name="value" select="$linkUrl" /></xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = '' and local-name(.) = 'description' and $isFirst = 'true'">
        <xsl:variable name="type">
          <xsl:call-template name="_GetRSS2TypeValue">
            <xsl:with-param name="type" select="@cf:type" />
            <xsl:with-param name="default" select="'text'" />
          </xsl:call-template>
        </xsl:variable>
        <xsl:call-template name="_OutputTextDescription">
          <xsl:with-param name="value" select="." />
          <xsl:with-param name="type" select="$type" />
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = '' and local-name(.) = 'pubDate' and $isFirst = 'true'">
        <xsl:call-template name="_OutputPubDate"><xsl:with-param name="value" select="." /></xsl:call-template>
        <xsl:if test="not(../lastBuildDate)">
          <xsl:call-template name="_OutputLastBuildDate"><xsl:with-param name="value" select="." /></xsl:call-template>
          <xsl:if test="not(../atom:updated)">
            <xsl:call-template name="_OutputAtomUpdated"><xsl:with-param name="value" select="." /></xsl:call-template>
          </xsl:if>
        </xsl:if>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSatom1 and local-name(.) = 'published'">
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSatom1 and local-name(.) = 'updated'">
        <xsl:if test="$isFirst = 'true'">
          <xsl:call-template name="_OutputAtomUpdated"><xsl:with-param name="value" select="." /></xsl:call-template>
          <xsl:if test="not(../pubDate) and not(../lastBuildDate)">
            <xsl:call-template name="_OutputLastBuildDate"><xsl:with-param name="value" select="." /></xsl:call-template>
          </xsl:if>
        </xsl:if>  
      </xsl:when>
      <xsl:when test="namespace-uri(.) = '' and local-name(.) = 'language' and $isFirst = 'true'">
        <xsl:call-template name="_OutputLanguage"><xsl:with-param name="value" select="." /></xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = '' and local-name(.) = 'copyright' and $isFirst = 'true'">
        <xsl:variable name="type">
          <xsl:call-template name="_GetRSS2TypeValue">
            <xsl:with-param name="type" select="@cf:type" />
            <xsl:with-param name="default" select="'text'" />
          </xsl:call-template>
        </xsl:variable>
        <xsl:call-template name="_OutputCopyright">
          <xsl:with-param name="value" select="." />
          <xsl:with-param name="type" select="$type" />
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = '' and local-name(.) = 'lastBuildDate' and $isFirst = 'true'">
        <xsl:call-template name="_OutputLastBuildDate"><xsl:with-param name="value" select="." /></xsl:call-template>
        <xsl:if test="not(../atom:updated)">
          <xsl:call-template name="_OutputAtomUpdated"><xsl:with-param name="value" select="." /></xsl:call-template>
        </xsl:if>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = '' and local-name(.) = 'managingEditor' and $isFirst = 'true'">
        <xsl:variable name="convertToAtom">
          <xsl:choose>
            <xsl:when test="../atom:author">false</xsl:when>
            <xsl:otherwise>true</xsl:otherwise>
          </xsl:choose>
        </xsl:variable>
        <xsl:call-template name="_OutputManagingEditor">
          <xsl:with-param name="value" select="." />
          <xsl:with-param name="convertToAtom" select="$convertToAtom" />
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = '' and local-name(.) = 'webMaster' and $isFirst = 'true'">
        <xsl:call-template name="_OutputWebMaster"><xsl:with-param name="value" select="." /></xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = '' and local-name(.) = 'category'">
        <xsl:call-template name="_OutputCategory">
          <xsl:with-param name="value" select="." />
          <xsl:with-param name="domain" select="@domain" />
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = '' and local-name(.) = 'generator' and $isFirst = 'true'">
        <xsl:call-template name="_OutputGenerator">
          <xsl:with-param name="value" select="." />
          <xsl:with-param name="uri" select="@cf:uri" />
          <xsl:with-param name="version" select="@cf:version" />
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = '' and local-name(.) = 'docs' and $isFirst = 'true'">
        <xsl:call-template name="_OutputDocs"><xsl:with-param name="value" select="." /></xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = '' and local-name(.) = 'cloud' and $isFirst = 'true'">
        <xsl:call-template name="_OutputCloud"><xsl:with-param name="value" select="." /></xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = '' and local-name(.) = 'ttl' and $isFirst = 'true'">
        <xsl:call-template name="_OutputTtl"><xsl:with-param name="value" select="." /></xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = '' and local-name(.) = 'image' and $isFirst = 'true'">
        <xsl:variable name="imageUrl">
          <xsl:call-template name="_CompleteUrl">
            <xsl:with-param name="baseUrl" select="$baseChannelUrl" />
            <xsl:with-param name="Url" select="url" />
          </xsl:call-template>
        </xsl:variable>
        <xsl:variable name="imageLink">
          <xsl:call-template name="_CompleteUrl">
            <xsl:with-param name="baseUrl" select="$baseChannelUrl" />
            <xsl:with-param name="Url" select="link" />
          </xsl:call-template>
        </xsl:variable>
        <xsl:call-template name="_OutputImage">
          <xsl:with-param name="url" select="$imageUrl" />
          <xsl:with-param name="title" select="title" />
          <xsl:with-param name="link" select="$imageLink" />
          <xsl:with-param name="width" select="width" />
          <xsl:with-param name="height" select="height" />
          <xsl:with-param name="description" select="description" />
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = '' and local-name(.) = 'rating' and $isFirst = 'true'">
        <xsl:call-template name="_OutputRating"><xsl:with-param name="value" select="." /></xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = '' and local-name(.) = 'textInput' and $isFirst = 'true'">
        <xsl:call-template name="_OutputTextInput">
          <xsl:with-param name="title" select="title" />
          <xsl:with-param name="name" select="name" />
          <xsl:with-param name="link" select="link" />
          <xsl:with-param name="description" select="description" />
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = '' and local-name(.) = 'skipHours' and $isFirst = 'true'">
        <xsl:call-template name="_OutputSkipHours"><xsl:with-param name="value" select="." /></xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = '' and local-name(.) = 'skipDays' and $isFirst = 'true'">
        <xsl:call-template name="_OutputSkipDays"><xsl:with-param name="value" select="." /></xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSatom1 and local-name(.) = 'link'">
        <xsl:call-template name="_OutputAtomLink">
          <xsl:with-param name="href" select="@href" />
          <xsl:with-param name="rel" select="@rel" />
          <xsl:with-param name="type" select="@type" />
          <xsl:with-param name="title" select="@title" />
          <xsl:with-param name="hreflang" select="@hreflang" />
          <xsl:with-param name="length" select="@length" />
          <xsl:with-param name="xmlBase" select="@xml:base" />
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSatom1 and local-name(.) = 'author'">
        <xsl:if test="$isFirst = 'true'">
          <xsl:call-template name="_OutputAtomAuthor">
            <xsl:with-param name="name" select="atom:name" />
            <xsl:with-param name="email" select="atom:email" />
            <xsl:with-param name="uri" select="atom:uri" />
          </xsl:call-template>
        </xsl:if>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSatom1 and local-name(.) = 'contributor'">
          <xsl:call-template name="_OutputAtomContributor">
            <xsl:with-param name="name" select="atom:name" />
            <xsl:with-param name="email" select="atom:email" />
            <xsl:with-param name="uri" select="atom:uri" />
          </xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NScf and local-name(.) = 'treatAs'">
        <xsl:if test="$isFirst = 'true'">
          <xsl:call-template name="_OutputCfTreatAs"><xsl:with-param name="value" select="." /></xsl:call-template>
        </xsl:if>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NScf and local-name(.) = 'listinfo'">
        <xsl:if test="$isFirst = 'true'">
          <xsl:call-template name="_OutputCfListinfo"><xsl:with-param name="value" select="." /></xsl:call-template>
        </xsl:if>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = '' and local-name(.) = 'item'">
        <!-- Do nothing here for items -->
      </xsl:when>
      <!-- Copy extension nodes -->
      <xsl:when test="namespace-uri(.) != ''">
        <xsl:call-template name="_OutputExtension"><xsl:with-param name="value" select="." /></xsl:call-template>
      </xsl:when>
    </xsl:choose>
  </xsl:template>
<!-- Item processing -->
  <xsl:template match="item">
    <xsl:param name="baseChannelUrl" />
    <xsl:param name="references" />
    <item>
      <!-- Copy all namespaces -->
      <xsl:for-each select="namespace::*">
        <xsl:copy />
      </xsl:for-each>
      <xsl:call-template name="_OutputXmlBase"><xsl:with-param name="value" select="@xml:base" /></xsl:call-template>
      <xsl:call-template name="_OutputXmlLang"><xsl:with-param name="value" select="@xml:lang" /></xsl:call-template>
      <!-- Item's base URL stacks onto channel's base URL -->
      <xsl:variable name="baseChannelItemUrl">
        <xsl:call-template name="_CombineUrls">
          <xsl:with-param name="baseUrl" select="$baseChannelUrl" />
          <xsl:with-param name="relUrl" select="@xml:base" />
        </xsl:call-template>
      </xsl:variable>
      <!-- Process item elements -->
      <xsl:apply-templates select="*" mode="item">
        <xsl:with-param name="baseItemUrl" select="$baseChannelItemUrl" />
        <xsl:with-param name="references" select="$references" />
      </xsl:apply-templates>
    </item>
  </xsl:template>
  <xsl:template match="*" mode="item">
    <xsl:param name="baseItemUrl" />
    <xsl:param name="references" />
    <xsl:variable name="isFirst">
      <xsl:call-template name="_IsFirstChildOfItsKind"><xsl:with-param name="value" select="." /></xsl:call-template>
    </xsl:variable>
    <xsl:choose>
      <xsl:when test="namespace-uri(.) = '' and local-name(.) = 'title' and $isFirst = 'true'">
        <xsl:variable name="type">
          <xsl:call-template name="_GetRSS2TypeValue">
            <xsl:with-param name="type" select="@cf:type" />
            <xsl:with-param name="default" select="'text'" />
          </xsl:call-template>
        </xsl:variable>
        <xsl:call-template name="_OutputTitle">
          <xsl:with-param name="value" select="." />
          <xsl:with-param name="type" select="$type" />
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = '' and local-name(.) = 'link' and $isFirst = 'true'">
        <xsl:variable name="linkUrl">
          <xsl:call-template name="_CompleteUrl">
            <xsl:with-param name="baseUrl" select="$baseItemUrl" />
            <xsl:with-param name="Url" select="." />
          </xsl:call-template>
        </xsl:variable>
        <xsl:call-template name="_OutputLink"><xsl:with-param name="value" select="$linkUrl" /></xsl:call-template>
      </xsl:when>
      <xsl:when test="(namespace-uri(.) = '' and local-name(.) = 'author') or (namespace-uri(.) = $_NSdc and local-name(.) = 'creator')">
        <xsl:variable name="convertToAtom">
          <xsl:choose>
            <xsl:when test="../atom:author">false</xsl:when>
            <xsl:otherwise>true</xsl:otherwise>
          </xsl:choose>
        </xsl:variable>
        <xsl:call-template name="_OutputAuthor">
          <xsl:with-param name="value" select="." />
          <xsl:with-param name="convertToAtom" select="$convertToAtom" />
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSatom1 and local-name(.) = 'contributor'">
        <xsl:call-template name="_OutputAtomContributor">
          <xsl:with-param name="name" select="atom:name" />
          <xsl:with-param name="email" select="atom:email" />
          <xsl:with-param name="uri" select="atom:uri" />
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = '' and local-name(.) = 'category'">
        <xsl:call-template name="_OutputCategory">
          <xsl:with-param name="value" select="." />
          <xsl:with-param name="domain" select="@domain" />
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = '' and local-name(.) = 'comments' and $isFirst = 'true'">
        <xsl:variable name="commentUrl">
          <xsl:call-template name="_CompleteUrl">
            <xsl:with-param name="baseUrl" select="$baseItemUrl" />
            <xsl:with-param name="Url" select="." />
          </xsl:call-template>
        </xsl:variable>
        <xsl:call-template name="_OutputComments"><xsl:with-param name="value" select="$commentUrl" /></xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = '' and local-name(.) = 'enclosure'">
        <xsl:variable name="enclosureUrl">
          <xsl:call-template name="_CompleteUrl">
            <xsl:with-param name="baseUrl" select="$baseItemUrl" />
            <xsl:with-param name="Url" select="@url" />
          </xsl:call-template>
        </xsl:variable>
        <xsl:call-template name="_OutputEnclosure">
          <xsl:with-param name="url" select="$enclosureUrl" />
          <xsl:with-param name="length" select="@length" />
          <xsl:with-param name="type" select="@type" />
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = '' and local-name(.) = 'guid' and $isFirst = 'true'">
        <xsl:choose>
          <xsl:when test="normalize-space(@isPermaLink) = 'true' or not(string(@isPermaLink))">
            <xsl:variable name="linkUrl">
              <xsl:call-template name="_CompleteUrl">
                <xsl:with-param name="baseUrl" select="$baseItemUrl" />
                <xsl:with-param name="Url" select="." />
              </xsl:call-template>
            </xsl:variable>
            <xsl:call-template name="_OutputGuid">
              <xsl:with-param name="value" select="$linkUrl" />
              <xsl:with-param name="isPermaLink" select="@isPermaLink" />
            </xsl:call-template>
            <!-- If there is no link we'll use permalink guid instead -->
            <xsl:if test="not(../link)">
              <xsl:call-template name="_OutputLink"><xsl:with-param name="value" select="$linkUrl" /></xsl:call-template>
            </xsl:if>
          </xsl:when>
          <xsl:otherwise>
            <xsl:call-template name="_OutputGuid">
              <xsl:with-param name="value" select="." />
              <xsl:with-param name="isPermaLink" select="@isPermaLink" />
            </xsl:call-template>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = '' and local-name(.) = 'pubDate' and $isFirst = 'true'">
        <xsl:call-template name="_OutputPubDate"><xsl:with-param name="value" select="." /></xsl:call-template>
        <xsl:if test="not(../atom:published)">
          <xsl:call-template name="_OutputAtomPublished"><xsl:with-param name="value" select="." /></xsl:call-template>
        </xsl:if>
        <xsl:if test="not(../atom:updated) and not(../dcterms:modified)">
          <xsl:call-template name="_OutputAtomUpdated"><xsl:with-param name="value" select="." /></xsl:call-template>
        </xsl:if>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSdc and local-name(.) = 'date'">
        <xsl:if test="$isFirst = 'true' and not(../pubDate) and not(../dcterms:modified) and not(../atom:updated)">
          <xsl:call-template name="_OutputAtomUpdated"><xsl:with-param name="value" select="." /></xsl:call-template>
        </xsl:if>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSdcterms and local-name(.) = 'modified'">
        <xsl:if test="$isFirst = 'true' and not(../atom:updated)">
          <xsl:call-template name="_OutputAtomUpdated"><xsl:with-param name="value" select="." /></xsl:call-template>
        </xsl:if>  
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSatom1 and local-name(.) = 'updated'">
        <xsl:if test="$isFirst = 'true'">
          <xsl:call-template name="_OutputAtomUpdated"><xsl:with-param name="value" select="." /></xsl:call-template>
        </xsl:if>  
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSatom1 and local-name(.) = 'published'">
        <xsl:if test="$isFirst = 'true'">
          <xsl:call-template name="_OutputAtomPublished"><xsl:with-param name="value" select="." /></xsl:call-template>
          <xsl:if test="not(../pubDate)">
            <xsl:call-template name="_OutputPubDate"><xsl:with-param name="value" select="." /></xsl:call-template>
          </xsl:if>
        </xsl:if>  
      </xsl:when>
      <xsl:when test="namespace-uri(.) = '' and local-name(.) = 'source' and $isFirst = 'true'">
        <xsl:variable name="srcUrl">
          <xsl:call-template name="_CompleteUrl">
            <xsl:with-param name="baseUrl" select="$baseItemUrl" />
            <xsl:with-param name="Url" select="@url" />
          </xsl:call-template>
        </xsl:variable>
        <xsl:call-template name="_OutputSource">
          <xsl:with-param name="value" select="." />
          <xsl:with-param name="url" select="$srcUrl" />
        </xsl:call-template>
      </xsl:when>
      <!-- content:encoded takes precedence over the description -->
      <xsl:when test="namespace-uri(.) = $_NScontent and local-name(.) = 'encoded'">
        <xsl:if test="$isFirst = 'true'">
          <xsl:variable name="summType">
            <xsl:call-template name="_GetRSS2TypeValue">
              <xsl:with-param name="type" select="../description/@cf:type" />
              <xsl:with-param name="default" select="'html'" />
            </xsl:call-template>
          </xsl:variable>
          <xsl:variable name="baseDescUrl">
            <xsl:call-template name="_CombineUrls">
              <xsl:with-param name="baseUrl" select="$baseItemUrl" />
              <xsl:with-param name="relUrl" select="@xml:base" />
            </xsl:call-template>
          </xsl:variable>
          <xsl:variable name="baseSummUrl">
            <xsl:call-template name="_CombineUrls">
              <xsl:with-param name="baseUrl" select="$baseItemUrl" />
              <xsl:with-param name="relUrl" select="../description/@xml:base" />
            </xsl:call-template>
          </xsl:variable>
          <xsl:call-template name="_OutputDescriptionAndSummary">
            <xsl:with-param name="description" select="." />
            <xsl:with-param name="descriptionType" select="'html'" />
            <xsl:with-param name="descriptionBaseUrl" select="$baseDescUrl" />
            <xsl:with-param name="summary" select="../description" />
            <xsl:with-param name="summaryType" select="$summType" />
            <xsl:with-param name="summaryXmlBase" select="../description/@xml:base" />
            <xsl:with-param name="summaryBaseUrl" select="$baseSummUrl" />
          </xsl:call-template>
        </xsl:if>
      </xsl:when>
      <!-- description will be used if there is no content:encoded -->
      <xsl:when test="namespace-uri(.) = '' and local-name(.) = 'description' and $isFirst = 'true'">
        <xsl:if test="not(../*[namespace-uri(.) = $_NScontent and local-name(.) = 'encoded'])">
          <xsl:variable name="type">
            <xsl:call-template name="_GetRSS2TypeValue">
              <xsl:with-param name="type" select="@cf:type" />
              <xsl:with-param name="default" select="'html'" />
            </xsl:call-template>
          </xsl:variable>
          <xsl:variable name="baseDescUrl">
            <xsl:call-template name="_CombineUrls">
              <xsl:with-param name="baseUrl" select="$baseItemUrl" />
              <xsl:with-param name="relUrl" select="@xml:base" />
            </xsl:call-template>
          </xsl:variable>
          <xsl:call-template name="_OutputDescription">
            <xsl:with-param name="value" select="." />
            <xsl:with-param name="type" select="$type" />
            <xsl:with-param name="baseUrl" select="$baseDescUrl" />
          </xsl:call-template>
        </xsl:if>
      </xsl:when>
      <!-- atom:summary will be preserved unless both content:encoded and description are present -->
      <xsl:when test="namespace-uri(.) = $_NSatom1 and local-name(.) = 'summary'">
        <xsl:if test="$isFirst = 'true' and not(../description and ../*[namespace-uri(.) = $_NScontent and local-name(.) = 'encoded'])">
          <xsl:variable name="baseSummUrl">
            <xsl:call-template name="_CombineUrls">
              <xsl:with-param name="baseUrl" select="$baseItemUrl" />
              <xsl:with-param name="relUrl" select="@xml:base" />
            </xsl:call-template>
          </xsl:variable>
          <xsl:call-template name="_OutputAtomSummary">
            <xsl:with-param name="value" select="." />
            <xsl:with-param name="type" select="@type" />
            <xsl:with-param name="xmlBase" select="@xml:base" />
            <xsl:with-param name="baseUrl" select="$baseSummUrl" />
          </xsl:call-template>
        </xsl:if>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSatom1 and local-name(.) = 'link'">
        <!-- Special handling for item level atom:link with rel=entry-content: complete relative URL -->
        <xsl:variable name="atomLinkUrl">
          <xsl:choose>
            <xsl:when test="@rel = 'entry-content'">
              <xsl:call-template name="_CombineUrls">
                <xsl:with-param name="baseUrl" select="$baseItemUrl" />
                <xsl:with-param name="relUrl" select="@href" />
              </xsl:call-template>
            </xsl:when>
            <xsl:otherwise>
              <xsl:value-of select="@href" />
            </xsl:otherwise>
          </xsl:choose>
        </xsl:variable>
        <xsl:call-template name="_OutputAtomLink">
          <xsl:with-param name="href" select="$atomLinkUrl" />
          <xsl:with-param name="rel" select="@rel" />
          <xsl:with-param name="type" select="@type" />
          <xsl:with-param name="title" select="@title" />
          <xsl:with-param name="hreflang" select="@hreflang" />
          <xsl:with-param name="length" select="@length" />
          <xsl:with-param name="xmlBase" select="@xml:base" />
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSatom1 and local-name(.) = 'author'">
        <xsl:call-template name="_OutputAtomAuthor">
          <xsl:with-param name="name" select="atom:name" />
          <xsl:with-param name="email" select="atom:email" />
          <xsl:with-param name="uri" select="atom:uri" />
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSslash and local-name(.) = 'comments'">
        <xsl:if test="$isFirst = 'true'">
          <xsl:call-template name="_OutputSlashComments"><xsl:with-param name="value" select="." /></xsl:call-template>
        </xsl:if>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSwfw and (local-name(.) = 'commentRss' or local-name(.) = 'commentRSS')">
        <xsl:if test="$isFirst = 'true'">
          <xsl:variable name="commentRssUrl">
            <xsl:call-template name="_CompleteUrl">
              <xsl:with-param name="baseUrl" select="$baseItemUrl" />
              <xsl:with-param name="Url" select="." />
            </xsl:call-template>
          </xsl:variable>
          <xsl:call-template name="_OutputWfwCommentRSS"><xsl:with-param name="value" select="$commentRssUrl" /></xsl:call-template>
        </xsl:if>
      </xsl:when>
      <!-- Copy extension nodes -->
      <xsl:when test="namespace-uri(.) != ''">
        <xsl:call-template name="_OutputExtension">
          <xsl:with-param name="value" select="." />
          <xsl:with-param name="references" select="$references" />
        </xsl:call-template>
      </xsl:when>
    </xsl:choose>
  </xsl:template>
</xsl:stylesheet><?xml version="1.0" ?>
<xsl:stylesheet version="1.0" 
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform" 
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:cf="http://www.microsoft.com/schemas/rss/core/2005"
  xmlns:content="http://purl.org/rss/1.0/modules/content/"
  xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
  xmlns:rss="http://purl.org/rss/1.0/"
  xmlns:dc="http://purl.org/dc/elements/1.1/"
  xmlns:dcterms="http://purl.org/dc/terms/"
  xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
  xmlns:msfeednorm="urn:microsoft:feed-normalization" 
  exclude-result-prefixes="content rdf rss dc dcterms sy msfeednorm"
<!-- Shared templates -->
  <xsl:import href="res://msfeeds.dll/SharedNormalizer.xsl" />
<!-- Output XML UTF-8 -->
  <xsl:output method="xml" encoding="utf-8" />
<!-- Entry point -->
  <xsl:template match="/rdf:RDF">
    <rss version="2.0">
      <channel>
        <!-- Build a list of referenced nodes from cf:sort and cf:group -->
        <xsl:variable name="cfReferences">
          <xsl:call-template name="_BuildCfReferenceList"><xsl:with-param name="value" select="rss:channel" /></xsl:call-template>
        </xsl:variable>
        <!-- Process feed elements -->
        <xsl:apply-templates select="rss:channel" />
        <xsl:apply-templates select="rss:image" />
        <xsl:apply-templates select="rss:textinput" />
        <xsl:apply-templates select="rss:item">
          <xsl:with-param name="references" select="$cfReferences" />
        </xsl:apply-templates>
      </channel>
    </rss>
  </xsl:template>
<!-- Channel processing -->
  <xsl:template match="rss:channel">
    <xsl:apply-templates select="*" mode="channel" />
  </xsl:template>
  <xsl:template match="*" mode="channel">
    <xsl:variable name="isFirst">
      <xsl:call-template name="_IsFirstChildOfItsKind"><xsl:with-param name="value" select="." /></xsl:call-template>
    </xsl:variable>
    <xsl:choose>
      <xsl:when test="namespace-uri(.) = $_NSrss and local-name(.) = 'title' and $isFirst = 'true'">
        <xsl:call-template name="_OutputTitle"><xsl:with-param name="value" select="." /></xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSrss and local-name(.) = 'link' and $isFirst = 'true'">
        <xsl:variable name="linkUrl">
          <xsl:call-template name="_CompleteUrl">
            <xsl:with-param name="baseUrl" select="$downloadUrl" />
            <xsl:with-param name="Url" select="." />
          </xsl:call-template>
        </xsl:variable>
        <xsl:call-template name="_OutputLink"><xsl:with-param name="value" select="$linkUrl" /></xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSrss and local-name(.) = 'description' and $isFirst = 'true'">
        <xsl:call-template name="_OutputTextDescription"><xsl:with-param name="value" select="." /></xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSdc and local-name(.) = 'creator'">
        <xsl:if test="$isFirst = 'true'">
          <xsl:call-template name="_OutputManagingEditor">
            <xsl:with-param name="value" select="." />
            <xsl:with-param name="convertToAtom" select="'true'" />
          </xsl:call-template>
        </xsl:if>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSdc and local-name(.) = 'subject'">
        <xsl:call-template name="_OutputCategory"><xsl:with-param name="value" select="." /></xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSdc and local-name(.) = 'publisher'">
        <xsl:if test="$isFirst = 'true'">
          <xsl:call-template name="_OutputWebMaster"><xsl:with-param name="value" select="." /></xsl:call-template>
        </xsl:if>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSdc and local-name(.) = 'language'">
        <xsl:if test="$isFirst = 'true'">
          <xsl:call-template name="_OutputLanguage"><xsl:with-param name="value" select="." /></xsl:call-template>
        </xsl:if>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSdc and local-name(.) = 'rights'">
        <xsl:if test="$isFirst = 'true'">
          <xsl:call-template name="_OutputCopyright"><xsl:with-param name="value" select="." /></xsl:call-template>
        </xsl:if>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSdcterms and local-name(.) = 'modified'">
        <xsl:if test="$isFirst = 'true'">
          <xsl:call-template name="_OutputLastBuildDate"><xsl:with-param name="value" select="." /></xsl:call-template>
          <xsl:if test="not(../atom:updated)">
            <xsl:call-template name="_OutputAtomUpdated"><xsl:with-param name="value" select="." /></xsl:call-template>
          </xsl:if>
        </xsl:if>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSdc and local-name(.) = 'date'">
        <xsl:if test="$isFirst = 'true'">
          <xsl:call-template name="_OutputPubDate"><xsl:with-param name="value" select="." /></xsl:call-template>
          <xsl:if test="not(../dcterms:modified)">
            <xsl:call-template name="_OutputLastBuildDate"><xsl:with-param name="value" select="." /></xsl:call-template>
            <xsl:if test="not(../atom:updated)">
              <xsl:call-template name="_OutputAtomUpdated"><xsl:with-param name="value" select="." /></xsl:call-template>
            </xsl:if>
          </xsl:if>
        </xsl:if>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSdcterms and local-name(.) = 'available'">
        <xsl:if test="$isFirst = 'true' and not(../dc:date) and not(../dcterms:modified)">
          <xsl:call-template name="_OutputLastBuildDate"><xsl:with-param name="value" select="." /></xsl:call-template>
          <xsl:if test="not(../atom:updated)">
            <xsl:call-template name="_OutputAtomUpdated"><xsl:with-param name="value" select="." /></xsl:call-template>
          </xsl:if>
        </xsl:if>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSdcterms and local-name(.) = 'issued'">
        <xsl:if test="$isFirst = 'true' and not(../dc:date) and not(../dcterms:available) and not(../dcterms:modified)">
          <xsl:call-template name="_OutputLastBuildDate"><xsl:with-param name="value" select="." /></xsl:call-template>
          <xsl:if test="not(../atom:updated)">
            <xsl:call-template name="_OutputAtomUpdated"><xsl:with-param name="value" select="." /></xsl:call-template>
          </xsl:if>
        </xsl:if>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSatom1 and local-name(.) = 'published'">
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSatom1 and local-name(.) = 'updated'">
        <xsl:if test="$isFirst = 'true'">
          <xsl:call-template name="_OutputAtomUpdated"><xsl:with-param name="value" select="." /></xsl:call-template>
          <xsl:if test="not(../dc:date) and not(../dcterms:available) and not(../dcterms:modified) and not(../dcterms:issued)">
            <xsl:call-template name="_OutputLastBuildDate"><xsl:with-param name="value" select="." /></xsl:call-template>
          </xsl:if>
        </xsl:if>
      </xsl:when>
      <!-- First pair of updateFrequency and updatePeriod gets converted to ttl; all sy:* nodes are preserved as extensions -->
      <xsl:when test="namespace-uri(.) = $_NSsy and local-name(.) = 'updatePeriod' and $isFirst = 'true'">
        <xsl:if test="../sy:updateFrequency">
          <xsl:call-template name="_ConvertUpdatesToTtl">
            <xsl:with-param name="updatePeriod" select="string(.)" />
            <xsl:with-param name="updateFrequency" select="string(../sy:updateFrequency)" />
          </xsl:call-template>
        </xsl:if>
        <xsl:call-template name="_OutputExtension"><xsl:with-param name="value" select="." /></xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NScf and local-name(.) = 'treatAs'">
        <xsl:if test="$isFirst = 'true'">
          <xsl:call-template name="_OutputCfTreatAs"><xsl:with-param name="value" select="." /></xsl:call-template>
        </xsl:if>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NScf and local-name(.) = 'listinfo'">
        <xsl:if test="$isFirst = 'true'">
          <xsl:call-template name="_OutputCfListinfo"><xsl:with-param name="value" select="." /></xsl:call-template>
        </xsl:if>
      </xsl:when>
      <!-- Copy extension nodes -->
      <xsl:when test="namespace-uri(.) != $_NSrss and namespace-uri(.) != ''">
        <xsl:call-template name="_OutputExtension"><xsl:with-param name="value" select="." /></xsl:call-template>
      </xsl:when>
    </xsl:choose>
  </xsl:template>
<!-- Image processing -->
  <xsl:template match="rss:image">
    <xsl:if test="position() = 1">
      <xsl:variable name="imageUrl">
        <xsl:call-template name="_CompleteUrl">
          <xsl:with-param name="baseUrl" select="$downloadUrl" />
          <xsl:with-param name="Url" select="rss:url" />
        </xsl:call-template>
      </xsl:variable>
      <xsl:variable name="imageLink">
        <xsl:call-template name="_CompleteUrl">
          <xsl:with-param name="baseUrl" select="$downloadUrl" />
          <xsl:with-param name="Url" select="rss:link" />
        </xsl:call-template>
      </xsl:variable>
      <xsl:call-template name="_OutputImage">
        <xsl:with-param name="url" select="$imageUrl" />
        <xsl:with-param name="title" select="rss:title" />
        <xsl:with-param name="link" select="$imageLink" />
        <xsl:with-param name="subnodesToCopy" select="*[namespace-uri(.) != $_NSrss and namespace-uri(.) != '']" />
      </xsl:call-template>
    </xsl:if>
  </xsl:template>
<!-- Text Input processing -->
  <xsl:template match="rss:textinput">
    <xsl:if test="position() = 1">
      <xsl:variable name="linkUrl">
        <xsl:call-template name="_CompleteUrl">
          <xsl:with-param name="baseUrl" select="$downloadUrl" />
          <xsl:with-param name="Url" select="rss:link" />
        </xsl:call-template>
      </xsl:variable>
      <xsl:call-template name="_OutputTextInput">
        <xsl:with-param name="title" select="rss:title" />
        <xsl:with-param name="name" select="rss:name" />
        <xsl:with-param name="link" select="$linkUrl" />
        <xsl:with-param name="description" select="rss:description" />
        <xsl:with-param name="subnodesToCopy" select="*[namespace-uri(.) != $_NSrss and namespace-uri(.) != '']" />
      </xsl:call-template>
    </xsl:if>
  </xsl:template>
<!-- Item processing -->
  <xsl:template match="rss:item">
    <xsl:param name="references" />
    <item>
      <xsl:call-template name="_OutputXmlLang"><xsl:with-param name="value" select="@xml:lang" /></xsl:call-template>
      <xsl:apply-templates select="* | @*" mode="item">
        <xsl:with-param name="references" select="$references" />
      </xsl:apply-templates>
    </item>
  </xsl:template>
  <xsl:template match="*" mode="item">
    <xsl:param name="references" />
    <xsl:variable name="isFirst">
      <xsl:call-template name="_IsFirstChildOfItsKind"><xsl:with-param name="value" select="." /></xsl:call-template>
    </xsl:variable>
    <xsl:choose>
      <xsl:when test="namespace-uri(.) = $_NSrss and local-name(.) = 'title' and $isFirst = 'true'">
        <xsl:call-template name="_OutputTitle"><xsl:with-param name="value" select="." /></xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSrss and local-name(.) = 'link' and $isFirst = 'true'">
        <xsl:variable name="linkUrl">
          <xsl:call-template name="_CompleteUrl">
            <xsl:with-param name="baseUrl" select="$downloadUrl" />
            <xsl:with-param name="Url" select="." />
          </xsl:call-template>
        </xsl:variable>
        <xsl:call-template name="_OutputLink"><xsl:with-param name="value" select="$linkUrl" /></xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSdc and local-name(.) = 'creator'">
          <xsl:call-template name="_OutputAuthor">
            <xsl:with-param name="value" select="." />
            <xsl:with-param name="convertToAtom" select="'true'" />
          </xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSdc and local-name(.) = 'subject'">
        <xsl:call-template name="_OutputCategory"><xsl:with-param name="value" select="." /></xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSdc and local-name(.) = 'date'">
        <xsl:if test="$isFirst= 'true'">
          <xsl:call-template name="_OutputPubDate"><xsl:with-param name="value" select="." /></xsl:call-template>    
          <xsl:if test="not(../atom:published)">
            <xsl:call-template name="_OutputAtomPublished"><xsl:with-param name="value" select="." /></xsl:call-template>
          </xsl:if>
          <xsl:if test="not(../atom:updated) and not(../dcterms:modified)">
            <xsl:call-template name="_OutputAtomUpdated"><xsl:with-param name="value" select="." /></xsl:call-template>
          </xsl:if>
        </xsl:if>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSatom1 and local-name(.) = 'published'">
        <xsl:if test="$isFirst= 'true'">
          <xsl:call-template name="_OutputAtomPublished"><xsl:with-param name="value" select="." /></xsl:call-template>
          <xsl:if test="not(../dc:date)">
            <xsl:call-template name="_OutputPubDate"><xsl:with-param name="value" select="." /></xsl:call-template>
          </xsl:if> 
        </xsl:if>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSatom1 and local-name(.) = 'updated'">
        <xsl:if test="$isFirst = 'true'">
          <xsl:call-template name="_OutputAtomUpdated"><xsl:with-param name="value" select="." /></xsl:call-template>
        </xsl:if>  
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSdcterms and local-name(.) = 'modified'">
        <xsl:if test="$isFirst = 'true'">
          <xsl:if test="not(../atom:updated)">
            <xsl:call-template name="_OutputAtomUpdated"><xsl:with-param name="value" select="." /></xsl:call-template>
          </xsl:if> 
        </xsl:if>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NScontent and local-name(.) = 'encoded'">
        <xsl:if test="$isFirst = 'true'">
          <xsl:call-template name="_OutputDescriptionAndSummary">
            <xsl:with-param name="description" select="." />
            <xsl:with-param name="descriptionType" select="'html'" />
            <xsl:with-param name="descriptionBaseUrl" select="$downloadUrl" />
            <xsl:with-param name="summary" select="../rss:description" />
            <xsl:with-param name="summaryType" select="'html'" />
            <xsl:with-param name="summaryBaseUrl" select="$downloadUrl" />
          </xsl:call-template>
        </xsl:if>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSrss and local-name(.) = 'description' and $isFirst = 'true'">
        <xsl:if test="not(../content:encoded)">
          <xsl:call-template name="_OutputDescription">
            <xsl:with-param name="value" select="." />
            <xsl:with-param name="type" select="'html'" />
            <xsl:with-param name="baseUrl" select="$downloadUrl" />
          </xsl:call-template>
        </xsl:if>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSslash and local-name(.) = 'comments'">
        <xsl:if test="$isFirst = 'true'">
          <xsl:call-template name="_OutputSlashComments"><xsl:with-param name="value" select="." /></xsl:call-template>
        </xsl:if>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSwfw and (local-name(.) = 'commentRss' or local-name(.) = 'commentRSS')">
        <xsl:if test="$isFirst = 'true'">
          <xsl:variable name="commentRssUrl">
            <xsl:call-template name="_CompleteUrl">
              <xsl:with-param name="baseUrl" select="$downloadUrl" />
              <xsl:with-param name="Url" select="." />
            </xsl:call-template>
          </xsl:variable>
          <xsl:call-template name="_OutputWfwCommentRSS"><xsl:with-param name="value" select="$commentRssUrl" /></xsl:call-template>
        </xsl:if>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSatom1 and local-name(.) = 'link'">
        <!-- Special handling for item level atom:link with rel=entry-content: complete relative URL -->
        <xsl:variable name="atomLinkUrl">
          <xsl:choose>
            <xsl:when test="@rel = 'entry-content'">
              <xsl:call-template name="_CombineUrls">
                <xsl:with-param name="baseUrl" select="$downloadUrl" />
                <xsl:with-param name="relUrl" select="@href" />
              </xsl:call-template>
            </xsl:when>
            <xsl:otherwise>
              <xsl:value-of select="@href" />
            </xsl:otherwise>
          </xsl:choose>
        </xsl:variable>
        <xsl:call-template name="_OutputAtomLink">
          <xsl:with-param name="href" select="$atomLinkUrl" />
          <xsl:with-param name="rel" select="@rel" />
          <xsl:with-param name="type" select="@type" />
          <xsl:with-param name="title" select="@title" />
          <xsl:with-param name="hreflang" select="@hreflang" />
          <xsl:with-param name="length" select="@length" />
          <xsl:with-param name="xmlBase" select="@xml:base" />
        </xsl:call-template>
      </xsl:when>
      <!-- Copy extension nodes -->
      <xsl:when test="namespace-uri(.) != $_NSrss and namespace-uri(.) != ''">
        <xsl:call-template name="_OutputExtension">
          <xsl:with-param name="value" select="." />
          <xsl:with-param name="references" select="$references" />
        </xsl:call-template>
      </xsl:when>
    </xsl:choose>
  </xsl:template>
  <xsl:template match="@*" mode="item">
    <!-- No need to check if first, because XML doesn't allow duplicate attributes -->
    <xsl:if test="namespace-uri(.) = $_NSrdf and local-name(.) = 'about'">
      <xsl:call-template name="_OutputGuid">
        <xsl:with-param name="value" select="." />
        <xsl:with-param name="isPermaLink" select="'false'" />
      </xsl:call-template>
    </xsl:if>
  </xsl:template>
</xsl:stylesheet>
<xsl:stylesheet version="1.0" 
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform" 
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:cf="http://www.microsoft.com/schemas/rss/core/2005"
  xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
  xmlns:atom03="http://purl.org/atom/ns#"
  xmlns:msfeednorm="urn:microsoft:feed-normalization"
  exclude-result-prefixes="sy atom03 msfeednorm"
<!-- Shared templates -->
  <xsl:import href="res://msfeeds.dll/SharedNormalizer.xsl" />
<!-- Output XML UTF-8 -->
  <xsl:output method="xml" encoding="utf-8" />
<!-- Entry point -->
  <xsl:template match="/atom03:feed">
    <rss version="2.0">
      <channel>
        <xsl:call-template name="_OutputXmlBase"><xsl:with-param name="value" select="@xml:base" /></xsl:call-template>
        <xsl:call-template name="_OutputXmlLang"><xsl:with-param name="value" select="@xml:lang" /></xsl:call-template>
        <xsl:call-template name="_OutputLanguage"><xsl:with-param name="value" select="@xml:lang" /></xsl:call-template>
        <!-- Figure out the base URL value; xml:base overrides the download URL -->
        <xsl:variable name="baseChannelUrl">
          <xsl:call-template name="_GetFeedBaseUrl">
            <xsl:with-param name="downloadUrl" select="$downloadUrl" />
            <xsl:with-param name="rootNode" select="." />
          </xsl:call-template>
        </xsl:variable>
        <!-- Try to find the main link - one that has an href pointing to html and with type alternate -->
        <xsl:variable name="mainLink" select="atom03:link[(@rel = 'alternate' or @rel = '' or not(@rel)) and (@type = 'text/html' or @type = '' or not(@type))]" />
        <!-- Output link -->
        <xsl:if test="$mainLink">
          <!-- Combine base URL with the main link -->
          <xsl:variable name="channelLinkUrl">
            <xsl:call-template name="_CompleteUrlTwoBase">
              <xsl:with-param name="baseUrl1" select="$baseChannelUrl" />
              <xsl:with-param name="baseUrl2" select="$mainLink/@xml:base" />
              <xsl:with-param name="Url" select="$mainLink/@href" />
            </xsl:call-template>
          </xsl:variable>
          <xsl:call-template name="_OutputLink"><xsl:with-param name="value" select="$channelLinkUrl" /></xsl:call-template>
        </xsl:if>
        <!-- Build a list of referenced nodes from cf:sort and cf:group -->
        <xsl:variable name="cfReferences">
          <xsl:call-template name="_BuildCfReferenceList"><xsl:with-param name="value" select="." /></xsl:call-template>
        </xsl:variable>
        <!-- Process channel elements -->
        <xsl:apply-templates select="*" mode="channel">
          <xsl:with-param name="baseChannelUrl" select="$baseChannelUrl" />
        </xsl:apply-templates>
        <!-- Process items -->
        <xsl:apply-templates select="atom03:entry">
          <xsl:with-param name="baseChannelUrl" select="$baseChannelUrl" />
          <xsl:with-param name="references" select="$cfReferences" />
        </xsl:apply-templates>
      </channel>
    </rss>
  </xsl:template>
<!-- Channel processing -->
  <xsl:template match="*" mode="channel">
    <xsl:param name="baseChannelUrl" />
    <xsl:variable name="isFirst">
      <xsl:call-template name="_IsFirstChildOfItsKind"><xsl:with-param name="value" select="." /></xsl:call-template>
    </xsl:variable>
    <xsl:choose>
      <xsl:when test="namespace-uri(.) = $_NSatom03 and local-name(.) = 'title' and $isFirst = 'true'">
        <xsl:call-template name="_OutputTitle">
          <xsl:with-param name="value" select="." />
          <xsl:with-param name="type" select="@type" />
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSatom03 and local-name(.) = 'author'">
        <!-- First one gets converted to managing Editor -->
        <xsl:if test="$isFirst = 'true'">
          <xsl:variable name="manEditor">
            <xsl:call-template name="_ConvertAtomAuthorToAuthor">
              <xsl:with-param name="name" select="atom03:name" />
              <xsl:with-param name="email" select="atom03:email" />
            </xsl:call-template>
          </xsl:variable>
          <xsl:call-template name="_OutputManagingEditor"><xsl:with-param name="value" select="$manEditor" /></xsl:call-template>
        </xsl:if>
        <!-- Map to Atom 1.0 -->
        <xsl:call-template name="_OutputAtomAuthor">
          <xsl:with-param name="name" select="atom03:name" />
          <xsl:with-param name="email" select="atom03:email" />
          <xsl:with-param name="uri" select="atom03:url" />
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSatom03 and local-name(.) = 'contributor'">
        <!-- Map to Atom 1.0 -->
        <xsl:call-template name="_OutputAtomContributor">
          <xsl:with-param name="name" select="atom03:name" />
          <xsl:with-param name="email" select="atom03:email" />
          <xsl:with-param name="uri" select="atom03:url" />
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSatom03 and local-name(.) = 'tagline' and $isFirst = 'true'">
        <xsl:call-template name="_OutputTextDescription">
          <xsl:with-param name="value" select="." />
          <xsl:with-param name="type" select="@type" />
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSatom03 and local-name(.) = 'id' and $isFirst = 'true'">
        <xsl:call-template name="_OutputGuid">
          <xsl:with-param name="value" select="." />
          <xsl:with-param name="isPermaLink" select="'false'" />
          <xsl:with-param name="channelGuid" select="'true'" />
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSatom03 and local-name(.) = 'generator' and $isFirst = 'true'">
        <xsl:call-template name="_OutputGenerator">
          <xsl:with-param name="value" select="." />
          <xsl:with-param name="uri" select="@url" />
          <xsl:with-param name="version" select="@version" />
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSatom03 and local-name(.) = 'modified' and $isFirst = 'true'">
        <xsl:call-template name="_OutputLastBuildDate"><xsl:with-param name="value" select="." /></xsl:call-template>
        <xsl:variable name="updatedExists">
          <xsl:choose>
            <xsl:when test="../atom:updated">true</xsl:when>
            <xsl:otherwise>false</xsl:otherwise>
          </xsl:choose>
        </xsl:variable>
        <xsl:if test="$updatedExists = 'false'">
          <xsl:call-template name="_OutputAtomUpdated"><xsl:with-param name="value" select="." /></xsl:call-template>
        </xsl:if>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSatom1 and local-name(.) = 'published'">
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSatom1 and local-name(.) = 'updated'">
        <xsl:if test="$isFirst = 'true'">
          <xsl:call-template name="_OutputAtomUpdated"><xsl:with-param name="value" select="." /></xsl:call-template>
          <xsl:if test="not(../atom03:modified)">
            <xsl:call-template name="_OutputLastBuildDate"><xsl:with-param name="value" select="." /></xsl:call-template>
          </xsl:if>
        </xsl:if>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSatom03 and local-name(.) = 'copyright' and $isFirst = 'true'">
        <xsl:call-template name="_OutputCopyright">
          <xsl:with-param name="value" select="." />
          <xsl:with-param name="type" select="@type" />
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSdc and local-name(.) = 'subject'">
        <xsl:call-template name="_OutputCategory"><xsl:with-param name="value" select="." /></xsl:call-template>
      </xsl:when>
      <!-- First pair of updateFrequency and updatePeriod gets converted to ttl; all sy:* nodes are preserved as extensions -->
      <xsl:when test="namespace-uri(.) = $_NSsy and local-name(.) = 'updatePeriod' and $isFirst = 'true'">
        <xsl:if test="../sy:updateFrequency">
          <xsl:call-template name="_ConvertUpdatesToTtl">
            <xsl:with-param name="updatePeriod" select="string(.)" />
            <xsl:with-param name="updateFrequency" select="string(../sy:updateFrequency)" />
          </xsl:call-template>
          <xsl:call-template name="_OutputExtension"><xsl:with-param name="value" select="." /></xsl:call-template>
        </xsl:if>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NScf and local-name(.) = 'treatAs'">
        <xsl:if test="$isFirst = 'true'">
          <xsl:call-template name="_OutputCfTreatAs"><xsl:with-param name="value" select="." /></xsl:call-template>
        </xsl:if>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NScf and local-name(.) = 'listinfo'">
        <xsl:if test="$isFirst = 'true'">
          <xsl:call-template name="_OutputCfListinfo"><xsl:with-param name="value" select="." /></xsl:call-template>
        </xsl:if>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSatom03 and local-name(.) = 'entry'">
        <!-- Do nothing here for items -->
      </xsl:when>
      <!-- Copy extension nodes -->
      <xsl:when test="namespace-uri(.) != $_NSatom03 and namespace-uri(.) != ''">
        <xsl:call-template name="_OutputExtension"><xsl:with-param name="value" select="." /></xsl:call-template>
      </xsl:when>
    </xsl:choose>
  </xsl:template>
<!-- Item processing -->
  <xsl:template match="atom03:entry">
    <xsl:param name="baseChannelUrl" />
    <xsl:param name="references" />
    <item>
      <xsl:call-template name="_OutputXmlBase"><xsl:with-param name="value" select="@xml:base" /></xsl:call-template>
      <xsl:call-template name="_OutputXmlLang"><xsl:with-param name="value" select="@xml:lang" /></xsl:call-template>
      <!-- Item's base URL stacks onto channel's base URL -->
      <xsl:variable name="baseChannelItemUrl">
        <xsl:call-template name="_CombineUrls">
          <xsl:with-param name="baseUrl" select="$baseChannelUrl" />
          <xsl:with-param name="relUrl" select="@xml:base" />
        </xsl:call-template>
      </xsl:variable>
      <!-- Try to find the main link - one that has an href pointing to html and with type alternate -->
      <xsl:variable name="mainLink" select="atom03:link[(@rel = 'alternate' or @rel = '' or not(@rel)) and (@type = 'text/html' or @type = '' or not(@type))]" />
      <!-- Output link -->
      <xsl:if test="$mainLink">
        <!-- Combine base URL with the main link -->
        <xsl:variable name="itemLinkUrl">
          <xsl:call-template name="_CompleteUrlTwoBase">
            <xsl:with-param name="baseUrl1" select="$baseChannelItemUrl" />
            <xsl:with-param name="baseUrl2" select="$mainLink/@xml:base" />
            <xsl:with-param name="Url" select="$mainLink/@href" />
          </xsl:call-template>
        </xsl:variable>
        <xsl:call-template name="_OutputLink"><xsl:with-param name="value" select="$itemLinkUrl" /></xsl:call-template>
      </xsl:if>
      <xsl:apply-templates select="*" mode="item">
        <xsl:with-param name="baseItemUrl" select="$baseChannelItemUrl" />
        <xsl:with-param name="references" select="$references" />
      </xsl:apply-templates>
    </item>
  </xsl:template>
  <xsl:template match="*" mode="item">
    <xsl:param name="baseItemUrl" />
    <xsl:param name="references" />
    <xsl:variable name="isFirst">
      <xsl:call-template name="_IsFirstChildOfItsKind"><xsl:with-param name="value" select="." /></xsl:call-template>
    </xsl:variable>
    <xsl:choose>
      <xsl:when test="namespace-uri(.) = $_NSatom03 and local-name(.) = 'title' and $isFirst = 'true'">
        <xsl:call-template name="_OutputTitle">
          <xsl:with-param name="value" select="." />
          <xsl:with-param name="type" select="@type" />
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSatom03 and local-name(.) = 'link' and @rel = 'enclosure' and (@href or @length or @type)">
        <xsl:variable name="enclosureUrl">
          <xsl:call-template name="_CompleteUrlTwoBase">
            <xsl:with-param name="baseUrl1" select="$baseItemUrl" />
            <xsl:with-param name="baseUrl2" select="@xml:base" />
            <xsl:with-param name="Url" select="@href" />
          </xsl:call-template>
        </xsl:variable>
        <xsl:call-template name="_OutputEnclosure">
          <xsl:with-param name="url" select="$enclosureUrl" />
          <xsl:with-param name="length" select="@length" />
          <xsl:with-param name="type" select="@type" />
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSatom03 and local-name(.) = 'author'">
        <xsl:variable name="author">
          <xsl:call-template name="_ConvertAtomAuthorToAuthor">
            <xsl:with-param name="name" select="atom03:name" />
            <xsl:with-param name="email" select="atom03:email" />
          </xsl:call-template>
        </xsl:variable>
        <xsl:call-template name="_OutputAuthor"><xsl:with-param name="value" select="$author" /></xsl:call-template>
        <!-- Map to Atom 1.0 -->
        <xsl:call-template name="_OutputAtomAuthor">
          <xsl:with-param name="name" select="atom03:name" />
          <xsl:with-param name="email" select="atom03:email" />
          <xsl:with-param name="uri" select="atom03:url" />
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSatom03 and local-name(.) = 'contributor'">
        <!-- Map to Atom 1.0 -->
        <xsl:call-template name="_OutputAtomContributor">
          <xsl:with-param name="name" select="atom03:name" />
          <xsl:with-param name="email" select="atom03:email" />
          <xsl:with-param name="uri" select="atom03:url" />
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSatom03 and local-name(.) = 'id' and $isFirst = 'true'">
        <xsl:call-template name="_OutputGuid">
          <xsl:with-param name="value" select="." />
          <xsl:with-param name="isPermaLink" select="'false'" />
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSatom1 and local-name(.) = 'published'">
        <xsl:if test="$isFirst = 'true'">
          <xsl:call-template name="_OutputAtomPublished"><xsl:with-param name="value" select="." /></xsl:call-template>
          <xsl:if test="not(../atom03:issued)">
            <xsl:call-template name="_OutputPubDate"><xsl:with-param name="value" select="." /></xsl:call-template>
          </xsl:if>
        </xsl:if>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSatom1 and local-name(.) = 'updated'">
        <xsl:if test="$isFirst = 'true'">
          <xsl:call-template name="_OutputAtomUpdated"><xsl:with-param name="value" select="." /></xsl:call-template>
        </xsl:if>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSatom03 and local-name(.) = 'modified' and $isFirst = 'true'">
        <xsl:if test="not(../atom:updated)">
          <xsl:call-template name="_OutputAtomUpdated"><xsl:with-param name="value" select="." /></xsl:call-template>
        </xsl:if>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSatom03 and local-name(.) = 'issued' and $isFirst = 'true'">
        <xsl:call-template name="_OutputPubDate"><xsl:with-param name="value" select="." /></xsl:call-template>
        <xsl:if test="not(../atom:updated) and not(../atom03:modified)">
          <xsl:call-template name="_OutputAtomUpdated"><xsl:with-param name="value" select="." /></xsl:call-template>
        </xsl:if>
        <xsl:if test="not(../atom:published)">
          <xsl:call-template name="_OutputAtomPublished"><xsl:with-param name="value" select="." /></xsl:call-template>
        </xsl:if>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSdc and local-name(.) = 'subject'">
        <xsl:call-template name="_OutputCategory"><xsl:with-param name="value" select="." /></xsl:call-template>
      </xsl:when>
      <!-- Handle content: printable goes into description; non-printable is preserved -->
      <xsl:when test="namespace-uri(.) = $_NSatom03 and local-name(.) = 'content' and $isFirst = 'true'">
          <xsl:if test="@type = '' or not(@type) or @type = 'text/plain' or @type = 'text/html' or @type = 'application/xhtml+xml'">
            <xsl:variable name="baseContentUrl">
              <xsl:call-template name="_CombineUrls">
                <xsl:with-param name="baseUrl" select="$baseItemUrl" />
                <xsl:with-param name="relUrl" select="@xml:base" />
              </xsl:call-template>
            </xsl:variable>
            <xsl:call-template name="_OutputDescription">
              <xsl:with-param name="value" select="." />
              <xsl:with-param name="type" select="@type" />
              <xsl:with-param name="baseUrl" select="$baseContentUrl" />
            </xsl:call-template>
          </xsl:if>
      </xsl:when>
      <!-- Handle summary: printable goes into description or atom:summary; non-printable is discarded -->
      <xsl:when test="namespace-uri(.) = $_NSatom03 and local-name(.) = 'summary' and $isFirst = 'true'">
        <xsl:if test="@type = '' or not(@type) or @type = 'text/plain' or @type = 'text/html' or @type = 'application/xhtml+xml'">
          <xsl:variable name="baseContentUrl">
            <xsl:call-template name="_CombineUrls">
              <xsl:with-param name="baseUrl" select="$baseItemUrl" />
              <xsl:with-param name="relUrl" select="@xml:base" />
            </xsl:call-template>
          </xsl:variable>
          <xsl:choose>
            <xsl:when test="not(../atom03:content[@type = '' or not(@type) or @type = 'text/plain' or @type = 'text/html' or @type = 'application/xhtml+xml'])">
              <xsl:call-template name="_OutputDescription">
                <xsl:with-param name="value" select="." />
                <xsl:with-param name="type" select="@type" />
                <xsl:with-param name="baseUrl" select="$baseContentUrl" />
              </xsl:call-template>
            </xsl:when>
            <xsl:otherwise>
              <!-- Map to Atom 1.0 -->
              <xsl:call-template name="_OutputAtomSummary">
                <xsl:with-param name="value" select="." />
                <xsl:with-param name="type" select="@type" />
                <xsl:with-param name="xmlBase" select="@xml:base" />
                <xsl:with-param name="baseUrl" select="$baseContentUrl" />
              </xsl:call-template>
            </xsl:otherwise>
          </xsl:choose>
        </xsl:if>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSslash and local-name(.) = 'comments'">
        <xsl:if test="$isFirst = 'true'">
          <xsl:call-template name="_OutputSlashComments"><xsl:with-param name="value" select="." /></xsl:call-template>
        </xsl:if>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSwfw and (local-name(.) = 'commentRss' or local-name(.) = 'commentRSS')">
        <xsl:if test="$isFirst = 'true'">
          <xsl:variable name="commentRssUrl">
            <xsl:call-template name="_CompleteUrlTwoBase">
              <xsl:with-param name="baseUrl1" select="$baseItemUrl" />
              <xsl:with-param name="baseUrl2" select="@xml:base" />
              <xsl:with-param name="Url" select="." />
            </xsl:call-template>
          </xsl:variable>
          <xsl:call-template name="_OutputWfwCommentRSS"><xsl:with-param name="value" select="$commentRssUrl" /></xsl:call-template>
        </xsl:if>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSatom1 and local-name(.) = 'link'">
        <!-- Special handling for item level atom:link with rel=entry-content: complete relative URL -->
        <xsl:variable name="atomLinkUrl">
          <xsl:choose>
            <xsl:when test="@rel = 'entry-content'">
              <xsl:call-template name="_CombineUrls">
                <xsl:with-param name="baseUrl" select="$baseItemUrl" />
                <xsl:with-param name="relUrl" select="@href" />
              </xsl:call-template>
            </xsl:when>
            <xsl:otherwise>
              <xsl:value-of select="@href" />
            </xsl:otherwise>
          </xsl:choose>
        </xsl:variable>
        <xsl:call-template name="_OutputAtomLink">
          <xsl:with-param name="href" select="$atomLinkUrl" />
          <xsl:with-param name="rel" select="@rel" />
          <xsl:with-param name="type" select="@type" />
          <xsl:with-param name="title" select="@title" />
          <xsl:with-param name="hreflang" select="@hreflang" />
          <xsl:with-param name="length" select="@length" />
          <xsl:with-param name="xmlBase" select="@xml:base" />
        </xsl:call-template>
      </xsl:when>
      <!-- Copy extension nodes -->
      <xsl:when test="namespace-uri(.) != $_NSatom03 and namespace-uri(.) != ''">
        <xsl:call-template name="_OutputExtension">
          <xsl:with-param name="value" select="." />
          <xsl:with-param name="references" select="$references" />
        </xsl:call-template>
      </xsl:when>
    </xsl:choose>
  </xsl:template>
</xsl:stylesheet>
<xsl:stylesheet version="1.0" 
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform" 
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:cf="http://www.microsoft.com/schemas/rss/core/2005"
  xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
  xmlns:msfeednorm="urn:microsoft:feed-normalization"
  exclude-result-prefixes="sy msfeednorm"
<!-- Shared templates -->
  <xsl:import href="res://msfeeds.dll/SharedNormalizer.xsl" />
<!-- Output XML UTF-8 -->
  <xsl:output method="xml" encoding="utf-8" />
<!-- Entry point -->
  <xsl:template match="/atom:feed">
    <rss version="2.0">
      <channel>
        <xsl:call-template name="_OutputXmlBase"><xsl:with-param name="value" select="@xml:base" /></xsl:call-template>
        <xsl:call-template name="_OutputXmlLang"><xsl:with-param name="value" select="@xml:lang" /></xsl:call-template>
        <xsl:call-template name="_OutputLanguage"><xsl:with-param name="value" select="@xml:lang" /></xsl:call-template>
        <!-- Figure out the base URL value; xml:base overrides the download URL -->
        <xsl:variable name="baseChannelUrl">
          <xsl:call-template name="_GetFeedBaseUrl">
            <xsl:with-param name="downloadUrl" select="$downloadUrl" />
            <xsl:with-param name="rootNode" select="." />
          </xsl:call-template>
        </xsl:variable>
        <!-- Try to find the main link - one that has an href pointing to html and with type alternate -->
        <xsl:variable name="mainLink" select="atom:link[(@rel = 'alternate' or @rel = '' or not(@rel)) and (@type = 'text/html' or @type = '' or not(@type))]" />
        <!-- Combine base URL with the main link -->
        <xsl:variable name="channelLinkUrl">
          <xsl:call-template name="_CompleteUrlTwoBase">
            <xsl:with-param name="baseUrl1" select="$baseChannelUrl" />
            <xsl:with-param name="baseUrl2" select="$mainLink/@xml:base" />
            <xsl:with-param name="Url" select="$mainLink/@href" />
          </xsl:call-template>
        </xsl:variable>
        <xsl:if test="$mainLink">
          <xsl:call-template name="_OutputLink"><xsl:with-param name="value" select="$channelLinkUrl" /></xsl:call-template>
        </xsl:if>
        <xsl:if test="atom:logo">
          <xsl:variable name="logoImageUrl">
            <xsl:call-template name="_CompleteUrlTwoBase">
              <xsl:with-param name="baseUrl1" select="$baseChannelUrl" />
              <xsl:with-param name="baseUrl2" select="atom:logo/@xml:base" />
              <xsl:with-param name="Url" select="atom:logo" />
            </xsl:call-template>
          </xsl:variable>
          <xsl:call-template name="_OutputImage">
            <xsl:with-param name="url" select="$logoImageUrl" />
            <xsl:with-param name="title" select="atom:title" />
            <xsl:with-param name="titleType" select="atom:title/@type" />
            <xsl:with-param name="link" select="$channelLinkUrl" />
          </xsl:call-template>
        </xsl:if>
        <!-- Build a list of referenced nodes from cf:sort and cf:group -->
        <xsl:variable name="cfReferences">
          <xsl:call-template name="_BuildCfReferenceList"><xsl:with-param name="value" select="." /></xsl:call-template>
        </xsl:variable>
        <xsl:apply-templates select="*" mode="channel">
          <xsl:with-param name="baseChannelUrl" select="$baseChannelUrl" />
        </xsl:apply-templates>
        <xsl:apply-templates select="atom:entry">
          <xsl:with-param name="baseChannelUrl" select="$baseChannelUrl" />
          <xsl:with-param name="references" select="$cfReferences" />
        </xsl:apply-templates>
      </channel>
    </rss>
  </xsl:template>
<!-- Channel processing -->
  <xsl:template match="*" mode="channel">
    <xsl:param name="baseChannelUrl" />
    <xsl:variable name="isFirst">
      <xsl:call-template name="_IsFirstChildOfItsKind"><xsl:with-param name="value" select="." /></xsl:call-template>
    </xsl:variable>
    <xsl:choose>
      <xsl:when test="namespace-uri(.) = $_NSatom1 and local-name(.) = 'updated'">
        <xsl:if test="$isFirst = 'true'">
          <xsl:call-template name="_OutputAtomUpdated"><xsl:with-param name="value" select="." /><xsl:with-param name="type" select="@type" /></xsl:call-template>
          <xsl:call-template name="_OutputLastBuildDate"><xsl:with-param name="value" select="." /><xsl:with-param name="type" select="@type" /></xsl:call-template>
        </xsl:if>
        
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSatom1 and local-name(.) = 'title' and $isFirst = 'true'">
        <xsl:call-template name="_OutputTitle">
          <xsl:with-param name="value" select="." />
          <xsl:with-param name="type" select="@type" />
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSatom1 and local-name(.) = 'author'">
        <!-- First one gets converted to managing Editor -->
        <xsl:if test="$isFirst = 'true'">
          <xsl:variable name="manEditor">
            <xsl:call-template name="_ConvertAtomAuthorToAuthor">
              <xsl:with-param name="name" select="atom:name" />
              <xsl:with-param name="email" select="atom:email" />
            </xsl:call-template>
          </xsl:variable>
          <xsl:call-template name="_OutputManagingEditor"><xsl:with-param name="value" select="$manEditor" /></xsl:call-template>
        </xsl:if>
        <!-- We also make a full copy of every atom:author -->
        <xsl:call-template name="_OutputAtomAuthor">
          <xsl:with-param name="name" select="atom:name" />
          <xsl:with-param name="email" select="atom:email" />
          <xsl:with-param name="uri" select="atom:uri" />
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSatom1 and local-name(.) = 'contributor'">
        <xsl:call-template name="_OutputAtomContributor">
          <xsl:with-param name="name" select="atom:name" />
          <xsl:with-param name="email" select="atom:email" />
          <xsl:with-param name="uri" select="atom:uri" />
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSatom1 and local-name(.) = 'subtitle' and $isFirst = 'true'">
        <xsl:call-template name="_OutputTextDescription">
          <xsl:with-param name="value" select="." />
          <xsl:with-param name="type" select="@type" />
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSatom1 and local-name(.) = 'id' and $isFirst = 'true'">
        <xsl:call-template name="_OutputGuid">
          <xsl:with-param name="value" select="." />
          <xsl:with-param name="isPermaLink" select="'false'" />
          <xsl:with-param name="channelGuid" select="'true'" />
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSatom1 and local-name(.) = 'generator' and $isFirst = 'true'">
        <xsl:call-template name="_OutputGenerator">
          <xsl:with-param name="value" select="." />
          <xsl:with-param name="uri" select="@uri" />
          <xsl:with-param name="version" select="@version" />
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSatom1 and local-name(.) = 'rights' and $isFirst = 'true'">
        <xsl:call-template name="_OutputCopyright">
          <xsl:with-param name="value" select="." />
          <xsl:with-param name="type" select="@type" />
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSatom1 and local-name(.) = 'link'">
        <xsl:call-template name="_OutputAtomLink">
          <xsl:with-param name="href" select="@href" />
          <xsl:with-param name="rel" select="@rel" />
          <xsl:with-param name="type" select="@type" />
          <xsl:with-param name="title" select="@title" />
          <xsl:with-param name="hreflang" select="@hreflang" />
          <xsl:with-param name="length" select="@length" />
          <xsl:with-param name="xmlBase" select="@xml:base" />
        </xsl:call-template>
      </xsl:when>
      <!-- First pair of updateFrequency and updatePeriod gets converted to ttl; all sy:* nodes are preserved as extensions -->
      <xsl:when test="namespace-uri(.) = $_NSsy and local-name(.) = 'updatePeriod' and $isFirst = 'true'">
        <xsl:if test="../sy:updateFrequency">
          <xsl:call-template name="_ConvertUpdatesToTtl">
            <xsl:with-param name="updatePeriod" select="string(.)" />
            <xsl:with-param name="updateFrequency" select="string(../sy:updateFrequency)" />
          </xsl:call-template>
        </xsl:if>
        <xsl:call-template name="_OutputExtension"><xsl:with-param name="value" select="." /></xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NScf and local-name(.) = 'treatAs'">
        <xsl:if test="$isFirst = 'true'">
          <xsl:call-template name="_OutputCfTreatAs"><xsl:with-param name="value" select="." /></xsl:call-template>
        </xsl:if>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NScf and local-name(.) = 'listinfo'">
        <xsl:if test="$isFirst = 'true'">
          <xsl:call-template name="_OutputCfListinfo"><xsl:with-param name="value" select="." /></xsl:call-template>
        </xsl:if>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSatom1 and local-name(.) = 'entry'">
        <!-- Do nothing here for items -->
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSmon and local-name(.) = 'expiration'">
        <xsl:if test="$isFirst = 'true'">
          <xsl:call-template name="_OutputMonExpiration"><xsl:with-param name="value" select="." /><xsl:with-param name="type" select="@type" /></xsl:call-template>
        </xsl:if>
      </xsl:when>
      <!-- Copy extension nodes -->
      <xsl:when test="namespace-uri(.) != $_NSatom1 and namespace-uri(.) != ''">
        <xsl:call-template name="_OutputExtension"><xsl:with-param name="value" select="." /></xsl:call-template>
      </xsl:when>
    </xsl:choose>
  </xsl:template>
<!-- Item processing -->
  <xsl:template match="atom:entry">
    <xsl:param name="baseChannelUrl" />
    <xsl:param name="references" />
    <item>
      <xsl:call-template name="_OutputXmlBase"><xsl:with-param name="value" select="@xml:base" /></xsl:call-template>
      <xsl:call-template name="_OutputXmlLang"><xsl:with-param name="value" select="@xml:lang" /></xsl:call-template>
      <!-- Item's base URL stacks onto channel's base URL -->
      <xsl:variable name="baseChannelItemUrl">
        <xsl:call-template name="_CombineUrls">
          <xsl:with-param name="baseUrl" select="$baseChannelUrl" />
          <xsl:with-param name="relUrl" select="@xml:base" />
        </xsl:call-template>
      </xsl:variable>
      <!-- Try to find the main link - one that has an href pointing to html and with type alternate -->
      <xsl:variable name="mainLink" select="atom:link[(@rel = 'alternate' or @rel = '' or not(@rel)) and (@type = 'text/html' or @type = '' or not(@type))]" />
      <!-- Output link -->
      <xsl:if test="$mainLink">
        <!-- Combine base URL with the main link -->
        <xsl:variable name="itemLinkUrl">
          <xsl:call-template name="_CompleteUrlTwoBase">
            <xsl:with-param name="baseUrl1" select="$baseChannelItemUrl" />
            <xsl:with-param name="baseUrl2" select="$mainLink/@xml:base" />
            <xsl:with-param name="Url" select="$mainLink/@href" />
          </xsl:call-template>
        </xsl:variable>
        <xsl:call-template name="_OutputLink"><xsl:with-param name="value" select="$itemLinkUrl" /></xsl:call-template>
      </xsl:if>
      <xsl:apply-templates select="*" mode="item">
        <xsl:with-param name="baseItemUrl" select="$baseChannelItemUrl" />
        <xsl:with-param name="references" select="$references" />
      </xsl:apply-templates>
    </item>
  </xsl:template>
  <xsl:template match="*" mode="item">
    <xsl:param name="baseItemUrl" />
    <xsl:param name="references" />
    <xsl:variable name="isFirst">
      <xsl:call-template name="_IsFirstChildOfItsKind"><xsl:with-param name="value" select="." /></xsl:call-template>
    </xsl:variable>
    <xsl:choose>
      <!-- Process items -->
      <xsl:when test="namespace-uri(.) = $_NSatom1 and local-name(.) = 'title' and $isFirst = 'true'">
        <xsl:call-template name="_OutputTitle">
          <xsl:with-param name="value" select="." />
          <xsl:with-param name="type" select="@type" />
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSatom1 and local-name(.) = 'link' and @rel = 'enclosure' and (@href or @length or @type)">
        <xsl:variable name="enclosureUrl">
          <xsl:call-template name="_CompleteUrlTwoBase">
            <xsl:with-param name="baseUrl1" select="$baseItemUrl" />
            <xsl:with-param name="baseUrl2" select="@xml:base" />
            <xsl:with-param name="Url" select="@href" />
          </xsl:call-template>
        </xsl:variable>
        <xsl:call-template name="_OutputEnclosure">
          <xsl:with-param name="url" select="$enclosureUrl" />
          <xsl:with-param name="length" select="@length" />
          <xsl:with-param name="type" select="@type" />
        </xsl:call-template>
        <!-- We also make a full copy of the atom:link -->
        <xsl:call-template name="_OutputAtomLink">
          <xsl:with-param name="href" select="@href" />
          <xsl:with-param name="rel" select="@rel" />
          <xsl:with-param name="type" select="@type" />
          <xsl:with-param name="title" select="@title" />
          <xsl:with-param name="hreflang" select="@hreflang" />
          <xsl:with-param name="length" select="@length" />
          <xsl:with-param name="xmlBase" select="@xml:base" />
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSatom1 and local-name(.) = 'link'">
        <!-- Special handling for item level atom:link with rel=entry-content: complete relative URL -->
        <xsl:variable name="atomLinkUrl">
          <xsl:choose>
            <xsl:when test="@rel = 'entry-content'">
              <xsl:call-template name="_CombineUrls">
                <xsl:with-param name="baseUrl" select="$baseItemUrl" />
                <xsl:with-param name="relUrl" select="@href" />
              </xsl:call-template>
            </xsl:when>
            <xsl:otherwise>
              <xsl:value-of select="@href" />
            </xsl:otherwise>
          </xsl:choose>
        </xsl:variable>
        <xsl:call-template name="_OutputAtomLink">
          <xsl:with-param name="href" select="$atomLinkUrl" />
          <xsl:with-param name="rel" select="@rel" />
          <xsl:with-param name="type" select="@type" />
          <xsl:with-param name="title" select="@title" />
          <xsl:with-param name="hreflang" select="@hreflang" />
          <xsl:with-param name="length" select="@length" />
          <xsl:with-param name="xmlBase" select="@xml:base" />
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSatom1 and local-name(.) = 'author'">
        <xsl:variable name="author">
          <xsl:call-template name="_ConvertAtomAuthorToAuthor">
            <xsl:with-param name="name" select="atom:name" />
            <xsl:with-param name="email" select="atom:email" />
          </xsl:call-template>
        </xsl:variable>
        <xsl:call-template name="_OutputAuthor"><xsl:with-param name="value" select="$author" /></xsl:call-template>
        <!-- We also make a full copy of the atom:author -->
        <xsl:call-template name="_OutputAtomAuthor">
          <xsl:with-param name="name" select="atom:name" />
          <xsl:with-param name="email" select="atom:email" />
          <xsl:with-param name="uri" select="atom:uri" />
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSatom1 and local-name(.) = 'contributor'">
        <xsl:call-template name="_OutputAtomContributor">
          <xsl:with-param name="name" select="atom:name" />
          <xsl:with-param name="email" select="atom:email" />
          <xsl:with-param name="uri" select="atom:uri" />
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSatom1 and local-name(.) = 'id' and $isFirst = 'true'">
        <xsl:call-template name="_OutputGuid">
          <xsl:with-param name="value" select="." />
          <xsl:with-param name="isPermaLink" select="'false'" />
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSatom1 and local-name(.) = 'updated' and $isFirst = 'true'">
        <xsl:call-template name="_OutputAtomUpdated"><xsl:with-param name="value" select="." /></xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSatom1 and local-name(.) = 'published' and $isFirst = 'true'">
        <xsl:call-template name="_OutputAtomPublished"><xsl:with-param name="value" select="." /></xsl:call-template>
        <xsl:call-template name="_OutputPubDate"><xsl:with-param name="value" select="." /></xsl:call-template>
        <xsl:if test="not(../atom:updated)">
          <xsl:call-template name="_OutputAtomUpdated"><xsl:with-param name="value" select="." /></xsl:call-template>
        </xsl:if>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSatom1 and local-name(.) = 'category' and (@term or @scheme)">
        <xsl:call-template name="_OutputCategory">
          <xsl:with-param name="value" select="@term" />
          <xsl:with-param name="domain" select="@scheme" />
        </xsl:call-template>
      </xsl:when>
      <!-- Handle content: printable goes into description; non-printable is preserved -->
      <xsl:when test="namespace-uri(.) = $_NSatom1 and local-name(.) = 'content' and $isFirst = 'true'">
        <xsl:choose>
          <xsl:when test="(@src = '' or not(@src)) and (@type = '' or not(@type) or @type = 'text' or @type = 'html' or @type = 'xhtml')">
            <xsl:variable name="baseContentUrl">
              <xsl:call-template name="_CombineUrls">
                <xsl:with-param name="baseUrl" select="$baseItemUrl" />
                <xsl:with-param name="relUrl" select="@xml:base" />
              </xsl:call-template>
            </xsl:variable>
            <xsl:call-template name="_OutputDescription">
              <xsl:with-param name="value" select="." />
              <xsl:with-param name="type" select="@type" />
              <xsl:with-param name="baseUrl" select="$baseContentUrl" />
            </xsl:call-template>
          </xsl:when>
          <xsl:otherwise>
            <!-- NOTE: We don't understand content so we just won't touch it -->
            <xsl:call-template name="_OutputExtension">
              <xsl:with-param name="value" select="." />
            </xsl:call-template>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:when>
      <!-- Handle summary: printable goes into description or atom:summary; non-printable is discarded -->
      <xsl:when test="namespace-uri(.) = $_NSatom1 and local-name(.) = 'summary' and $isFirst = 'true'">
        <xsl:if test="(@src = '' or not(@src)) and (@type = '' or not(@type) or @type = 'text' or @type = 'html' or @type = 'xhtml')">
          <xsl:variable name="baseContentUrl">
            <xsl:call-template name="_CombineUrls">
              <xsl:with-param name="baseUrl" select="$baseItemUrl" />
              <xsl:with-param name="relUrl" select="@xml:base" />
            </xsl:call-template>
          </xsl:variable>
          <xsl:choose>
            <xsl:when test="not(../atom:content[(@src = '' or not(@src)) and (@type = '' or not(@type) or @type = 'text' or @type = 'html' or @type = 'xhtml')])">
              <xsl:call-template name="_OutputDescription">
                <xsl:with-param name="value" select="." />
                <xsl:with-param name="type" select="@type" />
                <xsl:with-param name="baseUrl" select="$baseContentUrl" />
              </xsl:call-template>
            </xsl:when>
            <xsl:otherwise>
              <xsl:call-template name="_OutputAtomSummary">
                <xsl:with-param name="value" select="." />
                <xsl:with-param name="type" select="@type" />
                <xsl:with-param name="xmlBase" select="@xml:base" />
                <xsl:with-param name="baseUrl" select="$baseContentUrl" />
              </xsl:call-template>
            </xsl:otherwise>
          </xsl:choose>
        </xsl:if>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSslash and local-name(.) = 'comments'">
        <xsl:if test="$isFirst = 'true'">
          <xsl:call-template name="_OutputSlashComments"><xsl:with-param name="value" select="." /></xsl:call-template>
        </xsl:if>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSwfw and (local-name(.) = 'commentRss' or local-name(.) = 'commentRSS')">
        <xsl:if test="$isFirst = 'true'">
          <xsl:variable name="commentRssUrl">
            <xsl:call-template name="_CompleteUrlTwoBase">
              <xsl:with-param name="baseUrl1" select="$baseItemUrl" />
              <xsl:with-param name="baseUrl2" select="@xml:base" />
              <xsl:with-param name="Url" select="." />
            </xsl:call-template>
          </xsl:variable>
          <xsl:call-template name="_OutputWfwCommentRSS"><xsl:with-param name="value" select="$commentRssUrl" /></xsl:call-template>
        </xsl:if>
      </xsl:when>
      <!-- Copy extension nodes -->
      <xsl:when test="namespace-uri(.) != $_NSatom1 and namespace-uri(.) != ''">
        <xsl:call-template name="_OutputExtension">
          <xsl:with-param name="value" select="." />
          <xsl:with-param name="references" select="$references" />
        </xsl:call-template>
      </xsl:when>
    </xsl:choose>
  </xsl:template>
</xsl:stylesheet>
stdole2.tlbWWW
FeedsWWW
HIFeedsManagerWWW
|RootFolderWW
edisp
IsSubscribed
+feedUrlW
subscribedWW
WExistsFeedWW
feedPath
]existsWW
#GetFeedW
yGetFeedByUrl
ExistsFolder
folderPathWW
GetFolderWWW
DeleteFeedWW
DeleteFolderd
vFEEDS_BACKGROUNDSYNC_ACTIONWd
FBSA_DISABLEd
FBSA_ENABLEWd
OFBSA_RUNNOWW
BackgroundSyncWW
RactionWW
8IOFEEDS_BACKGROUNDSYNC_STATUSW
0I&FBSS_DISABLEDWWW
FBSS_ENABLED
BackgroundSyncStatus
+statusWW
*DefaultIntervalW
OgminutesW
AsyncSyncAll
.'NormalizeWWW
KfeedXmlInWWW
feedXmlOutWW
ItemCountLimitWW,
8{HIFeedsEnumWW,
0vCountWWW,
zItem
indexWWW,
xA_NewEnum
enumVarW
IFeedFolderW
x=SubfoldersWW
CreateFeedWW
feedName
CreateSubfolderW
folderNameWW
ExistsSubfolderW
i8GetSubfolder
xDeleteWW
B+RenameWW
>yMove
newParentPathWWW
ParentWW
IsRootWW
TotalUnreadItemCount
TotalItemCountWW
FEEDS_EVENTS_SCOPEWW
FES_ALLW
FES_SELF_ONLYWWW
FES_SELF_AND_CHILDREN_ONLYWWX
kFEEDS_EVENTS_MASKWWWX
?FEM_FOLDEREVENTSX
FEM_FEEDEVENTSWW
*GetWatcherWW
0scopeWWW
-mask
8ZfIFeedFolderEventsWWW
ErrorWWW
&6FolderAddedW
-IFolderDeletedWWW
FolderRenamedWWW
7oldPathW
FolderMovedFromW
FolderMovedToWWW
FolderItemCountChangedWW
WitemCountTypeWWW
FeedAddedWWW
oFeedDeletedW
FeedRenamedW
6FeedUrlChangedWW
FeedMovedFromWWW
FeedMovedToW
'FeedDownloadingW 
}FEEDS_DOWNLOAD_ERROR 
FDE_NONE 
FDE_DOWNLOAD_FAILEDW 
FDE_INVALID_FEED_FORMATW 
FDE_NORMALIZATION_FAILED 
FDE_PERSISTENCE_FAILEDWW 
FDE_DOWNLOAD_BLOCKED 
FDE_CANCELED 
FDE_UNSUPPORTED_AUTH 
SFDE_BACKGROUND_DOWNLOAD_DISABLED 
TFDE_NOT_EXISTWWW 
"FDE_UNSUPPORTED_MSXMLWWW 
FDE_UNSUPPORTED_DTDW 
FDE_DOWNLOAD_SIZE_LIMIT_EXCEEDED 
FDE_ACCESS_DENIEDWWW 
aFDE_AUTH_FAILEDW 
,FDE_INVALID_AUTH
v[FeedDownloadCompletedWWW
FeedItemCountChanged
IFeedWWW
FEEDS_XML_SORT_PROPERTYW
zFXSP_NONEWWW
fFXSP_PUBDATE
FXSP_DOWNLOADTIMEWWWL
FEEDS_XML_SORT_ORDERL
dFXSO_NONEWWWL
FXSO_ASCENDINGWWL
0dCFXSO_DESCENDINGW
FEEDS_XML_FILTER_FLAGSWW
FXFF_ALL
FXFF_UNREADW
QFXFF_READWWW
FEEDS_XML_INCLUDE_FLAGSW
)FXIF_NONEWWW
3FXIF_CF_EXTENSIONSWW
sortProperty
sortOrderWWW
NfilterFlagsW
includeFlags
LocalIdW
feedGuid
LastWriteTimeWWW
lastWriteWWW
Download
AsyncDownloadWWW
)`CancelAsyncDownloadWx
FEEDS_SYNC_SETTINGWWx
FSS_DEFAULTWx
0,GFSS_INTERVALx
FSS_MANUALWWx
FSS_SUGGESTEDWWW
SyncSettingW
u'Interval
LastDownloadTime
&lastDownload
/LocalEnclosurePathWW
`hItemsWWW
GetItemW
28itemIdWW
~TitleWWW
 DescriptionW
homePage
ImageWWW
WimageUrl
LastBuildDateWWW
PubDateW
blastPopulateDate
Language
!/CopyrightWWW
MaxItemCount
DownloadEnclosuresAutomaticallyW
FEEDS_DOWNLOAD_STATUSWWW
058FDS_NONE
FDS_PENDINGW
1FDS_DOWNLOADINGW
iFDS_DOWNLOADEDWW
FDS_DOWNLOAD_FAILEDW
(DownloadStatusWW
LastDownloadErrorWWW
q_MergeWWW
T:feedXmlW
DownloadUrlW
IsListWW
MarkAllItemsRead
LUnreadItemCountW
UItemCountWWW@
IFeed2WW@
GetItemByEffectiveId
itemEffectiveIdW@
XLastItemDownloadTime@
Username@
Password@
SetCredentialsWW@
ClearCredentials
IFeedEventsW
FeedMovedWWW
IFeedItemWWW
}linkUrlW
Z^itemGuid
)Comments
AuthorWW
PEnclosureWWW
IsReadWW
)itemUrlW
Modifiedl
IFeedItem2WWl
EffectiveIdW
IFeedEnclosureWW
enclosureUrl
mimeType
LengthWW
LocalPathWWW
nDownloadMimeType
RemoveFileWW
'SetFileW
downloadFilePath
enclosureFilenameWWW4
8\qFeedsManager
]FeedFolderWatcherWWW
5FeedWatcherW
Microsoft FeedsWWW'
Retrieves the root subscription folder.WWW:
Determines if the URL is in the system subscription store.
Checks if a feed exists.WW
Retrieves a feed from its path.WWW
Retrieves a feed by its URL.WW
Checks if a feed folder exists.WWW!
Retrieves a folder from its path.W
Deletes a feed.WWW
Deletes a feed folder.;
Controls the behavior of background synchronization engine.WWW%
Retrieves the background sync status.W0
Retrieves the default update interval for feeds.WW+
Sets the default update interval for feeds.WWW-
Starts the background synchronization engine.W'
Converts a feed to the normalized form.WWW9
Retrieves the maximum number of items retained for feeds.W3
Retrieves the number of objects in this collection.WWW
Returns an object by index.WWW1
Retrieves the collection of feeds in this folder.W6
Retrieves the collection of subfolders in this folder.)
Creates a new feed, and subscribes to it.W&
Creates a new subfolder in the folder.
Retrieves a feed by its name.W
Checks if a subfolder exists.W"
Retrieves a subfolder by its name.,
Deletes this folder and all of its contents.WW)
Retrieves the name of the current folder.W
Renames the folder.WWW)
Retrieves the path of the current folder.W(
Moves the feed folder to a new location.WW0
Retrieves the parent of the current feed folder.WW<
Checks to see whether the current folder is the root folder.WW8
Retrieves the total (aggregated) number of unread items.WW1
Retrieves the total (aggregated) number of items.W/
Retrieves the appropriate interface for events.WWW-
Occurs when a feed folder event error occurs.W+
Occurs when a folder or subfolder is added.WWW-
Occurs when a folder or subfolder is removed.W-
Occurs when a folder or subfolder is renamed.W<
Occurs when a folder or subfolder is moved from this folder.WW:
Occurs when a folder or subfolder is moved to this folder.?
Occurs when the aggregated item count of a feed folder changes.WWW*
Occurs when a feed is added to the folder..
Occurs when a feed is deleted from the folder.
Occurs when a feed is renamed.)
Occurs when the URL of a feed is changed.W-
Occurs when a feed is moved from this folder.W+
Occurs when a feed is moved to this folder.WWW&
Occurs when a feed starts to download.6
Occurs when a feed has finished or failed downloading.-
Occurs when the item count of a feed changed.W:
Returns the Extensible Markup Language (XML) for the feed.'
Retrieves the display name of the feed.WWW
Renames the feed.W
Retrieves the URL of the feed.
Sets the URL of the feed.W-
Retrieves the guid associated with this feed.W(
Retrieves the path for the current feed.WW!
Moves the feed to a new location.W(
Retrieves the parent folder of the feed.WW)
Retrieves the last time the feed changed.W
Deletes the feed.W
Downloads content for the feed.WWW.
Downloads content for the feed asynchronously.*
Cancels asynchronous download of the feed.*
Retrieves the update setting for the feed.%
Sets the update setting for the feed.W+
Retrieves the update interval for the feed.WWW&
Sets the update interval for the feed.I
Retrieves the date and time of the last successful download for the feed.WL
Retrieves the file system path where enclosures for the feed are downloaded.WW0
Retrieves an enumerator for items from the feed.WW.
Returns a IFeedItem object by identifier (ID)."
Retrieves the title from the feed.7
Retrieves a phrase or sentence that describes the feed.WWW*
Retrieves the home page URL from the feed.&
Retrieves the image URL from the feed.,
Retrieves the last build date from the feed.WW4
Retrieves the publication date and time of the feed.WW/
Retrieves the time to live (TTL) from the feed.WWW*
Retrieves the language code from the feed.&
Retrieves the copyright from the feed.=
Maximum number of items to keep, excess items will be deletedW_
Retrieves a VARIANT_BOOL value that determines whether enclosures are downloaded automatically.WWWZ
Sets a VARIANT_BOOL value that determines whether enclosures are downloaded automatically.2
Retrieves the current download status of the feed..
Retrieves the last download error of the feed.&
Merges feed XML into an existing feed.5
Retrieves the URL that was used to download the feed.W!
Determines if the feed is a list.WG
Sets the IFeedItem::IsRead property to VARIANT_TRUE for all feed items.WWW)
Retrieves the count of unread feed items.W*
Retrieves the count of items in this feed.2
Retrieves the item that contains the effective ID.;
Retrieves the most recent download time for all feed items.WWWA
Retrieves the username used to authenticate the feed, if present.WA
Retrieves the password used to authenticate the feed, if present.W=
Sets the username and password used to authenticate the feed.W?
Clears the username and password used to authenticate the feed.WWW&
Occurs when a feed event error occurs.
Occurs when a feed is deleted.
Occurs when a feed is moved.WWH
Returns the Extensible Markup Language (XML) fragment for the feed item.WW'
Retrieves the title from the feed item.WWW%
Retrieves the URL from the feed item.W&
Retrieves the guid from the feed item.-
Retrieves the description from the feed item.W0
Retrieves the publication date of the feed item.WW:
Retrieves the URL of the comments page from the feed item.(
Retrieves the author from the feed item.WWF
Retrieves the IFeedEnclosure object associated with the the feed item.+
Retrieves the read status of the feed item.WWW&
Sets the read status of the feed item.8
Retrieves the assigned identifier (ID) of the feed item.WW+
Retrieves the parent feed of the feed item.WWW
Deletes the feed item.6
Retrieves the URL that was used to download this item.?
Retrieves the date and time of the last download for this item.WWWC
Retrieves the date and time of the last modification for this item.WWW)
Retrieves the effective ID for this item.W%
Retrieves the URL from the enclosure.WS
Retrieves the Multipurpose Internet Mail Extensions (MIME) type from the enclosure.WWW.
Retrieves the length value from the enclosure.'
Downloads the enclosure asynchronously.WWW/
Cancels asynchronous download of the enclosure.WWW7
Retrieves the current download status of the enclosure.WWW3
Retrieves the last download error of the enclosure.WWW>
Retrieves the local system path where the enclosure is stored.0
Retrieves the parent feed item of the enclosure.WW:
Retrieves the URL that was used to download the enclosure.c
Retrieves the final Multipurpose Internet Mail Extensions (MIME) type for the downloaded enclosure.WWWK
Deletes the enclosure file or cancels any pending or in-progress downloads.WWW7
Adds the downloaded enclosure file to the RSS platform.WWW/
Exposes methods to access the System Feed List.WWW:
Exposes event handlers for System Feed List folder events.'
Exposes event handlers for feed events.WWW
Microsoft.Feeds.InteropWWW
TYPELIB
en-US
0 0$0(0,0004080<0@0D0H0L0P0T0X0\0`0d0h0l0p0t0x0|0
1 1$1(1,1014181<1@1D1H1L1P1T1X1\1`1d1h1l1p1t1x1|1
2 2$2(2,2024282<2@2D2H2L2P2T2X2\2`2d2h2l2p2t2x2|2
3 3$3(3,3034383<3@3D3H3L3P3T3X3\3`3d3h3l3p3t3x3|3
4 4$4(4,4044484<4@4D4H4L4P4T4X4\4`4d4h4l4p4t4x4|4
5 5$5(5,5054585<5@5D5H5L5P5T5X5\5`5d5h5l5p5t5x5|5
6 6$6(6,6064686<6@6D6H6L6P6T6X6\6`6d6h6l6p6t6x6|6
7 7$7(7,7074787<7@7D7H7L7P7T7X7\7`7d7h7l7p7t7x7|7
8 8$8(8,8084888<8@8D8H8L8P8T8X8\8`8d8h8l8p8t8x8|8
9 9$9(9,9094989<9@9D9H9L9P9T9X9\9`9d9h9l9p9t9x9|9
: :$:(:,:0:4:8:<:@:D:H:L:P:T:X:\:`:d:h:l:p:t:x:|:
; ;$;(;,;0;4;8;<;@;D;H;L;P;T;X;\;`;d;h;l;p;t;x;|;
< <$<(<,<0<4<8<<<@<D<H<L<P<T<X<\<`<d<h<l<p<t<x<|<
= =$=(=,=0=4=8=<=@=D=H=L=P=T=X=\=`=d=h=l=p=t=x=|=
> >$>(>,>0>4>8><>@>D>H>L>P>T>X>\>`>d>h>l>p>t>x>|>
? ?$?(?,?0?4?8?<?@?D?H?L?P?T?X?\?`?d?h?l?p?t?x?|?
0 0$0(0,0004080<0@0D0H0L0P0T0X0\0`0d0h0l0p0t0x0|0
14181<1@1D1H1L1P1T1X1\1`1d1h1l1p1t1x1|1
2 2$2(2,2024282<2@2D2H2L2P2T2X2\2`2d2h2l2p2t2x2|2
3 3$3(3,3034383<3@3D3H3L3P3T3X3\3`3d3h3l3p3t3x3|3
4 4$4(4,4044484<4@4D4H4L4P4T4X4\4`4d4h4l4p4t4x4|4
5 5$5(5,5054585<5@5D5H5L5P5T5X5\5`5d5h5l5p5t5x5|5
6 6$6(6,60646D6H6L6P6T6X6`6h6p6
7 7(7,74787@7D7L7P7X7\7d7h7p7t7|7
8$8(80848<8@8H8L8T8X8`8d8l8p8|8
9 9$9(9,9094989<9@9D9H9L9P9T9X9\9`9d9h9l9p9t9x9|9
: :$:(:,:0:4:8:<:@:D:H:P:\:h:t:
; ;$;(;,;0;4;8;<;@;D;H;L;P;T;d;t;
< <(<,<4<8<@<D<L<P<X<\<d<p<|<
<<=@=H=P=h=
"4I4S4Y4`4x4
455R5W5~5
5+6Q6q6
7#7(7-72777<7A7F7K7P7t7x7}7
8!8+8A8K8i8
9':E:_:q:
<H<j<
=&=Q=s=
>6>a>t>
?4?N?
0A0W0m0
1M1v1
1C2b2
3'3K3
3?4_4w4
435K5q5
646;6D6K6t6~6
:9:\:
;D;[;
;/<R<_<g<4=I=R=y=
>5>X>
 1/1<1X1~1
2@2R2j2
5(6?6^6
7<7K7X7
8V8t8
8-979
:4:_:
;1;d;q;
;M<Z<
=+=;=
0-1\1
2B3\3
4:4h4
646C6R6
839>9
92:::W:
:3;_;
<@<L<i<
<6===J=Y=i=o=
='>.>R>r>
0 0k0t0
1!141n1
2$2>2
3h3z3
494D4f4
4I5T5z5
5=6U6x6
677z7
7D8k8q8
9-9<9k9
9R:a:{:
<+=7=j=
=1>{>
><?|?
0N0W0
0<1|1
1V2]2c2w2
3e3t3{3
4/5b5
5+6:6m6
617{7
8K8W8
9*9J9|9
9,:k:t:
:<;|;
;6<=<D<J<^<
<$=:=A=H=f=q=
>">5>~>
?:?|?
1$1W1
324{4
798a8
9,:n:
<7<W<
=/>Y>
>-?q?
0$1K1
162=2D2J2^2
2$3:3A3H3f3q3
454~4
5:5~5
6*6Y6~6
7^7z7
768{8
:Y:~:
< <D<^<
>7>|>
?7?{?
0+0r0
293@3G3b3m3
5'5D5u5
5!6R6
%0]0u0
0-1E1h1
2<2Z2|2
2-3E3h3
4o4y4
5*5=5Y5q5
6A6|6
6"797O7e7
8U8m8
9)949T9
9B:I:P:k:v:
:+;h;
<L<b<
<1=G=
=?>F>M>Y>x>
?>?v?
111u1}1
2'2F2f2l2
3\3f3
3;4R4]4}4
5)5F5
8=8n8
9I9i9
:!:Z:c:
:!;X;
<K<x<
=/=e=
0_1m1
1+2i2
454x4
515|5
5,6d6
617b7
8F8z8
8L9|9
:J:p:
;$;v;~;
>i?t?
0*1o1
3<3f3
5,5|5
6%7U7
9$:]:
<&=g=
?-?_?~?
0N0x0
313K3i3
5<5|5
:_;i;
0N1}1
5 5_5
7(8{8
:B:t:
< =X=
0 0$0(0,0004080N0}0
0X1k1y1
5D5~5
5U6q6
6F7q7
7#8e8~8
=u>~>
>B?v?
0H1)2
30363F3L3
4c4j4q4x4
6b6q6
:A;~;
<#<@<j<
<T=~=
?*?|?
0'1S1
506g6
6K7p7
798h8
8!9y9
9s:w:{:
=/>X>
>+?1?A?G?
0 0+010m0t0
1@2I2
2-3E3h3
4,4}4
585~5
7%7H7
9K9T9
:.:E:
?B?c?u?
60;0C0{0
0G1P1n1}1
272P2o2x2
4N4U4
8j8q8x8
909C9
:9;P;Z;j;
;/<o<
='>_>|>
0)1x1
2I2k2r2
5;6t6
6&7-747:7N7k7
:);n;
;K<h<
=2>O>
>N?w?
0>0T0g0
102\2e2
243l3
=O>w>
?9?P?d?v?
0,1H1
2<2^2
2J3S3
4;4~4
6:6R6Y6`6g6
7'7D7R7
989K9
99:~:
:.;f;k;
2&3-3;3f3
818v8}8
8:9q9
:?;F;a;l;
<:<t<{<
<+=2=M=X=x=
=$>^>e>y>
?G?f?
1G1}1
282}2
383}3
3N4j4
5V5m5
6-6D6m6
8X8|8
:<:y:
:=;F;j;
<0<O<
?,?I?
0E0[0
0`1k1
2-2M2`2
343X3
92:m:
:&;;;E;;<G<
='===
=U>m>
?5?m?
0 0&0,020<0
152;2F2M2R2X2g2o2|2
3%3+3<3@3F3J3P3T3Z3^3
4#4+41474=4W4^4d4l4r4
5*5N5c5
6/6E6U6k6{6
8&818A8L8p8
8%9L9
:+;V;{;
;"<F<]<
=)=@=h=
>$>q>
?(?f?
 0)0g0
1!151L1V1`1
3<3|3
3#4,4_4
5V5d5r5
5"686A6\6
7D7i7u7
8!8*8y8
<Q<]<
=(={=
>@>\>p>
?+?F?u?~?
30:0A0H0\0
1+191[1
2-2O243=3F3h3
5N6c6x6
6J7&8
9?:z:
030Q0W0p0X2
748}8
;><p<
<1=G=T=]=
>%>->D>
>$?3?9?_?
070i0u0
3B3K3
8%8>8J8x8
8&<1<B<^<
=/=J=P=U=[=v=
>2>9>U>b>p>v>
?q?w?|?
0+0u0
1+1I1V1]1f1
2(2-272N2T2k2q2w2
3&393?3Q3x3
4%4A4c4
5$5F5o5|5
6@6Q6s6
707R7
8#8F8R8l8|8
9)9G9]9n9
:%:n:
:&;P;c;z;
<-<G<q<
=%=N=t=
>P>a>h>p>
1!2^2
3 3&3u3~3
445=5w5
5H6Q6
8?8m8
9H9j9|9
99:>:e:
=Z=c=
???s?
0S0Y0`0i0
1)2L2R2p2z2
3)3F3r3
4G4L4
5'5<5A5Z5p5
5K6|6
6K7a7
828d8l8
8/959S9
:4:]:o:x:
;#;6;^;
<"<B<u<
>;>D>w>
?1?;?w?|?
0$0W0w0
0K1T1
424I4`4z4
545T5
5 6V6
7*7J7d7m7
8-8M8v8
9P9Y9{9
;5;S;
<"<9<Z<x<
=S=a=h=
>C?H?N?
>0E0L0W0}0
10191C1z1
2F2y2
454X4y4
6&797@7L7n7
7B8R8`8Z9_9i9
9':M:d:{:
:K;k;
<:<y<
071`1
2 2:2C2|2
3#42474M4
5/585[5
5G6k6
7m7v7
9>9Z9d9s9
:N:a:l:
;9;o;
<D<n<
= >D>^>g>v>
???Y?o?
0&1Q1w1
1%2G2S2a2
2n3z3
546t6
7#737E7d7s7
8%8B8M8R8b8}8
999a9p9
:4:C:V:s:
;-<D<d<
=R=l=q=
?'?=?p?
020Y0v0
1G1m1
2'2-2I2k2
363L3
484H4\4m4
5'5A5U5o5
5/6J6O6T6
627k7
8.9_9
9J:x:
<6<E<j<r<
<"='=7=L=T=w=
>!>Z>_>o>
>$?*?p?
0)1B1U1u1
1#2P2
3@3t3
304m4
4)5q5
5.6b6
6$7D7m7}7
7!8-8?8g8
819Y9
98:?:Z:
:-;@;t;
<'<K<
=,=J=l=
=">]>u>
041\1
585>5L5{5
6/7L7
92999M9q9
93:::@:P:`:w:
;.;i;
>E>v>
1;1e1
1X2z2
2'3E3s3
4a4l4y4
4Z5z5
858>8
9@9_9x9
:=;H;\;y;
=>=y=
?8?[?
0F0f0
1%2p2
343?3G3y3
3"4T4
4&5F5
5=6w6
6(7H7q7
7(8V8
9.9Q9{9
:?:u:
;);2;c;
;)<^<
=R>[>
?1?S?s?
0N0z0
1+1Q1
1P2c2
585[5
6(7v7
:&:.:
<(<1<\<~<
=0=G=a=
><>\>
1?1X1^1{1
2?2g2
343U3w3
454X4
5E5J5U5m5w5
6K6m6
7 8v8}8
8?9i9
9!:p:}:
<><f<
=(=|=
>1>9>M>x>
>:?`?i?
0(0-070<0C0x0
1V1]1d1x1
282P2m2
393N3{3
4T4w4
5>5[5
5.686]6
7T7X7\7`7d7h7l7p7t7x7|7
888?8
9;9g9
9 :P:_:d:
;!;/;T;|;
;;<Z<
=5=b=
=,>7>
S0Z0n0
071>1E1`1k1
132U2
2<3N3
4K4X4
6.6E6
787z7
898[8
9g9z9
:E:r:
:B;K;{;
<`<p<~<
=!=%=8=
1!1+151?1I1S1]1g1{1&2d2h2l2p2t2x2|2
2"3g3p3
3n4v4
7q7{7
7G8N8p8
8I9*:L:l:
:(;1;
>6???
5e6g7
:,:K:
;J;m;0<Z<
<1=D=
>&>I>
647d7
7S8m8
84999~9
9&:+:3:8:D:K:R:Y:`:g:n:u:|:
;)<M<
<%=Q=u=
?4?;?Y?y?
0=0V0
0+1R1y1
2H2s2
2"3+3d3
3$424x4
4?5g5
5=6D6M6
6%7H7o7
9-9Y9
;9;c;
?b?p?
)0:0c0l0
0H1q1
242w2
3#4>4Q4o4v4
7#7D7
8,9O9
9-:l:
;A<{<
=%=H=.>
0J1]1
1D2|2
303<3d3j3
6(6G6M6n6|6
777V7\7
8,828P8
;$;r;/<h<
=2=d=
0;1B1
888P8]8d8q8x8
9.9L9b9y9
:l:s:y:
;#;7;e;
;B<I<U<`<r<
0:0{0
1"1V1_1k1
2#2,282k2~2
3O4{4
6#626
<#<<<G<V<_<e<j<
=R=w=
=>>E>_>h>m>s>z>
<0K0r0
0x182Q2g2
5 6A6
8.8T8
;L<D=q=
=D>Y>
???N?p?
0%161E1L1
343;3?4
6C7R7r7
879I9Z9v9
:(:z:
<B=b=
=(>.>r>
2=2B2K2z2
566=6
6.7R7q7
;A;f;
0L0u0
20393k3
3 4)4
7G7h7
7J8S8
80999k9
9 :):
;3;<;c;l;
<-=6=^=c=l=
?#?V?^?t?
0t0|0
0'1/1
2&2/2w2
4$484g4
545H5y5
5'6K6b6y6
9,9K9_9
:*:P:r:
=7=Y=z=
>">@>j>
0-0X0
0&1/1g1
303S3
445C5m5
5,6x6
8"878U8
9)929o9
:&:V:a:
:B;f;
<C<g<
?5?>?y?
0A0^0
1/1]1
1E2e2
4V4n4z4
5\5w5~5
506l6
868H8Z8l8
9&999":4:r:{:
;:<j<
=<=[=b=
=>>t>
?C?m?
&0R0~0
1(1J1t1
3O3X3s3
4$4*474=4J4P4
:::R:o:
:.;@;Q;
<0<H<Q<k<~<
>?>I>h>
1p2v2
7x7~7
8S8h8
889A9p9
;G;^;
<!<0<
>B>P>U>c>v>
?#?*?H?T?t?z?
J0Q0W0
142J2
2#3:3A3N3r3~3
3;4[4
4*5H5U5
8p8{8
9\;p;
<*<H<
=+>/?4?I?N?b?g?
1@1w1D2O2f2l2
3J364;4O4T4u4
5D5J5s5
5,646\6e6
7:7o7
7&8+84898B8G8P8U8^8c8l8q8z8
9.:::v:|:
:<;E;z;
>o>}>
?k?{?
2 2J2U2
363h3
5/5y5
7>7U7
:;:X:
;$;U;
< =x=
>#>G>N>i>
3%3|4
5%5,5p5
556;6U6
7n7{7
:.;;;
<4<f<
>E?|?
4G4y4
5:5H5Q5b5k5|5
6,636R6
8L8U8]8
9#949>9t9}9
9*:|:
;);8;C;
<)<n<
=?=L=
1Z1[2
6,646G6p6
7/7l7
758\8d8
:a:{:&;W;
<!=\=
>*>D>Y>
090T0
5@5e5
6h6m6
=5=q=
y0B1Q1
373T3`3
454Q4w4
7@:\:k:z:
<j<{<
<X>i>x>
4R4|4
<#=B=
=N>r>
4P5 6
7Q8]8j9
>1?=?I?
4%404>4B4R4V4
8*9a9m9
4-4{4
747~7
828o8
8&9e9o9u9
<2=k=q=
=/>5>J>|>
>E?\?
1+2U2
5/5X5y5
7#7+777y7
:,;=;g;
<P=W=
>(>y>
?&?,?P?V?g?
030>0m0
2,2G2[2
4-535
6$6B6v6
6A7Z7
858S8Y8
829@9
9f:W;
?C?}?
0>0c0z0
0>1y1
182U2\2
2 3I3g3
4&4F4y4
4!5P5}5
646T6
717K7
7 8:8o8
9E9p9
:Q:p:
<@<Z<{<
=c=l=
>9>i>
061g1
1S2x2
5K5x5
6*7P7p7
8.8W8
9S9k9
:%:*:3:8:I:P:Y:l:
1p1v1
152C2
3F3L3q3
364_4
6U7Y7]7a7e7i7m7q7u7
<><[<
<x>}>
>P?Y?_?
0:0Z0z0
0(111\1
4=4i4
5<5j5s5
576c6
6(737
7,8Y8r8~8
819A9
9";>;G;i;
<#<D<\<e<
< =)=\=
?&?-?6?
1Z1y1
1#2,2?2_2
2D3X3f3p3~3
4#4)4.43494C4G4M4W4]4c4m4q4w4
4%5*5I5^5u5
8)8O8
;#<E<
</=V=~=
0J0j0p0{0
1(1H1x1
2+3=3
4(4c4j4q4w4~4
5+5p5w5~5
5#6*6
6'7p7{7
9A9N9[9q9
;3;8;^;
<,<I<]<
090W0'1d1
3"3/3L3
455n5
6L6u6
7^8o8
;/;\;n;};
=+=n=y=
0Q0~0
172k2
546@6N6X6
6#7)7
;#;-;p;
;$<L<w<
= >P>
?&?>?a?x?
0F0l0
1r1,2U2}2
4I5[5
8"9<9
9,:5:O:n:{:
:=;s;
1"1U1Z1
292c2n2
373e3{3
5&6k6t6
7T8v8
:*:g:
;/;C;H;y;
<(<6<J<O<
>.>5>@>P>W>a>l>|>
?"?8?Z?~?
1(1A1K1U1h1
2#3O3
394N4b4
5*6?6N6h6}6
7'777g7
;/;g;
<.>4>W>u>
>'?u?
0N0\0
1D2{2
3:3d3
3>4_4~4
4&5i5
=1=y='>
2R2Y2
5P5q5
6$7W7
7G8y8
9E9s9
9,:E:S:
1%2L2
5J5y5
8B8f8
;/;};
4P4^4g4v4
:s;x;
<!<%<)<-<1<5<9<=<A<E<I<M<Q<e<q<
=^=h=r=y=
=.?G?
0:0-2
2!3L4
7<8j8
8&9z9
94:::n:t:
:^;d;
=%>->
?5?P?W?o?
090A0
1!2M2
41484H4O4_4f4r4{4
5"52595I5P5\5e5k5
5V6q6
7)7E7Q7]7i7o7
:3:c:
<.<5<K<
=a=l=x=
>:>F>
030@0l0
4A4_4u4
5%5,5=5G5
6(6x6
677l7
9H:n:x:
=">J>r>
3(4`4e4y4~4
6J6c6
8q8~8
9U9x9
:1:=:D:b:
:A;R;X;
<W<b<s<
>)>M>
2"2*2B2
2M3q3
5%5?5w5
596J6e6
7.858C8N8X8y8
8&9k9
<.<z<
7A8I8
8e9":
?/?J?
0I0k0
233]3
3!4D4g4
5&5p5x5~5
586>6
8 959B9V9`9j9t9
:+:1:Z:s:z:
;&;/;`;i;o;w;};
?"?/?6?B?X?`?
0.080U0j0q0x0
1'1.1=1D1S1Z1l1s1
2.252D2K2V2l2s2
4&4+414C4K4X4y4
5)505C5R5v5
6F6s7
7/8W8\8a8
9'90969W9_9f9l9r9
:%:-:@:L:T:
;-;Q<i<
<P=~=
>%>,>3>:>A>I>Q>Y>e>n>s>y>
?%?,?3?:?A?H?O?U?a?l?q?v?|?
0&0/0
1;1C1P1c1h1n1{1
2-2A2G2
3(373@3I3^3s3
4)4J4W4k4{4
5 515<5M5X5i5t5
6-6=6M6]6j6~6
7$707<7G7T7h7x7
8&8:8J8Z8j8z8
9*9:9J9Z9j9z9
:*:::J:Z:j:z:
;*;:;G;[;k;{;
;3=?=K=W=c=
>0>L>P>l>p>
?,?0?L?P?l?p?
00080<0D0H0P0T0\0`0h0l0t0x0
04080<0D0
1$141D1T1d1t1
2(242@2L2X2d2p2|2
0 0$0(0,0004080<0@0D0H0L0P0T0X0`0d0h0l0p0x0|0
1 1$1(1,1014181<1@1D1L1T1X1\1`1d1h1l1p1t1x1|1
