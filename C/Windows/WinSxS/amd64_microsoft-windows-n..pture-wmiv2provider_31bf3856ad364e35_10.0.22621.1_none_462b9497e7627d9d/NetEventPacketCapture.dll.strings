!This program cannot be run in DOS mode.
DRich]j
.text
`.rdata
@.data
.pdata
@.rsrc
@.reloc
q0R^G'
q0R^G'
q:_0#
|$ AVH
VWAVH
p:_0#
p:_0#
p:_0#
@A^_^
q:_0#
@SVWH
p:_0#
q0R^G'
\$ UH
M H1E
 H3E H3E
ntelA
ineID
L$ SUVWH
8_^][
H SVWH
SVWAVH
8A^_^[
WAVAWH
\$8H;
A_A^_
t5fA9(t/I
\$ UVWAVAWH
t,D8=
L9{Hu
A_A^_^]
\$ VWAVH
D$0H;
K SVWH
f94Cu
SVWAVAWH
`A_A^_^[
x AVH
H9;s!
L$ SVWH
qH[6G
qH[6G
qQZR4?`
x AVH
x AVH
qk_2f.U
qk_2f.U
q`Y^G
8\$8t
8\$8t
8\$8t
8\$8t
x AVH
q:_0#
p1X~^
L$ SH
x AVH
x AVH
qR[Py
qR[Py
t$ WATAUAVAWH
 A_A^A]A\_
t$ WATAUAVAWH
 A_A^A]A\_
WAVAWH
 A_A^_
WATAUAVAWH
 A_A^A]A\_
x AVH
VWATAVAWH
D$0H+C
D$8H+C
L$@H3
A_A^A\_^
s WAVAWH
D$0H+F u
D$8H+F(H
L$@H3
A_A^_
UVWAVAWH
 A_A^_^]
s WAVAWH
H+D$0u
H+D$8H
L$@H3
A_A^_
UVWATAUAVAWH
0A_A^A]A\_^]
UVWATAUAVAWH
H!h E2
t"D8q
t"@8q
0A_A^A]A\_^]
|$ UATAUAVAWH
A_A^A]A\]
t @8y
t+@8y
t"@8y
|$ UATAUAVAWH
A_A^A]A\]
|$ UATAUAVAWH
A_A^A]A\]
t(D8q
t$D8q
SUVWATAVAWH
H!x H!x
0A_A^A\_^][
SUVWATAVAWH
H!x H!x
0A_A^A\_^][
|$ UATAUAVAWH
t-@8y
t$@8y
A_A^A]A\]
SUVWATAVAWH
H!p E2
0A_A^A\_^][
VWATAVAWH
 A_A^A\_^
UVWATAUAVAWH
4$I;t$
0A_A^A]A\_^]
VWATAVAWH
L$hH3
A_A^A\_^
VWATAVAWH
L$hH3
A_A^A\_^
VWATAUAVH
D$8H!\$ L
L$HH3
A^A]A\_^
VWATAVAWH
L$hH3
A_A^A\_^
UVWATAUAVAWH
4$I;t$
0A_A^A]A\_^]
UVWATAUAVAWH
4$I;t$
0A_A^A]A\_^]
VWATAVAWH
L$hH3
A_A^A\_^
VWATAVAWH
L$hH3
A_A^A\_^
UVWATAVH
H!x H
 A^A\_^]
VWAWH
H!x L
D$XI;Cpt
 A__^
VWATAVAWH
H!p H
O8L+O0I
 A_A^A\_^
VWAVH
H!x L
 A^_^
VWAWH
H!x L
D$XI;Cpt
 A__^
UVWATAVH
H!x H
 A^A\_^]
UVWATAVH
H!x H
 A^A\_^]
VWAWH
H!x L
D$XI;Cpt
 A__^
VWAWH
H!x L
D$XI;Cpt
 A__^
J(I+H
I;CptBE3
I;KptBE3
L$HH3
I;CptDE3
I;CptDE3
I;CptDE3
L$`H3
\$0E3
|$ UATAUAVAWH
t2@8q
I9CpuB
H;CHt
A_A^A]A\]
|$ UATAUAVAWH
t"@8y
I;[pu<
A:F8t
I;FHt
t$@8y
A_A^A]A\]
x UATAUAVAWH
t"@8y
t%@8y
t"@8y
A_A^A]A\]
|$ UATAUAVAWH
t$D8a
I;Cpu>
H;CHt
t$D8a
A_A^A]A\]
|$ UATAUAVAWH
t$@8q
I;Cpu>
H;CHt
t$@8q
A_A^A]A\]
{ UATAUAVAWH
I9CpuR
H;CHt
H;Cht
A_A^A]A\]
UVWAUAVH
!\$ L
A^A]_^]
UVWATAUAVAWH
D$hM;
H+G`H
t$0E3
t$0E3
L9d$Ht.
L9d$Xt.
A_A^A]A\_^]
t$ UWAVH
!\$ L
!\$ L
!\$ L
UVWATAVH
!|$ L
A^A\_^]
UVWATAUAVAWH
L+wXI
H+GpH
fD93u
D$@E3
fD93u
D$@E3
L9l$`t.
L9l$pt.
A_A^A]A\_^]
t$ UWATAUAVH
D$0!\$ 
D$0!\$ 
D$0!\$ 
A^A]A\_]
UVWATAVH
!\$ L
A^A\_^]
UVWATAVH
!|$ L
D$0!|$ 
D$0!|$ 
H+~xH
A^A\_^]
UVWATAUAVAWH
H+NxH
fD93u
D$8E3
L9|$Ht.
A_A^A]A\_^]
\$0H9_pu
\$0H9_
W H;W(t
VWATAVAWH
H!t$ L
AhH;Apu2
L$HH3
A_A^A\_^
VWAVH
L$HH3
fA9<Cu
fC9<Qu
USVWH
x_^[]
L$(E3
L$(E3
t$ WATAUAVAWH
 A_A^A]A\_
t$ WATAUAVAWH
 A_A^A]A\_
t$ WATAUAVAWH
 A_A^A]A\_
SVWATAUAVAWH
0A_A^A]A\_^[
x AVH
UWAUAVAWH
t$`H;
C\$xL
A_A^A]_]
VWATAVAWH
VpI;Vxt
 A_A^A\_^
x AVH
D$HE3
t$@8y
t$ WAVAWH
L$@H;
 A_A^_
D$0I;Cpu
x AUAVAWH
G8HcC0H
|$hA#
0A_A^A]
UATAUH
D$ E3
A]A\]
L$xE3
UVWAVAWH
fF9<@u
D$ E3
L+OhH
A_A^_^]
d$ AUAVAWH
|$0L!|$PH
|$LD;|$H
pJQ~t
A_A^A]
D$XL;
WATAUAVAWH
D;d$@
VhI;Vpt
A_A^A]A\_
c AUAVAWH
!t$@I
D9t$ts
D$D;D$@
A_A^A]
UVWATAUAVAWH
ty@8=
t"@8=
fA9>u
@A_A^A]A\_^]
WATAUAVAWH
A_A^A]A\_
|$ UH
VWAVH
0A^_^
x UATAVH
A^A\]
|$ ATH
D$ E3
D$ E3
UVWAUAVH
A^A]_^]
L$PE3
WAVAWH
t0fA;
0A_A^_
UATAWH
D$XE3
D$pE3
H!\$8H!\$0!\$(!\$ H
A_A\]
UWAUAVAWH
A_A^A]_]
WAVAWH
H!|$XH
0A_A^_
VWAVH
 A^_^
9|$Du
9|$Du
fA9<Bu
fA9<Cu
fA9<Qu
@SVWATAUAVAWH
0A_A^A]A\_^[
l$ WH
\$ UVWH
E3H!E
t$ WAVAWH
A_A^_
D$(E3
D$ E3
VWAVH
D$XE3
D$(E3
0A^_^
fA9,@u
D$(E3
VWAVH
 A^_^
@USVWAVH
D$pH+
A^_^[]
t$ WH
@USVWATAUAVAWH
D$ A99uzA
hA_A^A]A\_^[]
D$dE3
L$@H3
WAVAWH
9kpvXH
 A_A^_
WAVAWH
\$ E3
t$0A;
@A_A^_
WAVAWH
\$ E3
@A_A^_
WAVAWH
\$ E3
@A_A^_
@SVWAVAWH
|$ E3
\$ E3
L$HH3
PA_A^_^[
@SVWAVAWH
|$ E3
\$ E3
L$XH3
`A_A^_^[
VWAVH
0A^_^
VWAVH
0A^_^
VWAVH
0A^_^
VWAVH
0A^_^
VWAVH
0A^_^
L$(E3
WAVAWH
fA+1M
 A_A^_
x ATAVAWH
thfA;
t-fA;
 A_A^A\
x ATAVAWH
tffA;
t+fA;
 A_A^A\
x ATAVAWH
tofA;
t6fA;
 A_A^A\
x ATAVAWH
tdfA;
t.fA;
(t$ H
0A_A^A\
x ATAVAWH
tffA;
t+fA;
 A_A^A\
t$ WATAUAVAWH
 A_A^A]A\_
t$ WATAUAVAWH
 A_A^A]A\_
t$ WATAUAVAWH
 A_A^A]A\_
t$ WATAUAVAWH
\$PI;
 A_A^A]A\_
t$ WATAUAVAWH
gfffffffI
 A_A^A]A\_
t$ WATAUAVAWH
 A_A^A]A\_
t$ WATAUAVAWH
 A_A^A]A\_
t$ WATAUAVAWH
H!t$(
t,A8[
H98uAH;{
L$HH3
A_A^A]A\_
VWAVH
u&H;{
 A^_^
VWAVH
D$(f9
uCL;_
D$4fA
L$8H3
@A^_^
VWAVH
 A^_^
SVWATAUAVAWH
D$xI;D$ptlH
|$`L;
4fE9,$u<M
L+t$@I
L+|$XI
|$`L;
4fE9,$u<M
L+t$@I
L+|$XI
t4E8r
t(E8r
t(E8r
t(E8r
t(E8r
t(E8r
t(E8r
t2A8R
pA_A^A]A\_^[
VATAUAVAWH
fG9dE
 A_A^A]A\^
L$hH3
WAVAWH
x`fD9|$PtX
 A_A^_
WATAVH
0A^A\_
t$ WAVAWH
fC94Fu
 A_A^_
L$hH3
x ATAVAWH
 A_A^A\
x ATAVAWH
 A_A^A\
x ATAVAWH
 A_A^A\
UVWATAUAVAWH
`A_A^A]A\_^]
UVWATAUAVAWH
`A_A^A]A\_^]
UVWATAUAVAWH
`A_A^A]A\_^]
UVWATAUH
0A]A\_^]
UVWATAUH
0A]A\_^]
UVWATAUH
0A]A\_^]
x ATAVAWH
t(fE;
 A_A^A\
WAVAWH
 A_A^_
WAVAWH
 A_A^_
WAVAWH
 A_A^_
t$ WATAUAVAWH
 A_A^A]A\_
t$ WATAUAVAWH
 A_A^A]A\_
t$ WATAUAVAWH
 A_A^A]A\_
VWAUAVAWH
tT@8y
L$HH3
PA_A^A]_^
VWAVH
u&H;{
 A^_^
VWAVH
D$(f9
uDM;^pt
D$4fA
L$8H3
@A^_^
VWAWH
0A__^
VWAWH
0A__^
VWAWH
0A__^
VWAVH
 A^_^
SVWATAUAVAWH
8^\t^D
d$XL;
1fE9/u:M
H+t$8H
L+d$PI
D$XH+D$PH
H;T$`t
pA_A^A]A\_^[
f9L$Hw
s WATAUAVAWH
I+T$xH
L$PH3
A_A^A]A\_
VWAWH
 A__^
VWAWH
0A__^
|$ AVH
|$ AVH
|$ AVH
VWAVH
 A^_^
VWAUAVAWH
tT@8y
L$HH3
PA_A^A]_^
WATAUAVAWH
8\$pH
 A_A^A]A\_
WAVAWH
 A_A^_
UWAWH
D$hE3
0A__]
WATAUAVAWH
H9~`u
t%H98t H
 A_A^A]A\_
\$ UVWATAUAVAWH
pA_A^A]A\_^]
|$ AVH
L$ USWH
UVWATAUAVAWH
D9u`A
pA_A^A]A\_^]
|$ UH
|$ UH
x AVH
VWAVH
D$0E3
|$ UATAUAVAWH
u.@8}
F8@88t
A_A^A]A\]
WAVAWH
 A_A^_
D$8E3
u%H!\$8H
D$@E3
USVWAVAWH
A_A^_^[]
s WAVAWH
@A_A^_
UVWAVAWH
~0H+~(H
0A_A^_^]
VWAVH
{8D8s@u;L97u$E3
0A^_^
VWATAVAWH
 A_A^A\_^
t$ WH
WAVAWH
T$0L+
A_A^_
|$ UATAUAVAWH
A_A^A]A\]
UVWAVAWH
H!t$XA
D$H!D$@
A_A^_^]
WATAUAVAWH
H9/sDH
 A_A^A]A\_
x AVH
rHfD97w
C9fD97u,
x AVH
uPH9i
VWAVH
t$$fD
D$0D9r
@A^_^
l$ VWAVH
 A^_^
UWAVH
HcT$ HcL$$H
{ ATAVAWH
 A_A^A\
D$(E3
h UAVAWH
L$@I+
L$PH;
T$PM;
A_A^]
H!|$8H
D$0E3
UVWAVAWH
pA_A^_^]
t9H9A
UVWATAUAVAWH
PA_A^A]A\_^]
SUVWATAUAVAWH
xA_A^A]A\_^][
UVWATAUAVAWH
t$hD;
 A_A^A]A\_^]
WATAUAVAWH
H9X uK
0A_A^A]A\_
UVWATAUAVAWH
PA_A^A]A\_^]
x AVH
D9QLs
t1B9\
x ATAVAWH
t E9|
tLD9d
HtED9d
@A_A^A\
WAVAWH
A_A^_
h VWAVH
s WAVAWH
A_A^_
|$ UATAUAVAWH
A_A^A]A\]
x AVH
api-ms-win-core-synch-l1-2-0.dll
kernel32.dll
SleepConditionVariableCS
WakeAllConditionVariable
bad allocation
j;9rJ
w[M`Z
PPTP00
Unknown exception
Exception
ReturnNt
ReturnHr
LogNt
LogHr
FailFast
%hs(%u)\%hs!%p: 
%hs!%p: 
(caller: %p) 
%hs(%d) tid(%x) %08X %ws
Msg:[%ws] 
CallContext:[%hs] 
[%hs(%hs)]
[%hs]
kernelbase.dll
RaiseFailFastException
std::exception: %hs
ntdll.dll
RtlNtStatusToDosErrorNoTeb
RtlDllShutdownInProgress
RtlDisownModuleHeapAllocation
WilFailureNotifyWatchers
m]E|9$nle
Abstract
Aggregate
Aggregation
Alias
ArrayType
Association
BitMap
BitValues
ClassConstraint
ClassVersion
Composition
Correlatable
Counter
Delete
Deprecated
Description
DisplayDescription
DisplayName
EmbeddedInstance
EmbeddedObject
Exception
Expensive
Experimental
Gauge
Ifdeleted
Indication
Invisible
IsPUnit
Large
MappingStrings
MaxLen
MaxValue
MethodConstraint
MinLen
MinValue
ModelCorrespondence
Nonlocal
NonlocalType
NullValue
Octetstring
Override
Propagated
PropertyConstraint
CurrentContext
PropertyUsage
Provider
PUnit
Required
Revision
Schema
Source
SourceType
Static
Stream
Syntax
SyntaxType
Terminal
TriggerType
UMLPackagePath
Units
UnknownValues
UnsupportedValues
ValueMap
Values
Version
Write
InstanceID
CIM_ManagedElement
Caption
ElementName
CIM::Core::CoreElements
InstallDate
CIM_ManagedSystemElement
0x8000..
Indexed
CIM_ManagedSystemElement.StatusDescriptions
OperationalStatus
CIM_ManagedSystemElement.OperationalStatus
StatusDescriptions
Error
Degraded
Unknown
Pred Fail
Starting
Stopping
Service
Stressed
NonRecover
No Contact
Lost Comm
Stopped
Status
HealthState
CommunicationStatus
CIM_EnabledLogicalElement.PrimaryStatus
CIM_ManagedSystemElement.HealthState
DetailedStatus
CIM_EnabledLogicalElement.EnabledState
OperatingStatus
CIM_ManagedSystemElement.DetailedStatus
PrimaryStatus
CIM_LogicalElement
MSFT_NetEventSession
CaptureMode
LocalFilePath
MaxFileSize
TraceBufferSize
MaxNumberOfBuffers
SessionStatus
MIReturn
Start
MSFT_NetEventProviderBase
SessionGuid
SessionName
Level
MatchAnyKeyword
MatchAllKeyword
MSFT_NetEventProvider
CaptureType
MSFT_NetEventPacketCaptureProvider
MultiLayer
LinkLayerAddress
EtherType
IPAddresses
IPProtocols
TruncationLength
VmCaptureDirection
MSFT_NetEventPacketCaptureTarget
ProviderName
CaptureStatus
InterfaceDescription
MSFT_NetEventNetworkAdapter
PromiscuousMode
MacAddress
MSFT_NetEventVmNetworkAdapter
SwitchName
PortName
VMName
MSFT_NetEventVmSwitch
GroupComponent
CIM_Component
PartComponent
MSFT_NetEventCaptureTarget_CaptureProvider
MSFT_NetEventSession_Provider
CaptureLayerSet
MSFT_NetEventWFPCaptureProvider
DiscardedEvents
TCPPorts
UDPPorts
DestinationMACAddresses
MSFT_NetEventVFPProvider
SourceMACAddresses
VLANIds
GREKeys
TenantIds
SourceIPAddresses
DestinationIPAddresses
VFPFlowDirection
PortIds
MSFT_NetEventVmSwitchProvider
wmitomi.dll
%s\%s
Adapter_RegisterDLL
Adapter_UnRegisterDLL
Adapter_DllCanUnloadNow
Adapter_DllGetClassObject
bad array new length
string too long
{%x-%hx-%hx-%4hx-%4hx%4hx%4hx}
ShowInstalled
\NetEventTrace.etl
%LOCALAPPDATA%
vector too long
SYSTEM\CurrentControlSet\Control\Diagnostics\NetEventCapture
TraceLevel
NetEvtFwdr.exe
MacPacketFilter
\Device\
%s\%s %s
onecore\internal\net\inc\NetSetupCxx.h
PPTP00
7K@5C
Ionecore\internal\net\inc\NetSetupCxx.cpp
wfpcapture
PEF WFP capture policy provider.
Used for inspection; passes all frames.
PEF WFP capture sublayer.
Sublayer used by WFP capture filters.
PEF WFP callout
PEF all pass filter.
This filter should pass all frames.
FzQs]
Microsoft-Windows-Hyper-V-VfpExt
SourceMacAddresses
DestinationMacAddresses
VlanIds
SourceIpAddresses
DestinationIpAddresses
TcpPorts
UdpPorts
IpProtocols
GreKeys
FlowDirection
SwitchFriendlyName
VportIds
onecore\net\diagnostics\netevent\wmi\NetEventCaptureCore.h
htuIP
Microsoft-Windows-Hyper-V-VmSwitch
Microsoft-Windows-NDIS-PacketCapture
CaptureDirection
LinkLayerAddresses
EtherTypes
IpAddresses
VmSwitches
VmAdapters
NetAdapters
Microsoft-Pef-WFP-MessageProvider
Filter Inbound IPv4 Address
Filter Inbound IPv6 Address
Filter Outbound IPv4 Address
Filter Outbound IPv6 Address
Filter local port
Filter remote port
RtlUnregisterFeatureConfigurationChangeNotification
RtlRegisterFeatureConfigurationChangeNotification
RtlNotifyFeatureUsage
NtUpdateWnfStateData
NtQueryWnfStateData
onecore\internal\sdk\inc\wil\opensource\wil\resource.h
WilError_03
WilStaging_02
onecore\internal\sdk\inc\wil\Staging.h
UNKNOWN
SWITCH
Successfully query vmswitch capabilities. Initializing VMSIF with those capabilities.
\\.\VmSwitch
Failed to query vmswitch capabilities, expected for TH, non-AZURE RS1, or RS2..RS3 vmswitch. Initializing VMSIF with no vmswitch capabilities. Status=0x%x
Underflow VmsIfOutstanding handle count!
Local\SM0:%lu:%lu:%hs
IOCTL_PORT_CREATE
IOCTL_SWITCH_CREATE
IOCTL_PORT_DELETE
IOCTL_SWITCH_GET_INFO
IOCTL_SWITCH_DELETE
IOCTL_NIC_SET_INFO
IOCTL_SWITCH_SET_INFO
IOCTL_PORT_GET_VLAN
IOCTL_NIC_GET_INFO
IOCTL_PORT_GET_INFO
IOCTL_PORT_SET_VLAN
IOCTL_PORT_LOOKUP_FROM_MAC
IOCTL_PORT_SET_INFO
IOCTL_PORT_PROPERTY_GET
IOCTL_PORT_FEATURE_STATUS_GET
IOCTL_PORT_PROPERTY_ADD
IOCTL_PORT_PROPERTY_SET
IOCTL_ENUM_NIC_COUNT
IOCTL_PORT_PROPERTY_DELETE
IOCTL_ENUM_PORT_COUNT
IOCTL_ENUM_NICS
IOCTL_ENUM_SWITCH_COUNT
IOCTL_ENUM_PORTS
IOCTL_ENUM_VMQ_GROUP_COUNT
IOCTL_ENUM_SWITCHES
IOCTL_ENUM_PROC_COUNT
IOCTL_ENUM_VMQ_GROUPS
IOCTL_PORT_ENUM_LEARNED_MAC_COUNT
IOCTL_ENUM_PROCS
IOCTL_VMSWITCH_SET_GLOBAL_VARIABLE
IOCTL_PORT_ENUM_LEARNED_MAC
IOCTL_VMSWITCH_GET_INTERNAL_STATS
IOCTL_VMSWITCH_GET_GLOBAL_VARIABLE
IOCTL_PORT_GET_STATS
IOCTL_SWITCH_GET_STATS
IOCTL_PORT_GET_ENCAP_INFO
IOCTL_PORT_SET_ENCAP_INFO
IOCTL_NIC_CONNECT
IOCTL_NIC_GET_STATS
IOCTL_SWITCH_FEATURE_STATUS_GET
IOCTL_NIC_DISCONNECT
IOCTL_SWITCH_PROPERTY_SET
IOCTL_SWITCH_PROPERTY_GET
IOCTL_SWITCH_PROPERTY_DELETE
IOCTL_SWITCH_PROPERTY_ADD
IOCTL_VMSWITCH_GET_INIT_STATE
IOCTL_PROC_GET_STATS
IOCTL_VMSWITCH_SERVICING_END
IOCTL_VMSWITCH_SERVICING_START
IOCTL_VMSWITCH_ENABLE_OPTIMIZATIONS
IOCTL_VMSWITCH_DISABLE_OPTIMIZATIONS
IOCTL_VMSWITCH_SHUTDOWN
IOCTL_VMSWITCH_DEREGISTER_PROTOCOL
IOCTL_VMSWITCH_CONFIGURE_PROCESSORS
IOCTL_VMSWITCH_GET_PORT_HANDLE_COUNT
IOCTL_PORT_PROPERTY_ENUM
IOCTL_SWITCH_PROPERTY_ENUM
IOCTL_PORT_GET_REQUIRED_EXTENSIONS
IOCTL_SWITCH_EXTENSION_ENUM
IOCTL_NIC_SET_CONNECTION_INFO
IOCTL_PORT_SET_REQUIRED_EXTENSIONS
IOCTL_DELETE_LW_MINIPORT_NIC
IOCTL_INIT_LW_MINIPORT_NIC
IOCTL_ENABLE_MINIPORT_NIC
IOCTL_DISABLE_MINIPORT_NIC
IOCTL_DELETE_MINIPORT_NIC
IOCTL_INIT_MINIPORT_NIC
IOCTL_NIC_SEND_STATUS
IOCTL_NIC_MORPH_TO_VMNIC
IOCTL_NIC_COLLECT_INT_STATS
IOCTL_NIC_GET_INT_STATS
IOCTL_NIC_GET_DROP_REASONS_STATS
IOCTL_NIC_GET_VLAN_INFO
IOCTL_VM_NIC_SUSPEND
IOCTL_NIC_GET_VMQ_INFO
IOCTL_VM_NIC_VMPHU_ZERO_COMPLETE
IOCTL_VM_NIC_VMPHU_ZERO_BEGIN
IOCTL_DIO_NIC_SET_ADDDRESSES
IOCTL_NIC_GET_ADDRESSES
IOCTL_NIC_GET_OPERATIONAL_STATUS
IOCTL_DIO_NIC_SET_MAC_ADDRESS
IOCTL_NIC_GET_VRSS_INFO
IOCTL_NIC_GET_VRSS_INDIRECTION_ENTRIES_COUNT
IOCTL_EXEC_MON_CONFIG_SET
IOCTL_EXEC_MON_CONFIG_GET
IOCTL_EXEC_MON_OPS_COUNT
IOCTL_EXEC_MON_OPS_GET
IOCTL_EXEC_MON_PENDING_GET
IOCTL_EXEC_MON_RESET
IOCTL_PROFILER_CLEAR_PROCESSOR_STATS
IOCTL_EXEC_MON_PENDING_COUNT
IOCTL_NIC_SET_PACKET_FILTER
IOCTL_PROFILER_GET_PROCESSOR_STATS
IOCTL_VM_NIC_FREE_VF
IOCTL_VM_NIC_ALLOCATE_VF
IOCTL_NIC_ENABLE_OPTIMIZATIONS
IOCTL_NIC_MORPH_TO_DIONIC
IOCTL_VM_NIC_PAUSE
IOCTL_NIC_DISABLE_OPTIMIZATIONS
IOCTL_VM_NIC_RESTORE
IOCTL_VM_NIC_RESUME
IOCTL_PORT_HW_TIMESTAMP_OVER_VMBUS_GET
IOCTL_NIC_RELEARN_MAC
IOCTL_VSWITCH_CALLER_AUDIT_GET
IOCTL_PORT_HW_TIMESTAMP_OVER_VMBUS_SET
IOCTL_EXEC_MON_HISTORY_GET
IOCTL_VSWITCH_CALLER_AUDIT_COUNT
IOCTL_EXEC_MON_HISTORY_CURRENT_GET
IOCTL_EXEC_MON_HISTORY_COUNT
IOCTL_EXEC_MON_HISTORY_RANGE_GET
IOCTL_EXEC_MON_HISTORY_CURRENT_COUNT
IOCTL_EXEC_MON_HISTORY_RANGE_COUNT
LibIoctlHelperPrivGetRecordInfoFromLegacyBuffer: error in legacy database. RecordType=%d, record offset (%d) exceeds bufferSize (%d). error=%d
LibIoctlHelperPrivGetRecordSize: Invalid record header format. HeaderSize=%d, VariableBufferSizeArrayOffset=%d, NumElements=%d
LibIoctlHelperPrivGetRecordInfoFromLegacyBuffer: invalid legacy info for RecordType=%d. FixedSize=%d, VariableBufferSize=%d, NumElements=%d, error=%d
Context=0x%p, IOCTL=0x%x, LegacyInfo=%p, InputBuffer=0x%p, InputBufferSize=%d, OutputBuffer=0x%p, OutputBufferSize=%d
LibIoctlHelperPrivGetVersionedArrayRecordInfo: Buffer contains record of size 0
LibIoctlHelperPrivGetRecordInfoFromLegacyBuffer: RecordType=%d not found in legacy database
LibIoctlHelperPrivValidateLegacyBufferInfo: Index=%d. Legacy info contains 0 element
LibIoctlHelperPrivGetVersionedArrayRecordInfo: RecordType=%d not found in buffer
LibIoctlHelperPrivValidateLegacyBufferInfo: overflow fixedSize=%d, variableBufferSize=%d
LibIoctlHelperInitializeOperation: IsLegacy specified, but DispatchTable->GetLegacyInfo is NULL. error=%d
LibIoctlHelperInitializeOperation: Fail to allocate memory for operation context (size=%d). error=%d
LibIoctlGetArrayRecordElementEx: request for element index (%d) exceeding numElements(%d) for RecordType=%d, error=%d
LibIoctlGetArrayRecordInfoEx: Invalid parameter. OperationContext=%p, RecordType=%d, RecordVersion=%p, FixedSize=%p, NumElements=%p, error=%d
LibIoctlHelperCopyRecordToVersionedBuffer: Failed to copy data to buffer (buffer too small). BufferSize=%d
RecordType=%d, RecordVersion=%d, FixedSize=%d
LibIoctlHelperCalculateSizeInLegacyBuffer: element (%p) does not exist in record. error=%d
LibIoctlHelperCalculateSizeInLegacyBuffer: legacy fixedSize (%d) is not same as record's size (%d)
LibIoctlHelperCalculateSizeInLegacyBuffer: element index (%d)exceeds num elements specified in legacy database (%d). Element not added.
LibIoctlHelperCalculateSizeInLegacyBuffer: invalid legacy database. fixedSize=%d, variableBufferSize=%d, error=%d
LibIoctlHelperCalculateSizeInLegacyBuffer: legacy variableBufferSize (%d) is not same as element's size (%d)
LibIoctlHelperCalculateSizeInLegacyBuffer: invalid legacy database. fixedSize=LIB_IOCTL_LEGACY_BUFFER_SIZE, variableBufferSize=%d, error=%d
ElementVariableBufferSize=%d
LibIoctlHelperCopyRecordToLegacyBuffer: invalid legacy database. Record with LIB_IOCTL_LEGACY_BUFFER_SIZE is not last record. error=%d
LibIoctlHelperCalculateSizeInLegacyBuffer: invalid legacy database. Record with LIB_IOCTL_LEGACY_BUFFER_SIZE is not last record. error=%d
LibIoctlHelperCopyRecordToLegacyBuffer: invalid legacy database. fixedSize(%d) > maxElementSize(%d), error=%d
LibIoctlHelperCopyRecordToLegacyBuffer: legacy numElements (%d) is not same as record info (%d)
LibIoctlHelperCopyRecordToLegacyBuffer: legacy variableBufferSize (%d) is not same as element's variableBufferSize (%d)
LibIoctlHelperCopyRecordToLegacyBuffer: legacy fixedSize (%d) is not same as record fixedSize (%d)
LibIoctlHelperCopyRecordToLegacyBuffer: invalid legacy database. variableBufferSize exceeds buffer size. OffsetFromStart=%d, variableBufferSize=%d, bufferSize=%d, error=%d
LibIoctlHelperCopyRecordToLegacyBuffer: invalid legacy database. fixedSize exceeds buffer size. OffsetFromStart=%d, fixedSize=%d, bufferSize=%d, error=%d
LibIoctlValidateLegacyInfo: Invalid legacy database inputBuffer size != 0 or LIB_IOCTL_LEGACY_REQUESTED_SIZE for IOCTL 0x%x
LibIoctlValidateLegacyInfo: Invalid legacy database LegacyIoct(0x%x) = NewIoctl(0x%x)
LibIoctlValidateLegacyInfo: validation for index %d failed for input info for IOCTL 0x%x
LibIoctlValidateLegacyInfo: Invalid legacy input info for IOCTL 0x%x, FixedSize=%d, VariableBufferSize=%d, NumElements=%d
LibIoctlValidateLegacyInfo: Invalid legacy output info for IOCTL 0x%x, FixedSize=%d, VariableBufferSize=%d, NumElements=%d
LibIoctlValidateLegacyInfo: Invalid legacy output buffersize (LIB_IOCTL_LEGACY_BUFFER_SIZE)
LibIoctlValidateLegacyInfo: validation for index %d failed for output info for IOCTL 0x%x
Failed to allocate memory for input buffer with size %d
LibIoctlPrivAllocateLegacyInputBuffer: Using user-requested size for input buffer: %d
LibIoctlPrivAllocateLegacyInputBuffer: legacy input buffer size is specified as LIB_IOCTL_LEGACY_REQUESTED_SIZE, and user failed to call SetInputBufferSizeIfLegacy() before calling LibIoctlDeviceIoControl. error=%d
LibIoctlPrivAllocateLegacyInputBuffer size=%d
LibIoctlHelperCalculateSizeInLegacyBuffer does not return actual value for buffer size. legacy fixedSize=%d, legacy variableBufferSize=%d. error=%d
LibIoctlPrivConstructInputBuffer - input bufer was already constructed
LibIoctlPrivAllocateVersionedInputBuffer, size=%d
Invalid legacy output buffer size specified: LIB_IOCTL_LEGACY_BUFFER_SIZE. error=%d
LibIoctlPrivConstructInputBuffer - input buffer constructed
LibIoctlPrivSendIoctl
LibIoctlPrivSetInitialOutputBuffer with size=%d
LibIoctlPrivSendIoctl: First IOCTL returns output buffersize needed=%d
Failed to create event for overlapped object. error=%d
IOCTL returned from kernel with error %d
LibIoctlPrivSendIoctl: Failed to allocate IOCTL output buffer with size %d
LibIoctlPrivSendIoctl: IOCTL returns with error=%d
LibIoctlPrivSendIoctl: Second IOCTL returns with error=%d
LibIoctlInitializeOperation: Called with legacy IOCTL code 0x%x error=%d
Initialize library context, IsLegacy=%d
LibIoctlInitializeOperation: Use legacy IOCTL (0x%x) instead of IOCTL (0x%x)
LibIoctlInitializeOperation: Unable to find legacy IOCTL code for %x to communicate with legacy driver. error=%d
LibIoctlInitializeOperation: IOCTL library either failed, or has not been initialized.
=====> Initialized IOCTL 0x%x, DriverHandle=0x%p, IsOverlappedHandle=%d
=====> ReInitialize IOCTL 0x%x, DriverHandle=0x%p, IsOverlappedHandle=%d
LibIoctlInitializeOperation: OperationContext is NULL
LibIoctlGetRecordEx: Found more than 1 element (%d) for the record RecordType=%d, error=%d
LibIoctlGetRecordEx: Invalid parameter. OperationContext=%p, RecordType=%d, RecordVersion=%p, FixedSize=%p, Record=%p, error=%d
LibIoctlDeviceIoControl: Invalid parameter: NULL OperationContext
LibIoctlGetRecordEx: RecordType=%d. Got record with info: RecordVersion=%d, FixedSize=%d, VariableBufferSize=%d, Record=%p
LibIoctlDeviceIoControl: Fail to allocate initial output buffer of size %d, error=%d
LibIoctlDeviceIoControl: legacy output buffer size is specified as LIB_IOCTL_LEGACY_REQUESTED_SIZE, and user failed to call SetOutputBufferSizeIfLegacy() before calling this function. error=%d
LibIoctlSetOutputBufferSizeIfLegacy: OutputBufferSize=%d
<===== DeInitializing IOCTL operation
VmsCapabilityFeatureReserved
VmsCapabilityFeatureExtensibilityStackBypass
ReservedFeature
VmsCapabilityFeatureUntrustedGuestIsolation
Can bypass extensibility stack for host vNICs
VmsCapabilityFeaturePacketTracking
Can isolate untrusted VMs from cache attacks on host
VmsCapabilityFeatureNblOobIndicateUncachedData
Can track where packets have been within vmswitch
VmsCapabilityFeatureSuspendedLiveMigration
Marks NBL as fully shadowed using bits in FORWARDING_EXTENSION
VmsCapabilityFeatureIndependentHostSpreading
Can support suspended live migration for port redirection
VmsCapabilityFeatureVersionedIoctl
Can support independent host spreading when RSS is disabled in guest
VmsCapabilityFeatureQueryVlanInfo
IOCTL buffers start with header meta data
VmsCapabilityFeatureSoftwareRscOnPhysicalNic
Returns VLAN information
VmsCapabilityFeatureLightweightMiniports
Can perform Software RSC over physical NIC
VmsCapabilityFeatureDisableVmNicIM
Supports device-less host MINIPORTs
VmsCapabilityFeatureNrtNameResolutionId
Supports disabling vmbus monitored notifications to vmNIC
VmsCapabilityFeatureVmbusAffinityPolicy
Handles NrtNameResolutionId in NBLs
VmsCapabilityFeatureHostVNicProxy
Supports setting of VMBUS affinity policy
VmsCapabilityFeatureReloadability
Supports proxy driver for host vNICs
VmsCapabilityFeatureVmPhuZeroReloadability
Supports vmswitch reloadability
VmsCapabilityFeaturePacketMonitor
Supports vmswitch Phu-Zero reloadability
VmsCapabilityFeatureDynamicVMMQ
Can perform packet monitoring
VmsCapabilityFeatureStateSeparation
Can perform dynamic VMMQ steering using RSSv2
VmsCapabilityFeatureHardwarePacketTimestamp
Supports state separation
VmsCapabilityFeatureQueryCapabilitiesIoctl
Supports hardware timestamping of NBLs
VmsCapabilityFeatureConfigureSwitchPerfParameters
Supports IOCTL to query capabilities
VmsCapabilityFeatureHostNicUseL2IndirectionTable
Supports configurable parameters to modify switch performance
VmsCapabilityFeatureConfigureGlobalsUsingIoctl
Allows host vNic to indicate packets using L2 indirection table
VmsCapabilityFeatureReloadSensitiveIoctls
Allows user to configure global variable using the ioctl interface.
VmsCapabilityFeatureNonConsecutiveRssCpus
Supports reload-sensitive IOCTLs.
VmsCapabilityFeatureRscOnVPortLevel
Supports non-consecutive CPUs in RSS/VMMQ OIDs.
VmsCapabilityFeatureConfigureSwitchExtensionParameters
Supports RSC Enablement/Disablement per vPort
VmsCapabilityFeatureHotPatchIOCTL
Supports Enablement/Disablement of By passing extension stack and setting Required Extensions
The vSwitch has support for hot patch IOCTL
RSDS!
NetEventPacketCapture.pdb
.text$di
.text$mn
.text$mn$00
.text$x
.text$yd
.rdata$brc
.rdata$T$brc
.idata$5
.00cfg
.CRT$XCA
.CRT$XCU
.CRT$XCZ
.CRT$XIA
.CRT$XIC
.CRT$XIZ
.CRT$XLA
.CRT$XLZ
.CRT$XPA
.CRT$XPZ
.CRT$XTA
.CRT$XTZ
.gehcont
.gfids
.rdata
.rdata$r
.rdata$voltmd
.rdata$zzzdbg
.rtc$IAA
.rtc$IZZ
.rtc$TAA
.rtc$TZZ
.tls$
.tls$ZZZ
.xdata
.xdata$x
.edata
.idata$2
.idata$3
.idata$4
.idata$6
.data$brc
.data$r$brc
.data$rs$brc
.data
.pdata
.rsrc$01
.rsrc$02
NetEventPacketCapture.DLL
DllCanUnloadNow
DllGetClassObject
DllMain
DllRegisterServer
DllUnregisterServer
GetProviderClassID
MI_Main
?_Xlength_error@std@@YAXPEBD@Z
msvcp_win.dll
_initterm
_initterm_e
api-ms-win-crt-runtime-l1-1-0.dll
__CxxFrameHandler4
__std_terminate
_o___std_exception_copy
_o___std_exception_destroy
_o___std_type_info_destroy_list
_o___stdio_common_vsnprintf_s
_o___stdio_common_vswprintf
_o___stdio_common_vswprintf_s
_o___stdio_common_vswscanf
_o__callnewh
_o__cexit
_o__configure_narrow_argv
_o__crt_atexit
_o__errno
_o__execute_onexit_table
_o__initialize_narrow_environment
_o__initialize_onexit_table
_o__invalid_parameter_noinfo
_o__invalid_parameter_noinfo_noreturn
_o__purecall
_o__register_onexit_function
_o__seh_filter_dll
_o__wcsicmp
_o_free
_o_malloc
_o_terminate
_o_tolower
_o_toupper
__C_specific_handler
__CxxFrameHandler3
__current_exception
__current_exception_context
memset
_CxxThrowException
api-ms-win-crt-private-l1-1-0.dll
api-ms-win-crt-string-l1-1-0.dll
GetModuleFileNameA
HeapFree
GetModuleHandleExW
GetCurrentThreadId
FormatMessageW
HeapAlloc
GetProcAddress
GetProcessHeap
GetModuleHandleW
DebugBreak
TraceMessage
GetTraceLoggerHandle
GetTraceEnableLevel
GetTraceEnableFlags
RegisterTraceGuidsW
UnregisterTraceGuids
DisableThreadLibraryCalls
FreeLibrary
GetSystemDirectoryW
LoadLibraryExW
GetLastError
ExpandEnvironmentStringsW
CoCreateGuid
CreateFileW
ReleaseSRWLockExclusive
AcquireSRWLockExclusive
CloseHandle
ReleaseSRWLockShared
AcquireSRWLockShared
EnableTraceEx2
RegQueryValueExW
SetLastError
DeviceIoControl
CoUninitialize
CoCreateInstance
ControlTraceW
CheckTokenMembership
FreeSid
WaitForSingleObject
RegSetValueExW
RegDeleteTreeW
RegEnumKeyExW
OutputDebugStringW
AllocateAndInitializeSid
CreateProcessW
CoInitializeEx
StartTraceW
StopTraceW
IsDebuggerPresent
GetExitCodeProcess
StringFromGUID2
ConvertInterfaceGuidToLuid
RegCreateKeyExW
RegCloseKey
ConvertInterfaceLuidToIndex
OpenServiceW
StartServiceW
ControlService
OpenSCManagerW
CloseServiceHandle
RtlCaptureContext
RtlLookupFunctionEntry
RtlVirtualUnwind
UnhandledExceptionFilter
SetUnhandledExceptionFilter
GetCurrentProcess
TerminateProcess
IsProcessorFeaturePresent
EnterCriticalSection
LeaveCriticalSection
InitializeCriticalSectionAndSpinCount
DeleteCriticalSection
WaitForSingleObjectEx
CreateEventW
QueryPerformanceCounter
GetCurrentProcessId
GetSystemTimeAsFileTime
InitializeSListHead
api-ms-win-core-libraryloader-l1-2-0.dll
api-ms-win-core-heap-l1-1-0.dll
api-ms-win-core-processthreads-l1-1-0.dll
api-ms-win-core-localization-l1-2-0.dll
api-ms-win-core-debug-l1-1-0.dll
api-ms-win-eventing-classicprovider-l1-1-0.dll
api-ms-win-core-sysinfo-l1-1-0.dll
api-ms-win-core-errorhandling-l1-1-0.dll
api-ms-win-core-processenvironment-l1-1-0.dll
api-ms-win-core-com-l1-1-0.dll
api-ms-win-core-file-l1-1-0.dll
api-ms-win-core-synch-l1-1-0.dll
api-ms-win-core-handle-l1-1-0.dll
OLEAUT32.dll
api-ms-win-eventing-controller-l1-1-0.dll
api-ms-win-core-registry-l1-1-0.dll
api-ms-win-core-io-l1-1-0.dll
api-ms-win-security-base-l1-1-0.dll
IPHLPAPI.DLL
api-ms-win-service-management-l1-1-0.dll
api-ms-win-service-winsvc-l1-1-0.dll
WS2_32.dll
api-ms-win-core-rtlsupport-l1-1-0.dll
api-ms-win-core-processthreads-l1-1-1.dll
api-ms-win-core-profile-l1-1-0.dll
api-ms-win-core-interlocked-l1-1-0.dll
PathIsRelativeW
api-ms-win-core-shlwapi-legacy-l1-1-0.dll
RtlIpv4AddressToStringW
RtlEthernetAddressToStringW
RtlIpv6AddressToStringW
NtOpenFile
RtlIpv6StringToAddressW
RtlEthernetStringToAddressW
RtlIpv4StringToAddressW
ntdll.dll
NetSetupFreeObjects
NetSetupGetObjects
NetSetupFreeObjectProperties
NetSetupClose
NetSetupInitialize
NetSetupGetObjectProperties
NetSetupApi.dll
FwpmProviderAdd0
FwpmSubLayerAdd0
FwpmEngineOpen0
FwpmFilterDeleteById0
FwpmCalloutDeleteById0
FwpmCalloutAdd0
FwpmFilterAdd0
FwpmEngineClose0
fwpuclnt.dll
InitializeCriticalSection
CreateSemaphoreExW
ReleaseSemaphore
InitializeCriticalSectionEx
WaitForThreadpoolTimerCallbacks
ReleaseMutex
CloseThreadpoolTimer
OpenSemaphoreW
SetThreadpoolTimer
CreateThreadpoolTimer
CreateMutexExW
GetVersionExW
GetOverlappedResult
CreateEventA
api-ms-win-core-threadpool-l1-2-0.dll
memchr
memcmp
memcpy
memmove
.?AVbad_alloc@std@@
.?AVResultException@wil@@
.?AVexception@std@@
.?AVbad_array_new_length@std@@
.?AVtype_info@@
VS_VERSION_INFO
StringFileInfo
040904B0
CompanyName
Microsoft Corporation
FileDescription
NetEvent Packet Capture Provider
FileVersion
10.0.22621.1 (WinBuild.160101.0800)
InternalName
NetEventPacketCapture.dll
LegalCopyright
 Microsoft Corporation. All rights reserved.
OriginalFilename
NetEventPacketCapture.dll
ProductName
Microsoft
 Windows
 Operating System
ProductVersion
10.0.22621.1
VarFileInfo
Translation
en-US
