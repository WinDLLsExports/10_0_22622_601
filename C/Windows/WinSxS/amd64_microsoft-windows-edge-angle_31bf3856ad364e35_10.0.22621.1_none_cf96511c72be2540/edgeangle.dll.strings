!This program cannot be run in DOS mode.
Rich}
.text
`.rdata
@.data
.pdata
@.didat
.rsrc
@.reloc
|$ UAVAWH
A_A^]
t$ WATAUAVAWH
pKP|K
A_A^A]A\_
UATAUAVAWH
\$0E3
<tXA+
D8WstDI
D8Wst
D$h@t
w3D9|$,s,H
H;G@u
:D$ u
A_A^A]A\]
|$ AVH
VWATAVAWH
 A_A^A\_^
J0D8R(
|5D8R
x AVH
{ AVH
UR7?!
UAUAVH
pKP|K
A^A]]
A8IUu{
B,A9@,
B<A9@<
BtA9@t
@x#Bx
H;F@u8H
x AVH
UVWATAUAVAWH
t$8L#
|$(E3
D8xwtl
D8~Fu
D8~Htg
`A_A^A]A\_^]
WATAUAVAWH
A_A^A]A\_
x ATAVAWH
 A_A^A\
H9Q@t
H9Q8t
H9QHu
H;G t
t$ WH
@USVWATAVAWH
H;Kpt
A_A^A\_^[]
H;C u
x AVH
t$ WAVAWH
0A_A^_
t$ WH
HcKD8
L$@H3
UVWATAUAVAWH
@A_A^A]A\_^]
WATAUAVAWH
 A_A^A]A\_
p WAVAWH
D$PL;C t
0A_A^_
x AVH
VWAVH
 A^_^
UATAVH
A^A\]
@USVWATAVH
HM;B(u
A^A\_^[]
\$ VATAUAVAWH
0A_A^A]A\^
@UVWAUAVAWH
A98t/M
H(HcA
A_A^A]_^]
D8~@u
D$0E3
|$(E3
t$ UWAVH
D80t+H
D!u#I
x AVH
VWAVH
D$PL;C t
0A^_^
x AVH
x AVH
UATAUAVAWH
A_A^A]A\]
UWAVH
WATAUAVAWH
 A_A^A]A\_
x AVH
UWAVH
UWAVH
UWAVH
x AVH
UVWATAUAVAWH
L!|$pI+
t$8E3
D9h<A
A_A^A]A\_^]
x ATAVAWH
A_A^A\
x AVH
VWAVH
D$PL;C t
0A^_^
x UAVAWH
A_A^]
|$ UAVAWH
@A_A^]
x ATAUAVH
 A^A]A\
L$(H3
@USVWATAVAWH
A_A^A\_^[]
H;C u
L$8I;
L$HI;
@seE3
\$ VWATAUAWH
L9(uoH
 A_A]A\_^
UVWATAUAVAWH
D;mXu
`A_A^A]A\_^]
UVWATAUAVAWH
PA_A^A]A\_^]
p \4!
@USVWATAUAVAWH
\$h8X
L$`E3
D$pH;F t?L
H9F(r
A_A^A]A\_^[]
@USVWATAUAVAWH
O`L9I sZH
H9G`wCE3
O`L9I 
H;wxt
D8l$A
FhL9(
p[\RJ
A_A^A]A\_^[]
USWATAUAWH
pq^p6
A_A]A\_[]
|$ AVH
UVWATAUAVAWH
A_A^A]A\_^]
H9D$hD
L$HE3
|$(E3
|$(E3
USVATAUAVH
~0D9U
xA^A]A\^[]
@USWATAVH
pA^A\_[]
|$ AVH
UVWATAUAVAWH
A8t$(t
E8|$)t
L$PLcN
H9F(u
N`L9I sOH
H9F`wBL
T$PE3
FxH9E
T$(E3
A_A^A]A\_^]
\$ UVWATAUAVAWH
D$@E3
A!ELA
A_A^A]A\_^]
@USVWATAUAVAWH
A_A^A]A\_^[]
@USVWATAUAVAWH
D$8t.H
D;t$P
D$@E3
D;d$PsCH
D$HE3
\$0D:
D$H;F@t
I;G t*L
uxD9uh
A_A^A]A\_^[]
\$ UVWATAUAVAWH
A_A^A]A\_^]
USATAVAWH
A_A^A\[]
@UVWAUAVAWH
ppQ<W
L9l$Pt
F(H+F H
A_A^A]_^]
@UVWATAVAWH
ppQ<W
L9|$P
F@H+F8H
A_A^A\_^]
@USVWAUAVAWH
D$XE3
ppQ<W
D9d$h
A_A^A]_^[]
@USVWATAUAVAWH
D$0H+
A_A^A]A\_^[]
USVWH
D$8H9D$0
|$ AVH
t$ WH
@USVWH
F ;H4
)|$`D
)D$PH
L$@H3
(|$`D
(D$PH
|$ AVH
(t$0H
@SVWH
H;C u
|$ ATAVAWH
A_A^A\
VATAUAVAWH
C0D9D
 A_A^A]A\^
UAVAWH
F rIw
rA;xp~
A_A^]
pZYTe&X
t$ AVH
x AVH
|$ AVH
t$ WH
WAVAWH
0A_A^_
A`H9AXuDA
t$ WH
t$ UWAVH
9X`tz
t$ WH
(|$@D
(D$0D
(L$ H
L$0H3
\$ UVWAUAVH
t49]Ht/H
PA^A]_^]
UVWATAVH
F@H9F8sUH
A^A\_^]
x AVH
x AVH
@SUVWATAVAWH
CD$ H
CL$ H
G`H9GXt
L$@H3
PA_A^A\_^][
x UAVAWH
A_A^]
x AVH
UWAVH
WAVAWH
 A_A^_
UVWATAUAVAWH
 A_A^A]A\_^]
t$ WH
UUUUUUU
pq]||
(|$0H
UUUUUUU
x AVH
x ATAVAWH
UUUUUUU
 A_A^A\
UUUUUUU
t$ UWAWH
P HcB$
t)HcA$
@A__]
UVWAVAWH
G0H9G(
C H+C
UUUUUUUU
C H+C
A_A^_^]
@USVWATAUAVAWH
H+S0H
A_A^A]A\_^[]
D8APv
D8AQwfE2
D8BQw\D8APv$D8AQu
D8BQu
D8BQw1A:
D8BQu
D8APv
D8AQu
VWATAVAWH
 A_A^A\_^
UWAVH
UWAVH
v!D83v
?tIA;
vtD83voH
@SUVWATAUAVAWH
D$ D8l$!u{E9/tmH
CD$0H
L$PH3
hA_A^A]A\_^][
l$ H;
9?trI
A8@hv
A8@iE
L$ L;
D8]Pv,D8]Qv&E
t$ UWAVH
WAVAWH
 A_A^_
\$ UVWH
UWAUAVAWH
r&w$L
@A_A^A]_]
p AWH
H9T$Pw]H
L+t$PL
AP:BP
CP8GPt
CQ8GQu
ChH9Ght
@USVWATAUAVAWH
xA_A^A]A\_^[]
UVWAVAWH
pA_A^_^]
t$ UWAVH
@SUVWAVH
PA^_^][
k VWAUAVAWH
L$pH3
A_A^A]_^
L$XH3
x AVH
qQ\z#
@USVWATAUAVAWH
D$PE3
A_A^A]A\_^[]
t$ WH
@SUVWAVAWH
A_A^_^][
x AVH
t$ WH
L$@H3
x AVH
GhH9C v:H
WhH9V
t$ WAVAWH
D$HE3
E9xLu
D9x8u#
HcC4H
H9C@vl
HcC4H
P@I;P
P@I;P
HcC8I
P@I;P
P@I;P
HcC8I
P@I;P
P@I;P
P@I;P
P@I;P
P@I;P
P@I;P
HcC8I
P@I;P
P@I;P
HcC8I
P@I;P
P@I;P
HcC8I
P@I;P
P@I;P
HcC8I
HcS8L
L$HH3
PA_A^_
P@I;P
P@I;P
HcC8I
P@I;P
P@I;P
HcC8I
@HLcC8H
P@I;P
sYfff
P@I;P
HcC8I
@HLcC8H
P@I;P
sYfff
P@I;P
HcC8I
@HLcC8H
P@I;P
sYfff
P@I;P
HcC8I
@HLcC8H
P@I;P
sYfff
P@I;P
HcC8I
@HLcC8H
P@I;P
sYfff
P@I;P
HcC8I
@HLcC8H
P@I;P
sYfff
P@I;P
HcC8I
@HLcC8H
P@I;P
sYfff
P@I;P
HcC8I
@HLcC8H
P@I;P
sYfff
P@I;P
HcC8I
@HLcC8H
P@I;P
sYfff
P@I;P
HcC8I
@HLcC8H
P@I;P
sYfff
P@I;P
HcC8I
@HLcC8H
P@I;P
sYfff
P@I;P
HcC8I
@HLcC8H
P@I;P
sYfff
P@I;P
HcC8I
@HLcC8H
P@I;P
sYfff
P@I;P
HcC8I
@HLcC8H
P@I;P
sYfff
P@I;P
HcC8I
@HLcC8H
P@I;P
sYfff
P@I;P
HcC8I
@HLcC8H
P@I;P
sYfff
P@I;P
HcC8I
@HLcC8H
P@I;P
sYfff
P@I;P
HcC8I
@HLcC8H
P@I;P
sYfff
P@I;P
HcC8I
@HLcC8H
P@I;P
sYfff
P@I;P
HcC8I
@HLcC8H
P@I;P
sYfff
P@I;P
HcC8I
@HLcC8H
P@I;P
sYfff
P@I;P
HcC8I
@HLcC8H
P@I;P
sYfff
P@I;P
HcC8I
@HLcC8H
P@I;P
sYfff
P@I;P
HcC8I
@HLcC8H
P@I;P
sYfff
P@I;P
HcC8I
@HLcC8H
P@I;P
sYfff
P@I;P
HcC8I
P@I;P
P@I;P
HcC8I
P@I;P
P@I;P
HcC8I
H9Q@t*H
t$ AWD
@USVWATAUAVAWH
t$8u/L
A_A^A]A\_^[]
WAVAWH
 A_A^_
WAVAWH
 A_A^_
@USVWATAUH
)T$`H
D$0E3
D$0E3
(D$`L
L$PfA
A]A\_^[]
QLL;I@stL
M;H@r
WATAUAVAWH
D9C8~If
D;K8|
D9h8u#
HcC4H
H9C@vp
HcC4H
HcS8L
 A_A^A]A\_
 !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVVVWXYZ[\]^_`abcdefghiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiijkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkklmmmnnnooopppqrstuvwxyz{|}~
HcK4H
L$`H3
WATAUAVAWH
A_A^A]A\_
p[\RJ
\$ UVWAVAWH
A_A^_^]
t$ WH
|$ UATAUAVAWH
FXH+F`H
A_A^A]A\]
USVWATAUAVAWH
GPH9GHtDH
RH9GHt
HA_A^A]A\_^[]
\$ UVWATAUAVAWH
PA_A^A]A\_^]
h UAVAWH
D$(E3
A_A^]
x AVH
x ATAVAWH
@A_A^A\
UAVAWH
A_A^]
WATAVH
UTB7U
@A^A\_
x UAVAWH
A_A^]
Q|V?`
uV9QDtQH
t$ UH
UVWATAUAVAWH
A_A^A]A\_^]
USWATH
A\_[]
8gu(I
A\_[]
WATAVH
paUPE
0A^A\_
Q|V?`
t*H9z(t
t$ UWATAVAWH
G(D9`<~/H
G(D9`t~/H
A_A^A\_]
WAVAWH
A_A^_
l$ VWAVH
H+F H
H+F H
L$@H;
 A^_^
WATAUAVAWH
t7D9>u2H
D$HH;
A_A^A]A\_
UWAVH
pKP|K
|$ UAVAWH
A_A^]
t$ UWATAVAWH
A_A^A\_]
UAVAWH
A_A^]
H9Z(tjI
D8Jzu
@VWAVH
IcJ<I;
IcJtI;
IcJ@I;
IcJpI;
IcJlI;
IcJxI#
{IcJT
oIcJ I;
bE9B,
XIcJhI#
LIcJ8I#
CIcJHI;
=IcJLI;
0IcJPI;
T$@H;W
D$@E3
D$AE3
D$BE3
D$CE3
 A^_^
WATAUAVAWH
A_A^A]A\_
x AVH
|$ UATAUAVAWH
A_A^A]A\]
UATAUAVAWH
A_A^A]A\]
9\$Dw(9\$Hw"H9_ 
UVWATAUAVAWH
u/D;J
G0D8x
G0D8x
G0D8x
G0D8x
G0D8xa
T$8Hc
G0D8x
G08Plu
A_A^A]A\_^]
UATAVH
A^A\]
WATAUAVAWH
D$0u:
A_A^A]A\_
x ATAVAWH
@A_A^A\
UAVAWH
0A_A^]
UATAUAVAWH
A_A^A]A\]
umD9Q$w{D9Q(wu
u5E9P
H UATAUAVAWH
A8vut
A_A^A]A\]
ATAVAWH
A_A^A\
WAVAWH
FU9^Pu
Nxu.E3
0A_A^_
|$ UAVAWH
@A_A^]
VWAVH
0A^_^
USVWATAVAWH
EPD8`
D8`4t
PA_A^A\_^[]
@USVWATAUAVAWH
L$ E3
t$ H;t$(
\$xD8[
H;t$(
A_A^A]A\_^[]
|$ UH
teL;U0t_A
\$@H;_
D$@H;C tQH
UVWATAUAVAWH
PA_A^A]A\_^]
WAVAWH
 A_A^_
WAVAWH
 A_A^_
L$8H;K
x UATAUAVAWH
A_A^A]A\]
H UATAUAVAWH
A_A^A]A\]
` UAVAWH
A_A^]
@USVWATAUAVAWH
A_A^A]A\_^[]
x AVH
x AVH
x AVH
T$`Lc
H;C u
L$PH3
UWATAVAWH
A_A^A\_]
9D$(vE
D;T$(r
x ATAVAWH
0A_A^A\
SUVWATAUAVAWH
XA_A^A]A\_^][
WAVAWH
 A_A^_
x AUAVAWH
A_A^A]
T$0E3
UVWATAUAVAWH
E@A9E
EXA9E
D9}`tRL
PA_A^A]A\_^]
x AVH
UATAUAVAWH
EXL9}P
MXL9K 
I9F`I
A_A^A]A\]
x AVH
H9A uW
` UAVAWH
A_A^]
@SUVWAUAVAWH
L$@H3
PA_A^A]_^][
` UAVAWH
O`L9I s]H
@A_A^]
x AVH
H9F`wNE3
UATAUAVAWH
A_A^A]A\]
N`L9I s\H
VWAVH
L$hH3
pA^_^
x ATAUAVH
 A^A]A\
x AVH
H!1H!q
uUD9G
\$ UVWH
x AVH
@USVWAUH
A;Y@A
`A]_^[]
USVWATAVH
}_A8~
A^A\_^[]
x UAVAWH
A_A^]
\$ UVWH
VWAVH
 A^_^
zWuUH
\$ WH
L$@H3
@USVWATAUAVAWH
A_A^A]A\_^[]
L$@H3
L$@H3
\$0HcH
D$0HcH
L$@H3
D8APv
D8APw)
D8AQu
D$ H;
t$ UWATAVAWH
A_A^A\_]
\$ WH
H9Aht H
APH9AHt
WATAUAVAWH
t$XE2
 A_A^A]A\_
|$ UH
x ATAVAWH
A_A^A\
I+RpH
I;@`H
UVWATAUAVAWH
A_A^A]A\_^]
UWATAVAWH
F`H9FXtcL
A_A^A\_]
UVWATAUAVAWH
A9<$H
`A_A^A]A\_^]
UVWATAUAVAWH
PA_A^A]A\_^]
@USVWATAUAVAWH
D$pI9D$hI
L$8E3
A_A^A]A\_^[]
WAVAWH
t:H;W
tVHcT$XH
pX^6V>
A_A^_
t$ WH
OPH9OHt|
L$PH3
APH9AHt
x AVH
9gu'H
F`8L$Pt
UAUAWH
A_A]]
@USVWATAUAVAWH
A_A^A]A\_^[]
@USVWATAUAVAWH
A8]0t
A8^*tpA8^,tjH
A8u`t
FPH9FHt
@8t$0
A8v)H
F8@8p
L9~ t&H
GPH9GHt
A_A^A]A\_^[]
\$ UVWATAUAVAWH
pA_A^A]A\_^]
UVWAVAWH
 A_A^_^]
UWATAVAWH
0A_A^A\_]
I8H;K@tBH
WAVAWH
 A_A^_
k VWAVH
@A^_^
@USVWATAUAVAWH
H9VHt
A_A^A]A\_^[]
\$ UVWATAUAVAWH
}@H9z
D$8H;
A_A^A]A\_^]
|$ UAVAWH
@A_A^]
x AVH
p AWH
x ATAVAWH
pX^6V>
A_A^A\
UVWATAUAVAWH
@A_A^A]A\_^]
WAVAWH
D$@H;V
 A_A^_
VWAVH
H;G t
 A^_^
pIT>J
UVWATAUAVAWH
l$hH;
|$hE3
A_A^A]A\_^]
\$ UVWATAUAVAWH
|$ H;
A_A^A]A\_^]
t$ WH
L$`H3
@USVWATAUAVAWH
D$(H;
@8t$!H
A_A^A]A\_^[]
WAVAWH
p!^:N7
0A_A^_
VWAVH
L$`H3
pA^_^
UVWAVAWH
A_A^_^]
@USVWATAUAVAWH
A_A^A]A\_^[]
@USVWATAUAVAWH
D$8I;
D$8I;
\$8I;
@8t$0t$A
A_A^A]A\_^[]
p AWH
UVWATAUAVAWH
A_A^A]A\_^]
L$8H3
D8APu
D8AQu
L$0H3
UVWATAUAVAWH
@t6E8.u1
L$pH3
A_A^A]A\_^]
x ATAVAWH
gfffffffL+
fffffff
 A_A^A\
fffffff
UVWATAUAVAWH
A_A^A]A\_^]
UVWATAUAVAWH
D$@H9D$8t
GpH9GhuSH
A_A^A]A\_^]
L$@H3
UWATAVAWH
L$0E3
}8H9}0
D8cAt'D
t}D8c@u
D$(D8`Au#H
A_A^A\_]
UVWAVAWH
PA_A^_^]
UVWATAUAVAWH
A_A^A]A\_^]
@SVWH
L$ H;
L$`H3
t$ WH
>?u:H
L$`H3
UVWAVAWH
G8H+G(H
@A_A^_^]
UWAVH
L!E'H
L$0E3
@USVWAVH
L$0E3
A^_^[]
H9{ht
WAVAWH
 A_A^_
WAVAWH
A_A^_
UWAVH
x AVH
Hc@ H
` UAVAWH
A_A^]
?H+9H
UVWATAUAVAWH
CHH;CPt
A_A^A]A\_^]
|$ UH
version
x AVH
UVWATAUAVAWH
\$@H;W
D$8I9D$0u(H
M+T$0I
L$8H+
L$8H+
A_A^A]A\_^]
C0H9C(
G H+G
UUUUUUUU
G H+G
UVWATAUAVAWH
~0H;~8
 H;~8u
H;~8twH+~0I
@A_A^A]A\_^]
l$ VWAVH
defined
?(u!H
?)t5H
L$XH3
|$ UH
@USVWATAUAVAWH
D$xE3
A_A^A]A\_^[]
qpQ<W
@USVWATAUAVAWH
H!|$hA
A_A^A]A\_^[]
\$ UVWAVAWH
`A_A^_^]
\$ UVWATAUAVAWH
l$0E3
H;C(u
C`H9CX
C`H9CXtA
D$ A9
H;C(u-H
@A_A^A]A\_^]
p AWH
UVWAVAWH
H;CHtBH
L$hH3
pA_A^_^]
@USWH
@USVWAVH
A^_^[]
x UATAUAVAWH
|$@L;
T$4Hc
A_A^A]A\]
l$ VWAVH
u18_(t,H
0A^_^
D$ HcH
L$@H3
D$ HcH
80u4H
WAVAWH
 A_A^_
x AVH
VWAVH
@A^_^
D$(H;SHt
@USVWATAUAVAWH
u#D9X
A_A^A]A\_^[]
D$@H;
t$ WH
L$0H3
L$ WH
H97vCH
D$HH;S
WAVAWH
D98t-D8yHu'L
 A_A^_
pQ\z#
H+A8H
x AUAVAWH
HcS4H
HcS4H
 A_A^A]
WAVAWH
 A_A^_
@USVWATAUAVAWH
A_A^A]A\_^[]
WAVAWH
0A_A^_
VWAVH
D$@H;S
 A^_^
UWAVH
D$ H;W
VWAVH
0A^_^
@USVWATAVAWH
A_A^A\_^[]
UVWAVAWH
A_A^_^]
H;Q`t
x ATAVAWH
 A_A^A\
WAVAWH
 A_A^_
L$0I+
L$HH+
x AVH
x AVH
D$(H;SPt
UAVAWH
D9q t
z D9s$t
y D9s(t
y D9s,t
y D9s0t!L
D9s4t
y D9s8t
y D9s<t
y D9s@t
y D9sHt
y D9sLt
y D9sPt
y D9sTt
y D9sXt
y D9s\t<L
0A_A^]
UATAUAVAWH
|$ E3
d$(E3
d$(E3
d$(E3
d$(E3
d$(E3
L9] t
d$(E3
D9o<tG
D9oHu8D9oLu2D9oP
D9oHt#H
gD9oLtaD
D9o\ttD
A_A^A]A\]
VWATAVAWH
(t$0L
(|$ I
A_A^A\_^
t$ WH
qq]||
WAVAWH
0A_A^_
qZYTe&X
|$ AVH
|$ AVH
|$ AVH
D$PMcJ
D$XA9
SUWATAWH
\$TH+
A_A\_][
L$`H3
L$`H3
@USVWAUAWH
xA_A]_^[]
G A9Fhu
G$A9Flt;
A9FXu
A9F\u
A9F`u
A9Fdt
G,A8Ft
G-A8Fu
G(A8Fp
G)A8Fq
G*A8Fr
G+A8Fs
A9FDu(
A9FHu
A9FLu
!!!!!!!!!
!!!!!!!! 
VWAVH
|$09|$ tDH
@A^_^
UATAUAVAWH
A_A^A]A\]
H WATAUAVAWH
A_A^A]A\_
UATAUAVAWH
LcE`I
A_A^A]A\]
UWAVH
UATAUAVAWH
D$`A;
D$`E3
A_A^A]A\]
@H9KHw
t$ WH
D$ L;
D$0;X
SUWAUAWH
D$@E9
D9l$Pt
D9l$Tu
A_A]_][
L$@E3
D$4D9:H
A_A]_][
SUVWATAUAVAWH
8A_A^A]A\_^][
@WATAWH
t$8A;
l$(A_A\_
+L$(A
x AUH
H+L$(H
UVWAVAWH
@A_A^_^]
VWAVH
 A^_^
UWAVH
UWATAUAVH
D$8H;
H9t$0t
@8t$!t
@8t$"t
@8t$#t#I
tIH9t$PtBH
A^A]A\_]
p;W|S
{ AVH
L$@H3
L$@H3
T$0H+T$ H
T$0H+T$ H
)D$ H
(D$ H
L$@H3
|$ UH
p"QtU
L$@H3
UWAVH
L$8H;
H9|$HH
fA94Qu
WAVAWH
fD93u
 A_A^_
t$ WH
|$ UH
x ATAVAWH
 A_A^A\
x ATAVAWH
 A_A^A\
x ATAVAWH
 A_A^A\
@USVWATAUAVAWH
A_A^A]A\_^[]
UWAVH
VWAVH
D$PL;C t
0A^_^
x AVH
t$ UWATAUAVH
D8(t1L
D8opt
L9o8uhH
D$8E3
D$PE3
A^A]A\_]
t$ WH
t$ UWATAVAWH
\$`E3
d$pD8 t.H
D8 t+H
A_A^A\_]
UWATAVAWH
d$PD8 t/H
A_A^A\_]
UWAVH
D81t#L
t$PD80
x UAVAWH
A_A^]
p;]tZ
L$PH3
UVWATAUAVAWH
qPI9>t
|$`@88t/H
A_A^A]A\_^]
\$ UVWATAUAVAWH
A_A^A]A\_^]
UVWATAUAVAWH
@88t+H
C@H9P
D$dD;
L$0E3
D$ E3
L9sPt
|$(E3
A_A^A]A\_^]
@USVWAVH
`A^_^[]
UVWATAUAVAWH
H9D$ t H
Ep9E4t 
A_A^A]A\_^]
H90t<
H90t$H
H90t$H
H90t$H
H90t$H
@8s4u
UVWATAUAVAWH
l$PE;
A_A^A]A\_^]
` UAUAVH
L90tCH
D8u@t
A^A]]
x UAVAWH
A_A^]
@USVWATAUAVAWH
/L90t
L9I s
D$@E3
A_A^A]A\_^[]
@USVWATAVAWH
tkD8e
D$@E3
d$8E3
A_A^A\_^[]
UWATAVAWH
A_A^A\_]
UATAUAVAWH
I;L$H
A_A^A]A\]
UVWATAUAVAWH
MwMcE
A_A^A]A\_^]
UVWATAUAVAWH
9t$0us
D9d$0
D$HD;
A_A^A]A\_^]
t$ UWATAVAWH
A_A^A\_]
qZQ80?
UVWATAUAVAWH
pq^p6
D$0E3
pZQ80?
A_A^A]A\_^]
VWAVH
K UATAUAVAWH
A_A^A]A\]
t$ UWATAVAWH
D8q(t
t$`D80t/H
T$PD!u
T$PD!u4
T$PD!u
A_A^A\_]
D9\$`
D$PE:
FD:L$Pu
.D:L$Pu
D:L$Pu
D$0H;S
L$8H3
x AVH
pq^p6
WATAUAVAWH
tQL9l
A_A^A]A\_
!l$HH
!l$HH
USVATAUAVAWH
p!\4H
pj[<l
PA_A^A]A\^[]
@USVWATAUAVAWH
$u#A9\$
A_A^A]A\_^[]
\$ E3
D$ E3
t$ WH
L$0E3
x AVH
L$0E3
9\$@H
L$0E3
x ATAVAWH
0A_A^A\
VWATAVAWH
0A_A^A\_^
h UAVAWH
A_A^]
L$0E3
UVWATAUAVAWH
L$`E3
|$ E3
|$ E3
L$`E3
A_A^A]A\_^]
WAVAWH
0A_A^_
UATAUAVAWH
l$ E3
A_A^A]A\]
duED9
L$pE3
L$0E3
L$0E3
L$0E3
A@H9A8tSH
L$0E3
x UATAUAVAWH
A_A^A]A\]
x ATAVAWH
 A_A^A\
x ATAVAWH
 A_A^A\
WAVAWH
 A_A^_
x ATAVAWH
 A_A^A\
x ATAVAWH
 A_A^A\
x ATAVAWH
 A_A^A\
L$0E3
H9J`t
D$(H;S
D$(H;S
UVWATAUAVAWH
D8v\tqI
A_A^A]A\_^]
x AVH
|$pdu
@USVWATAUAVAWH
L+~hI
FpI+FhI
A_A^A]A\_^[]
\$ UVWATAUAVAWH
`A_A^A]A\_^]
UVWAVAWH
A_A^_^]
|$ UH
UVWATAUAVAWH
PA_A^A]A\_^]
@USVWATAUAVAWH
D8d$pu9L
\$@t5
O I+O
D8d$pu6L
A_A^A]A\_^[]
X UVWATAUAVAWH
D9|$Ht3H
D$ @B
F0D9n(
D9l$Ht8H
A;],t
D8hfI
D9l$ht,H
FxH9Fpt
D$ @B
A_A^A]A\_^]
SVWATAUAVAWH
D$hH;
 A_A^A]A\_^[
UAVAWH
D$ t#H
A_A^]
x AVH
@SUVWAVH
A^_^][
h UAVAWH
A_A^]
UAVAWH
A_A^]
^wq,"<>w
\$ UVWATAUAVAWH
KpH9Khu~M
A_A^A]A\_^]
@USVWATAVAWH
4dL+{
E8f(t
F8D8`
pA_A^A\_^[]
WAVAWH
 A_A^_
x AUAVAWH
 A_A^A]
p AWH
x AUAVAWH
 A_A^A]
p AWH
x AVH
x AVH
UVWATAUAVAWH
A_A^A]A\_^]
T$(E3
L$hH3
VWAVH
 A^_^
UWATAVAWH
A_A^A\_]
q;]tZ
D$(E3
SUVWATAUAVAWH
)\$pD
)d$`L
z*u(H
\$0I;
\$PMc
A_A^A]A\_^][
t$ WH
L$PH3
|$ UH
@SVWH
UVWATAUAVAWH
A_A^A]A\_^]
UVWATAUAVAWH
D$pH;
 A_A^A]A\_^]
@SUVWATAUAVAWH
HA_A^A]A\_^][
\$ UVWAVAWH
A_A^_^]
|$ UATAUAVAWH
A_A^A]A\]
UVWAVAWH
A_A^_^]
@SUVWATAUAVAWH
D8whv
D9e u
D$0E9f
A_A^A]A\_^][
u:D8A,u4D9A
u.D9A
D9B$u
D9B0u
D9B4u
WAVAWH
0A_A^_
CL$ H
x AVH
@USVWATAUAVAWH
D$(H9]@u
A_A^A]A\_^[]
@SUVWH
L$ H+
\$ UVWAVAWH
CL$ L
L$@H3
PA_A^_^]
\$ UVWATAUAVAWH
EwH;WHt
A_A^A]A\_^]
\$ UVWATAUAVAWH
L$0E3
@8t$ ttH
L$hH3
pA_A^A]A\_^]
VWAVH
@USVWATAUAVAWH
D8|$0t
A_A^A]A\_^[]
L$@H3
t$ WH
@USVWAVAWH
|$@?u<
H!|$0H
A_A^_^[]
x AVH
UVWAVAWH
A_A^_^]
WATAUAVAWH
A_A^A]A\_
t$ WH
T$ D9H 
x AVH
x AVH
WAVAWH
0A_A^_
WAVAWH
0A_A^_
t$ WAVAWH
A9z u
A_A^_
@SUVWH
WATAUAVAWH
 A_A^A]A\_
EhA8Fhu
EiA8Fi
x AVH
\$ UVWATAUAVAWH
atTA+
@A_A^A]A\_^]
APA8@P
@PA:AQu
A8APv
A8AQu
A8@Pv
A8@Qu
A8@Qu
A:IQu
A:IPt
APA8@Pu
AQA8@Qu
@SUVWAVH
9Klt<
A^_^][
L$ H+
@USVWATAVAWH
)D$0H
)L$@@
A_A^A\_^[]
|$ AVH
D$@x*Hc
t$ UWAVH
WAVAWH
 A_A^_
UVWATAUAVAWH
D$H@2
L$HH3
PA_A^A]A\_^]
\$ UVWAVAWH
F H+F
L$hH3
pA_A^_^]
UVWATAUAVAWH
T$ 9A
D$ H;
L$HH3
PA_A^A]A\_^]
L$@H3
@SUVWAVAWH
C H+C
A_A^_^][
VWATAVAWH
0A_A^A\_^
UWAVH
\$ WH
L$PH3
x AVH
L$@E3
UVWATAUAVAWH
A_A^A]A\_^]
SUATAVAWH
@A_A^A\][
L$PH3
t$ WH
@USVWAVAWH
D$0E3
A_A^_^[]
XVI'a
@UWAUAVH
t$`I;
(A^A]_]
T$0D9A
@UWAUAVH
8A^A]_]
T$0D9A
@SVWH
x AVH
AHD90t
D92t4H
D9q(v
VWATAVAWH
 A_A^A\_^
B0A;@0
B,A;@,
BlA;@lu
BpA;@pu
B<A;@<t
BtA;@tu
B A;@ u
BdA;@du
@49B4u
x AVH
D$XA9
|$ UATAUAVAWH
A_A^A]A\]
` UAVAWH
L9y t
A_A^]
UVWATAUAVAWH
@A_A^A]A\_^]
H UATAUAVAWH
A_A^A]A\]
x AVH
UVWATAUAVAWH
`A_A^A]A\_^]
VWAUAVAWH
A_A^A]_^
` UAVAWH
pLc}@M
A_A^]
T$0E3
` AUAVAWH
0A_A^A]
x AVH
x AVH
UVWATAUAVAWH
A_A^A]A\_^]
` UAVAWH
L9y t
A_A^]
t$ WH
qZUpm7
qrV\:/
H;C u
q`V:6
T$09A
T$09A
VWATAVAWH
 A_A^A\_^
VWAVH
 A^_^
VWATAVAWH
 A_A^A\_^
VWAVH
H;G t
 A^_^
WAVAWH
 A_A^_
x AVH
qIT>J
T$09A
t$ WH
D$HH;
D$`H;
x ATAVAWH
 A_A^A\
VWAVH
 A^_^
T$09A
p AWH
UVWATAUAVAWH
|$HE3
|$HE3
\$@E3
l$0E3
\$@E3
L$XE3
D$hE3
D$pE3
L$XE3
D$pE3
D$pE3
D$(E3
|$hE3
\$hE3
D$pE3
D$pE3
D$pE3
D$XE3
D$ E3
|$HE3
D$pE3
D$0E3
d$HE3
t$pE3
t$hE3
t$pE3
l$`E3
L$XE3
\$`E3
\$`E3
L$XE3
D$hE3
\$`E3
|$(E3
\$@E3
\$@E3
\$@E3
|$8E3
|$8E3
|$0E3
t$(E3
\$@E3
|$XE3
t$PE3
d$@E3
d$ E3
D$XE3
A_A^A]A\_^]
WAVAWH
 A_A^_
WATAUAVAWH
 A_A^A]A\_
WATAUAVAWH
 A_A^A]A\_
WAVAWH
 A_A^_
x AVH
WATAUAVAWH
 A_A^A]A\_
WAVAWH
 A_A^_
x AVH
UATAUAVAWH
~YH!UPL
A_A^A]A\]
x AVH
H97s/3
RH;9tMH
WAVAWH
gfffffffL+
fffffff
 A_A^_
h UAVAWH
A_A^]
x ATAVAWH
'D9&uDH
A_A^A\
WAVAWH
 A_A^_
p`V:6
@SUVWAVH
L$HH3
PA^_^][
UVWATAUAVAWH
E9VHu
|$ E3
A_A^A]A\_^]
\$(E3
@SUVWATAUAVAWH
A;^0uu3
L$pH3
A_A^A]A\_^][
H+L$(H
x ATAVAWH
 A_A^A\
UVWATAUAVAWH
 A_A^A]A\_^]
x ATAVAWH
 A_A^A\
x ATAVAWH
gfffffffH
 A_A^A\
VWAUAVAWH
 A_A^A]_^
WAVAWH
 A_A^_
UVWATAUAVAWH
 A_A^A]A\_^]
@USVWATAVAWH
A_A^A\_^[]
@SVWH
k VWAVH
L$hH3
L$`H3
t$ WH
L$HH3
WAVAWH
UUUUUUU
 A_A^_
UUUUUUU
WAVAWH
 A_A^_
\$ UVWATAUAVAWH
UUUUUUU
 A_A^A]A\_^]
UVWAVAWH
A_A^_^]
H9EHv
L$ E3
L$@H3
@USVWAVH
A^_^[]
t$ WH
L$ E3
L$`H3
UVWATAUAVAWH
L$pH3
A_A^A]A\_^]
x AUAVAWH
 A_A^A]
@SVWH
L$`H3
UATAUAVAWH
A_A^A]A\]
x AVH
{ AVH
VWAVH
\$@H;
 A^_^
H;BH~
@USVWAVH
A^_^[]
@SUVWAVH
L$hH3
pA^_^][
\$ WH
\$ VWAVH
L$@H3
PA^_^
x ATAVAWH
 A_A^A\
q"QtU
L$`H3
@SUVWATAUAVAWH
H+GHH
;\$@r
A_A^A]A\_^][
@SUVWATAVAWH
H+GHH
L$`H3
pA_A^A\_^][
@USVWATAUAVAWH
FPH+FHH
A_A^A]A\_^[]
UVWATAUAVAWH
\$@A8z
A_A^A]A\_^]
L$pLi
FPI9FHt
FPI9FHt
p AWH
@SUVWATAUAVAWH
L$0H+
pX^6V>
A_A^A]A\_^][
\$ UVWATAUAVAWH
L$`H3
pA_A^A]A\_^]
@USVWATAUAVAWH
A_A^A]A\_^[]
WAVAWH
A_A^_
x ATAVAWH
 A_A^A\
p AWH
x ATAVAWH
 A_A^A\
WAVAWH
 A_A^_
Q@H;QHt
H;C u
H;C u
WATAUAVAWH
 A_A^A]A\_
WATAUAVAWH
 A_A^A]A\_
x AVH
D$ @8|$!
A9J E
UVWATAUAVAWH
)d$pD
)l$`D
)t$PD
(t$PL
(|$@I
A_A^A]A\_^]
z"u E
qQ\z#
x ATAVAWH
gfffffffI
fffffff
 A_A^A\
WAVAWH
0A_A^_
\$ UVWATAUAVAWH
uHD+u@D
}LD+}D
p(]T2&
A_A^A]A\_^]
x AVH
|$ UATAUAVAWH
A_A^A]A\]
qxPZa
WAVAWH
 A_A^_
T$09A
qxPZa
WAVAWH
 A_A^_
3333333
WATAUAVAWH
3333333
gfffffffH
 A_A^A]A\_
3333333
q0R^G'
VWAVH
swH9;t
0A^_^
x AVH
T$09A
{ AVH
T$09A
WAVAWH
 A_A^_
|$ UATAUAVAWH
A_A^A]A\]
\$ WH
L$@H3
A(H;A0t
x AVH
WAVAWH
 A_A^_
UWAUAVAWH
A_A^A]_]
UATAUAVAWH
A_A^A]A\]
x ATAVAWH
gfffffffL+
fffffff
 A_A^A\
WATAUAVAWH
A_A^A]A\_
L$pH3
q8[:d
t$ WAVAWH
@A_A^_
WAVAWH
 A_A^_
WAVAWH
 A_A^_
UWATAVAWH
G(M;G0t&D
M;G0u
A_A^A\_]
q;]tZ
|$(A^
WAVAWH
 A_A^_
t$ WAVAWH
0A_A^_
UVWATAUAVAWH
@A_A^A]A\_^]
WATAUAVAWH
UUUUUUU
 A_A^A]A\_
H;C u
UWAVH
H H+H
@A^_]
@8n:t
WAVAWH
 A_A^_
WAVAWH
 A_A^_
VWAVH
WATAUAVAWH
 A_A^A]A\_
L$0E3
l$09l$ 
9\$0t?D
x AVH
WATAUAVAWH
 A_A^A]A\_
H;\$x
Q H;Q
WAVAWH
gfffffffL+
fffffff
 A_A^_
WAVAWH
 A_A^_
UVWATAUAVAWH
 A_A^A]A\_^]
t$ WATAUAVAWH
 A_A^A]A\_
WAVAWH
 A_A^_
x AVH
S(H;S0t
@USVWATAUAVAWH
D$ D8l$!
D$ D8l$!
D$ D8l$!
E9,$u
A_A^A]A\_^[]
QLL;I@spL
M;H@r
FpH9D$0t
L$@H3
q(]T2&
UVWATAUAVAWH
A_A^A]A\_^]
UVWATAUAVAWH
 A_A^A]A\_^]
x ATAVAWH
 A_A^A\
x ATAVAWH
 A_A^A\
q;]tZ
x AVH
UVWATAUAVAWH
t'A;E
D$ fA
A_A^A]A\_^]
IhD8L$(
x ATAVAWH
 A_A^A\
x ATAVAWH
 A_A^A\
UVWATAUAVAWH
n`u"H
A_A^A]A\_^]
WAVAWH
 A_A^_
t$ WATAUAVAWH
 A_A^A]A\_
x ATAVAWH
 A_A^A\
x ATAVAWH
 A_A^A\
UVWATAUAVAWH
A_A^A]A\_^]
L$0H3
WATAUAVAWH
0A_A^A]A\_
H9A(t
A8H9A
SUVWATAUAVAWH
HA_A^A]A\_^][
H9A(t
|$ UATAUAVAWH
A_A^A]A\]
q!\4H
w_IcA
tNH;L$`tGH
x ATAVAWH
UUUUUUU
 A_A^A\
qQ\z#
L$0E3
UWAVH
x ATAVAWH
 A_A^A\
UTB7U
UVWATAUAVAWH
CPH9CH
CPH9CHt
D$ [H
A_A^A]A\_^]
UVWAVAWH
H+S H
N0H+S H
S(H+S H
L$PH;
 A_A^_^]
qyVVY.
WAVAWH
 A_A^_
\$ UVWH
Phv$A
x AVH
H;D$0t
x AUH
H+L$(H
x AVH
x UAVAWH
A_A^]
@SVWH
\$ WH
x AVH
\$ UVWH
WAVAWH
 A_A^_
\$ UVWATAUAVAWH
d$@I;
A_A^A]A\_^]
x ATAVAWH
 A_A^A\
t$ WH
UVWATAUAVAWH
|$(E3
d$ E3
|$(E3
`A_A^A]A\_^]
L$`H3
x AUH
H+L$(H
|$ AVH
t$ WATAUAVAWH
 A_A^A]A\_
t$ WAVAWH
L$HH3
A_A^_
UVWATAUAVAWH
A_A^A]A\_^]
UVWAVAWH
A_A^_^]
(t$ H
x ATAVAWH
 A_A^A\
CT$ I
CT$ I
L$@H3
L$@H3
L$`H3
t$ WH
WATAUAVAWH
0A_A^A]A\_
WAVAWH
 A_A^_
p!SR@
L$8H3
x AVH
qj[<l
x AUAVAWH
 A_A^A]
qKP|K
VWAVH
D$PL;C t
0A^_^
x AVH
qQ\z#
L$@H3
L$0E3
D8APv
D8AQwJ2
D8BPv
D8BQw9D8APv%D8AQu
D8BPv
D8BQu
98u6D9X
x ATAVAWH
 A_A^A\
VWAVH
|$ UAVAWH
A_A^]
q!\4H
wjIcA
tNH;L$`tGH
qyQXg
x AVH
x AVH
\$ UVWAVAWH
`A_A^_^]
WAVAWH
 A_A^_
@SUVWH
L$@H3
X_^][
x ATAVAWH
pX^6V>
A_A^A\
H;C u
L$@H3
q8[:d
(t$ H
x AVH
qj[<l
UR7?!
p X~0
(t$ H
x AVH
q X~0
t$ WATAUAVAWH
D$`E3
L$`H3
A_A^A]A\_
UWAVH
qaUPE
qj[<l
x AVH
w$tU-q
t$ WATAUAVAWH
 A_A^A]A\_
qX^6V>
q!^:N7
q!^:N7
q0R^G'
q0R^G'
q:_0#
|$ AVH
VWAVH
p:_0#
p:_0#
p:_0#
@A^_^
q:_0#
p:_0#
\$ UH
M H1E
 H3E H3E
@SVWH
ntelA
ineID
oD$ f
oL$0f
oT$@f
o\$PH
q0R^G'
L$ SUVWH
8_^][
H SVWH
L$ SUVWH
8_^][
@VWAWH
 A__^
H;FhH
BFhH+
uv9\$ ~JL
fffffff
fffffff
UUUUUUU
UUUUUUU
H;H s
H;H s
H;H s
L9@ s
L9@ s
L9@ s
L9@ s
L9@ s
L$0E3
L$0E3
UVAVH
 A^^]
 A^^]
L9@ }
UUUUUUU
fffffff
H;H s
EL$0H
D9@ s
t$ WH
@UAVAWH
 A_A^]
@UAVAWH
 A_A^]
@UAVAWH
 A_A^]
@UAVAWH
 A_A^]
@UAVAWH
 A_A^]
@UAVAWH
 A_A^]
H#G0L
|$ M;
|$ M;
|$ M;
|$ M;
H#F0L
H#Q0H
SWAUH
I#E0H
L$ M;
\$0L;
PA]_[
\$0L;
I#E0H
L$ L;
\$0L;
fffffff
VATAWH
A_A\^
@VAWH
l$ WH
t$8I+
l$ WH
t$8I+
|$ AVH
A 9F r
@UVAVH
0A^^]
@UAVAWH
 A_A^]
UUUUUUU
3333333
l$ WH
t$8I+
|$ ATAVAWH
 A_A^A\
@SAUH
I#E0M
|$ AVH
L$ WH
;D$Hu'H
|$ AWH
fffffff
t$ AVH
|$8I;
t$ AVH
|$8I;
|$ AVH
H;H s
fffffff
L9@ s
9D$ u
9D$$t
VWAVH
@A^_^
@A^_^
|$ AVH
VWAVH
@A^_^
@A^_^
|$ AVH
D$0@8h
D$09P
@UATAWH
0A_A\]
0A_A\]
|$ AVH
UUUUUUU
H#F0H
I ;H u5L
I ;H u
@UAVAWH
 A_A^]
@UAVAWH
 A_A^]
|$ M;
|$ M;
|$ M;
|$ M;
|$ M;
|$ M;
|$ M;
|$ M;
|$ M;
|$ M;
UUUUUUU
UUUUUUU
l$ AVH
t$ WH
D$@@8h
D$@9P
UUUUUUU
UWATH
L$XH3
L$`H3
L$XH3
L$`H3
D$0@8h
D$09P
fffffff
D9H t
H(I;H
H0I;H
H8A:H
H;B(t
H;B0t
@UVAVH
 A^^]
@UAVAWH
 A_A^]
l$ AVH
UUUUUUU
l$ AVH
3333333
UUUUUUU
@UAVAWH
 A_A^]
|$ M;
t&H;^
UVWATAUAVAWH
D$pH+
 A_A^A]A\_^]
D$0@8h
D$0H9P s
fffffff
H;H s
WAVAWH
@A_A^_
l$ AVH
L$0E3
|$ AVAWH
H$A;N
H(A:N
8H)r8A
H)A8N
A;Q |,
A;A$| 
A:A(r
A)A8F
H$A9K
D9@ |
D9H u
H$A;H
H$A;H
H(A:H
B(A9@
;B |'
B)A8@
;B |!
B$A9C
UUUUUUU
D9@ }
t$ WH
D$@@8h
D$@H9P }
|$ AVH
@VWAWH
 A__^
t$ WH
|$ AWH
D9@ }
D9@ }
UUUUUUU
D$0@8h
D$0H9P s
fffffff
H;H s
t$ AVH
WAVAWH
 A_A^_
|$ AVH
|$ AWH
fffffff
t$0I;
|$ AVH
UUUUUUU
H;GPu
W(H+W I
|$ AVH
|$ AVH
3333333
|$ AVH
|$ AVH
3333333
@SAUH
I#M0H
@SAUH
I#M0H
@SAUH
I#M0H
@SAUH
I#M0H
3333333
|$ AVH
|$ AVH
vb'vb'v
@SAUH
I#M0H
vb'vb'v
@UVAWH
 A_^]
@VAVAWH
l$pM+
0A_A^^
l$ WH
t$8I+
l$ AVH
t$ WH
l$0I;
fffffff
t2fff
D9@ }
t$ AVH
UUUUUUU
|$0L+
|$ ATAVAWH
 A_A^A\
L9@ s
@UAVH
@UAVAWH
0A_A^]
@SUWH
t$HH+
|$PL+
VWAUAVAWH
 A_A^A]_^
|$ ATAVAWH
 A_A^A\
SATAWH
`A_A\[
`A_A\[
`A_A\[
UUUUUUU
t(fff
D$0@8h
D$0L9P u
H9H(s
I;A u
A(I9@
UUUUUUU
fffffff
L9@ s
\$ H+
l$ WH
\$0I;
t$ WH
D$@@8h
D$@9P }
@SWAVH
D9{ t
 A^_[
vb'vb'v
t3fff
fffffff
D$0@8h
D$0H9P s
fffffff
|$ AVH
fffffff
|$0L+
@SAUH
I#E0M
VWAVH
@A^_^
@A^_^
VWAVH
@A^_^
@A^_^
UUUUUUU
|$ AVH
@UATAVH
 A^A\]
t$ WH
D$@@8h
D$@H9P s
fffffff
fffffff
fffffff
@SUVAUH
(A]^][
L9@ s
L9@ s
t$ AWH
h(@8k
L9@ s
|$ ATAVAWH
D$0D8`
D$09p
H A;H
H$A:H
H%A:H
d$8D8`
t$pE8a
A;A |/
A:A$r"w
A:A%r
A(A9@
UUUUUUU
A_A^A\
WAVAWH
D$0D8x
D$0D9@
|$8D8x
A;A | 
A:A$r
UUUUUUU
PA_A^_
|$ AVH
VWAWH
 A__^
@UAWH
\$@H+
UUUUUUU
D9@ u
B$A9@
t$ WAVAWH
A_A^_
l$HH;
3333333
|$ AVH
UUUUUUU
3333333
D$@eH
L$HE3
D$0D9D$ 
)|$PD
)D$@H
L$0H3
(|$PD
(D$@H
A A;P4vQH
UWAUAVAWH
A_A^A]_]
pZYTe&X
q@QXL'
T$09A
WAVAWH
 A_A^_
x AUAVAWH
A_A^A]
` UAVAWH
A_A^]
D8R(t
VUUUA
AQ:BQ
AhI9Bh
T$XE3
D8APv;D8AQu5
"tmA+
2t^A+
{@E+~
A9~ tTA
L$0H;
D9K H
J;D$(u
O;T$(t
HcQ ;Q
H;l$p
L$xt&
D8BPv
D8BQv
T$(E3
T$(E3
D$0E3
T$(E3
T$(E3
T$(E3
T$(E3
T$HE3
q8[:d
Q\R?9
x AVH
qxPZa
qxPZa
qxPZa
x AVH
x AVH
XVI'a
XVI'a
XVI'a
XVI'a
XVI'a
XVI'a
XVI'a
Q\R?9
qR\>@7
L$@H3
L$@H3
L$@H3
L$@H3
L$@H3
L$@H3
WATAUAVAWH
H9Fhs
 A_A^A]A\_
WATAUAVAWH
H9Ghs
 A_A^A]A\_
L$@H3
L$@H3
L$@H3
UAVAWH
A_A^]
H;F@t
(|$PD
(D$@D
(L$0H
WATAUAVAWH
A_A^A]A\_
UVWATAUAVAWH
PA_A^A]A\_^]
WATAUAVAWH
A_A^A]A\_
WATAUAVAWH
A_A^A]A\_
(|$ H
x AVH
WAVAWH
0A_A^_
x AVH
x AVH
x AVH
(|$ H
x AVH
(t$ H
x AVH
x AVH
(t$0H
@SUVWAVH
L$0H3
@A^_^][
@SUVWAVH
L$0H3
@A^_^][
x AVH
)t$@H
L$0H3
(t$@H
\$ WH
)|$@H
L$0H3
(|$@H
)|$PD
)D$@H
L$0H3
(|$PD
(D$@H
)|$PD
)D$@H
L$0H3
(|$PD
(D$@H
L$@H3
L$@H3
L$@H3
SUVWATAUAVAWH
A_A^A]A\_^][
WAVAWH
0A_A^_
WATAUAVAWH
A_A^A]A\_
WATAUAVAWH
A_A^A]A\_
x UAVAWH
@0E8p5utH
@8D8p
A_A^]
WAVAWH
0A_A^_
L$@H3
x AVH
xuLcD$PE
xkLcL$XE
L;D$`u
L;L$hu
I08AFu
;ADr8
UVWATAUAVAWH
D9`$t6I
\$0E3
D9P$w
D8P4u
A_A^A]A\_^]
UATAUAVAWH
F0D8h
F0D8h
F0D8h:
A_A^A]A\]
wFtuA
UVWATAUAVAWH
9x$t%H
H;KHv
A_A^A]A\_^]
;X v H
L$@H3
L$@H3
L$@H3
D$0I;A@t9H
x UATAUAVAWH
|$ E3
A_A^A]A\]
x ATAVAWH
 A_A^A\
{ AWH
L$@H3
WAVAWH
0A_A^_
WAVAWH
0A_A^_
p;W|S
t$ WH
w\tUA
wet^A
@SVWH
L$PH3
)D$ D
(|$0D
(D$ H
D$0H;G t
H;C(v
H;C(v
HcUPH
UATAUAVAWH
LcM_3
A_A^A]A\]
x AVH
` UAVAWH
A_A^]
VWAVH
 A^_^
WAVAWH
A_A^_
p AWH
H;C u
x AVH
` UAVAWH
A_A^]
WAVAWH
 A_A^_
WAVAWH
 A_A^_
WAVAWH
 A_A^_
\$PHc
\$PHc
T$8L;
H;C u
x AVH
HcT$pMc
WAVAWH
 A_A^_
x AVH
` UAVAWH
A_A^]
I;H t
H+AX3
F`H+FXH
H UATAUAVAWH
A_A^A]A\]
UATAUAVAWH
A_A^A]A\]
UATAUAVAWH
A_A^A]A\]
LcD$4H
UATAUAVAWH
A_A^A]A\]
ATAVAWH
A_A^A\
` UAVAWH
A_A^]
` UAVAWH
A_A^]
ATAVAWH
A_A^A\
h UAVAWH
A_A^]
UAVAWH
L$0E3
L$0E3
A_A^]
UATAUAVAWH
E8odu/H
E8owu
A_A^A]A\]
L$(E3
L$(E3
UATAUAVAWH
F0D8x
F0D8x
F0D8x
F0D8x
F0D8x
F0D8x
F0D8xat
A_A^A]A\]
Hc]hH
x AVH
|$ UH
H UATAUAVAWH
A_A^A]A\]
H UATAUAVAWH
A_A^A]A\]
A:D$4
x ATAVAWH
A_A^A\
x ATAVAWH
 A_A^A\
l$ VWAVH
UVWATAUAVAWH
H;l$hu%I;
 A_A^A]A\_^]
L$ UVWATAUAVAWH
0A_A^A]A\_^]
t$ WH
WAVAWH
 A_A^_
L$@H3
WAVAWH
 A_A^_
x ATAVAWH
UUUUUUU
 A_A^A\
WATAUAVAWH
 A_A^A]A\_
x ATAVAWH
 A_A^A\
@USVWAVAWH
tp=Pw
A_A^_^[]
@USWATAVAWH
t}=Pw
A_A^A\_[]
t%H;u
UVWATAUAVAWH
I+xxI
I+AxH
A`A9@`t.L
AdA9@d
AlA9@l
A_A^A]A\_^]
VWAVH
L$@H3
H9D$Ht
VWAVH
L$@H3
WAVAWH
0A_A^_
WAVAWH
0A_A^_
x AVH
pq]||
D$@I;
|$ UAVAWH
@A_A^]
|$ UAVAWH
@A_A^]
|$ UAVAWH
@A_A^]
|$ UAVAWH
@A_A^]
WATAUAVAWH
 A_A^A]A\_
x AVH
VWAVH
D$@H;
 A^_^
K VWAVH
H9n0uJH
@A^_^
WATAUAVAWH
 A_A^A]A\_
t$ WAVAWH
I+G0H
I+G0H
 A_A^_
VWAVH
 A^_^
;D$(}|H
t$ WAVAWH
G0D8ppt#
 A_A^_
B 9A u<
B(9A(u4
B$9A$u,L
H+A0I;
L$@H;
USVWATAUAVAWH
D8UHt
D9Q(tLH
D9Q$w
D9Q(v
D8Pft
D8UXt
D8UYu
D8Pft
HA_A^A]A\_^[]
WAVAWH
 A_A^_
UAVAWH
D9>tO
D9?tHL
A_A^]
x AVH
D$TE3
VWATAVAWH
C0D9$
 A_A^A\_^
x ATAVAWH
A_A^A\
WAVAWH
 A_A^_
x AVH
WAVAWH
UUUUUUU
 A_A^_
B 9A uk
B$9A$uc
B(9A(u[L
x ATAVAWH
 A_A^A\
|$ UATAUAVAWH
 A_A^A]A\]
UVWATAUAVAWH
0A_A^A]A\_^]
WATAUAVAWH
D$tL;
 A_A^A]A\_
UWAVH
0A^_]
p WAVAWH
D$PL;C t
0A_A^_
x ATAVAWH
 A_A^A\
WATAUAVAWH
 A_A^A]A\_
x ATAVAWH
 A_A^A\
x ATAVAWH
"""""""
 A_A^A\
UVWATAUAVAWH
L$pI+
 A_A^A]A\_^]
x AVH
UWAVH
]0H;W
0A^_]
@USVWAVH
0A^_^[]
@USVWATAVAWH
A_A^A\_^[]
@USVWATAUAVAWH
u"H;\$Pw
d0cdd066H9
u$L;t$Pw
u%L;t$Pw
u%H;\$Pw
u%H;\$Pw
u%H;\$Pw
u%H;\$Pw
A_A^A]A\_^[]
x AVH
|$ UATAUAVAWH
0A_A^A]A\]
u H;s
UVWAVAWH
PA_A^_^]
|$ UATAUAVAWH
]8H;V(t
0A_A^A]A\]
@USVWAUAVAWH
L$0E3
L$0H;
L$0H;
L$0H;
CxH9CptAA
H+CpH
L$0H;
L$0H;
L$0H;
L$0H;
L$0I;
H+T$0
D$8L+D$0I
H#T$0
T$@H+
A_A^A]_^[]
|$ UH
|$ UH
M H+C
L;C0t$M
@(L;C
T$0H)C
H;C0u
@USVWATAUAVAWH
D$@H!t$@M
D9mxtDH
A_A^A]A\_^[]
t$ WH
D$ @B
t$ WH
L+H@L
l$@I+
@SVWH
L$8H3
x AVH
x AVH
L;J t
H;C(v
H;C(v
L$ L+
T$(A9S
D$0I9C
H;C u
H;C u
H;C u
H;C u
t$ UWAVH
L;A@u
]$L;G
E$L;G
 A^_]
WATAUAVAWH
A_A^A]A\_
H9A8t H
wdt4A
@USVWATAUAVAWH
FPH+FHH
A_A^A]A\_^[]
@USVWATAUAVAWH
FPH+FHH
A_A^A]A\_^[]
@USVWATAUAVAWH
|$@E3
CPH9CHt6H
A_A^A]A\_^[]
@USVWATAUAVAWH
t$@E3
CPH9CHt6H
A_A^A]A\_^[]
@USVWATAUAVAWH
\$@I;
A_A^A]A\_^[]
@USVWATAUAVAWH
\$@I;
A_A^A]A\_^[]
@USVWAVH
A^_^[]
@USVWATAUAVAWH
A9G`A
A_A^A]A\_^[]
@USVWATAUAVAWH
FPH9FHt
A_A^A]A\_^[]
x ATAVAWH
 A_A^A\
WAVAWH
 A_A^_
l$ VWAVH
L$hH3
@SUVWAVH
L$pH3
A^_^][
@SUVWH
L$XH3
h_^][
@SVWH
L$`H3
UVWATAUAVAWH
H;l$hu
 A_A^A]A\_^]
WATAUAVAWH
 A_A^A]A\_
WATAUAVAWH
 A_A^A]A\_
x ATAVAWH
 A_A^A\
L$hH3
\$ UVWH
\$ L+
L$pH3
x ATAVAWH
A_A^A\
x ATAVAWH
A_A^A\
x ATAVAWH
A_A^A\
x ATAVAWH
A_A^A\
x ATAVAWH
A_A^A\
x ATAVAWH
A_A^A\
x ATAVAWH
A_A^A\
x ATAVAWH
A_A^A\
x ATAVAWH
A_A^A\
x ATAVAWH
A_A^A\
x ATAVAWH
A_A^A\
x ATAVAWH
A_A^A\
x ATAVAWH
A_A^A\
x ATAVAWH
A_A^A\
x ATAVAWH
A_A^A\
x ATAVAWH
A_A^A\
x ATAVAWH
A_A^A\
x ATAVAWH
A_A^A\
x ATAVAWH
A_A^A\
x ATAVAWH
A_A^A\
x ATAVAWH
A_A^A\
x ATAVAWH
A_A^A\
x ATAVAWH
A_A^A\
x ATAVAWH
A_A^A\
x ATAVAWH
A_A^A\
x ATAVAWH
A_A^A\
x ATAVAWH
A_A^A\
x ATAVAWH
A_A^A\
x ATAVAWH
A_A^A\
x ATAVAWH
A_A^A\
x ATAVAWH
A_A^A\
x ATAVAWH
A_A^A\
x ATAVAWH
A_A^A\
x ATAVAWH
A_A^A\
x ATAVAWH
A_A^A\
x ATAVAWH
A_A^A\
x ATAVAWH
A_A^A\
x ATAVAWH
A_A^A\
x ATAVAWH
A_A^A\
x ATAVAWH
A_A^A\
x ATAVAWH
A_A^A\
x ATAVAWH
A_A^A\
x ATAVAWH
A_A^A\
H9\$`v!H
H;\$`r
H9D$8v,H
H;D$8r
H9T$8v'L
H;T$8r
H9T$8v/L
H;T$8r
H9T$8v4L
H;T$8r
H9\$`v9H
H;\$`r
H9L$8vEH
H;L$8r
H9T$8v7L
H;T$8r
H9T$8v.L
H;T$8r
H9T$8vPM
H;T$8r
L9D$8vEL
L;D$8r
L9D$8v)L
L;D$8r
H9T$8v*L
H;T$8r
H9T$8vBM
H;T$8r
L9D$8vCL
L;D$8r
L9D$8v,L
T$PKc
L;D$8r
L9D$8vCL
L;D$8r
L9D$8v(L
L;D$8r
WATAUAVAWH
0A_A^A]A\_
WATAUAVAWH
A_A^A]A\_
WATAUAVAWH
A_A^A]A\_
L9t$8vDI
L;t$8r
WATAUAVAWH
A_A^A]A\_
p AWL
t$(A_
3L$X#D$X
WATAUAVAWH
A_A^A]A\_
` AVAWL
d$0A_A^
WATAUAVAWH
A_A^A]A\_
WATAUAVAWH
A_A^A]A\_
` AVAWL
d$0A_A^
` AUAVAWL
d$8A_A^A]
WATAUAVAWH
fA#D$
fE3\$
fA#D$
fE3T$
fA#D$
fE3D$
fA#D$
fA3T$
fA#D$
fA3L$
A_A^A]A\_
WATAUAVAWH
0A_A^A]A\_
WATAUAVAWH
A_A^A]A\_
WATAUAVAWH
A_A^A]A\_
WATAUAVAWH
A_A^A]A\_
WATAUAVAWH
A_A^A]A\_
WATAUAVAWH
A_A^A]A\_
` AUAVAWL
d$8A_A^A]
` AVAWL
d$0A_A^
x ATAUAVAWL
|$@A_A^A]A\
WATAUAVAWH
A_A^A]A\_
WATAUAVAWH
A_A^A]A\_
WATAUAVAWH
A_A^A]A\_
(t$@L
(|$0I
WATAUAVAWH
A_A^A]A\_
WATAUAVAWH
A_A^A]A\_
` AUAVAWL
d$8A_A^A]
WATAUAVAWH
A_A^A]A\_
WATAUAVAWH
A_A^A]A\_
WATAUAVAWH
A_A^A]A\_
WATAUAVAWH
A_A^A]A\_
WATAUAVAWH
A_A^A]A\_
WATAUAVAWH
A_A^A]A\_
WATAUAVAWH
A_A^A]A\_
WATAUAVAWH
A_A^A]A\_
p AWL
L9t$@v>I
L;t$@r
t$(A_
WATAUAVAWH
A_A^A]A\_
H WATAUAVAWH
A_A^A]A\_
H UATAUAVAWH
A_A^A]A\]
H WATAUAVAWH
A_A^A]A\_
H UATAUAVAWH
A_A^A]A\]
H WATAUAVAWH
A_A^A]A\_
H UATAUAVAWH
A_A^A]A\]
H WATAUAVAWH
A_A^A]A\_
H WATAUAVAWH
A_A^A]A\_
H WATAUAVAWH
A_A^A]A\_
H WATAUAVAWH
)\$PM
D$(L+
l$8H+
D$ H+
A_A^A]A\_
H WATAUAVAWH
fA#D-
fE3L-
fA#L-
fE3D-
0A_A^A]A\_
H UATAUAVAWH
A_A^A]A\]
H UATAUAVAWH
A_A^A]A\]
H WATAUAVAWH
fD3L7
fA3L$
7fA#T$
0A_A^A]A\_
H WATAUAVAWH
L$@E3
D$pH+
t$XI+
A_A^A]A\_
H WATAUAVAWH
t$(I+
l$pI+
fE31fA
\$ fA
A_A^A]A\_
H UATAUAVAWH
A_A^A]A\]
H UATAUAVAWH
A_A^A]A\]
H UATAUAVAWH
A_A^A]A\]
H UATAUAVAWH
A_A^A]A\]
H UATAUAVAWH
A_A^A]A\]
H WATAUAVAWH
L$XE3
T$xfA
A_A^A]A\_
H WATAUAVAWH
 A_A^A]A\_
H WATAUAVAWH
A_A^A]A\_
H WATAUAVAWH
D$`I+
d$XL+
<C34<
,A3<,
A_A^A]A\_
H WATAUAVAWH
L$`M+
A_A^A]A\_
H UATAUAVAWH
A_A^A]A\]
H WATAUAVAWH
A_A^A]A\_
H UATAUAVAWH
A_A^A]A\]
H WATAUAVAWH
)l$pD
)t$`D
)|$PM
T$ E3
(t$`L
(|$PI
A_A^A]A\_
H UATAUAVAWH
A_A^A]A\]
H WATAUAVAWH
D$pM+
D$ M+
<Ic?IcD
Jc4>H
D$pHcL
A_A^A]A\_
H WATAUAVAWH
A_A^A]A\_
H UATAUAVAWH
A_A^A]A\]
H UATAUAVAWH
A_A^A]A\]
H UATAUAVAWH
A_A^A]A\]
H WATAUAVAWH
A_A^A]A\_
H UATAUAVAWH
A_A^A]A\]
H UATAUAVAWH
A_A^A]A\]
H UATAUAVAWH
A_A^A]A\]
H WATAUAVAWH
l$0E3
A_A^A]A\_
H WATAUAVAWH
0A_A^A]A\_
H UATAUAVAWH
A_A^A]A\]
WATAUAVAWH
0A_A^A]A\_
WATAUAVAWH
A_A^A]A\_
WATAUAVAWH
A_A^A]A\_
L9t$8vDI
L;t$8r
WATAUAVAWH
A_A^A]A\_
p AWL
t$(A_
3L$`#D$`
WATAUAVAWH
A_A^A]A\_
` AVAWL
d$0A_A^
WATAUAVAWH
A_A^A]A\_
WATAUAVAWH
A_A^A]A\_
` AVAWL
d$0A_A^
` AUAVAWL
d$8A_A^A]
WATAUAVAWH
fA#D$
fE3\$
fA#D$
fE3T$
fA#D$
fE3D$
fA#D$
fA3T$
fA#D$
fA3L$
A_A^A]A\_
WATAUAVAWH
0A_A^A]A\_
WATAUAVAWH
A_A^A]A\_
WATAUAVAWH
A_A^A]A\_
WATAUAVAWH
A_A^A]A\_
WATAUAVAWH
A_A^A]A\_
WATAUAVAWH
A_A^A]A\_
` AUAVAWL
d$8A_A^A]
` AVAWL
d$0A_A^
x ATAUAVAWL
|$@A_A^A]A\
WATAUAVAWH
A_A^A]A\_
WATAUAVAWH
A_A^A]A\_
WATAUAVAWH
A_A^A]A\_
(t$@L
(|$0I
WATAUAVAWH
A_A^A]A\_
WATAUAVAWH
A_A^A]A\_
` AUAVAWL
d$8A_A^A]
WATAUAVAWH
A_A^A]A\_
WATAUAVAWH
A_A^A]A\_
WATAUAVAWH
A_A^A]A\_
WATAUAVAWH
A_A^A]A\_
WATAUAVAWH
A_A^A]A\_
WATAUAVAWH
A_A^A]A\_
WATAUAVAWH
A_A^A]A\_
WATAUAVAWH
A_A^A]A\_
p AWL
L9t$@v>I
L;t$@r
t$(A_
WATAUAVAWH
A_A^A]A\_
x AVH
x AVH
x AVH
x AVH
x AVH
x AVH
x AVH
x AVH
x AVH
x AVH
x AVH
x AVH
x AVH
x AVH
x AVH
x AVH
x AVH
x AVH
x AVH
x AVH
H WATAUAVAWH
A_A^A]A\_
H WATAUAVAWH
A_A^A]A\_
` AUAVAWH
d$8A_A^A]
H WATAUAVAWH
A_A^A]A\_
H WATAUAVAWH
A_A^A]A\_
H WATAUAVAWH
A_A^A]A\_
WATAUAVAWH
\$hE3
A_A^A]A\_
WATAUAVAWH
\$hE3
A_A^A]A\_
WATAUAVAWH
l$HfA
A_A^A]A\_
` AUAVAWH
A_A^A]
H WATAUAVAWH
\$hE3
A_A^A]A\_
H WATAUAVAWH
A_A^A]A\_
H WATAUAVAWH
A_A^A]A\_
H WATAUAVAWH
A_A^A]A\_
WATAUAVAWH
fC#D.
fC3T.
 A_A^A]A\_
WATAUAVAWH
fB#D+
fF3\+
fC#D,
fG3L,
fC#D<
fG3D<
fC#D<
fC3L<
0A_A^A]A\_
H WATAUAVAWH
|$(L+
A_A^A]A\_
H WATAUAVAWH
A_A^A]A\_
H WATAUAVAWH
A_A^A]A\_
H WATAUAVAWH
A_A^A]A\_
H WATAUAVAWH
A_A^A]A\_
WATAUAVAWH
0A_A^A]A\_
H WATAUAVAWH
A_A^A]A\_
H WATAUAVAWH
A_A^A]A\_
H WATAUAVAWH
A_A^A]A\_
H WATAUAVAWH
A_A^A]A\_
H WATAUAVAWH
|$(L+
A_A^A]A\_
x ATAUAVH
l$xH+
 A^A]A\
H WATAUAVAWH
A_A^A]A\_
WATAUAVAWH
(t$PL
(|$@I
A_A^A]A\_
H WATAUAVAWH
A_A^A]A\_
H WATAUAVAWH
 A_A^A]A\_
H WATAUAVAWH
A_A^A]A\_
H WATAUAVAWH
A_A^A]A\_
H WATAUAVAWH
A_A^A]A\_
H WATAUAVAWH
A_A^A]A\_
WATAUAVAWH
 A_A^A]A\_
H WATAUAVAWH
A_A^A]A\_
H WATAUAVAWH
A_A^A]A\_
H WATAUAVAWH
A_A^A]A\_
WATAUAVAWH
 A_A^A]A\_
H WATAUAVAWH
A_A^A]A\_
H WATAUAVAWH
A_A^A]A\_
x AVH
x AVH
x AVH
x AVH
x AVH
x AVH
x AVH
x AVH
x AVH
x AVH
x AVH
x AVH
x AVH
x AVH
x AVH
x AVH
x AVH
x AVH
x AVH
x AVH
YVF/e
qHXz(.
x AVH
q;W|S
D$(M#
@USVWATAVAWH
`A_A^A\_^[]
q1[|e/
L$PH3
L$`H3
L$@H3
L$PH3
L$`H3
L$@H3
L$PH3
L$`H3
L$@H3
L$`H3
L$@H3
L$PH3
x AUAVAWH
UUUUUUU
 A_A^A]
WAVAWH
UUUUUUU
 A_A^_
WATAUAVAWH
UUUUUUU
 A_A^A]A\_
D$XA9
WAVAWH
0A_A^_
WAVAWH
0A_A^_
l$ VWAVH
L$@H3
x AVH
x AVH
x AVH
x AVH
x AVH
l$ VWAVH
L$`H3
x AVH
l$ VWAVH
L$`H3
WAVAWH
@A_A^_
WAVAWH
@A_A^_
WAVAWH
@A_A^_
WAVAWH
@A_A^_
WAVAWH
@A_A^_
WAVAWH
@A_A^_
WAVAWH
@A_A^_
UUUUUUU
@USVWAVH
ppQ<W
A^_^[]
@USVWATAUAVAWH
GPH9GHt
pX^6V>
A_A^A]A\_^[]
L$xH3
@USVWAVH
`A^_^[]
ApH;Axu
UVWATAUAVAWH
u!L;f
u!H;^
u%L;N
u!H;^
u!L;f
u!L;f
D$P;E
A_A^A]A\_^]
UVWATAUAVAWH
H+F H
H+F8H
A_A^A]A\_^]
VWAVH
 A^_^
UWATAVAWH
A_A^A\_]
USVWATAVAWH
A_A^A\_^[]
Q|V?`
Q|V?`
WAVAWH
A_A^_
@SVWH
SUVWAVH
A^_^][
SUVWAVH
A^_^][
USVWAUAVAWH
A_A^A]_^[]
t$ WH
UVWATAUAVAWH
 A_A^A]A\_^]
UVWATAUAVAWH
 A_A^A]A\_^]
UVWATAUAVAWH
 A_A^A]A\_^]
@USVWATAVAWH
0A_A^A\_^[]
@USVWATAVAWH
0A_A^A\_^[]
@USVWATAVAWH
0A_A^A\_^[]
p;W|S
x ATAVAWH
 A_A^A\
x ATAVAWH
 A_A^A\
p AWH
UVWATAUAVAWH
u(D;}
A_A^A]A\_^]
WAVAWH
D$0HcK
@A_A^_
UATAUAVAWH
A_A^A]A\]
UATAUAVAWH
A_A^A]A\]
UATAUAVAWH
A_A^A]A\]
UATAUAVAWH
A_A^A]A\]
UATAUAVAWH
A_A^A]A\]
UATAUAVAWH
D9m@tOH
A_A^A]A\]
@USVWATAUAVAWH
D9t$|
L9w t8H
A_A^A]A\_^[]
H UVWATAUAVAWH
t$@E3
`A_A^A]A\_^]
UVAVH
q X<0
ATAVAWH
@A_A^A\
|$ UATAUAVAWH
A_A^A]A\]
x UATAUAVAWH
d$(E3
D9d$@t3H
A_A^A]A\]
x UATAUAVAWH
D9|$@t
D$@E3
p@QXL'
L$ E3
A_A^A]A\]
x UATAUAVAWH
D9|$@t
D$@E3
p@QXL'
L$ E3
A_A^A]A\]
q [zB
UWAVH
|$ AVH
WAVAWH
0A_A^_
)t$ H
(t$ H
s AWH
D$XHcH
@USVWATAUAVAWH
D$8E3
EP8T$PuR
A_A^A]A\_^[]
UVWATAUAVAWH
pq^p6
A_A^A]A\_^]
t&HcH
UVWAVAWH
9]0u+D9u4u%
A_A^_^]
x ATAVAWH
0A_A^A\
L$ VWAVH
0A^_^
x ATAVAWH
0A_A^A\
t$ WH
L$`H3
qj[<l
x AVH
qj[<l
qj[<l
|$XH9
@USVWATAUAVAWH
H!|$ L
A_A^A]A\_^[]
|$ UAVAWH
p{Wtm
A_A^]
UVWATAUAVAWH
~ H9p
p{Wtm
p{Wtm
p{Wtm
PA_A^A]A\_^]
UVWATAUAVAWH
p{Wtm
p{Wtm
p{Wtm
@A_A^A]A\_^]
UAVAWH
p{Wtm
A_A^]
@USWAVAWH
A_A^_[]
@USWAVAWH
A_A^_[]
@USWAVAWH
A_A^_[]
t$ UWAVH
x UATAUAVAWH
A_A^A]A\]
x UATAUAVAWH
A_A^A]A\]
UVWATAUAVAWH
A_A^A]A\_^]
UVWATAUAVAWH
\$HE;
L$HD;
A_A^A]A\_^]
UATAUAVAWH
|$PE;
L$HE;
|$PE;
A_A^A]A\]
UWAVH
UWAVH
pA^_]
UWATAVAWH
A_A^A\_]
UWATAVAWH
A_A^A\_]
UWATAVAWH
A_A^A\_]
UWATAVAWH
A_A^A\_]
d$ UAVAWH
A_A^]
\$ UVAVH
\$ UWAVH
\$ UWAVH
pA^_]
\$ UVAVH
\$ UVAVH
x UAUAVH
A^A]]
|$ UATAUAVAWH
A_A^A]A\]
WAVAWH
0A_A^_
x AUAVAWH
0A_A^A]
q!\4H
E0H9A0tjL
q!\4H
q!\4H
w_IcA
tNH;L$`tGH
q!\4H
tNH;L$`tGH
@USVWATAUAVAWH
LcD$XHcT$PHcL$\D
L$ E3
A_A^A]A\_^[]
ATAVAWH
L9d$Xt
D$0E3
D$0E3
A_A^A\
{ ATAVAWH
A_A^A\
H UATAUAVAWH
I9D$`I
CD$`I
A_A^A]A\]
@USVWATAUAVAWH
D9d$Pt5H
A_A^A]A\_^[]
L$ UVWATAUAVAWH
0M9f(u
M+f H
PA_A^A]A\_^]
UAVAWH
A_A^]
L$ E3
UATAUAVAWH
A_A^A]A\]
p AWH
@USVWATAUAVAWH
D$0E3
A_A^A]A\_^[]
L;I t_H
H UATAUAVAWH
A_A^A]A\]
B(HcH
UVWATAUAVAWH
D8Eht2E
0A_A^A]A\_^]
R\u/L
x ATAVAWH
 A_A^A\
x UATAUAVAWH
A H98uXH
H98upH
H98ukH
H98u{H
H98u9L
A_A^A]A\]
L$ UVWATAUAVAWH
EHA;F
pA_A^A]A\_^]
L$HH3
UWAVH
x UAVAWH
A_A^]
UWAVH
UWATAVAWH
A_A^A\_]
L$ E3
\$ UVWAVAWH
`A_A^_^]
D;A(w
D;I,u
VWATAVAWH
\$@D;
A_A^A\_^
SVAVH
L$XH3
`A^^[
D;L$xu^
WATAUAVAWH
t$ Hc
0A_A^A]A\_
x AUAVAWH
(t$ H
0A_A^A]
qZQ80?
UATAVH
A^A\]
UVWATAUAVAWH
L$ E3
A_A^A]A\_^]
H UATAUAVAWH
D$0E3
D$0E3
A_A^A]A\]
UVWATAUAVAWH
D$0E3
L9(ujH
L9(usL
pA_A^A]A\_^]
t$ WATAUAVAWH
A_A^A]A\_
@USWAVAWH
A_A^_[]
\$ UVWAVAWH
A_A^_^]
UATAUAVAWH
L9(uwH
L9(uqL
A_A^A]A\]
UATAUAVAWH
H;]pt
L9 uyI
L9 u{H
L9 unH
L9 unH
A_A^A]A\]
UVWATAUAVAWH
pq^p6
|$(E3
pZQ80?
D$0E3
A_A^A]A\_^]
UWAWH
@USVWATAUAVAWH
A_A^A]A\_^[]
t$ UWAWH
L$pE3
L$HE3
D;A(v
)t$pH
(t$pH
D$ E3
\$ UVWATAUAVAWH
pA_A^A]A\_^]
L$ UVWATAUAVAWH
D$PE3
D9d$Pt,H
pA_A^A]A\_^]
UVWATAUAVAWH
0A_A^A]A\_^]
x ATAVAWH
0A_A^A\
L$0H3
UATAUAVAWH
A_A^A]A\]
WATAUAVAWH
A_A^A]A\_
t$09t$ t&
L$8H3
WATAUAVAWH
0A_A^A]A\_
(|$pL
p{Wtm
@USVWATAVAWH
A_A^A\_^[]
UWAVH
@80t+H
M@!uTH
T$P!uP
@USWH
UVWATAUAVAWH
|$`@88t/H
D9v(u
A_A^A]A\_^]
x AVH
UVWATAUAVAWH
A_A^A]A\_^]
H UATAUAVAWH
A_A^A]A\]
UVWATAUAVAWH
A_A^A]A\_^]
UAVAWH
A_A^]
@USVWATAUAVAWH
A_A^A]A\_^[]
UVWATAUAVAWH
A_A^A]A\_^]
t$ W3
T$0L+
L$8L+
x ATH
WAVAWH
0A_A^_
WAVAWH
0A_A^_
WAVAWH
0A_A^_
WAVAWH
0A_A^_
@USVWATAUAVAWH
H;C(u
EhD86tQ
A_A^A]A\_^[]
p AWH
qaPP\
VWAVH
 A^_^
t$ UWAUAVAWH
A_A^A]_]
@USVWATAVAWH
L9d$8I
D9eXt
H+D$8H;L$8H
uPD8eH
D8g0uTH
A_A^A\_^[]
t$ WH
D$ E3
x UATAUAVAWH
D$0H;
A_A^A]A\]
UWAVH
V\o7|
q(U6<
RPH+SHH
O8H+SHL
A(H+A H
H+A I
qx_Tb
ATAVAWH
@A_A^A\
L$0I+
WAVAWH
0A_A^_
WATAWH
L$0E;
@A_A\_
;D$(u
1;T$(t!A
x AVH
L$8H+T$0L
\$ UVWATAUAVAWH
A_A^A]A\_^]
UWAVH
D$@vT2
WAVAWH
 A_A^_
t$ WH
L$hH3
t$ WH
L$hH3
APH9AHt
@USVWATAUAVAWH
H9L$Hs
D$0H+
A_A^A]A\_^[]
@USVWATAUAVAWH
H9L$Hs
D$0H+
A_A^A]A\_^[]
\$ UVWATAUAVAWH
|$0I;
A_A^A]A\_^]
\$ UVWATAUAVAWH
T$8H;
H;t$0
A_A^A]A\_^]
@SUVWATAUAVAWH
GPH+GHH
L$xH3
A_A^A]A\_^][
@SUVWATAUAVAWH
GPH+GHH
L$xH3
A_A^A]A\_^][
pX^6V>
qX^6V>
WAVAWH
\$@H+
 A_A^_
x ATAVAWH
 A_A^A\
T$ E3
H+C@H
t$ UWATAVAWH
D$0=1
CL$XL
A_A^A\_]
t$ UWATAVAWH
D$ I;
A_A^A\_]
WAVAWH
 A_A^_
@SUVWAVH
A^_^][
@SVWH
WATAUAVAWH
 A_A^A]A\_
WATAUAVAWH
 A_A^A]A\_
\$ UVWH
VWAVH
L$HH3
x ATAVAWH
 A_A^A\
x ATAVAWH
 A_A^A\
x ATAVAWH
 A_A^A\
\$ UVWH
\$ UVWAVAWH
A_A^_^]
\$ UVWAVAWH
A_A^_^]
@USVWAUAVAWH
CT$@H
A_A^A]_^[]
\$ UVWATAUAVAWH
CT$@H
A_A^A]A\_^]
UVWATAUAVAWH
@A_A^A]A\_^]
L$pH3
@USVWAVH
pA^_^[]
@USVWATAUAVAWH
A_A^A]A\_^[]
l$ VWATAVAWH
A_A^A\_^
UVWAVAWH
0A_A^_^]
L$@H3
L$0E3
UVWATAUAVAWH
D8`hu.A
A_A^A]A\_^]
H9A t
\$ UVWATAUAVAWH
L9n8t.H
H9F8t0H
H9F0t0H
H9F(tVH
PA_A^A]A\_^]
x ATAVAWH
 A_A^A\
UVWATAUAVAWH
 A_A^A]A\_^]
WATAUAVAWH
 A_A^A]A\_
l$ L+
T$09A
T$09A
T$09A
T$09A
t$ UWAVH
@SVWH
L$HH3
L$hH3
UAVAWH
@A_A^]
x ATAVAWH
0A_A^A\
@USVWAVAWH
xA_A^_^[]
x AVH
@USVWAVAWH
A_A^_^[]
@USVWAVH
D$ A;
A^_^[]
\$ UVWH
|$ UH
UVWAVAWH
K H;S0t
A_A^_^]
p!^:N7
x ATAVAWH
 A_A^A\
x UATAUAVAWH
A_A^A]A\]
l$ VWAVH
L$HH3
D$ H;S
CT$(L
UVWAVAWH
D$ H;S
CT$(3
A_A^_^]
L$HH3
UVWATAUAVAWH
t$@9t$HD
D;t$H
T$@E3
A_A^A]A\_^]
T$ E3
L$0E3
x UATAUAVAWH
A_A^A]A\]
t$ UWATAUAVH
A^A]A\_]
L$0E3
WAVAWH
0A_A^_
D$PH;
L$0E3
WAVAWH
 A_A^_
L!E?H
L!EGH
UVWATAUAVAWH
A_A^A]A\_^]
UATAUAVAWH
A_A^A]A\]
t$ WH
t$ WH
L$0E3
t$ WH
L$@H3
t$ WH
L$HH3
VWAVH
 A^_^
t$ WH
L$@H3
t$ WH
L$@H3
t$ WH
L$HH3
t$ WH
L$@H3
t$ WH
L$@H3
x AVH
x ATAVAWH
 A_A^A\
L!E7H
USVWATAUAVAWH
hA_A^A]A\_^[]
x UATAUAVAWH
A_A^A]A\]
t$ WH
UVWATAUAVAWH
A_A^A]A\_^]
L$0E3
UVWATAUAVAWH
A_A^A]A\_^]
WAVAWH
 A_A^_
t$ WATAUAVAWH
 A_A^A]A\_
t$ WATAUAVAWH
 A_A^A]A\_
t$ WATAUAVAWH
 A_A^A]A\_
t$ WH
USVWATAUAVAWH
D9w }&
t&D9w L
E(9],u
H9D$@u
H9\$Xt
$M9y`t
A_A^A]A\_^[]
VWAUAVAWH
0A_A^A]_^
UVWAVAWH
A_A^_^]
@SVWH
@SUVWAVH
A^_^][
@SUVWAVH
A^_^][
L$(H3
x AVH
A9H0u
A9H4u
A9H$t
x UAVAWH
A_A^]
t$ WH
t$ UWAVH
@USVWAVAWH
A_A^_^[]
WATAWH
 A_A\_
@USVWATAUAVAWH
t:D9k
t9D9k
xA_A^A]A\_^[]
@SUVWATAVAWH
A_A^A\_^][
t$ WH
x AVH
@SUVWH
t$ WH
L$PH3
x AVH
@SUVWAVAWH
A_A^_^][
\$ UVWATAUAVAWH
A_A^A]A\_^]
x ATAVAWH
 A_A^A\
WATAUAVAWH
 A_A^A]A\_
x AUAVAWH
A_A^A]
p UWATAVAWH
A_A^A\_]
L$0E3
UVWATAUAVAWH
|$ E3
A_A^A]A\_^]
l$ VWAVH
 A^_^
VWATAVAWH
H+Ax3
H+OxH
 A_A^A\_^
\$ UVWATAUAVAWH
l$(I;
L$PH3
`A_A^A]A\_^]
L$0E3
WAVAWH
 A_A^_
L$0E3
t$ WH
S H;S(t
@SUVWATAUAVAWH
A_A^A]A\_^][
UVWAVAWH
L$HH3
PA_A^_^]
x AVH
D$ H;V(t
x ATAVAWH
 A_A^A\
|$ E3
UVWATAUAVAWH
l$0M+
IcA,H
A_A^A]A\_^]
UVWAVAWH
A_A^_^]
T$09A
x AVH
x AVH
x AVH
x AUAVAWH
 A_A^A]
WATAUAVAWH
 A_A^A]A\_
x AUAVAWH
 A_A^A]
@USVWAVAWH
A_A^_^[]
x ATAVAWH
 A_A^A\
UVWATAUAVAWH
H;D$(
t$8M;
A_A^A]A\_^]
L$0E3
\$ UVWAVAWH
A_A^_^]
)t$ L
(t$ H
t$ WAVAWH
K H;S0t
 A_A^_
L$@H3
x AVH
x ATAVAWH
 A_A^A\
x ATAVAWH
 A_A^A\
VWAVH
 A^_^
x AVH
USVWATAUAVAWH
L$8H;
l$hI+
J9< t
A_A^A]A\_^[]
|$ UAVAWH
A_A^]
UWAVH
(t$ H
)D$0D
(|$@D
(D$0H
)D$0D
(|$@D
(D$0H
D$ M+
8Chv 8Civ
|$ UAVAWH
A_A^]
UVWAVAWH
A_A^_^]
VWAVH
@A^_^
)D$ D
(t$0D
)D$ D
(t$0D
H9Q u
H9Q u
H9Q u
H9Q(u
H9Q u
H9Q(u
H9Q0u
H9Q8u
VWAVH
0A^_^
WAVAWH
 A_A^_
@USVWATAUAVAWH
A_A^A]A\_^[]
BP8APu
BQ8AQu
BhH9Ahu
@USVWATAVAWH
|$(I+
A_A^A\_^[]
(t$ H
D$HH;
D$HH;
x ATAVAWH
 A_A^A\
8?u>H
l$ H;
x AVH
WAVAWH
 A_A^_
L$Pv`
L$@H3
\$ UVWH
@SVWH
@SUVWAVH
L$PH3
`A^_^][
@SUVWAVH
A^_^][
UVWATAUAVAWH
A_A^A]A\_^]
@USVWATAVAWH
A_A^A\_^[]
@SVWH
x ATAVAWH
 A_A^A\
|$ E3
x ATAVAWH
 A_A^A\
WATAUAVAWH
 A_A^A]A\_
@USVWATAVAWH
`A_A^A\_^[]
L$@H3
L$@H3
@SVWH
L$@H3
@SUVWH
L$@H3
X_^][
@SVWH
L$HH3
\$ UVWH
L$HH3
L$@H3
\$ UVWH
L$@H3
WAVAWH
 A_A^_
L$ H;
L$(H;
WATAUAVAWH
A_A^A]A\_
WATAUAVAWH
A_A^A]A\_
x ATAVAWH
@A_A^A\
x ATAVAWH
0A_A^A\
WAVAWH
HL;L$p
?H;D$p
 A_A^_
x AVH
\$hH+
\$ H;
x AUAVAWH
 A_A^A]
WAVAWH
 A_A^_
WAVAWH
 A_A^_
WATAUAVAWH
A_A^A]A\_
WAVAWH
 A_A^_
p AWH
p AWH
UVWATAUAVAWH
t"D96t
t!9s0t
 A_A^A]A\_^]
x AVH
VWATAVAWH
0A_A^A\_^
require
disable
x AWH
@USVWAVH
A^_^[]
@SVWH
VWAVH
L$0E3
UVWATAUAVAWH
A_A^A]A\_^]
L$0E3
\$ WH
(t$0H
(t$ H
q;W|S
UATAUAVAWH
A_A^A]A\]
SVWATAUAVAWH
|$ E3
|$pH;
0A_A^A]A\_^[
@SUVWATAUAVAWH
t$8@8y@t
D$HD9@@u>
9HDu6A9>
l$0Mc
|$ A;
D$`A9>
t$(Ic
\$@D;
d$ E;>
L$xH3
A_A^A]A\_^][
L$ UVWATAUAVAWH
A_A^A]A\_^]
p AVH
WAVAWH
 A_A^_
WAVAWH
 A_A^_
WAVAWH
 A_A^_
UVWATAUAVAWH
 A_A^A]A\_^]
t$ WATAUAVAWH
 A_A^A]A\_
x AVL
|$(A^
x AVL
|$(A^
x AVL
|$(A^
x AVAWL
T$PI+
T$XM+
|$0A_A^
x AVL
|$(A^
x AVL
|$(A^
x AVL
|$(A^
x AVL
|$(A^
t$ WAVL
t$0A^_
WATAUAVAWH
H;l$pu3H;
 A_A^A]A\_
WATAUAVAWH
H;\$xu!I;
H;l$pu5H;
 A_A^A]A\_
WATAUAVAWH
H;\$xu!I;
H;l$pu5H;
 A_A^A]A\_
WATAUAVAWH
H;\$xu!I;
H;l$pu5H;
 A_A^A]A\_
WATAUAVAWH
H;\$xu!I;
H;l$pu5H;
 A_A^A]A\_
q X~0
h UAVAWH
A_A^]
H UATAUAVAWH
F0D8xfu
A_A^A]A\]
H UATAUAVAWH
A_A^A]A\]
UATAUAVAWH
A_A^A]A\]
UATAUAVAWH
LcmgL
A_A^A]A\]
UATAUAVAWH
Lc}gH
A_A^A]A\]
H UATAUAVAWH
Lc}gD
A_A^A]A\]
UATAUAVAWH
A_A^A]A\]
H UATAUAVAWH
A_A^A]A\]
WATAUAVAWH
A_A^A]A\_
WATAUAVAWH
A_A^A]A\_
x AVH
93~4E3
p [zB
UVWATAUAVAWH
M9o tII
A_A^A]A\_^]
}MLcJ
tCLcR
x AVH
` UAVAWH
@A_A^]
WATAUAVAWH
A_A^A]A\_
x ATAVAWH
A_A^A\
UATAUAVAWH
I9~ tIH
A_A^A]A\]
` UAVAWH
L9y t
A_A^]
` UAVAWH
L9y t
A_A^]
` UAVAWH
L9y t
A_A^]
x AVH
x ATAVAWH
~aD;w(t_N
 A_A^A\
u;Hcr
H9A t
H9A t
x AVH
UVWATAUAVAWH
@A_A^A]A\_^]
UVWATAUAVAWH
u(D9e
@A_A^A]A\_^]
UVWATAUAVAWH
0A_A^A]A\_^]
UATAUAVAWH
A_A^A]A\]
ATAVAWH
A_A^A\
d$ UAVAWH
A_A^]
UATAUAVAWH
A_A^A]A\]
UATAUAVAWH
p X<0
A_A^A]A\]
p X<0
UVWATAUAVAWH
A_A^A]A\_^]
UATAUAVAWH
LcuWH
A_A^A]A\]
h UAVAWH
A_A^]
UATAUAVAWH
$D9>~mE
A_A^A]A\]
UATAUAVAWH
A_A^A]A\]
UVWATAUAVAWH
`A_A^A]A\_^]
UAVAWH
A_A^]
UATAUAVAWH
A_A^A]A\]
UAVAWH
A_A^]
|$ UATAUAVAWH
A_A^A]A\]
|$ UAVAWH
A_A^]
p AWH
` AUAVAWH
0A_A^A]
UATAUAVAWH
A_A^A]A\]
UVWATAUAVAWH
D9d$@t5H
A_A^A]A\_^]
|$ UATAUAVAWH
A_A^A]A\]
VWATAVAWH
A9H u6
A9H$u-A
A8H,u
A8@-u
I9P0t&I
 A_A^A\_^
L$ E3
VWATAVAWH
A_A^A\_^
WAVAWH
 Hc|$`3
8\$ht3
 A_A^_
x AVH
8\$Xt:
9\$P~;
fD97t
HcL$PH
h UAVAWH
D$0E3
p@QXL'
A_A^]
UATAUAVAWH
LcmXH
l$0E3
A_A^A]A\]
L$0E3
E8Yhv E8Yit
E8Yhv
E8Yiv
)|$ I
(t$pL
(|$`E
x ATAVAWH
 A_A^A\
x ATAVAWH
 A_A^A\
t$ WH
t$ UWAVH
@USVWAVH
A^_^[]
u5D8ugt/H
u>D8ugt,H
t$ UWATAVAWH
A_A^A\_]
t$ WH
t$ WAVAWH
0A_A^_
x ATAVAWH
 A_A^A\
L$PH3
UVWATAUAVAWH
PA_A^A]A\_^]
UVWATAUAVAWH
t$PI;
pA_A^A]A\_^]
WATAUAVAWH
T$hE3
l$XI;
A_A^A]A\_
UVWATAUAVAWH
`A_A^A]A\_^]
UVWATAUAVAWH
|$PI;
pA_A^A]A\_^]
UVWATAUAVAWH
0A_A^A]A\_^]
x ATAVAWH
A_A^A\
@SUVWATAUAVAWH
D$`D+
|$HE3
L$pH3
A_A^A]A\_^][
WATAUAVAWH
A_A^A]A\_
@SUVWATAUAVAWH
l$@E3
\$PE3
A_A^A]A\_^][
SUVWATAUAVAWH
L$ A+
HA_A^A]A\_^][
t$ WAVI
2H;D$@stE3
)H;D$8sOI
t$0A^_
@SUVWATAUAVAWH
|$@E3
L$XH3
hA_A^A]A\_^][
WATAUAVAWL
t$HA_A^A]A\_
x AVH
UUUU3
UATAUAVAWH
+L$PA
+T$TE
D+D$X
D$d+D$tE
D$h+D$xE
A_A^A]A\]
x AVH
UVWATAUAVAWH
A_A^A]A\_^]
WAVAWH
A_A^_
UVWATAUAVAWH
A_A^A]A\_^]
@USWH
UVWATAUAVAWH
A_A^A]A\_^]
x AVL
T$@E3
|$(A^
x AVAWL
|$0A_A^
x AVL
|$(A^
x AVAWL
|$0A_A^
x AVL
|$(A^
x AVAWL
|$0A_A^
UVWATAUAVAWH
0A_A^A]A\_^]
UVWATAUAVAWH
0A_A^A]A\_^]
UVWATAUAVAWH
 A_A^A]A\_^]
UVWATAUAVAWH
D$pE3
 A_A^A]A\_^]
WATAUAVAWH
 A_A^A]A\_
x AVL
|$(A^
x AVL
|$(A^
x ATAUAVAWH
|$@A_A^A]A\
x AVAWL
|$0A_A^
x AVL
|$(A^
x ATAVAWH
|$8A_A^A\
x AVL
|$(A^
x AVL
|$(A^
ANGLE (
2.1.0.d0cdd066eca2
 (ANGLE 
0 (ANGLE 
OpenGL ES 
OpenGL ES GLSL ES 
Clear11 GS Multiview
Clear11 VS Multiview
Clear11 PS FloatFL9
Clear11 PS Float8
Clear11 PS Float7
Clear11 PS Float6
Clear11 PS Float5
Clear11 PS Float4
Clear11 PS Float3
Clear11 PS Float2
Clear11 PS Float1
Clear11 PS Sint8
Clear11 PS Sint7
Clear11 PS Sint6
Clear11 PS Sint5
Clear11 PS Sint4
Clear11 PS Sint3
Clear11 PS Sint2
Clear11 PS Sint1
Clear11 PS Uint8
Clear11 PS Uint7
Clear11 PS Uint6
Clear11 PS Uint5
Clear11 PS Uint4
Clear11 PS Uint3
Clear11 PS Uint2
Clear11 PS Uint1
Clear11 PS Depth
Clear11 VS FL9
Clear11 VS
Invalid enum.
float
GL_OES_EGL_image_external
GL_FRAGMENT_PRECISION_HIGH
GL_NV_EGL_stream_consumer_external
__LINE__
__FILE__
__VERSION__
GL_ES
GL_OES_standard_derivatives
D3DCompile
D3DDisassemble
d3dcompiler_47.dll
gpu.angle
Vertex shader uniform block count exceeds GL_MAX_VERTEX_UNIFORM_BLOCKS (
Fragment shader uniform block count exceeds GL_MAX_FRAGMENT_UNIFORM_BLOCKS (
TEXCOORD
attribute
varying
assign
uniform
float2
float3
(adapter LUID: %08x%08x)
Blit11 Alpha Mask Blend
imageSize
imageLoad
imageStore
image
const
inout
C:\fakepath
Texture2D<float4>
TextureCube<float4>
SamplerState
FRAGMENT
VERTEX
 Direct3D11
    output.v
input.v
sampler2D
textureGather
texture
textureSize
ntdll.dll
RtlIsMultiSessionSku
void copyVertex(inout GS_OUTPUT output, GS_INPUT input, GS_INPUT flatinput)
    output.gl_Position = input.gl_Position;
    output.dx_Position = input.dx_Position;
#endif  // ANGLE_POINT_SPRITE_SHADER
#ifndef ANGLE_POINT_SPRITE_SHADER
struct GS_OUTPUT
struct GS_INPUT
gl_Position
textureGrad
textureGatherOffset
textureProjOffset
textureOffset
textureProj
textureGradOffset
texture2DProj
textureLod
textureProjGradOffset
textureProjLodOffset
textureLodOffset
textureProjGrad
textureProjLod
texelFetch
samplerCube
texelFetchOffset
texture2D
structure
atomicCompSwap
atomicExchange
atomicAnd
atomicAdd
atomicXor
atomicMax
atomicMin
atomicOr
textureCube
gl_MaxCombinedShaderOutputResources
:MaxCombinedShaderOutputResources:
:MaxGeometryTotalOutputComponents:
gl_MaxCombinedAtomicCounterBuffers
gl_MaxFragmentAtomicCounterBuffers
:MaxCombinedAtomicCounterBuffers:
:MaxFragmentAtomicCounterBuffers:
:NV_EGL_stream_consumer_external:
gl_MaxComputeAtomicCounterBuffers
:MaxGeometryAtomicCounterBuffers:
:MaxGeometryShaderStorageBlocks:
gl_MaxVertexAtomicCounterBuffers
:MaxComputeAtomicCounterBuffers:
:MinProgramTextureGatherOffset:
:MaxProgramTextureGatherOffset:
:MaxVertexAtomicCounterBuffers:
gl_MaxCombinedTextureImageUnits
:MaxCombinedTextureImageUnits:
gl_MaxComputeUniformComponents
:EXT_shader_framebuffer_fetch:
gl_MaxComputeTextureImageUnits
:MaxGeometryTextureImageUnits:
:MaxGeometryUniformComponents:
:MaxGeometryShaderInvocations:
:OES_EGL_image_external_essl3:
:WEBGL_debug_shader_precision:
:ARM_shader_framebuffer_fetch:
:MaxGeometryOutputComponents:
:MaxComputeUniformComponents:
:NV_shader_framebuffer_fetch:
:MaxComputeTextureImageUnits:
gl_MaxAtomicCounterBufferSize
gl_MaxVertexTextureImageUnits
:MaxGeometryInputComponents:
gl_MaxFragmentAtomicCounters
:MaxVertexTextureImageUnits:
gl_MaxCombinedAtomicCounters
:MaxAtomicCounterBufferSize:
gl_MaxFragmentUniformVectors
gl_MaxCombinedImageUniforms
:MaxFragmentAtomicCounters:
:MaxFragmentUniformVectors:
:MaxCombinedAtomicCounters:
gl_MaxComputeWorkGroupCount
:MaxComputeWorkGroupCountY:
:MaxComputeWorkGroupCountX:
:MaxComputeWorkGroupCountZ:
:MaxGeometryOutputVertices:
gl_MaxFragmentImageUniforms
gl_MaxComputeAtomicCounters
:MaxGeometryAtomicCounters:
gl_MaxAtomicCounterBindings
:MaxFragmentImageUniforms:
gl_MaxComputeWorkGroupSize
:MaxGeometryUniformBlocks:
gl_MaxVertexUniformVectors
:MaxDualSourceDrawBuffers:
:MaxComputeWorkGroupSizeZ:
:MaxComputeWorkGroupSizeX:
:MaxComputeWorkGroupSizeY:
gl_MaxComputeImageUniforms
:MaxCombinedImageUniforms:
:MaxGeometryImageUniforms:
memoryBarrierAtomicCounter
gl_MaxVertexAtomicCounters
gl_MaxFragmentInputVectors
:OES_standard_derivatives:
:MaxComputeAtomicCounters:
:MaxAtomicCounterBindings:
:MaxFragmentInputVectors:
:MaxComputeImageUniforms:
:MaxExpressionComplexity:
gl_MaxVertexImageUniforms
:EXT_blend_func_extended:
:MaxVertexUniformVectors:
gl_MaxVertexOutputVectors
:MaxVertexAtomicCounters:
:MaxVertexOutputVectors:
:OES_EGL_image_external:
:EXT_shader_texture_lod:
gl_MinProgramTexelOffset
:MaxVertexImageUniforms:
gl_MaxProgramTexelOffset
gl_MaxTextureImageUnits
:MaxFunctionParameters:
:FragmentPrecisionHigh:
:MinProgramTexelOffset:
:MaxProgramTexelOffset:
gl_DepthRangeParameters
:ARB_texture_rectangle:
atomicCounterIncrement
:MaxTextureImageUnits:
atomicCounterDecrement
:OES_geometry_shader:
gl_MaxVaryingVectors
memoryBarrierBuffer
:MaxVaryingVectors:
:MaxCallStackDepth:
gl_MaxVertexAttribs
memoryBarrierImage
:EXT_draw_buffers:
:MaxVertexAttribs:
gl_MaxDrawBuffers
:NV_draw_buffers:
:MaxDrawBuffers:
:EXT_YUV_target:
gl_MaxImageUnits
:EXT_frag_depth:
texture2DProjLod
:OVR_multiview:
:MaxImageUnits:
atomicCounter
:MaxViewsOVR:
memoryBarrier
gl_DepthRange
ColorAndDepthDataUint
color_Uint
zValueF_Uint
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
ISGN,
SV_POSITION
SV_TARGET
SV_DEPTH
SHDRX
STATt
DXBC(PW
ColorAndDepthDataSint
color_Sint
zValueF_Sint
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
ISGN,
SV_POSITION
SV_TARGET
SV_DEPTH
SHDRX
STATt
ColorAndDepthDataFloat
color_Float
zValueF_Float
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
ISGN,
SV_POSITION
SV_TARGET
SV_DEPTH
SHDRX
STATt
ColorAndDepthDataUint
color_Uint
zValueF_Uint
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
ISGN,
SV_POSITION
SV_TARGET
SV_DEPTH
SHDR4
STATt
ColorAndDepthDataSint
color_Sint
zValueF_Sint
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
ISGN,
SV_POSITION
SV_TARGET
SV_DEPTH
SHDR4
STATt
ColorAndDepthDataFloat
color_Float
zValueF_Float
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
ISGN,
SV_POSITION
SV_TARGET
SV_DEPTH
SHDR4
STATt
DXBC2p
Aon9t
STATt
ColorAndDepthDataFloat
color_Float
zValueF_Float
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
ISGN,
SV_POSITION
SV_TARGET
SV_DEPTH
DXBC\#
ColorAndDepthDataUint
color_Uint
zValueF_Uint
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
ISGN,
SV_POSITION
SV_TARGET
SV_DEPTH
STATt
ColorAndDepthDataSint
color_Sint
zValueF_Sint
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
ISGN,
SV_POSITION
SV_TARGET
SV_DEPTH
STATt
DXBCY
ColorAndDepthDataFloat
color_Float
zValueF_Float
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
ISGN,
SV_POSITION
SV_TARGET
SV_DEPTH
STATt
ColorAndDepthDataUint
color_Uint
zValueF_Uint
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
ISGN,
SV_POSITION
SV_TARGET
SV_DEPTH
STATt
DXBCk
ColorAndDepthDataSint
color_Sint
zValueF_Sint
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
ISGN,
SV_POSITION
SV_TARGET
SV_DEPTH
STATt
DXBCn
ColorAndDepthDataFloat
color_Float
zValueF_Float
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
ISGN,
SV_POSITION
SV_TARGET
SV_DEPTH
STATt
ColorAndDepthDataUint
color_Uint
zValueF_Uint
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
ISGN,
SV_POSITION
SV_TARGET
SV_DEPTH
STATt
DXBCVy
ColorAndDepthDataSint
color_Sint
zValueF_Sint
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
ISGN,
SV_POSITION
SV_TARGET
SV_DEPTH
STATt
ColorAndDepthDataFloat
color_Float
zValueF_Float
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
ISGN,
SV_POSITION
SV_TARGET
SV_DEPTH
STATt
ColorAndDepthDataUint
color_Uint
zValueF_Uint
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
ISGN,
SV_POSITION
OSGN|
SV_TARGET
SV_DEPTH
STATt
ColorAndDepthDataSint
color_Sint
zValueF_Sint
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
ISGN,
SV_POSITION
OSGN|
SV_TARGET
SV_DEPTH
STATt
DXBCT
ColorAndDepthDataFloat
color_Float
zValueF_Float
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
ISGN,
SV_POSITION
OSGN|
SV_TARGET
SV_DEPTH
STATt
DXBC@
ColorAndDepthDataUint
color_Uint
zValueF_Uint
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
ISGN,
SV_POSITION
OSGNd
SV_TARGET
SV_DEPTH
STATt
ColorAndDepthDataSint
color_Sint
zValueF_Sint
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
ISGN,
SV_POSITION
OSGNd
SV_TARGET
SV_DEPTH
STATt
DXBClh
ColorAndDepthDataFloat
color_Float
zValueF_Float
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
ISGN,
SV_POSITION
OSGNd
SV_TARGET
SV_DEPTH
STATt
DXBC-
RDEFP
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
ISGNT
SV_VertexID
SV_InstanceID
OSGNP
SV_POSITION
TEXCOORD
STATt
RDEFP
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
ISGNP
SV_Position
TEXCOORD
OSGN`
SV_Position
SV_RenderTargetArrayIndex
STATt
ColorAndDepthDataUint
color_Uint
zValueF_Uint
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
ISGN,
SV_POSITION
OSGNL
SV_TARGET
SV_DEPTH
SHDR\
STATt
ColorAndDepthDataSint
color_Sint
zValueF_Sint
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
ISGN,
SV_POSITION
OSGNL
SV_TARGET
SV_DEPTH
SHDR\
STATt
ColorAndDepthDataFloat
color_Float
zValueF_Float
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
ISGN,
SV_POSITION
OSGNL
SV_TARGET
SV_DEPTH
SHDR\
STATt
a/XpL
RDEFP
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
ISGN,
SV_VertexID
OSGN,
SV_POSITION
STATt
DXBCvi
DepthOnlyData
zValue_Depth
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
ISGN,
SV_POSITION
OSGN,
SV_DEPTH
SHDR8
STATt
Aon9\
SHDR<
STATt
RDEFP
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
ISGN,
POSITION
OSGN,
SV_POSITION
textureCubeLod
texture2DLod
edgeIso.dll
api-ms-win-core-synch-l1-2-0.dll
kernel32.dll
SleepConditionVariableCS
WakeAllConditionVariable
MinLoadLib.exe
bbtlddll.exe
unknown exception
bad array new length
Extension is not enabled.
A buffer must be bound.
Texture is not cubemap complete. All cubemaps faces must be defined and be the same size.
It is invalid to change default FBO's attachments
Fragment shader output type does not match the bound framebuffer attachment type.
Enum is not currently supported.
Enum requires GLES 3.1
OpenGL ES 3.1 Required
OpenGL ES 3.0 Required.
Feedback loop formed between Framebuffer and active Texture.
Attachment type must be compatible with attachment object.
Index exceeds MAX_VERTEX_ATTRIBS.
Insufficient buffer size.
Integer overflow.
Invalid Attachment Type.
Border must be 0.
Invalid buffer target enum.
Invalid draw mode.
Texture only supports NEAREST and LINEAR filtering.
Invalid format.
Invalid parameter name for framebuffer attachment.
Level of detail outside of range.
Program object expected.
Invalid renderbuffer target.
Texture filter not recognized.
Invalid or unsupported texture target.
Texture wrap mode not recognized.
Invalid type.
Vertex attribute size must be 1, 2, 3, or 4.
Invalid wrap mode for texture type.
Invalid format and type combination.
Missing read attachment.
Negative count.
Negative offset.
Cannot have negative height or width.
Offset must be a multiple of the passed in datatype.
A program must be bound.
Program not linked.
Read buffer is GL_NONE.
A renderbuffer must be bound.
Desired resource size is greater than max texture size.
Stencil reference and mask values must be the same for front facing and back facing triangles.
Stride must be a multiple of the passed in datatype.
A texture must be bound.
Only UNSIGNED_SHORT and UNSIGNED_BYTE types are supported.
Uniform size does not match uniform method.
Unknown parameter value.
Vertex shader input type does not match the type of the bound vertex attribute.
Stride is over the maximum stride allowed by WebGL.
Invalid uniform location
wrong type of value for uniform
ANGLE_texture_rectangle extension not present
Neither NV_EGL_stream_consumer_external nor GL_OES_EGL_image_external extensions enabled
The active read framebuffer object has multiview attachments.
This ANGLE implementation does not support separate front/back stencil writemasks, reference values, or stencil mask values.
gl::ValidateDrawBase
It is a undefined behaviour to render without vertex shader stage or fragment shader stage.
The number of views in the active program and draw framebuffer does not match.
There is an active transform feedback object when the number of views in the active draw framebuffer is greater than 1.
There is an active query for target GL_TIME_ELAPSED_EXT when the number of views in the active draw framebuffer is greater than 1.
It is undefined behaviour to have a used but unbound uniform buffer.
It is undefined behaviour to use a uniform buffer that is too small.
Querying GL_PROGRAM_BINARY_LENGTH requires GL_OES_get_program_binary or ES 3.0.
Vertex type not supported before OpenGL ES 3.0.
Type is INT_2_10_10_10_REV or UNSIGNED_INT_2_10_10_10_REV and size is not 4.
pname requires OpenGL ES 3.0 or GL_OES_mapbuffer.
pname requires OpenGL ES 3.0, GL_OES_mapbuffer or GL_EXT_map_buffer_range.
GL_BUFFER_MAP_POINTER can only be queried with GetBufferPointerv.
pname requires OpenGL ES 3.0 or GL_EXT_map_buffer_range.
pname requires OpenGL ES 3.0.
GL_EXT_texture_sRGB_decode is not enabled.
GL_VERTEX_ATTRIB_ARRAY_DIVISOR requires OpenGL ES 3.0 or GL_ANGLE_instanced_arrays.
GL_VERTEX_ATTRIB_ARRAY_INTEGER requires OpenGL ES 3.0.
Vertex Attrib Bindings require OpenGL ES 3.1.
ES3 texture parameters are not available without GL_OES_EGL_image_external_essl3.
Invalid parameter for 2D multisampled textures.
GL_EXT_texture_anisotropic is not enabled.
Max anisotropy must be at least 1.
Base level must be 0 for external textures.
Base level must be 0 for multisampled textures.
Base level must be 0 for rectangle textures.
EGL_ANGLE_surface_orientation is not enabled.
EGL_EXT_pixel_format_float is not enabled.
Unknown attribute.
Direct3D platform is unsupported.
OpenGL platform is unsupported.
Display type EGL_PLATFORM_ANGLE_TYPE_NULL_ANGLE requires EGL_ANGLE_platform_angle_null.
Vulkan platform is unsupported.
Unknown platform type.
Platform ANGLE extension is not active
Platform Device extension is not active
Bad platform type.
Invalid automatic trim attribute
EGL_ANGLE_experimental_present_path extension not active
Invalid value for EGL_EXPERIMENTAL_PRESENT_PATH_ANGLE
Invalid value for EGL_PLATFORM_ANGLE_DEVICE_TYPE_ANGLE attrib
EGL_ANGLE_platform_angle extension not active
EGL_PLATFORM_ANGLE_DEBUG_LAYERS_ENABLED_ANGLE must be EGL_TRUE, EGL_FALSE, or EGL_DONT_CARE.
Must specify major version if you specify a minor version.
EGL_PLATFORM_ANGLE_DEVICE_TYPE_WARP_ANGLE requires a device type of EGL_PLATFORM_ANGLE_TYPE_D3D11_ANGLE.
EGL_PLATFORM_ANGLE_ENABLE_AUTOMATIC_TRIM_ANGLE requires a device type of EGL_PLATFORM_ANGLE_TYPE_D3D11_ANGLE.
EGL_EXPERIMENTAL_PRESENT_PATH_ANGLE requires a device type of EGL_PLATFORM_ANGLE_TYPE_D3D11_ANGLE.
EGL_PLATFORM_ANGLE_DEVICE_TYPE_ANGLE requires a device type of EGL_PLATFORM_ANGLE_TYPE_D3D9_ANGLE or EGL_PLATFORM_ANGLE_TYPE_D3D9_ANGLE.
EGL_PLATFORM_ANGLE_TYPE_VULKAN_ANGLE currently only supports Vulkan 1.0.
native_display should be a valid EGL device if platform equals EGL_PLATFORM_DEVICE_EXT
EGL_FLEXIBLE_SURFACE_COMPATIBILITY_SUPPORTED_ANGLE cannot be used without EGL_ANGLE_flexible_surface_compatibility support.
Device creation extension not active
Unhandled internal error: 
gl::RefCountObjectNoID::release
egl::Display::initialize
Context has been lost.
Each cubemap face must have equal width and height.
Invalid blend equation.
Invalid buffer usage enum.
Cull mode not recognized.
Invalid internal format.
Mipmap level must be 0 when attaching a texture.
Invalid name.
Invalid or unsupported precision type.
Invalid shader type.
Unpack alignment must be 1, 2, 4, or 8.
Texture level must be zero.
Invalid texture target and format combination.
Pixel data must be null.
Passed in texture target and format must match the one originally used to define the texture.
Invalid combination of type and internalFormat.
ETC lossy decode formats can't be copied to.
Invalid texture dimensions.
webgl_
ANGLE_lossy_etc_decode extension is not supported.
Rectangle texture cannot have a compressed format.
_webgl_
Invalid compressed format dimension.
Texture level does not exist.
Sized GL_RGBA32F internal format requires GL_CHROMIUM_color_buffer_float_rgba
ETC lossy decode formats can't work with this type.
Sized GL_RGB32F internal format requires GL_CHROMIUM_color_buffer_float_rgb
Context does not support GL_ANGLE_texture_rectangle
Texture was not generated
External texture extension not enabled
hint requires OES_standard_derivatives.
compute shader precision not yet implemented.
Cannot use negative values in PixelStorei
Textarget must match the texture target type.
internalformat is not a supported compressed internal format.
Reads would overflow the pixel unpack buffer.
Format must match the internal format of the texture.
Pixel unpack buffer is mapped.
Fragment shader version does not match vertex shader version.
Both a compute and non-compute shaders are attached to the same program.
Program has not been successfully linked.
GPU.ANGLE.ProgramCache.ProgramCacheMissTimeUS
 does not match any vertex varying
 differ between vertex and fragment shaders
Attribute '
Too many active attributes (
Layout qualifiers differ for interface block '
Types for 
' of 
Structure lengths for 
Name mismatch for field '
gl_FragCoord
gl_PointCoord
gl_PointSize
Two transform feedback varyings include the same array element (
gl_FragCoord can only be declared invariant if and only if gl_Position is declared invariant.
gl_PointCoord can only be declared invariant if and only if gl_PointSize is declared invariant.
 components (
) exceed the maximum separate components (
Capture of arrays is undefined and not supported.
gl_FragColor
gl_FragData
GL_OES_get_program_binary
GL_OES_rgb8_rgba8
GL_OES_element_index_uint
GL_OES_packed_depth_stencil
GL_NV_pixel_buffer_object
GL_OES_mapbuffer
GL_EXT_texture_format_BGRA8888
GL_EXT_read_format_bgra
GL_OES_texture_half_float
GL_OES_texture_half_float_linear
GL_EXT_map_buffer_range
GL_EXT_color_buffer_half_float
GL_EXT_texture_rg
GL_EXT_texture_compression_dxt1
GL_OES_texture_float
GL_OES_texture_float_linear
GL_EXT_texture_compression_s3tc_srgb
GL_KHR_texture_compression_astc_hdr
GL_ANGLE_texture_compression_dxt3
GL_ANGLE_texture_compression_dxt5
GL_EXT_sRGB
GL_ANGLE_depth_texture
GL_KHR_texture_compression_astc_ldr
GL_OES_compressed_ETC1_RGB8_texture
GL_OES_texture_npot
GL_EXT_draw_buffers
GL_OES_depth32
GL_EXT_texture_storage
GL_NV_fence
GL_EXT_disjoint_timer_query
GL_EXT_texture_filter_anisotropic
GL_EXT_occlusion_query_boolean
GL_EXT_blend_minmax
GL_ANGLE_framebuffer_blit
GL_EXT_robustness
GL_KHR_robust_buffer_access_behavior
GL_ANGLE_pack_reverse_row_order
GL_ANGLE_framebuffer_multisample
GL_ANGLE_instanced_arrays
GL_ANGLE_multiview
GL_ANGLE_texture_usage
GL_EXT_shader_texture_lod
GL_EXT_frag_depth
GL_EXT_discard_framebuffer
GL_EXT_debug_marker
GL_ANGLE_translated_shader_source
GL_OES_fbo_render_mipmap
GL_OES_EGL_image_external_essl3
GL_OES_EGL_image
GL_EXT_color_buffer_float
GL_OES_vertex_array_object
GL_EXT_unpack_subimage
GL_NV_pack_subimage
GL_CHROMIUM_bind_uniform_location
GL_CHROMIUM_sync_query
GL_KHR_debug
GL_ANGLE_lossy_etc_decode
GL_ANGLE_webgl_compatibility
GL_ANGLE_request_extension
GL_CHROMIUM_copy_texture
GL_CHROMIUM_copy_compressed_texture
GL_EXT_texture_sRGB_decode
GL_EXT_sRGB_write_control
GL_CHROMIUM_bind_generates_resource
GL_ANGLE_robust_client_memory
GL_EXT_multisample_compatibility
GL_CHROMIUM_framebuffer_mixed_samples
GL_CHROMIUM_color_buffer_float_rgb
GL_CHROMIUM_color_buffer_float_rgba
GL_OES_surfaceless_context
GL_ANGLE_client_arrays
GL_EXT_texture_norm16
GL_CHROMIUM_path_rendering
GL_ANGLE_texture_rectangle
GL_EXT_geometry_shader
GL_ANGLE_robust_resource_initialization
GL_ANGLE_program_cache_control
EGL_ANGLE_d3d_texture_client_buffer
EGL_ANGLE_surface_d3d_texture_2d_share_handle
EGL_EXT_create_context_robustness
EGL_ANGLE_d3d_share_handle_client_buffer
EGL_ANGLE_keyed_mutex
EGL_ANGLE_surface_orientation
EGL_ANGLE_query_surface_pointer
EGL_ANGLE_window_fixed_size
EGL_KHR_create_context
EGL_EXT_device_query
EGL_ANGLE_direct_composition
EGL_NV_post_sub_buffer
EGL_KHR_image_pixmap
EGL_KHR_gl_texture_2D_image
EGL_KHR_image
EGL_KHR_image_base
EGL_KHR_gl_renderbuffer_image
EGL_KHR_get_all_proc_addresses
EGL_KHR_gl_texture_cubemap_image
EGL_KHR_gl_texture_3D_image
EGL_NV_stream_consumer_gltexture_yuv
EGL_ANGLE_flexible_surface_compatibility
EGL_KHR_stream
EGL_KHR_stream_consumer_gltexture
EGL_CHROMIUM_create_context_bind_generates_resource
EGL_CHROMIUM_sync_control
EGL_ANGLE_stream_producer_d3d_texture
EGL_ANGLE_create_context_webgl_compatibility
EGL_KHR_surfaceless_context
EGL_ANGLE_display_texture_share_group
EGL_EXT_swap_buffers_with_damage
EGL_EXT_pixel_format_float
EGL_ANGLE_robust_resource_initialization
EGL_ANGLE_device_d3d
EGL_ANGLE_create_context_client_arrays
EGL_ANGLE_program_cache_control
Current driver does not support transform feedback in binary programs.
uniform '
Vertex shader atomic counter count exceeds MAX_VERTEX_ATOMIC_COUNTERS (
Fragment shader atomic counter count exceeds MAX_FRAGMENT_ATOMIC_COUNTERS (
Vertex shader active uniforms exceed MAX_VERTEX_UNIFORM_VECTORS (
Vertex shader sampler count exceeds MAX_VERTEX_TEXTURE_IMAGE_UNITS (
Vertex shader image count exceeds MAX_VERTEX_IMAGE_UNIFORMS (
Fragment shader active uniforms exceed MAX_FRAGMENT_UNIFORM_VECTORS (
Fragment shader sampler count exceeds MAX_TEXTURE_IMAGE_UNITS (
Fragment shader image count exceeds MAX_FRAGMENT_IMAGE_UNIFORMS (
Google Inc.
Point rendering without writing to gl_PointSize.
Could not retrieve the window dimensions
Could not create compute shader.
Error compiling dynamic geometry executable:
rx::ProgramD3D::getGeometryExecutableForPrimitiveType
Cannot pack these varyings on D3D9.
@@ VERTEX ATTRIBUTES @@
@@ PIXEL OUTPUT @@
gl_InstanceID
gl_VertexID
struct VS_INPUT
GL_USES_POINT_SIZE
input.
struct PS_OUTPUT
float4(0, 0, 0, 1)
dummy
    output.
void initAttributes(VS_INPUT input)
SV_TARGET
SV_Depth
    float4 dx_Position : 
    float4 gl_Position : 
    return output;
PS_OUTPUT generateOutput()
    PS_OUTPUT output;
struct VS_OUTPUT
    initAttributes(input);
VS_OUTPUT main(VS_INPUT input)
    VS_OUTPUT output;
    gl_main();
    output.gl_Position = gl_Position;
    output.dx_Position.y = - gl_Position.y;
    output.dx_Position.w = gl_Position.w;
    output.dx_Position.z = (gl_Position.z + gl_Position.w) * 0.5;
    output.dx_Position.x = gl_Position.x;
    return output;
struct PS_INPUT
PS_OUTPUT main(PS_INPUT input)
    return generateOutput();
 = input.v
point
Triangle
cbuffer DriverConstants : register(b0)
    float4 dx_ViewCoords : packoffset(c1);
    float2 dx_ViewScale : packoffset(c3);
    float multiviewSelectViewportIndex : packoffset(c3.z);
Point
triangle
void main(
[maxvertexcount(
uint primitiveID : SV_PrimitiveID, 
    GS_OUTPUT output = (GS_OUTPUT)0;
static float maxPointSize = 
#define ANGLE_POINT_SPRITE_SHADER
static float2 pointSpriteCorners[] = 
    float2( 0.5f, -0.5f),
    float2( 0.5f,  0.5f),
    float2(-0.5f, -0.5f),
    float2(-0.5f,  0.5f)
static float2 pointSpriteTexcoords[] = 
    float2(1.0f, 1.0f),
    float2(1.0f, 0.0f),
    float2(0.0f, 1.0f),
    float2(0.0f, 0.0f)
static float minPointSize = 
 GS_INPUT input[
], input[lastVertexIndex]);
    copyVertex(output, input[
   selectView(output, input[
Stream<GS_OUTPUT> outStream)
 inout 
    uint lastVertexIndex = (primitiveID % 2 == 0 ? 2 : 1);
    uint lastVertexIndex = 
    output.dx_Position = dx_Position + float4(pointSpriteCorners[
    output.gl_PointCoord = pointSpriteTexcoords[
    outStream.RestartStrip();
    outStream.Append(output);
    float4 dx_Position = input[0].dx_Position;
    float gl_PointSize = clamp(input[0].gl_PointSize, minPointSize, maxPointSize);
    float2 viewportScale = float2(1.0f / dx_ViewCoords.x, 1.0f / dx_ViewCoords.y) * dx_Position.w;
] * viewportScale * gl_PointSize, 0.0f, 0.0f);
    output.dx_Position = dx_Position + float4(1.0f, -dx_ViewScale.y, 1.0f, 1.0f)        * float4(pointSpriteCorners[
gl_Color[
SV_Position
gl_Color
gl_Color[0]
GL_USES_MRT
GL_USES_FRAG_COLOR
GL_USES_FRAG_DATA
GL_USES_FRAG_COORD
GL_ANGLE_MULTIVIEW_ENABLED
GL_USES_VIEW_ID
ANGLE_USES_DISCARD_REWRITING
ANGLE_USES_NESTED_BREAK
GL_USES_FRONT_FACING
GL_USES_POINT_COORD
GL_USES_DEPTH_RANGE
GL_USES_FRAG_DEPTH
// GLSL BEGIN
// INITIAL HLSL END
// INITIAL HLSL BEGIN
ANGLE_REQUIRES_IEEE_STRICT_COMPILING
 SHADER BEGIN
// GLSL END
GPU.ANGLE.SupportsDXGI1_2
GPU.ANGLE.D3D11FeatureLevel
client buffer is not a ID3D11Texture2D
Texture's device does not match.
Texture's sample count does not match.
Unknown client buffer texture format: 
rx::Renderer11::applyPrimitiveType
default
skip validation
skip optimization
_level_9_3
GPU.ANGLE.Buffer11CPUMemoryMB
ANGLE_ENABLE_LOOP_FLATTEN
Clear11::ensureResourcesInitialized
Software Adapter
Basic Render
Blit11 2D vertex shader
Blit11 2D input layout
Blit11 3D input layout
Blit11 2D depth pixel shader
Blit11::mResolveDepthStencilPS
Blit11::mResolveDepthPS
Blit11::initResources
Blit11::mResolveStencilPS
Blit11 3D geometry shader
Blit11 3D vertex shader
Blit11::mResolveDepthStencilVS
RDEFP
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
ISGN,
SV_VertexID
OSGNP
SV_Position
TEXCOORD
SHDRd
STATt
STATt
RDEFP
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
ISGNL
POSITION
TEXCOORD
OSGNP
SV_POSITION
TEXCOORD
Aon9d
SHDRd
STATt
Sampler
TextureF
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
ISGNP
SV_POSITION
TEXCOORD
OSGN,
SV_TARGET
DXBCj+
RDEFt
Depth
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
ISGNP
SV_Position
TEXCOORD
OSGN,
SV_Depth
STATt
DXBCz
RDEFx
Stencil
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
ISGNP
SV_Position
TEXCOORD
OSGN,
SV_Target
STATt
Sampler
TextureF
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
ISGNP
SV_POSITION
TEXCOORD
OSGN,
SV_DEPTH
SHDRx
STATt
DXBC\
RDEFP
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
ISGNl
SV_POSITION
LAYER
TEXCOORD
SV_POSITION
SV_RENDERTARGETARRAYINDEX
TEXCOORD
SHDR<
STATt
RDEFP
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
ISGNh
POSITION
LAYER
TEXCOORD
OSGNl
SV_POSITION
LAYER
TEXCOORD
STATt
Depth
Stencil
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
ISGNP
SV_Position
TEXCOORD
OSGN,
SV_Target
SHDR@
STATt
blend state
rasterizer state
depth stencil state
sampler state
Failed to get the data of an internal query, 
Failed to test get query result, device is lost.
input layout
asfloat(
static 
static float4 gl_Color[
// Varyings
#ifdef ANGLE_ENABLE_LOOP_FLATTEN
#define LOOP [loop]
#define FLATTEN [flatten]
#else
#define LOOP
#define FLATTEN
#endif
#define ANGLE_USES_DISCARD_REWRITING
cbuffer DriverConstants : register(b1)
    float4(0, 0, 0, 0)
// Varyings
static float4 gl_Position = float4(0, 0, 0, 0);
// Attributes
#define GL_USES_FRAG_COLOR
    float2 dx_ViewScale  : packoffset(c3);
    float2 dx_ViewCoords : packoffset(c2);
    float4 dx_ViewAdjust : packoffset(c1);
gl_FragDepth
gl_FragDepthEXT
ViewID_OVR
, transpose(
 = mul(
 >>= 
 <<= 
), transpose(
 = transpose(mul(transpose(
angle
transpose(mul(transpose(
mul(transpose(
asin(
degrees(
radians(
exp2(
tanh(
cosh(
sinh(
atan(
acos(
round(
trunc(
floor(
sign(
rsqrt(
sqrt(
log2(
normalize(
length(
asuint(
asint(
isinf(
isnan(
frac(
ceil(
reversebits(
determinant(transpose(
transpose(
fwidth(
, 0.0)
texture_
Lod0(
gl_main(
firstbithigh(
firstbitlow(
countbits(
clamp(
modf(
, texture_
angle_
, sampler_
refract(
reflect(
cross(
distance(
smoothstep(
step(
lerp(
discard
return
return 
continue
break
float4
index
Missing condition
Invalid condition
Expected loop index
Invalid relational operator
Loop index cannot be compared with non-constant expression
Missing expression
Invalid expression
Invalid operator
Loop index cannot be modified by non-constant expression
InstanceID
gl_ViewportIndex
gl_Layer
gl_ViewID_OVR
multiviewBaseViewLayerIndex
std430
gl_in
invariant
illegal type for precision qualifier
No precision specified for (float)
vector field selection out of range
can't modify a varying
can't modify gl_FragCoord
can't modify gl_FrontFacing
can't modify gl_PointCoord
can't modify gl_NumWorkGroups
can't modify gl_WorkGroupSize
can't modify gl_WorkGroupID
can't modify gl_LocalInvocationID
No precision specified
 l-value of swizzle cannot have duplicate components
 l-value required
can't modify a const
can't modify an attribute
can't modify an input
can't modify a uniform
can't modify gl_Layer in a fragment shader
can't modify void
can't modify a variable with type 
can't modify a readonly variable
l-value required
l-value required (
can't modify gl_GlobalInvocationID
can't modify gl_LocalInvocationIndex
can't modify gl_ViewID_OVR
can't modify work group size variable
can't modify any member in gl_in
can't modify gl_PrimitiveIDIn
can't modify gl_InvocationID
can't modify gl_PrimitiveID in a fragment shader
invalid layout qualifier: only valid on program inputs and outputs
invalid layout qualifier: only valid on shader inputs, outputs, and uniforms
The std430 layout is supported only for shader storage blocks.
location
location must only be specified for a single input or output variable
implicitly sized arrays need to be initialized
gl_LastFragData
cannot be used with a yuvCscStandardEXT
internal image format requires a floating image type
internal image format requires an integer image type
internal image format requires an unsigned image type
No image internal format specified
layout qualifier
unrecognized token
Except for images with the r32f, r32i and r32ui format qualifiers, image variables must be qualified readonly and/or writeonly
cannot be used with a structure
cannot declare buffer variables at global scope(outside a block)
s must be uniform
atomic counter binding greater than gl_MaxAtomicCounterBindings
invalid layout qualifier: only valid on program outputs
invalid layout qualifier: only valid when used with images
binding
invalid layout qualifier: only valid when used with opaque types or blocks
offset
invalid layout qualifier: only valid when used with atomic counters
gl_WorkGroupSize
Only allowed with shader storage blocks, variables declared within shader storage blocks and variables declared as image types.
s can't be function return values
function parameter array must specify a size
 left of '[' is not of type array, matrix, or vector 
expression
missing input primitive declaration before indexing gl_in.
array indexes for uniform block arrays and shader storage block arrays must be constant integral expressions
array indexes for fragment outputs must be constant integral expressions
array index for gl_FragData must be constant zero
index expression is negative
array index for gl_FragData must be zero when GL_EXT_draw_buffers is disabled
array index out of range
matrix field selection out of range
redefinition of a struct
Invalid operation for variables with an opaque type
Invalid operation for variables with writeonly
Invalid operation for structs
Invalid operation for interface blocks
array / non-array mismatch
invalid qualifier on struct member
disallowed type in struct
array members of structs must specify a size
Texture component must be a constant expression
Invalid operation for arrays
array size mismatch
undefined operation for structs containing arrays
undefined operation for structs containing samplers
dimension mismatch
comparison operator only defined for scalars
Texture offset value out of valid range
Component must be in the range [0;3]
Texture offset must be a constant expression
length
extension is not supported
groupMemoryBarrier
EmitVertex
EndPrimitive
barrier
memoryBarrierShared
gl_SecondaryFragColorEXT
gl_SecondaryFragDataEXT
gl_LastFragColor
gl_LastFragColorARM
gl_PrimitiveID
gl_NumWorkGroups
gl_WorkGroupID
gl_LocalInvocationID
gl_FrontFacing
gl_GlobalInvocationID
gl_LocalInvocationIndex
gl_PerVertex
gl_PrimitiveIDIn
gl_InvocationID
Infinity divided by infinity during constant folding generated NaN
Constant folded division overflowed to infinity
Zero divided by zero during constant folding generated NaN
Divide by zero during constant folding
Negative modulus operator operand encountered during constant folding
Divide by zero error during constant folding
sext2y2y
is2ms
iim2a
us2ms
uim2a
atomic_uint
struct-
.length()
equal
degrees
radians
greaterThan
lessThanEqual
notEqual
lessThan
greaterThanEqual
atanh
asinh
acosh
fract
clamp
inversesqrt
round
roundEven
floor
trunc
packUnorm2x16
packHalf2x16
ldexp
packSnorm2x16
unpackHalf2x16
packUnorm4x8
unpackSnorm2x16
unpackUnorm2x16
isinf
floatBitsToInt
smoothstep
isnan
tBitsToFloat
frexp
floatBitsToUint
intBitsToFloat
reflect
refract
outerProduct
transpose
fwidth
matrixCompMult
unpackSnorm4x8
distance
packSnorm4x8
unpackUnorm4x8
normalize
faceforward
cross
findMSB
uaddCarry
bitCount
findLSB
imulExtended
usubBorrow
umulExtended
determinant
inverse
bitfieldInsert
bitfieldReverse
bitfieldExtract
_ctor
#pragma pack_matrix(column_major)
#pragma pack_matrix(row_major)
struct 
    return 
Cube_snorm_float4_
Cube_unorm_float4_
Cube_int4_
Cube_float4_
Cube_uint4_
_External
RWCube_float4_
uint4
bool2
uint2
uint3
samplerCUBE
bool3
bool4
RWCube_uint4_
RWCube_unorm_float4_
RWCube_int4_
void umulExtended_emu(uint4 x, uint4 y, out uint4 msb, out uint4 lsb)
    umulExtended_emu(x.x, y.x, msb.x, lsb.x);
    umulExtended_emu(x.y, y.y, msb.y, lsb.y);
    umulExtended_emu(x.z, y.z, msb.z, lsb.z);
    umulExtended_emu(x.w, y.w, msb.w, lsb.w);
void imulExtended_emu(int x, int y, out int msb, out int lsb)
    uint unsignedMsb;
    uint unsignedLsb;
    bool negative = (x < 0) != (y < 0);
    umulExtended_emu(uint(abs(x)), uint(abs(y)), unsignedMsb, unsignedLsb);
    lsb = asint(unsignedLsb);
    msb = asint(unsignedMsb);
    if (negative)
    {
        lsb = ~lsb;
        msb = ~msb;
        if (lsb == 0xffffffff)
        {
            lsb = 0;
            msb += 1;
        }
        else
        {
            lsb += 1;
        }
    }
void umulExtended_emu(uint2 x, uint2 y, out uint2 msb, out uint2 lsb)
    umulExtended_emu(x.x, y.x, msb.x, lsb.x);
    umulExtended_emu(x.y, y.y, msb.y, lsb.y);
void umulExtended_emu(uint3 x, uint3 y, out uint3 msb, out uint3 lsb)
    umulExtended_emu(x.x, y.x, msb.x, lsb.x);
    umulExtended_emu(x.y, y.y, msb.y, lsb.y);
    umulExtended_emu(x.z, y.z, msb.z, lsb.z);
void imulExtended_emu(int4 x, int4 y, out int4 msb, out int4 lsb)
    imulExtended_emu(x.x, y.x, msb.x, lsb.x);
    imulExtended_emu(x.y, y.y, msb.y, lsb.y);
    imulExtended_emu(x.z, y.z, msb.z, lsb.z);
    imulExtended_emu(x.w, y.w, msb.w, lsb.w);
void imulExtended_emu(int2 x, int2 y, out int2 msb, out int2 lsb)
    imulExtended_emu(x.x, y.x, msb.x, lsb.x);
    imulExtended_emu(x.y, y.y, msb.y, lsb.y);
void imulExtended_emu(int3 x, int3 y, out int3 msb, out int3 lsb)
    imulExtended_emu(x.x, y.x, msb.x, lsb.x);
    imulExtended_emu(x.y, y.y, msb.y, lsb.y);
    imulExtended_emu(x.z, y.z, msb.z, lsb.z);
void umulExtended_emu(uint x, uint y, out uint msb, out uint lsb)
    lsb = x * y;
    uint a = (x & 0xffffu);
    uint b = (x >> 16);
    uint c = (y & 0xffffu);
    uint d = (y >> 16);
    uint ad = a * d + ((a * c) >> 16);
    uint bc = b * c;
    uint carry = uint(ad > (0xffffffffu - bc));
    msb = ((ad + bc) >> 16) + (carry << 16) + b * d;
uniform 
 textures
static const uint textureIndexOffset
static const uint samplerIndexOffset
 : register(s
 : register(t
 samplers
static const uint 
    struct SamplerMetadata
    {
        int baseLevel;
        int internalFormatBits;
        int wrapModes;
        int padding;
    };
    SamplerMetadata samplerMetadata[
] : packoffset(
register(
// Uniforms
samplerCUBE s
.SampleGrad(
sampler2D s
, int2 t
, int3 t
uint samplerIndex
.Load(
.SampleCmp(
.SampleBias(
.SampleLevel(
.SampleCmpLevelZero(
.Sample(
, int2 offset
, float bias
, int mip
, int3 offset
samplers
    const uint textureIndex = samplerIndex - textureIndexOffset
[samplerIndex]
textures
, float3 t
, float4 t
, int lod
, float2 t
, float lod
, int index
, float2 ddx, float2 ddy
, float3 ddx, float3 ddy
[samplerArrayIndex]
[textureIndex]
    const uint samplerArrayIndex = samplerIndex - samplerIndexOffset
grad(
bias(
, mip)
), t.z
, bias
, lod
tex2D
texCUBE
    return 
), index
), bias
), t.w
), ddx, ddy
, offset
gl_texture
), lod
, int2 p
, int3 p
, uint4 data
, float4 data
, int4 data
Illegal character at fieldname start
yyset_lineno called with no buffer
yyset_column called with no buffer
Input buffer overflow
Illegal use of reserved word
fatal flex scanner internal error--no action found
Invalid parameter qualifier 
invalid parameter qualifier
extension cannot have 'require' behavior
behavior invalid
extension cannot have 'enable' behavior
rx::HLSLCompiler::compileToBinary
// COMPILER INPUT HLSL BEGIN
// COMPILER INPUT HLSL END
error X4014:
error X3531:
 flags. (
rx::`anonymous-namespace'::DirectStoragePossible
Unlogged error in DirectStoragePossible.
Integer overflow on line number
EOF while in a comment
defined
float mix_emu(float x, float y, bool a)
    return a ? y : x;
float mod_emu(float x, float y)
    return x - y * floor(x / y);
float2 mix_emu(float2 x, float2 y, bool2 a)
    return a ? y : x;
float3 mix_emu(float3 x, float3 y, bool3 a)
    return a ? y : x;
float4 mix_emu(float4 x, float4 y, bool4 a)
    return a ? y : x;
float2 mod_emu(float2 x, float y)
    return x - y * floor(x / y);
float3 mod_emu(float3 x, float y)
    return x - y * floor(x / y);
float4 mod_emu(float4 x, float y)
    return x - y * floor(x / y);
float ldexp_emu(float x, int exp)
    return ldexp(x, float(exp));
float2 mod_emu(float2 x, float2 y)
    return x - y * floor(x / y);
float3 mod_emu(float3 x, float3 y)
    return x - y * floor(x / y);
float4 mod_emu(float4 x, float4 y)
    return x - y * floor(x / y);
float2 ldexp_emu(float2 x, int2 exp)
    return ldexp(x, float2(exp));
float3 ldexp_emu(float3 x, int3 exp)
    return ldexp(x, float3(exp));
float4 ldexp_emu(float4 x, int4 exp)
    return ldexp(x, float4(exp));
float asinh_emu(in float x)
    return log(x + sqrt(pow(x, 2.0) + 1.0));
float atanh_emu(in float x)
    return 0.5 * log((1.0 + x) / (1.0 - x));
float2 asinh_emu(in float2 x)
    return log(x + sqrt(pow(x, 2.0) + 1.0));
float3 asinh_emu(in float3 x)
    return log(x + sqrt(pow(x, 2.0) + 1.0));
float4 asinh_emu(in float4 x)
    return log(x + sqrt(pow(x, 2.0) + 1.0));
float2 atanh_emu(in float2 x)
    return 0.5 * log((1.0 + x) / (1.0 - x));
float3 atanh_emu(in float3 x)
    return 0.5 * log((1.0 + x) / (1.0 - x));
float4 atanh_emu(in float4 x)
    return 0.5 * log((1.0 + x) / (1.0 - x));
float acosh_emu(in float x)
    return log(x + sqrt(x + 1.0) * sqrt(x - 1.0));
float2 acosh_emu(in float2 x)
    return log(x + sqrt(x + 1.0) * sqrt(x - 1.0));
float3 acosh_emu(in float3 x)
    return log(x + sqrt(x + 1.0) * sqrt(x - 1.0));
float4 acosh_emu(in float4 x)
    return log(x + sqrt(x + 1.0) * sqrt(x - 1.0));
float atan_emu(float y, float x)
    if(x == 0 && y == 0) x = 1;
    return atan2(y, x);
float2x2 outerProduct_emu(in float2 c, in float2 r)
    return mul(float2x1(r), float1x2(c));
float3x3 outerProduct_emu(in float3 c, in float3 r)
    return mul(float3x1(r), float1x3(c));
float4x4 outerProduct_emu(in float4 c, in float4 r)
    return mul(float4x1(r), float1x4(c));
float2x3 outerProduct_emu(in float3 c, in float2 r)
    return mul(float2x1(r), float1x3(c));
float3x2 outerProduct_emu(in float2 c, in float3 r)
    return mul(float3x1(r), float1x2(c));
float2x4 outerProduct_emu(in float4 c, in float2 r)
    return mul(float2x1(r), float1x4(c));
float4x2 outerProduct_emu(in float2 c, in float4 r)
    return mul(float4x1(r), float1x2(c));
float3x4 outerProduct_emu(in float4 c, in float3 r)
    return mul(float3x1(r), float1x4(c));
float4x3 outerProduct_emu(in float3 c, in float4 r)
    return mul(float4x1(r), float1x3(c));
uint usubBorrow_emu(uint x, uint y, out uint borrow)
    borrow = uint(x < y);
    return x - y;
uint2 usubBorrow_emu(uint2 x, uint2 y, out uint2 borrow)
    borrow = uint2(x < y);
    return x - y;
uint3 usubBorrow_emu(uint3 x, uint3 y, out uint3 borrow)
    borrow = uint3(x < y);
    return x - y;
uint4 usubBorrow_emu(uint4 x, uint4 y, out uint4 borrow)
    borrow = uint4(x < y);
    return x - y;
float roundEven_emu(in float x)
    return (frac(x) == 0.5 && trunc(x) % 2.0 == 0.0) ? trunc(x) : round(x);
uint uaddCarry_emu(uint x, uint y, out uint carry)
    carry = uint(x > (0xffffffffu - y));
    return x + y;
uint2 uaddCarry_emu(uint2 x, uint2 y, out uint2 carry)
    carry = uint2(x > (0xffffffffu - y));
    return x + y;
uint3 uaddCarry_emu(uint3 x, uint3 y, out uint3 carry)
    carry = uint3(x > (0xffffffffu - y));
    return x + y;
uint4 uaddCarry_emu(uint4 x, uint4 y, out uint4 carry)
    carry = uint4(x > (0xffffffffu - y));
    return x + y;
uint packHalf2x16_emu(in float2 v)
    uint x = f32tof16(v.x);
    uint y = f32tof16(v.y);
    return (y << 16) | x;
float2 unpackHalf2x16_emu(in uint u)
    uint y = (u >> 16);
    uint x = u & 0xffffu;
    return float2(f16tof32(x), f16tof32(y));
float2x2 inverse_emu(in float2x2 m)
    float2x2 cof = { m[1][1], -m[0][1], -m[1][0], m[0][0] };
    return cof / determinant(transpose(m));
float frexp_emu(float x, out int exp)
    float fexp;
    float mantissa = frexp(abs(x), fexp) * sign(x);
    exp = int(fexp);
    return mantissa;
float faceforward_emu(float N, float I, float Nref)
    if(dot(Nref, I) >= 0)
    {
        return -N;
    }
    else
    {
        return N;
    }
float2 faceforward_emu(float2 N, float2 I, float2 Nref)
    if(dot(Nref, I) >= 0)
    {
        return -N;
    }
    else
    {
        return N;
    }
float3 faceforward_emu(float3 N, float3 I, float3 Nref)
    if(dot(Nref, I) >= 0)
    {
        return -N;
    }
    else
    {
        return N;
    }
float4 faceforward_emu(float4 N, float4 I, float4 Nref)
    if(dot(Nref, I) >= 0)
    {
        return -N;
    }
    else
    {
        return N;
    }
float2 frexp_emu(float2 x, out int2 exp)
    float2 fexp;
    float2 mantissa = frexp(abs(x), fexp) * sign(x);
    exp = int2(fexp);
    return mantissa;
float3 frexp_emu(float3 x, out int3 exp)
    float3 fexp;
    float3 mantissa = frexp(abs(x), fexp) * sign(x);
    exp = int3(fexp);
    return mantissa;
float4 frexp_emu(float4 x, out int4 exp)
    float4 fexp;
    float4 mantissa = frexp(abs(x), fexp) * sign(x);
    exp = int4(fexp);
    return mantissa;
float2 atan_emu(float2 y, float2 x)
    if(x[0] == 0 && y[0] == 0) x[0] = 1;
    if(x[1] == 0 && y[1] == 0) x[1] = 1;
    return float2(atan2(y[0], x[0]), atan2(y[1], x[1]));
float webgl_fromUnorm16(in uint x) {
    return float(x) / 65535.0;
float2 unpackUnorm2x16_emu(in uint u)
    uint y = (u >> 16);
    uint x = u & 0xffffu;
    return float2(webgl_fromUnorm16(x), webgl_fromUnorm16(y));
uint webgl_toUnorm16(in float x) {
    return uint(round(clamp(x, 0.0, 1.0) * 65535.0));
uint packUnorm2x16_emu(in float2 v)
    uint x = webgl_toUnorm16(v.x);
    uint y = webgl_toUnorm16(v.y);
    return (y << 16) | x;
float3 atan_emu(float3 y, float3 x)
    if(x[0] == 0 && y[0] == 0) x[0] = 1;
    if(x[1] == 0 && y[1] == 0) x[1] = 1;
    if(x[2] == 0 && y[2] == 0) x[2] = 1;
    return float3(atan2(y[0], x[0]), atan2(y[1], x[1]), atan2(y[2], x[2]));
float2 roundEven_emu(in float2 x)
    float2 v;
    v[0] = (frac(x[0]) == 0.5 && trunc(x[0]) % 2.0 == 0.0) ? trunc(x[0]) : round(x[0]);
    v[1] = (frac(x[1]) == 0.5 && trunc(x[1]) % 2.0 == 0.0) ? trunc(x[1]) : round(x[1]);
    return v;
int webgl_toSnorm16(in float x) {
    return int(round(clamp(x, -1.0, 1.0) * 32767.0));
uint packSnorm2x16_emu(in float2 v)
    int x = webgl_toSnorm16(v.x);
    int y = webgl_toSnorm16(v.y);
    return (asuint(y) << 16) | (asuint(x) & 0xffffu);
float webgl_fromSnorm16(in uint x) {
    int xi = asint(x & 0x7fffu) - asint(x & 0x8000u);
    return clamp(float(xi) / 32767.0, -1.0, 1.0);
float2 unpackSnorm2x16_emu(in uint u)
    uint y = (u >> 16);
    uint x = u;
    return float2(webgl_fromSnorm16(x), webgl_fromSnorm16(y));
float4 atan_emu(float4 y, float4 x)
    if(x[0] == 0 && y[0] == 0) x[0] = 1;
    if(x[1] == 0 && y[1] == 0) x[1] = 1;
    if(x[2] == 0 && y[2] == 0) x[2] = 1;
    if(x[3] == 0 && y[3] == 0) x[3] = 1;
    return float4(atan2(y[0], x[0]), atan2(y[1], x[1]), atan2(y[2], 
    x[2]), atan2(y[3], x[3]));
uint bitfieldExtract_emu(uint value, int offset, int bits)
    if (offset < 0 || bits <= 0 || offset >= 32 || bits > 32 || offset + bits > 32)
    {
        return 0u;
    }
    uint maskMsb = (1u << (bits - 1));
    uint mask = ((maskMsb - 1u) | maskMsb) << offset;
    return (value & mask) >> offset;
uint webgl_toUnorm8(in float x) {
    return uint(round(clamp(x, 0.0, 1.0) * 255.0));
uint packUnorm4x8_emu(in float4 v)
    uint x = webgl_toUnorm8(v.x);
    uint y = webgl_toUnorm8(v.y);
    uint z = webgl_toUnorm8(v.z);
    uint w = webgl_toUnorm8(v.w);
    return (w << 24) | (z << 16) | (y << 8) | x;
uint2 bitfieldExtract_emu(uint2 value, int offset, int bits)
    if (offset < 0 || bits <= 0 || offset >= 32 || bits > 32 || offset + bits > 32)
    {
        return uint2(0u, 0u);
    }
    uint maskMsb = (1u << (bits - 1));
    uint mask = ((maskMsb - 1u) | maskMsb) << offset;
    return (value & mask) >> offset;
uint3 bitfieldExtract_emu(uint3 value, int offset, int bits)
    if (offset < 0 || bits <= 0 || offset >= 32 || bits > 32 || offset + bits > 32)
    {
        return uint3(0u, 0u, 0u);
    }
    uint maskMsb = (1u << (bits - 1));
    uint mask = ((maskMsb - 1u) | maskMsb) << offset;
    return (value & mask) >> offset;
uint4 bitfieldExtract_emu(uint4 value, int offset, int bits)
    if (offset < 0 || bits <= 0 || offset >= 32 || bits > 32 || offset + bits > 32)
    {
        return uint4(0u, 0u, 0u, 0u);
    }
    uint maskMsb = (1u << (bits - 1));
    uint mask = ((maskMsb - 1u) | maskMsb) << offset;
    return (value & mask) >> offset;
float3 roundEven_emu(in float3 x)
    float3 v;
    v[0] = (frac(x[0]) == 0.5 && trunc(x[0]) % 2.0 == 0.0) ? trunc(x[0]) : round(x[0]);
    v[1] = (frac(x[1]) == 0.5 && trunc(x[1]) % 2.0 == 0.0) ? trunc(x[1]) : round(x[1]);
    v[2] = (frac(x[2]) == 0.5 && trunc(x[2]) % 2.0 == 0.0) ? trunc(x[2]) : round(x[2]);
    return v;
float webgl_fromUnorm8(in uint x) {
    return float(x) / 255.0;
float4 unpackUnorm4x8_emu(in uint u)
    uint w = (u >> 24) & 0xffu;
    uint z = (u >> 16) & 0xffu;
    uint y = (u >> 8) & 0xffu;
    uint x = u & 0xffu;
    return float4(webgl_fromUnorm8(x), webgl_fromUnorm8(y), 
    webgl_fromUnorm8(z), webgl_fromUnorm8(w));
float webgl_fromSnorm8(in uint x) {
    int xi = asint(x & 0x7fu) - asint(x & 0x80u);
    return clamp(float(xi) / 127.0, -1.0, 1.0);
float4 unpackSnorm4x8_emu(in uint u)
    uint w = (u >> 24);
    uint z = (u >> 16);
    uint y = (u >> 8);
    uint x = u;
    return float4(webgl_fromSnorm8(x), webgl_fromSnorm8(y), 
    webgl_fromSnorm8(z), webgl_fromSnorm8(w));
int webgl_toSnorm8(in float x) {
    return int(round(clamp(x, -1.0, 1.0) * 127.0));
uint packSnorm4x8_emu(in float4 v)
    int x = webgl_toSnorm8(v.x);
    int y = webgl_toSnorm8(v.y);
    int z = webgl_toSnorm8(v.z);
    int w = webgl_toSnorm8(v.w);
    return ((asuint(w) & 0xffu) << 24) | ((asuint(z) & 0xffu) << 16) 
    | ((asuint(y) & 0xffu) << 8) | (asuint(x) & 0xffu);
uint bitfieldInsert_emu(uint base, uint insert, int offset, int bits)
    if (offset < 0 || bits <= 0 || offset >= 32 || bits > 32 || offset + bits > 32)
    {
        return base;
    }
    uint maskMsb = (1u << (bits - 1));
    uint insertMask = ((maskMsb - 1u) | maskMsb) << offset;
    uint baseMask = ~insertMask;
    return (base & baseMask) | ((insert << offset) & insertMask);
uint2 bitfieldInsert_emu(uint2 base, uint2 insert, int offset, int bits)
    if (offset < 0 || bits <= 0 || offset >= 32 || bits > 32 || offset + bits > 32)
    {
        return base;
    }
    uint maskMsb = (1u << (bits - 1));
    uint insertMask = ((maskMsb - 1u) | maskMsb) << offset;
    uint baseMask = ~insertMask;
    return (base & baseMask) | ((insert << offset) & insertMask);
uint3 bitfieldInsert_emu(uint3 base, uint3 insert, int offset, int bits)
    if (offset < 0 || bits <= 0 || offset >= 32 || bits > 32 || offset + bits > 32)
    {
        return base;
    }
    uint maskMsb = (1u << (bits - 1));
    uint insertMask = ((maskMsb - 1u) | maskMsb) << offset;
    uint baseMask = ~insertMask;
    return (base & baseMask) | ((insert << offset) & insertMask);
uint4 bitfieldInsert_emu(uint4 base, uint4 insert, int offset, int bits)
    if (offset < 0 || bits <= 0 || offset >= 32 || bits > 32 || offset + bits > 32)
    {
        return base;
    }
    uint maskMsb = (1u << (bits - 1));
    uint insertMask = ((maskMsb - 1u) | maskMsb) << offset;
    uint baseMask = ~insertMask;
    return (base & baseMask) | ((insert << offset) & insertMask);
float4 roundEven_emu(in float4 x)
    float4 v;
    v[0] = (frac(x[0]) == 0.5 && trunc(x[0]) % 2.0 == 0.0) ? trunc(x[0]) : round(x[0]);
    v[1] = (frac(x[1]) == 0.5 && trunc(x[1]) % 2.0 == 0.0) ? trunc(x[1]) : round(x[1]);
    v[2] = (frac(x[2]) == 0.5 && trunc(x[2]) % 2.0 == 0.0) ? trunc(x[2]) : round(x[2]);
    v[3] = (frac(x[3]) == 0.5 && trunc(x[3]) % 2.0 == 0.0) ? trunc(x[3]) : round(x[3]);
    return v;
int4 bitfieldInsert_emu(int4 base, int4 insert, int offset, int bits)
    if (offset < 0 || bits <= 0 || offset >= 32 || bits > 32 || offset + bits > 32)
    {
        return base;
    }
    uint maskMsb = (1u << (bits - 1));
    uint insertMask = ((maskMsb - 1u) | maskMsb) << offset;
    uint baseMask = ~insertMask;
    uint4 resultUnsigned = (asuint(base) & baseMask) | ((asuint(insert) << offset) & 
    insertMask);
    return asint(resultUnsigned);
int bitfieldInsert_emu(int base, int insert, int offset, int bits)
    if (offset < 0 || bits <= 0 || offset >= 32 || bits > 32 || offset + bits > 32)
    {
        return base;
    }
    uint maskMsb = (1u << (bits - 1));
    uint insertMask = ((maskMsb - 1u) | maskMsb) << offset;
    uint baseMask = ~insertMask;
    uint resultUnsigned = (asuint(base) & baseMask) | ((asuint(insert) << offset) & 
                           insertMask);
    return asint(resultUnsigned);
int2 bitfieldInsert_emu(int2 base, int2 insert, int offset, int bits)
    if (offset < 0 || bits <= 0 || offset >= 32 || bits > 32 || offset + bits > 32)
    {
        return base;
    }
    uint maskMsb = (1u << (bits - 1));
    uint insertMask = ((maskMsb - 1u) | maskMsb) << offset;
    uint baseMask = ~insertMask;
    uint2 resultUnsigned = (asuint(base) & baseMask) | ((asuint(insert) << offset) & 
                            insertMask);
    return asint(resultUnsigned);
int3 bitfieldInsert_emu(int3 base, int3 insert, int offset, int bits)
    if (offset < 0 || bits <= 0 || offset >= 32 || bits > 32 || offset + bits > 32)
    {
        return base;
    }
    uint maskMsb = (1u << (bits - 1));
    uint insertMask = ((maskMsb - 1u) | maskMsb) << offset;
    uint baseMask = ~insertMask;
    uint3 resultUnsigned = (asuint(base) & baseMask) | ((asuint(insert) << offset) & 
                            insertMask);
    return asint(resultUnsigned);
int bitfieldExtract_emu(int value, int offset, int bits)
    if (offset < 0 || bits <= 0 || offset >= 32 || bits > 32 || offset + bits > 32)
    {
        return 0;
    }
    uint maskMsb = (1u << (bits - 1));
    uint mask = ((maskMsb - 1u) | maskMsb) << offset;
    uint resultUnsigned = (asuint(value) & mask) >> offset;
    if (bits != 32 && (resultUnsigned & maskMsb) != 0)
    {
        uint higherBitsMask = ((1u << (32 - bits)) - 1u) << bits;
        resultUnsigned |= higherBitsMask;
    }
    return asint(resultUnsigned);
int2 bitfieldExtract_emu(int2 value, int offset, int bits)
    if (offset < 0 || bits <= 0 || offset >= 32 || bits > 32 || offset + bits > 32)
    {
        return int2(0, 0);
    }
    uint maskMsb = (1u << (bits - 1));
    uint mask = ((maskMsb - 1u) | maskMsb) << offset;
    uint2 resultUnsigned = (asuint(value) & mask) >> offset;
    if (bits != 32)
    {
        uint higherBitsMask = ((1u << (32 - bits)) - 1u) << bits;
        resultUnsigned |= ((resultUnsigned & maskMsb) >> (bits - 1)) * higherBitsMask;
    }
    return asint(resultUnsigned);
int3 bitfieldExtract_emu(int3 value, int offset, int bits)
    if (offset < 0 || bits <= 0 || offset >= 32 || bits > 32 || offset + bits > 32)
    {
        return int3(0, 0, 0);
    }
    uint maskMsb = (1u << (bits - 1));
    uint mask = ((maskMsb - 1u) | maskMsb) << offset;
    uint3 resultUnsigned = (asuint(value) & mask) >> offset;
    if (bits != 32)
    {
        uint higherBitsMask = ((1u << (32 - bits)) - 1u) << bits;
        resultUnsigned |= ((resultUnsigned & maskMsb) >> (bits - 1)) * higherBitsMask;
    }
    return asint(resultUnsigned);
int4 bitfieldExtract_emu(int4 value, int offset, int bits)
    if (offset < 0 || bits <= 0 || offset >= 32 || bits > 32 || offset + bits > 32)
    {
        return int4(0, 0, 0, 0);
    }
    uint maskMsb = (1u << (bits - 1));
    uint mask = ((maskMsb - 1u) | maskMsb) << offset;
    uint4 resultUnsigned = (asuint(value) & mask) >> offset;
    if (bits != 32)
    {
        uint higherBitsMask = ((1u << (32 - bits)) - 1u) << bits;
        resultUnsigned |= ((resultUnsigned & maskMsb) >> (bits - 1)) * higherBitsMask;
    }
    return asint(resultUnsigned);
float3x3 inverse_emu(in float3x3 m)
    float cof00 = m[1][1] * m[2][2] - m[2][1] * m[1][2];
    float cof01 = -(m[1][0] * m[2][2] - m[2][0] * m[1][2]);
    float cof02 = m[1][0] * m[2][1] - m[2][0] * m[1][1];
    float cof10 = -(m[0][1] * m[2][2] - m[2][1] * m[0][2]);
    float cof11 = m[0][0] * m[2][2] - m[2][0] * m[0][2];
    float cof12 = -(m[0][0] * m[2][1] - m[2][0] * m[0][1]);
    float cof20 = m[0][1] * m[1][2] - m[1][1] * m[0][2];
    float cof21 = -(m[0][0] * m[1][2] - m[1][0] * m[0][2]);
    float cof22 = m[0][0] * m[1][1] - m[1][0] * m[0][1];
    float3x3 cof = { cof00, cof10, cof20, cof01, cof11, cof21, cof02, cof12, cof22 };
    return cof / determinant(transpose(m));
float4x4 inverse_emu(in float4x4 m)
    float cof00 = m[1][1] * m[2][2] * m[3][3] + m[2][1] * m[3][2] * m[1][3] + m[3][1] * 
    m[1][2] * m[2][3]
     - m[1][1] * m[3][2] * m[2][3] - m[2][1] * m[1][2] * m[3][3] - m[3][1] * m[2][2] * 
    m[1][3];
    float cof01 = -(m[1][0] * m[2][2] * m[3][3] + m[2][0] * m[3][2] * m[1][3] + m[3][0] * 
    m[1][2] * m[2][3]
     - m[1][0] * m[3][2] * m[2][3] - m[2][0] * m[1][2] * m[3][3] - m[3][0] * m[2][2] * 
    m[1][3]);
    float cof02 = m[1][0] * m[2][1] * m[3][3] + m[2][0] * m[3][1] * m[1][3] + m[3][0] * 
    m[1][1] * m[2][3]
     - m[1][0] * m[3][1] * m[2][3] - m[2][0] * m[1][1] * m[3][3] - m[3][0] * m[2][1] * 
    m[1][3];
    float cof03 = -(m[1][0] * m[2][1] * m[3][2] + m[2][0] * m[3][1] * m[1][2] + m[3][0] * 
    m[1][1] * m[2][2]
     - m[1][0] * m[3][1] * m[2][2] - m[2][0] * m[1][1] * m[3][2] - m[3][0] * m[2][1] * 
    m[1][2]);
    float cof10 = -(m[0][1] * m[2][2] * m[3][3] + m[2][1] * m[3][2] * m[0][3] + m[3][1] * 
    m[0][2] * m[2][3]
     - m[0][1] * m[3][2] * m[2][3] - m[2][1] * m[0][2] * m[3][3] - m[3][1] * m[2][2] * 
    m[0][3]);
    float cof11 = m[0][0] * m[2][2] * m[3][3] + m[2][0] * m[3][2] * m[0][3] + m[3][0] * 
    m[0][2] * m[2][3]
     - m[0][0] * m[3][2] * m[2][3] - m[2][0] * m[0][2] * m[3][3] - m[3][0] * m[2][2] * 
    m[0][3];
    float cof12 = -(m[0][0] * m[2][1] * m[3][3] + m[2][0] * m[3][1] * m[0][3] + m[3][0] * 
    m[0][1] * m[2][3]
     - m[0][0] * m[3][1] * m[2][3] - m[2][0] * m[0][1] * m[3][3] - m[3][0] * m[2][1] * 
    m[0][3]);
    float cof13 = m[0][0] * m[2][1] * m[3][2] + m[2][0] * m[3][1] * m[0][2] + m[3][0] * 
    m[0][1] * m[2][2]
     - m[0][0] * m[3][1] * m[2][2] - m[2][0] * m[0][1] * m[3][2] - m[3][0] * m[2][1] * 
    m[0][2];
    float cof20 = m[0][1] * m[1][2] * m[3][3] + m[1][1] * m[3][2] * m[0][3] + m[3][1] * 
    m[0][2] * m[1][3]
     - m[0][1] * m[3][2] * m[1][3] - m[1][1] * m[0][2] * m[3][3] - m[3][1] * m[1][2] * 
    m[0][3];
    float cof21 = -(m[0][0] * m[1][2] * m[3][3] + m[1][0] * m[3][2] * m[0][3] + m[3][0] * 
    m[0][2] * m[1][3]
     - m[0][0] * m[3][2] * m[1][3] - m[1][0] * m[0][2] * m[3][3] - m[3][0] * m[1][2] * 
    m[0][3]);
    float cof22 = m[0][0] * m[1][1] * m[3][3] + m[1][0] * m[3][1] * m[0][3] + m[3][0] * 
    m[0][1] * m[1][3]
     - m[0][0] * m[3][1] * m[1][3] - m[1][0] * m[0][1] * m[3][3] - m[3][0] * m[1][1] * 
    m[0][3];
    float cof23 = -(m[0][0] * m[1][1] * m[3][2] + m[1][0] * m[3][1] * m[0][2] + m[3][0] * 
    m[0][1] * m[1][2]
     - m[0][0] * m[3][1] * m[1][2] - m[1][0] * m[0][1] * m[3][2] - m[3][0] * m[1][1] * 
    m[0][2]);
    float cof30 = -(m[0][1] * m[1][2] * m[2][3] + m[1][1] * m[2][2] * m[0][3] + m[2][1] * 
    m[0][2] * m[1][3]
     - m[0][1] * m[2][2] * m[1][3] - m[1][1] * m[0][2] * m[2][3] - m[2][1] * m[1][2] * 
    m[0][3]);
    float cof31 = m[0][0] * m[1][2] * m[2][3] + m[1][0] * m[2][2] * m[0][3] + m[2][0] * 
    m[0][2] * m[1][3]
     - m[0][0] * m[2][2] * m[1][3] - m[1][0] * m[0][2] * m[2][3] - m[2][0] * m[1][2] * 
    m[0][3];
    float cof32 = -(m[0][0] * m[1][1] * m[2][3] + m[1][0] * m[2][1] * m[0][3] + m[2][0] * 
    m[0][1] * m[1][3]
     - m[0][0] * m[2][1] * m[1][3] - m[1][0] * m[0][1] * m[2][3] - m[2][0] * m[1][1] * 
    m[0][3]);
    float cof33 = m[0][0] * m[1][1] * m[2][2] + m[1][0] * m[2][1] * m[0][2] + m[2][0] * 
    m[0][1] * m[1][2]
     - m[0][0] * m[2][1] * m[1][2] - m[1][0] * m[0][1] * m[2][2] - m[2][0] * m[1][1] * 
    m[0][2];
    float4x4 cof = { cof00, cof10, cof20, cof30, cof01, cof11, cof21, cof31,
     cof02, cof12, cof22, cof32, cof03, cof13, cof23, cof33 };
    return cof / determinant(transpose(m));
HasIndexRange
POSITION
LAYER
 !"#$%%%%%%&%'%%()*+%%,-%.
23456789:%;<=>?@%ABCDEFGHIJKLM
 !"#$%&'()
*+,-./01234
6789:;<:::::::::::::::::::::::::::===============:::=========================::::?@ADFHHHHHHHHHH
JQVWGEY
KKKKKKKKLLRMST
Z_\`NMabck
ldNOM]^egmf
~ujowpNxqOyzv
LXXXXXX
s[UPIC>
T(+-,)/.0*
""#%o%#
!!#$%#+$
7*($&)&
))(*&)),).
013M1M300,^01.^3.00102HH
2KK2fLp
zHHzzJJzpz
~}|{yxvutsrqnmlkjihgedcba`_]\[WS5/-' 
 !"#$%&'()*+,-./01
23456789:;<=>?@AB
CDEFGHIJKLMNOPQRSTU
 !"#$%&'()*+,-./01
23456789:;<=>?@AB
CDEFGHIJKLMNOPQRSTU
 !"#$%&'()*+,-./01
23456789:;<=>?@AB
CDEFGHIJKLMNOPQRSTU
 !"#$%&'()*+,-./01
23456789:;<=>?@AB
CDEFGHIJKLMNOPQRSTU
 !"#$%&'()*+,-./01
23456789:;<=>?@AB
CDEFGHIJKLMNOPQRSTU
 !"#$%&'()*+,-./01
23456789:;<=>?@AB
CDEFGHIJKLMNOPQRSTU
 !"#$%&'()*+,-./01
23456789:;<=>?@AB
CDEFGHIJKLMNOPQRSTU
 !"#$%&'()*+,-./01
23456789:;<=>?@AB
CDEFGHIJKLMNOPQRSTU
!"#$%&
23456789:;<=>?@AB
CDEFGHIJKLMNOPQRS
!"#$%&
23456789:;<=>?@AB
CDEFGHIJKLMNOPQRS
!"#$%&
23456789:;<=>?@AB
CDEFGHIJKLMNOPQRS
!"#$%&
23456789:;<=>?@AB
CDEFGHIJKLMNOPQRS
!"#$%&
23456789:;<=>?@AB
CDEFGHIJKLMNOPQRS
 !"#$%&'()*+,-./01
23456789:;<=>?@AB
CDEFGHIJKLMNOPQRSTU
 !"#$%&'()*+,-./01
23456789:;<=>?@AB
CDEFGHIJKLMNOPQRSTU
 !"#$%&'()*+,-./01
23456789:;<=>?@AB
CDEFGHIJKLMNOPQRSTU
 !"#$%&'()*+,-./01
23456789:;<=>?@AB
CDEFGHIJKLMNOPQRSTU
 !"#$%&'()*+,-./01
23456789:;<=>?@AB
CDEFGHIJKLMNOPQRSTU
 !"#$%&'()*+,-./01
23456789:;<=>?@AB
CDEFGHIJKLMNOPQRSTU
!"#$%&
23456789:;<=>?@AB
CDEFGHIJKLMNOPQRS
!"#$%&
23456789:;<=>?@AB
CDEFGHIJKLMNOPQRS
&-ON.
xyz{|}~
 !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOP
RSTUVWXYZ[\]^_`abcdefghijkl
 !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOP
RSTUVWXYZ[\]^_`abcdefghijkl
 !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOP
RSTUVWXYZ[\]^_`abcdefghijkl
 !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOP
RSTUVWXYZ[\]^_`abcdefghijkl
 !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOP
RSTUVWXYZ[\]^_`abcdefghijkl
 !"#$%&'()*+,-./0123456789:;<=>
@ABCDEFGHIJKLMNOP
RSTUVWXYZ[\]^_`abcdefghijkl
 !"#$%&'()*+,-./0123456789:;<=>
@ABCDEFGHIJKLMNOP
RSTUVWXYZ[\]^_`abcdefghijkl
 !"#$%&'()*+,-./0123456789:;<=>
@ABCDEFGHIJKLMNOP
RSTUVWXYZ[\]^_`abcd
 !"#$%&'
./0123
@ABCDEFGHIJKLMNOP
RSTUVWXYZ[\]^_`ab
defghijkl
 !"#$%&'
./0123
@ABCDEFGHIJKLMNOP
RSTUVWXYZ[\]^_`ab
defghijkl
 !"#$%&'
./0123
@ABCDEFGHIJKLMNOP
RSTUVWXYZ[\]^_`ab
defghijkl
 !"#$%&'
./0123
@ABCDEFGHIJKLMNOP
RSTUVWXYZ[\]^_`ab
defghijkl
 !"#$%&'
./0123
@ABCDEFGHIJKLMNOP
RSTUVWXYZ[\]^_`ab
defghijkl
 !"#$%&'()*+,-./0123456789:;<=>
@ABCDEFGHIJKLMNOP
RSTUVWXYZ[\]^_`abcd
 !"#$%&'()*+,-./0123456789:;<=>
@ABCDEFGHIJKLMNOP
RSTUVWXYZ[\]^_`abcd
 !"#$%&'()*+,-./0123456789:;<=>
@ABCDEFGHIJKLMNOP
RSTUVWXYZ[\]^_`abcd
 !"#$%&'()*+,-./0123456789:;<=>
@ABCDEFGHIJKLMNOP
RSTUVWXYZ[\]^_`abcd
 !"#$%&'()*+,-./0123456789:;<=>
@ABCDEFGHIJKLMNOP
RSTUVWXYZ[\]^_`abcd
 !"#$%&'()*+,-./0123456789:;<=>
@ABCDEFGHIJKLMNOP
RSTUVWXYZ[\]^_`abcd
 !"#$%&'
./0123
@ABCDEFGHIJKLMNOP
RSTUVWXYZ[\]^_`ab
 !"#$%&'
./0123
@ABCDEFGHIJKLMNOP
RSTUVWXYZ[\]^_`ab
 !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
eikgof
,/27:<>@BDFW
KLNMPQRSTOJ
)*+.-01563489;=?ACE
YZ[wxy\]^_`abcdef
)\,(?%-*+++./S00189R232245666;<@WWW272QOAE2FFF222EGHEEE2 JJJ11D2KL222C222:222ZZZ&2MM#"NNNEEE! ^^EETT^^UUUTT2^VVVX^^^^^2Y2WWW^H^L^[ZZZ^^^^^]
B^^BBI^IIIPP
^^^^^^^^^^^^^^^^^^^^^^^^^^^^
&$"##!
!!!!!!!!
+0+++555++++++/ ///11
//////
222TTT
333EEE
EEGGNNGGGKKP
KKKNUUVV
PPPWWW
Z_____a
bbbcc^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
&2&]1
Q7Tbn5=
__^^^^^^^^^^^^^^^^
^^^`^^a^^^^^^^^^^^^^^^^b^^
2^^^^^`^^^^a^^++EEb/22^32c2^^^GK^22^^2^
^^^^^
define
undef
endif
error
pragma
extension
ifdef
ifndef
 !%&'()*+,-./01234
ActivityStoppedAutomatically
Microsoft.Web.Platform
IEXPLORE.EXE
MSFEEDSSYNC.EXE
SYSPREP.EXE
EXPLORER.EXE
LOADER42.EXE
WWAHOST.EXE
IEUTLAUNCH.EXE
TE.EXE
Te.ProcessHost.exe
FAKEVIRTUALSURFACETESTAPP.EXE
MSOOBE.EXE
NETPLWIZ.EXE
USERACCOUNTBROKER.EXE
MSHTMPAD.EXE
FirstLogonAnim.exe
RESTOREOPTIN.EXE
EMAIL.EXE
DCIScanner
microsoftedge.exe
microsoftedgecp.exe
microsoftedgebchost.exe
microsoftedgedevtools.exe
microsoftedgesh.exe
browser.exe
pickerhost.exe
browser_broker.exe
jshost.exe
authhost.exe
The current context doesn't support setting a non-zero divisor on the attribute with index zero. Please reorder the attributes in your vertex shader so that attribute zero can have a zero divisor.
gl::VertexAttribDivisorANGLE
Could not set thread local storage.
egl::`anonymous-namespace'::AllocateCurrentThread
HRESULT: 
Element value exceeds maximum element index.
Expected a program name, but found a shader name.
Expected a shader name, but found a program name.
Index exceeds MAX_DRAW_BUFFERS.
Vertex buffer is not big enough for the draw call
Draw mode must match current transform feedback object's draw mode.
Invalid framebuffer target.
Invalid renderbuffer internalformat.
Renderbuffer width and height cannot be negative and cannot exceed maximum texture size.
Shader object expected.
Buffer size does not align with data type.
Must have element array buffer binding.
Negative buffer size.
Primcount must be greater than or equal to zero.
Cannot have negative start.
At least one enabled attribute must have a divisor of zero.
The provided parameters overflow with the provided buffer.
The texture is a non-power-of-two texture.
An enabled vertex array has no buffer.
An enabled vertex array has no buffer and no pointer.
imageSize must be 0 if no texture data is provided.
imageSize must be at least 
sampler uniform value out of range
Index buffer is mapped.
No element array buffer and no pointer.
Invalid buffer value
Buffer value is greater than MAX_DRAW_BUFFERS
Ith value does not match COLOR_ATTACHMENTi or NONE
n must be 1 when GL is bound to the default framebuffer
Only NONE or BACK are valid values when drawing to the default framebuffer
GL_ANGLE_robust_client_memory is not available.
No defined conversion between clear value and attachment format.
Attempting to read from a multi-view framebuffer.
Pixel pack buffer is mapped.
display is EGL_NO_DISPLAY.
display is not a valid display.
display is not initialized.
display had a context loss
EGL_CONTEXT_OPENGL_RESET_NOTIFICATION_STRATEGY_KHR is not
 valid for GLES with EGL 1.4 and KHR_create_context. Use
 EXT_create_context_robustness.
Invalid Context attribute.
Attribute must be EGL_TRUE or EGL_FALSE.
Attribute EGL_CONTEXT_WEBGL_COMPATIBILITY_ANGLE requires EGL_ANGLE_create_context_webgl_compatibility.
EGL_CONTEXT_WEBGL_COMPATIBILITY_ANGLE must be EGL_TRUE or EGL_FALSE.
Attribute EGL_CONTEXT_BIND_GENERATES_RESOURCE_CHROMIUM requires EGL_CHROMIUM_create_context_bind_generates_resource.
EGL_CONTEXT_BIND_GENERATES_RESOURCE_CHROMIUM must be EGL_TRUE or EGL_FALSE.
Attribute EGL_DISPLAY_TEXTURE_SHARE_GROUP_ANGLE requires EGL_ANGLE_display_texture_share_group.
EGL_DISPLAY_TEXTURE_SHARE_GROUP_ANGLE must be EGL_TRUE or EGL_FALSE.
All contexts within a share group must be created with the same value of EGL_DISPLAY_TEXTURE_SHARE_GROUP_ANGLE.
Attribute EGL_CONTEXT_CLIENT_ARRAYS_ENABLED_ANGLE requires EGL_ANGLE_create_context_client_arrays.
EGL_CONTEXT_CLIENT_ARRAYS_ENABLED_ANGLE must be EGL_TRUE or EGL_FALSE.
Attribute EGL_CONTEXT_PROGRAM_BINARY_CACHE_ENABLED_ANGLE requires EGL_ANGLE_program_cache_control.
EGL_CONTEXT_PROGRAM_BINARY_CACHE_ENABLED_ANGLE must be EGL_TRUE or EGL_FALSE.
Attribute EGL_ROBUST_RESOURCE_INITIALIZATION_ANGLE requires EGL_ANGLE_robust_resource_initialization.
EGL_ROBUST_RESOURCE_INITIALIZATION_ANGLE must be either EGL_TRUE or EGL_FALSE.
Requested GLES version is not supported.
If ctx is EGL_NO_CONTEXT, surfaces must be EGL_NO_SURFACE
If ctx is not EGL_NOT_CONTEXT, draw or read must both be EGL_NO_SURFACE, or both not
If ctx is not EGL_NO_CONTEXT, surfaces must not be EGL_NO_SURFACE
read and draw must both be valid surfaces, or both be EGL_NO_SURFACE
'dpy' not a valid EGLDisplay handle
'dpy' not initialized
Color buffer types are not compatible.
Color buffer sizes are not compatible.
Color buffer component types are not compatible.
Depth-stencil buffer types are not compatible.
Surface types are not compatible.
Invalid attrib_list parameter
D3D11 device creation extension not active
Invalid device_type parameter
Invalid device parameter
Device must have been created using eglCreateDevice
Texture is null
num_config cannot be null.
GPU.ANGLE.DisplayInitializeMS
ANGLE Display::initialize error 
angle::DestroyThenDelete<class gl::Context,class egl::Display>::operator ()
egl::SurfaceDeleter::operator ()
Failed to allocate internal buffer.
Microsoft
Compressed texture dimensions must exactly match the dimensions of the data passed in.
Index exceeds program active uniform count.
Texture format does not support mipmap generation.
Invalid blend function.
Invalid mask bits.
CONSTANT_COLOR (or ONE_MINUS_CONSTANT_COLOR) and CONSTANT_ALPHA (or ONE_MINUS_CONSTANT_ALPHA) cannot be used together as source and destination factors in the blend function.
Near value cannot be greater than far.
Name contains invalid characters.
Invalid stencil.
Invalid width.
Attributes that begin with 'gl_' are not allowed.
Cannot have negative stride.
Object cannot be used because it has not been generated.
Shader attachment already has a shader.
Shader to be detached must be currently attached to the program.
Shader source contains invalid characters.
The specified dimensions are outside of the bounds of the texture.
Viewport size cannot be negative.
Attributes that begin with 'webgl_', or '_webgl_' are not allowed.
Location lengths must not be greater than 1024 characters.
Location name lengths must not be greater than 256 characters.
Extension not supported.
GL_CHROMIUM_copy_texture extension not available.
Source texture a valid texture type.
Source texture is not a valid texture object.
Source texture internal format is invalid.
Source texture level is not valid.
Destination texture a valid texture type.
Destination texture is not a valid texture object.
Destination texture is immutable.
Destination width and height must be equal for cube map textures.
x and y cannot be negative.
The source level of the source texture must be defined.
The destination level of the destination texture must be defined.
Destination texture level is not valid.
Destination texture not large enough to copy to.
Destination internal format and type combination is not valid.
Extension 
GL_ANGLE_request_extension is not available.
Simultaneous use of GL_CONSTANT_ALPHA/GL_ONE_MINUS_CONSTANT_ALPHA and GL_CONSTANT_COLOR/GL_ONE_MINUS_CONSTANT_COLOR not supported by this implementation.
 is not requestable.
stride cannot be greater than MAX_VERTEX_ATTRIB_STRIDE.
gl::ValidateBlendFuncSeparate
Client data cannot be used with a non-default vertex array object.
index must be smaller than MAX_VERTEX_ATTRIB_BINDINGS.
GL_FIXED is not supported in WebGL.
gl::ValidateEnable
Current renderer doesn't support alpha-to-coverage
Cannot link program while program is associated with an active transform feedback object.
Cannot change active program while transform feedback is unpaused.
Invalid combination of format, type and internalFormat.
Format cannot be GL_DEPTH_COMPONENT or GL_DEPTH_STENCIL if target is GL_TEXTURE_3D
Unsupported internal format.
gl::Shader::resolveCompile
GPU.ANGLE.ProgramCache.LoadBinarySuccess
GPU.ANGLE.ProgramCache.ProgramCacheHitTimeUS
Work group size is not specified.
Attached compute shader is not compiled.
Fragment varying 
 conflicts with 
Matrix packings for 
Binding for fragment input 
Active attribute (
) at location 
Too many vertex attributes.
' aliases attribute '
' at location 
 is too big to fit
Compute shader shader storage block count exceeds GL_MAX_COMPUTE_SHADER_STORAGE_BLOCKS (
Compute shader uniform block count exceeds GL_MAX_COMPUTE_UNIFORM_BLOCKS (
Fragment shader shader storage block count exceeds GL_MAX_FRAGMENT_SHADER_STORAGE_BLOCKS (
Types for interface block '
Vertex shader shader storage block count exceeds GL_MAX_VERTEX_SHADER_STORAGE_BLOCKS (
' between vertex and fragment shaders
' differ between vertex and fragment shaders
Array sizes differ for interface block '
': (in vertex: '
', in fragment: '
Name mismatch for field 
 of interface block '
' member '
interface block '
Precisions for 
Structure names for 
Array sizes for 
: (in vertex: '
Invariance for 
 differs between vertex and fragment shaders.
Interpolation types for 
 differ between vertex and fragment shaders.
Two transform feedback varyings specify the same output variable (
Transform feedback varying's 
 does not exist in the vertex shader.
Transform feedback varying total components (
Capture of array elements is undefined and not supported.
Transform feedback varying 
) exceed the maximum interleaved components (
Name conflicts between a uniform and an attribute: 
Cannot load program binaries across different ES context versions.
Invalid program binary version.
d0cdd066eca2
Failed to load binary from cache: 
gl::MemoryProgramCache::Serialize
Saving program binary with transform feedback, which is not supported on this driver.
GPU.ANGLE.ProgramCache.ProgramBinarySizeBytes
GPU.ANGLE.ProgramCache.CacheResult
Reaching warning limit for cache load failures, silencing subsequent warnings.
gl::MemoryProgramCache::getProgram
gl::MemoryProgramCache::putProgram
Failed to store binary program in memory cache, program is too large.
gl::Compiler::~Compiler
Binding layout qualifiers for 
Compute shader atomic counter count exceeds MAX_COMPUTE_ATOMIC_COUNTERS (
Multiple uniforms bound to location 
Offset layout qualifiers for 
Location layout qualifiers for 
Compute shader active uniforms exceed MAX_COMPUTE_UNIFORM_COMPONENTS (
Compute shader sampler count exceeds MAX_COMPUTE_TEXTURE_IMAGE_UNITS (
Compute shader image count exceeds MAX_COMPUTE_IMAGE_UNIFORMS (
atomic counter count exceeds MAX_COMBINED_ATOMIC_COUNTERS
Could not pack varying 
Invalid D3D device passed into EGLDeviceEXT
rx::SurfaceD3D::SurfaceD3D
Invalid program binary, device configuration has changed.
Mismatched compilation flags.
Invalid program binary.
COLOR
Error compiling dynamic pixel executable:
rx::ProgramD3D::getPixelExecutableForCachedOutputLayout
Error compiling dynamic vertex executable:
rx::ProgramD3D::getVertexExecutableForCachedInputLayout
Could not create vertex shader.
Could not create pixel shader.
Could not create geometry shader.
Error compiling dynamic compute executable:
rx::ProgramD3D::compileComputeExecutable
Failed to create D3D compute shader.
The current renderer doesn't support gl_FrontFacing
// GEOMETRY SHADER BEGIN
GEOMETRY SHADER END
Failed to create D3D shaders.
PSIZE
float2x2
float3x3
float4x4
float2x3
float4x3
float3x2
float2x4
float4x2
float3x4
    float3 spriteVertexPos : SPRITEPOSITION0;
    float2 spriteTexCoord : SPRITETEXCOORD0;
 uint
SV_InstanceID
SV_VertexID
DEPTH
    float4 gl_FragCoord : 
    float2 gl_PointCoord : 
    float gl_Depth : 
    output.gl_Depth = gl_Depth; 
    nointerpolation 
    centroid 
    float gl_PointSize : 
    nointerpolation uint gl_ViewID_OVR : 
    nointerpolation uint gl_ViewportIndex : 
    nointerpolation uint gl_Layer : 
static float maxPointSize = 
static float minPointSize = 
         output.gl_Layer = _ViewID_OVR;
         output.gl_ViewportIndex = 0;
    } else {
         output.gl_ViewportIndex = _ViewID_OVR;
    output.gl_ViewID_OVR = _ViewID_OVR;
    }
    output.dx_Position.x = gl_Position.x * dx_ViewAdjust.z + dx_ViewAdjust.x * gl_Position.w;
    {
    if (multiviewSelectViewportIndex)
    output.dx_Position.y = dx_ViewScale.y * gl_Position.y;
    gl_PointSize = clamp(gl_PointSize, minPointSize, maxPointSize);
    output.dx_Position.x += (input.spriteVertexPos.x * gl_PointSize / (dx_ViewCoords.x*2)) * output.dx_Position.w;
    output.dx_Position.y += (-dx_ViewScale.y * input.spriteVertexPos.y * gl_PointSize / (dx_ViewCoords.y*2)) * output.dx_Position.w;
    output.dx_Position.y = dx_ViewScale.y * (gl_Position.y * dx_ViewAdjust.w + dx_ViewAdjust.y * gl_Position.w);
    output.dx_Position.y = -(gl_Position.y * dx_ViewAdjust.w + dx_ViewAdjust.y * gl_Position.w);
    output.gl_PointSize = gl_PointSize;
    output.gl_FragCoord = gl_Position;
PS_OUTPUT main(PS_INPUT input, bool isFrontFace : SV_IsFrontFace)
PS_OUTPUT main(PS_INPUT input, float vFace : VFACE)
    output.dx_Position.y += (input.spriteVertexPos.y * gl_PointSize / (dx_ViewCoords.y*2)) * output.dx_Position.w;
    output.dx_Position.z += input.spriteVertexPos.z * output.dx_Position.w;
    output.gl_PointCoord = input.spriteTexCoord;
    output.gl_PointCoord = float2(0.5, 0.5);
    gl_FragCoord.x = input.dx_Position.x;
    gl_FragCoord.y = input.dx_Position.y + 0.5;
    gl_FragCoord.x = input.dx_Position.x + 0.5;
    gl_FragCoord.y = (input.gl_FragCoord.y * rhw) * dx_ViewCoords.y + dx_ViewCoords.w;
    _ViewID_OVR = input.gl_ViewID_OVR;
    float rhw = 1.0 / input.gl_FragCoord.w;
    gl_FragCoord.y = input.dx_Position.y;
    gl_PointCoord.y = 1.0 - input.gl_PointCoord.y;
    gl_PointCoord.x = input.gl_PointCoord.x;
    gl_FrontFacing = (vFace * dx_DepthFront.z >= 0.0);
    gl_FrontFacing = isFrontFace;
    gl_FragCoord.x = (input.gl_FragCoord.x * rhw) * dx_ViewCoords.x + dx_ViewCoords.z;
    gl_FragCoord.y = (1.0f + dx_ViewScale.y) * gl_FragCoord.y /(1.0f - input.gl_FragCoord.y * rhw)  - dx_ViewScale.y * gl_FragCoord.y;
    gl_FragCoord.w = rhw;
    gl_FragCoord.z = (input.gl_FragCoord.z * rhw) * dx_DepthFront.x + dx_DepthFront.y;
GL_USES_WORK_GROUP_ID
GL_USES_LOCAL_INVOCATION_ID
GL_USES_GLOBAL_INVOCATION_ID
SV_GroupThreadID;
    uint3 dx_LocalInvocationID : 
SV_DispatchThreadID;
    uint3 dx_GlobalInvocationID : 
GL_USES_LOCAL_INVOCATION_INDEX
struct CS_INPUT
SV_GroupID;
    uint3 dx_WorkGroupID : 
[numthreads(
void main(CS_INPUT input)
    gl_WorkGroupID = input.dx_WorkGroupID;
SV_GroupIndex;
    uint dx_LocalInvocationIndex : 
    output.gl_PointSize = input.gl_PointSize;
    gl_LocalInvocationID = input.dx_LocalInvocationID;
    gl_GlobalInvocationID = input.dx_GlobalInvocationID;
    gl_LocalInvocationIndex = input.dx_LocalInvocationIndex;
    output.gl_FragCoord = input.gl_FragCoord;
    output.gl_ViewID_OVR = input.gl_ViewID_OVR;
    output.gl_Layer = input.gl_Layer;
    output.gl_ViewportIndex = input.gl_ViewportIndex;
        output.gl_ViewportIndex = input.gl_ViewID_OVR;
void selectView(inout GS_OUTPUT output, GS_INPUT input)
        output.gl_Layer = input.gl_ViewID_OVR;
        output.gl_ViewportIndex = 0;
transpose(input.
(input.
SV_ViewportArrayIndex
SV_RenderTargetArrayIndex
rx::FramebufferD3D::getColorAttachmentsForRender
COMPUTE
 SHADER END
Renderer11::initialize (ComQueries)
Renderer11::initialize (HideWarnings)
Inputted D3D11 device has been lost.
GPU.ANGLE.Renderer11InitializeDeviceMS
Could not query DXGI device.
Could not retrieve DXGI adapter
Could not read DXGI adaptor description.
Could not create DXGI factory.
Error querying driver version from DXGI Adapter.
rx::Renderer11::populateRenderer11DeviceCaps
Failed to get event query data, 
Device was lost while waiting for sync.
Renderer11::initializeDevice
Error initializing state manager.
NULL share handle.
Failed to open share handle, 
Failed to query ID3D11Texture2D object from share handle.
Invalid texture parameters in share handle texture.
rx::Renderer11::testDeviceLost
Failed to create a 32-bit looping index buffer for GL_LINE_LOOP, too many indices required.
Failed to create a scratch index buffer for GL_TRIANGLE_FAN, too many indices required.
The D3D11 device was removed, 
Failed to retrieve the internal read render target from the read framebuffer.
New vertex buffer size would result in an overflow.
Failed to map D3D11 resource.
avoid flow control
Failed to retrieve the internal draw render target from the draw framebuffer.
-Failed to resize EmulatedIndexedStorage
Failed to resize SystemMemoryStorage
Failed to resize internal buffer storage.
Failed to allocate mappable internal buffer.
Error resizing buffer in Buffer11::EmulatedIndexedStorage::getBuffer
Error resizing index memory buffer in Buffer11::EmulatedIndexedStorage::getBuffer
rx::`anonymous-namespace'::UpdateCachedRenderTarget
Internal rendertarget error: 
rx::Context11::triggerDrawCallProgramRecompilation
Dynamic recompilation error log: 
rx::Context11::onMakeCurrent
It is undefined behaviour to clear a render buffer which is not normalized fixed point or floating-point to floating point values (color attachment 
 has internal format 
rx::Clear11::clearFramebuffer
?333?
?ComputeShader
Buffer
DepthStencilView
DepthStencilState
BlendState
RenderTargetView
RasterizerState
ShaderResourceView
InputLayout
GeometryShader
Query
PixelShader
Texture3D
Texture2D
VertexShader
Error allocating 
Index buffer map range is not inside the buffer.
Internal index buffer is not initialized.
Internal blit shader type mismatch
Swizzle shader type not found
Sampler
TextureF
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
ISGNP
SV_POSITION
TEXCOORD
OSGN,
SV_TARGET
STATt
RDEFx
TextureUI
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
SV_POSITION
SV_RENDERTARGETARRAYINDEX
TEXCOORD
OSGN,
SV_TARGET
STATt
STATt
Sampler
TextureF
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
ISGNP
SV_POSITION
TEXCOORD
OSGN,
SV_TARGET
Sampler
TextureF
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
SV_POSITION
SV_RENDERTARGETARRAYINDEX
TEXCOORD
OSGN,
SV_TARGET
STATt
<PJ*Ax
RDEF(
Sampler
TextureF3D
SwizzleProperties
SwizzleIndices
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
SV_POSITION
SV_RENDERTARGETARRAYINDEX
TEXCOORD
OSGN,
SV_TARGET
STATt
DXBCu
Sampler
TextureF
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
SV_POSITION
SV_RENDERTARGETARRAYINDEX
TEXCOORD
OSGN,
SV_TARGET
STATt
Sampler
TextureF
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
SV_POSITION
SV_RENDERTARGETARRAYINDEX
TEXCOORD
OSGN,
SV_TARGET
STATt
RDEFx
TextureUI
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
ISGNP
SV_POSITION
TEXCOORD
OSGN,
SV_TARGET
STATt
Sampler
TextureF
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
ISGNP
SV_POSITION
TEXCOORD
OSGN,
SV_TARGET
STATt
RDEFx
TextureI
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
ISGNP
SV_POSITION
TEXCOORD
OSGN,
SV_TARGET
STATt
DXBC0Ta
TextureI3D
SwizzleProperties
SwizzleIndices
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
SV_POSITION
SV_RENDERTARGETARRAYINDEX
TEXCOORD
OSGN,
SV_TARGET
SHDRL
STATt
TextureI2D
SwizzleProperties
SwizzleIndices
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
ISGNP
SV_POSITION
TEXCOORD
OSGN,
SV_TARGET
SHDRX
STATt
Aon9p
STATt
Sampler
TextureF
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
ISGNP
SV_POSITION
TEXCOORD
OSGN,
SV_TARGET
Sampler
TextureF
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
ISGNP
SV_POSITION
TEXCOORD
OSGN,
SV_TARGET
SHDR@
STATt
RDEF(
Sampler
TextureF2D
SwizzleProperties
SwizzleIndices
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
ISGNP
SV_POSITION
TEXCOORD
OSGN,
SV_TARGET
STATt
Sampler
TextureF
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
ISGNP
SV_POSITION
TEXCOORD
OSGN,
SV_TARGET
STATt
>m^-|
RDEFx
TextureUI
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
ISGNP
SV_POSITION
TEXCOORD
OSGN,
SV_TARGET
STATt
TextureUI3D
SwizzleProperties
SwizzleIndices
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
SV_POSITION
SV_RENDERTARGETARRAYINDEX
TEXCOORD
OSGN,
SV_TARGET
SHDRL
STATt
Sampler
TextureF
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
ISGNP
SV_POSITION
TEXCOORD
OSGN,
SV_TARGET
STATt
DXBCl
Sampler
TextureF
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
ISGNP
SV_POSITION
TEXCOORD
OSGN,
SV_TARGET
STATt
RDEFx
TextureI
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
SV_POSITION
SV_RENDERTARGETARRAYINDEX
TEXCOORD
OSGN,
SV_TARGET
STATt
DXBC(H
Sampler
TextureF
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
ISGNP
SV_POSITION
TEXCOORD
OSGN,
SV_TARGET
STATt
TextureUI2DArray
SwizzleProperties
SwizzleIndices
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
SV_POSITION
SV_RENDERTARGETARRAYINDEX
TEXCOORD
OSGN,
SV_TARGET
SHDRp
STATt
DXBC'
RDEF,
Sampler
TextureF2DArray
SwizzleProperties
SwizzleIndices
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
SV_POSITION
SV_RENDERTARGETARRAYINDEX
TEXCOORD
OSGN,
SV_TARGET
SHDR$
STATt
DXBC+
Sampler
TextureF
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
ISGNP
SV_POSITION
TEXCOORD
OSGN,
SV_TARGET
STATt
DXBC%8+
2VL=N
RDEFx
TextureUI
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
SV_POSITION
SV_RENDERTARGETARRAYINDEX
TEXCOORD
OSGN,
SV_TARGET
STATt
RDEFx
TextureUI
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
ISGNP
SV_POSITION
TEXCOORD
OSGN,
SV_TARGET
STATt
DXBC@}n
Sampler
TextureF
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
ISGNP
SV_POSITION
TEXCOORD
OSGN,
SV_TARGET
STATt
RDEFx
TextureI
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
SV_POSITION
SV_RENDERTARGETARRAYINDEX
TEXCOORD
OSGN,
SV_TARGET
STATt
DXBCR
Sampler
TextureF
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
ISGNP
SV_POSITION
TEXCOORD
OSGN,
SV_TARGET
STATt
Sampler
TextureF
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
SV_POSITION
SV_RENDERTARGETARRAYINDEX
TEXCOORD
OSGN,
SV_TARGET
STATt
Sampler
TextureF
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
ISGNP
SV_POSITION
TEXCOORD
OSGN,
SV_TARGET
SHDR,
STATt
DXBCY{
RDEFx
TextureI
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
ISGNP
SV_POSITION
TEXCOORD
OSGN,
SV_TARGET
STATt
STATt
Sampler
TextureF
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
ISGNP
SV_POSITION
TEXCOORD
OSGN,
SV_TARGET
Sampler
TextureF
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
ISGNP
SV_POSITION
TEXCOORD
OSGN,
SV_TARGET
SHDR,
STATt
Sampler
TextureF
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
SV_POSITION
SV_RENDERTARGETARRAYINDEX
TEXCOORD
OSGN,
SV_TARGET
STATt
Sampler
TextureF
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
SV_POSITION
SV_RENDERTARGETARRAYINDEX
TEXCOORD
OSGN,
SV_TARGET
SHDRd
STATt
Sampler
TextureF
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
ISGNP
SV_POSITION
TEXCOORD
OSGN,
SV_TARGET
STATt
Sampler
TextureF
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
ISGNP
SV_POSITION
TEXCOORD
OSGN,
SV_TARGET
STATt
STATt
Sampler
TextureF
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
ISGNP
SV_POSITION
TEXCOORD
OSGN,
SV_TARGET
TextureUI2D
SwizzleProperties
SwizzleIndices
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
ISGNP
SV_POSITION
TEXCOORD
OSGN,
SV_TARGET
SHDRX
STATt
DXBC>w=
S*P}y
RDEFx
TextureI
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
SV_POSITION
SV_RENDERTARGETARRAYINDEX
TEXCOORD
OSGN,
SV_TARGET
STATt
RDEFx
TextureUI
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
SV_POSITION
SV_RENDERTARGETARRAYINDEX
TEXCOORD
OSGN,
SV_TARGET
STATt
DXBCQ
RDEFx
TextureI
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
ISGNP
SV_POSITION
TEXCOORD
OSGN,
SV_TARGET
STATt
DXBCa
Sampler
TextureF
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
ISGNP
SV_POSITION
TEXCOORD
OSGN,
SV_TARGET
STATt
Sampler
TextureF
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
ISGNP
SV_POSITION
TEXCOORD
OSGN,
SV_TARGET
STATt
STATt
Sampler
TextureF
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
ISGNP
SV_POSITION
TEXCOORD
OSGN,
SV_TARGET
DXBC3Z1
STATt
Sampler
TextureF
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
ISGNP
SV_POSITION
TEXCOORD
OSGN,
SV_TARGET
RDEFx
TextureI
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
SV_POSITION
SV_RENDERTARGETARRAYINDEX
TEXCOORD
OSGN,
SV_TARGET
STATt
Sampler
TextureF
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
ISGNP
SV_POSITION
TEXCOORD
OSGN,
SV_TARGET
STATt
DXBC=
Sampler
TextureF
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
ISGNP
SV_POSITION
TEXCOORD
OSGN,
SV_TARGET
STATt
Sampler
TextureF
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
ISGNP
SV_POSITION
TEXCOORD
OSGN,
SV_TARGET
STATt
DXBCE
RDEFx
TextureUI
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
SV_POSITION
SV_RENDERTARGETARRAYINDEX
TEXCOORD
OSGN,
SV_TARGET
STATt
RDEFx
TextureUI
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
ISGNP
SV_POSITION
TEXCOORD
OSGN,
SV_TARGET
STATt
DXBCi
STATt
Sampler
TextureF
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
ISGNP
SV_POSITION
TEXCOORD
OSGN,
SV_TARGET
DXBC{
RDEFx
TextureI
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
ISGNP
SV_POSITION
TEXCOORD
OSGN,
SV_TARGET
STATt
Sampler
TextureF
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
ISGNP
SV_POSITION
TEXCOORD
OSGN,
SV_TARGET
STATt
STATt
Sampler
TextureF
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
ISGNP
SV_POSITION
TEXCOORD
OSGN,
SV_TARGET
DXBCU=<$!
TextureI2DArray
SwizzleProperties
SwizzleIndices
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
SV_POSITION
SV_RENDERTARGETARRAYINDEX
TEXCOORD
OSGN,
SV_TARGET
SHDRp
STATt
STATt
Sampler
TextureF
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
ISGNP
SV_POSITION
TEXCOORD
OSGN,
SV_TARGET
DXBCO
RDEFP
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
ISGNl
SV_Position
TEXCOORD
LAYER
SV_Position
TEXCOORD
SV_RenderTargetArrayIndex
STATt
RDEFP
Buffer4F
BufferCopyParams
FirstPixelOffset
PixelsPerRow
RowStride
RowsPerSlice
PositionOffset
PositionScale
TexLocationOffset
TexLocationScale
FirstSlice
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
ISGNP
SV_Position
TEXCOORD
OSGN,
SV_Target
SHDR`
STATt
RDEFx
Buffer4UI
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
ISGNP
SV_Position
TEXCOORD
OSGN,
SV_Target
SHDRP
STATt
DXBC'
RDEF(
BufferCopyParams
FirstPixelOffset
PixelsPerRow
RowStride
RowsPerSlice
PositionOffset
PositionScale
TexLocationOffset
TexLocationScale
FirstSlice
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
ISGN,
SV_VertexID
OSGNl
SV_Position
TEXCOORD
LAYER
STATt
RDEFx
Buffer4I
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
ISGNP
SV_Position
TEXCOORD
OSGN,
SV_Target
SHDRP
STATt
Width or height < 1
rx::StreamProducerD3DTexture::getGLFrameDescription
Unsupported format
NV12 tetxures must have even width and height.
Texture not created on ANGLE D3D device
Plane out of range
d3d11.dll
D3D11CreateDevice
Internal vertex buffer is not initialized.
SwapChain11::resetOffscreenTexture
Could not create depthstencil surface for new swap chain, 
Could not get offscreen texture shared handle, 
Could not query offscreen texture resource, 
Could not create offscreen texture, 
rx::SwapChain11::resetOffscreenColorBuffer
rx::SwapChain11::resize
Error resizing swap chain buffers, 
SwapChain11::resize
Error reading swap chain description, 
rx::SwapChain11::resetOffscreenDepthBuffer
SwapChain11::initPassThroughResources
Could not create additional swap chains or offscreen surfaces, 
rx::SwapChain11::reset
SwapChain11::reset
Present failed: the D3D11 device was removed, 
rx::SwapChain11::present
Failed to get frame statistics, 
Swap chain uninitialized
Present failed: the D3D11 device was reset from a bad command.
Present failed with 
STATt
RDEFP
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
ISGNL
POSITION
TEXCOORD
OSGNP
SV_POSITION
TEXCOORD
Aon9d
SHDRd
STATt
Sampler
TextureF
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
ISGNP
SV_POSITION
TEXCOORD
OSGN,
SV_TARGET
RDEF|
TextureF_MS
Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
ISGNt
SV_POSITION
TEXCORD
SV_SAMPLEINDEX
OSGN,
SV_TARGET
STATt
Overflowed the 
angle::TrimCache
 elements, removing the least recently used to make room.
 cache limit of 
Device was lost while querying result of an event query.
Failed to get query data, 
Failed to create event query, 
SPRITEPOSITION
SPRITETEXCOORD
Invalid value.
Not initialized.
Bad access.
Invalid framebuffer operation.
Stack underflow.
Out of memory.
Invalid operation.
Stack overflow.
Bad match.
Bad native window.
Bad current surface.
Bad display.
Bad config.
Bad context.
Bad allocation.
Bad attribute.
Bad state.
Bad device.
Context lost.
Bad stream.
Bad parameter.
Bad surface.
too many uniforms
Precision emulation not supported for this output type.
unsupported shader version
) with the following call chain: 
Function has too many parameters.
Expression too complex.
Missing main()
Call stack too deep (larger than 
angle_return
false
// Array constructor functions
// Assignment functions
// Equality functions
 out_
#define ANGLE_REQUIRES_IEEE_STRICT_COMPILING
#define ANGLE_USES_NESTED_BREAK
    float3 dx_DepthRange : packoffset(c0);
struct gl_DepthRangeParameters
    float near;
    float far;
    float diff;
static bool gl_FrontFacing = false;
static float2 gl_PointCoord = float2(0.5, 0.5);
static float4 gl_FragCoord = float4(0, 0, 0, 0);
static float gl_Depth = 0.0;
#define GL_USES_MRT
// Structures from std140 blocks with padding removed
static gl_DepthRangeParameters gl_DepthRange = {dx_DepthRange.x, dx_DepthRange.y, dx_DepthRange.z};
uniform float3 dx_DepthFront : register(c2);
uniform float4 dx_ViewCoords : register(c1);
uniform float3 dx_DepthRange : register(c0);
    float3 dx_DepthFront : packoffset(c2);
static int gl_VertexID;
static int gl_InstanceID;
static float gl_PointSize = float(1);
#define GL_USES_FRAG_DATA
    uint3 gl_NumWorkGroups : packoffset(c0);
uniform float2 dx_ViewCoords : register(c2);
uniform float4 dx_ViewAdjust : register(c1);
uniform float3 dx_DepthRange : register(c0);
#define GL_USES_POINT_SIZE
#define GL_USES_FRONT_FACING
#define GL_USES_POINT_COORD
#define GL_USES_FRAG_COORD
static uint gl_LocalInvocationIndex = uint(0);
static uint3 gl_GlobalInvocationID = uint3(0, 0, 0);
static uint3 gl_LocalInvocationID = uint3(0, 0, 0);
static uint3 gl_WorkGroupID = uint3(0, 0, 0);
#define GL_USES_GLOBAL_INVOCATION_ID
#define GL_USES_LOCAL_INVOCATION_ID
#define GL_USES_WORK_GROUP_ID
#define GL_USES_NUM_WORK_GROUPS
#define GL_USES_DEPTH_RANGE
#define GL_USES_FRAG_DEPTH
#define GL_USES_VIEW_ID
#define GL_ANGLE_MULTIVIEW_ENABLED
gl_Depth
bool xor(bool p, bool q)
    return (p || q) && !(p && q);
#define GL_USES_LOCAL_INVOCATION_INDEX
case (
switch (
FLATTEN 
while (
 for(
default:
bool Break
{int 
 = true; break;}
{Break
#line 
if (!Break
 = false;
, const uint 
 texture_
 sampler_
const uint 
angle_eq
    return 
bool 
angle_eq_
angle_assign
) { return false; }
    }
    return true;
; ++i)
    {
        if (
    for (int i = 0; i < 
angle_construct_into
    }
; ++i)
    {
        
(out 
void 
angle_frm
angle_frl
 angle_compound_
_frm(inout 
 x, in 
 y) {
    x = angle_frm(angle_frm(x) 
    return x;
_frl(inout 
 v) {
    v = clamp(v, -65504.0, 65504.0);
 exponent = floor(log2(abs(v) + 1e-30)) - 10.0;
    bvec
 isNonZero = greaterThanEqual(exponent, vec
(-25.0));
    v = v * exp2(-exponent);
    v = sign(v) * floor(abs(v));
    return v * exp2(exponent) * vec
(isNonZero);
 v) {
    v = clamp(v, -2.0, 2.0);
    v = v * 256.0;
    v = sign(v) * floor(abs(v));
    return v * 0.00390625;
 y) {
    x = angle_frl(angle_frl(x) 
highp 
 angle_frm(in 
 x) {
    x = clamp(x, -65504.0, 65504.0);
 exponent = floor(log2(abs(x) + 1e-30)) - 10.0;
    bool isNonZero = (exponent >= -25.0);
    x = x * exp2(-exponent);
    x = sign(x) * floor(abs(x));
    return x * exp2(exponent) * float(isNonZero);
 angle_frl(in 
 x) {
    x = clamp(x, -2.0, 2.0);
    x = x * 256.0;
    x = sign(x) * floor(abs(x));
    return x * 0.00390625;
mat2x3
 m) {
 rounded;
    rounded[
    return rounded;
)(isNonZero);
 angle_frl(
angle_compound_
mat2x4
mat3x2
mat3x4
mat4x2
mat4x3
 angle_frm(
 exponent = floor(log2(abs(v) + 1e-30)) - 10.0;
    bool
 isNonZero = exponent < -25.0;
    v = v * exp2(-exponent);
    v = sign(v) * floor(abs(v));
    return v * exp2(exponent) * (float
value
Performance: dynamic indexing of vectors and matrices is emulated and can be slow.
dyn_index_
write_
Invalid type for loop index
Loop index cannot be initialized with non-constant expression
Loop index cannot be statically assigned to within the body of the loop
while
This type of loop is not allowed
Missing init declaration
Invalid init declaration
Index expression must be constant
itu_601
itu_601_full_range
itu_709
move second child to first child
initialize first child with second child
add second child into first child
subtract second child into first child
multiply second child into first child
matrix mult second child into first child
vector scale second child into first child
matrix scale second child into first child
 (internal function)
 (symbol id 
(symbol id 
vector swizzle (
comma
indirect index
direct index for structure
direct index for interface block
subtract
component-wise multiply
divide
modulo
bit-wise shift left
divide second child into first child
modulo second child into first child
bit-wise shift first child left by second child
bit-wise shift first child right by second child
bit-wise and second child into first child
bit-wise xor second child into first child
bit-wise or second child into first child
direct index
Compare Less Than or Equal
Compare Greater Than or Equal
vector-scale
vector-times-matrix
matrix-times-vector
matrix-scale
matrix-multiply
logical-or
bit-wise shift right
bit-wise and
bit-wise xor
bit-wise or
Compare Equal
Compare Not Equal
Compare Less Than
Compare Greater Than
Post-Increment
Post-Decrement
Pre-Increment
Pre-Decrement
Array length
component-wise not
Function Definition:
Invariant Declaration:
logical-xor
logical-and
<unknown op>
 (field '
Negate value
Positive sign
negation
bit-wise not
component-wise less than
component-wise greater than
component-wise less than or equal
component-wise greater than or equal
dot product
cross product
Code block
Declaration
Function Prototype
node is still EOpNull!
Call an user-defined function
Call an internal function with raw implementation
Call a built-in function
Construct
component-wise equal
component-wise not equal
const bool
 (const float)
 (const int)
 (const uint)
 (const yuvCscStandardEXT)
Unknown constant
Loop with condition 
Ternary selection
Condition
true case
false case
If test
true case is null
Switch
Default
Branch: Break
Branch: Continue
Branch: Return
Branch: Unknown Branch
 with expression
tested first
Loop Condition
No loop condition
Loop Body
No loop body
Loop Terminal Expression
Branch: Kill
highp
mediump
local_size_y
local_size_z
Temporary
Global
local_size_x
FragCoord
FrontFacing
PointCoord
FragColor
FragData
FragDepth
SecondaryFragColorEXT
SecondaryFragDataEXT
buffer
VertexID
Position
PointSize
smooth in
flat in
smooth centroid in
centroid
smooth
shared
NumWorkGroups
WorkGroupSize
ViewIDOVR
ViewportIndex
Layer
LastFragColor
LastFragData
smooth out
smooth centroid out
flat out
mp_unspecified
row_major
column_major
bs_unspecified
packed
std140
WorkGroupID
LocalInvocationID
GlobalInvocationID
LocalInvocationIndex
readonly
writeonly
rgba32i
rgba16i
rgba8i
rgba8
rgba8_snorm
points
rgba32f
rgba16f
rgba32ui
rgba16ui
rgba8ui
r32ui
layout
lines
triangles
lines_adjacency
triangles_adjacency
line_strip
triangle_strip
' exists that takes an operand of type 
wrong operand type - no operation '
' (or there is no acceptable conversion)
' and a right operand of type '
' exists that takes a left-hand operand of type '
wrong operand types - no operation '
illegal vector field selection
illegal - vector component fields not from the same set
' to '
cannot convert from '
 (or there is no acceptable conversion)
constant expression required
cannot convert a variable with writeonly
cannot convert a void
array constructor needs one argument per array element
constructing from a non-dereferenced array
Array constructor argument has an incorrect type
Number of constructor parameters does not match the number of structure fields
Structure constructor arguments do not match structure fields
a struct cannot be used as a constructor argument for this type
integer expression required
only allowed at global scope
reserved built-in name
identifiers containing two consecutive underscores (__) are reserved as possible future keywords
constructor
constructor does not have any arguments
cannot convert a variable with type 
opaque types cannot be output parameters
array size must be a constant integer expression
array size must be non-negative
array size must be greater than zero
array size too large
constructing matrix from matrix can only take one argument
not enough data provided for construction
too many arguments
illegal use of type 'void'
boolean expression expected
 (structure contains a sampler)
redeclaration of gl_LastFragData as an array of arrays
redeclaration of gl_LastFragData with size != gl_MaxDrawBuffers
redefinition
Shared memory declarations cannot have layout specified
layout qualifier only valid for interface blocks
invalid layout qualifier combination
storage qualifier supported in GLSL ES 3.00 and above only
cannot declare arrays of this qualifier
cannot declare arrays of arrays
cannot declare arrays of structs of this qualifier
structures containing arrays may not be declared constant since they cannot be initialized
variables with qualifier 'const' must be initialized
atomic counter
Can only be highp
location must not be set for atomic_uint
no binding specified
empty array declaration needs to specify a size
sampler binding greater than maximum texture units
uniform block binding greater than MAX_UNIFORM_BUFFER_BINDINGS
shader storage block binding greater than MAX_SHADER_STORAGE_BUFFER_BINDINGS
Uniform location out of range
Writeonly value cannot be passed for 'in' or 'inout' parameters.
invalid layout qualifier: not supported
invalid layout qualifier: only valid when used with 'in' in a compute shader global layout declaration
image binding greater than gl_MaxImageUnits
global variable initializers must be constant expressions
global variable initializers should be constant expressions (uniforms and globals are allowed in global initializers for legacy compatibility)
 cannot initialize this type of qualifier 
assigning non-constant to '
 non-matching types for const initializer 
first-class array
not supported
Constant value cannot be passed for 'out' or 'inout' parameters.
Cannot be qualified as invariant.
undeclared identifier
variable expected
cannot use both gl_FragData and gl_FragColor
cannot use both output variable sets (gl_FragData, gl_SecondaryFragDataEXT) and (gl_FragColor, gl_SecondaryFragColorEXT)
It is an error to use gl_WorkGroupSize before declaring the local group size
cannot be a structure containing a structure
cannot be a structure containing a bool
Local variables can only use the const storage qualifier.
coherent
restrict
volatile
Offset overlapping
cannot be bool or int
'in' can be only used to specify the local group size
cannot be bool
cannot be array
cannot be matrix
must use 'flat' interpolation here
cannot be an array of structures
cannot be a structure containing an array
invariant declaration specifies layout
Requires both binding and offset
precision is not supported in fragment shader
illegal type argument for default precision qualifier
Array size or input primitive declaration doesn't match the size of earlier sized array inputs.
max_vertices can only be declared in 'out' layout in a geometry shader
invalid primitive type for 'in' layout
primitive doesn't match earlier input primitive declaration
Missing a valid input primitive declaration before declaring an unsized array input
Geometry shader input variable must be declared as an array
Expected invariant
invariant varying
undeclared identifier declared as invariant
invariant declaration specifies qualifier
invariant declaration specifies precision
'layout'
in type qualifier supported in GLSL ES 3.10 only
No local work group size specified
invalid value: Value must be at least 1 and no greater than 
out type qualifier supported in GLSL ES 3.10 only
Number of views does not match the previous declaration
No num_views specified
num_views greater than the value of GL_MAX_VIEWS_OVR
invocations contradicts to the earlier declaration
invocations can only be declared in 'in' layout in a geometry shader
invalid primitive type for 'out' layout
primitive doesn't match earlier output primitive declaration
max_vertices contradicts to the earlier declaration
Error during layout qualifier parsing.
Work group size does not match the previous declaration
function already has a body
Function parameter type cannot be a structure definition
Name of a built-in function cannot be redeclared as function
function must have the same return type in all of its declarations
function must have the same parameter qualifiers in all of its declarations
redefinition of a function
function cannot take any parameter(s)
main function cannot return a value
invalid qualifier: global layout can only be set for blocks
layout qualifiers supported in GLSL ES 3.00 and above
function parameter array must be sized at compile time
function
duplicate function prototype declarations are not allowed
local function prototype declarations are not allowed
function does not return a value:
built-in functions cannot be redefined
implicitly sized array of arrays constructor argument is not an array
implicitly sized array of arrays constructor argument dimensionality is too low
invalid qualifier: interface blocks must be uniform in version lower than GLSL ES 3.10
invalid qualifier: interface blocks must be uniform or buffer
invalid qualifier on interface block member
unsupported type - 
 types are not allowed in interface blocks
invalid qualifier on shader storage block member
no qualifiers allowed for function return
structures containing arrays can't be function return values
array constructor supported in GLSL ES 3.00 and above only
constructor can't be a structure definition
cannot construct this type
implicitly sized array constructor must have at least one argument
Embedded struct definitions are not allowed
 exceeds maximum allowed nesting level of 
Reference of struct type 
invalid qualifier on uniform block member
invalid layout qualifier: cannot be used here
extraneous layout qualifier: only has an effect on matrix types
array members of interface blocks must specify a size
redefinition of an interface block name
redefinition of an interface block member name
redefinition of an interface block instance name
struct
structure has no fields
 no such field in structure
interface block has no fields
 no such field in interface block
 field selection requires structure or vector on left hand side
 field selection requires structure, vector, or interface block on left hand side
Only std140 layout is allowed in WebGL
invalid layout qualifier: location requires an argument
cannot apply dot operator to an array
Internal Error
out of range: offset must be non-negative
num_views
invocations
max_vertices
storage qualifier isn't supported in compute shaders
invalid qualifier: can be only used with function parameters
duplicate field name in structure
invalid layout qualifier
 must be positive
out of range: 
out of range: num_views must be positive
out of range: invocations must be in the range of [1, MAX_GEOMETRY_SHADER_INVOCATIONS_OES]
out of range: max_vertices must be in the range of [0, gl_MaxGeometryOutputVertices]
out of range: location must be non-negative
out of range: binding must be non-negative
case label must be a scalar integer
case label must be constant
default labels need to be inside switch statements
switch
init-expression in a switch statement must be a scalar integer
case labels need to be inside switch statements
case label must have a condition
break statement only allowed in loops and switch statements
non-void function must return a value
discard supported in fragment shaders only
void function cannot return a value
function return is not matching type:
sequence operator is not allowed for void, arrays, or structs containing arrays
continue statement only allowed in loops
The value passed to the mem argument of an atomic memory function does not correspond to a buffer or shared variable.
Store
'imageStore' cannot be used with images qualified as 'readonly'
'imageLoad' cannot be used with images qualified as 'writeonly'
Function call discards the 'readonly' qualifier from image
Function call discards the 'writeonly' qualifier from image
no matching overloaded function found
 and '
mismatching ternary operator operand types '
ternary operator is not allowed for opaque types
ternary operator is not allowed for variables with writeonly
ternary operator is not allowed for structures or arrays
ternary operator is not allowed for interface blocks
Function call discards the 'coherent' qualifier from image
Function call discards the 'volatile' qualifier from image
invalid method
method takes no parameters
length can only be called on arrays
missing input primitive declaration before calling length on gl_in
function name expected
ternary operator is not allowed for void
extension is disabled
extension is being used
texture2DRect
texture2DRectProj
texture2DGradEXT
texture2DProjGradEXT
textureCubeGradEXT
rgb_2_yuv
yuv_2_rgb
texture2DLodEXT
texture2DProjLodEXT
textureCubeLodEXT
gl_MaxDualSourceDrawBuffersEXT
gl_MaxGeometryInputComponents
gl_MaxGeometryOutputComponents
gl_MaxGeometryImageUniforms
gl_MaxGeometryTextureImageUnits
gl_MaxGeometryOutputVertices
gl_MaxGeometryTotalOutputComponents
gl_MaxGeometryUniformComponents
gl_MaxGeometryAtomicCounters
gl_MaxGeometryAtomicCounterBuffers
mf2x2;
mf4x4;
mf3x3;
mf3x2;
mf2x3;
mf4x2;
mf2x4;
sext1;
s2r1;
mf4x3;
mf3x4;
sext2y2y1;
s2s1;
ycs1;
s2as1;
sCs1;
Undefined function '
)' used in the following call chain:
Recursive function call in the following call chain:
is21;
us21;
is2ms1;
s2ms1;
us2ms1;
us31;
is31;
isC1;
s2a1;
usC1;
us2a1;
is2a1;
not allowed to specify yuv qualifier when using depth or multiple color fragment outputs
must explicitly specify all locations when using multiple fragment outputs
conflicting output locations with previously defined output '
output location must be < MAX_DRAW_BUFFERS
output array locations would exceed MAX_DRAW_BUFFERS
_webgl_struct_
GL_ARM_shader_framebuffer_fetch
GL_ARB_texture_rectangle
GL_EXT_shader_framebuffer_fetch
GL_EXT_blend_func_extended
GL_NV_shader_framebuffer_fetch
GL_EXT_YUV_target
GL_OVR_multiview
GL_OES_geometry_shader
EXT_YUV_target
EXT_shader_texture_lod
NV_shader_framebuffer_fetch
NV_EGL_stream_consumer_external
OES_EGL_image_external_essl3
OES_EGL_image_external
OES_standard_derivatives
OES_geometry_shader
ARB_texture_rectangle
EXT_blend_func_extended
ARM_shader_framebuffer_fetch
EXT_frag_depth
EXT_draw_buffers
EXT_shader_framebuffer_fetch
EXT_geometry_shader
OVR_multiview
enable
' conflicting location with previously defined '
initGlobals
operation result is undefined for the values passed in
sampler3D
yuvCscStandardEXT
sampler2DRect
sampler2DArray
samplerExternalOES
__samplerExternal2DY2YEXT
usampler2DMS
sampler2DShadow
usamplerCube
usampler2DArray
interface block
samplerCubeShadow
sampler2DArrayShadow
isampler3D
isamplerCube
sampler2DMS
isampler2D
usampler2D
usampler3D
isampler2DArray
isampler2DMS
iimageCube
uimageCube
uimage2DArray
imageCube
ivec2
ivec3
uimage2D
image3D
image2D
iimage2D
image2DArray
iimage2DArray
iimage3D
uimage3D
 matrix of 
] of 
array[
iblock-
-component vector of 
bvec3
bvec4
ivec4
bvec2
uvec4
invariant 
uvec2
uvec3
    float pad_
 structure = { 
    return structure;
.xyzw
SamplerComparisonState
Texture2D<unorm float4>
TextureCube<unorm float4>
Texture2DArray<float4>
Texture3D<float4>
Texture2DMS<int4>
Texture2D<uint4>
Texture3D<int4>
Texture2DArray<int4>
Texture2DMS<uint4>
TextureCube
Texture3D<uint4>
Texture2DArray<uint4>
Texture2D<snorm float4>
TextureCube<snorm float4>
Texture2DArray<unorm float4>
Texture3D<unorm float4>
Texture2DMS<float4>
Texture2D<int4>
Texture2DArray<snorm float4>
Texture3D<snorm float4>
2D_snorm_float4_
2DArray_unorm_float4_
3D_unorm_float4_
2D_int4_
2DArray_snorm_float4_
3D_snorm_float4_
Texture2DArray
2D_unorm_float4_
2DArray
Cube_comparison
2DArray_comparison
RWTexture2D<float4>
2DMS_int4_
2D_uint4_
3D_int4_
2DArray_int4_
2DMS_uint4_
2D_comparison
3D_uint4_
2DArray_uint4_
RWTexture3D<uint4>
RWTexture2D<int4>
RWTexture2D<uint4>
RWTexture2DArray<uint4>
RWTexture2DArray<int4>
RWTexture3D<int4>
RWTexture2D<unorm float4>
RWTexture2DArray<unorm float4>
RWTexture2DArray<float4>
RWTexture3D<float4>
RWTexture2DArray<snorm float4>
RWTexture3D<snorm float4>
RWTexture3D<unorm float4>
RWTexture2D<snorm float4>
linear
nointerpolation
Constant folded undefined subtraction generated NaN
Constant folded subtraction overflowed to infinity
Constant folded undefined addition generated NaN
Constant folded addition overflowed to infinity
Undefined shift (operand out of range)
Constant folded undefined multiplication generated NaN
Constant folded multiplication overflowed to infinity
bool isnan_emu(float x)
    return (x > 0.0 || x < 0.0) ? false : x != 0.0;
bool4 isnan_emu(float4 x)
    bool4 isnan;
    for (int i = 0; i < 4; i++)
    {
        isnan[i] = (x[i] > 0.0 || x[i] < 0.0) ? false : x[i] != 0.0;
    }
    return isnan;
bool2 isnan_emu(float2 x)
    bool2 isnan;
    for (int i = 0; i < 2; i++)
    {
        isnan[i] = (x[i] > 0.0 || x[i] < 0.0) ? false : x[i] != 0.0;
    }
    return isnan;
bool3 isnan_emu(float3 x)
    bool3 isnan;
    for (int i = 0; i < 3; i++)
    {
        isnan[i] = (x[i] > 0.0 || x[i] < 0.0) ? false : x[i] != 0.0;
    }
    return isnan;
 : register(u
_type
cbuffer 
// Uniform Blocks
 : register(b
Performance: non-empty fall-through cases in switch statements generate extra code.
else if (
 == 3)
Offset)), 0, int(
) - 1);
 = int(floor(
 * coordWrapped));
    float coordWrapped = 1.0 - abs(frac(abs(
Offset) * 0.5) * 2.0 - 1.0);
float 
Offset = 
 == 1)
 = clamp(int(floor(
 + float(
height
wrapT
offset.y
offset.z
int(max(0, min(layers - 1, floor(0.5 + t.z))))
int wrapR = (samplerMetadata[samplerIndex].wrapModes >> 4) & 0x3;
int wrapS = samplerMetadata[samplerIndex].wrapModes & 0x3;
 * frac(
Offset)));
wrapS
int wrapT = (samplerMetadata[samplerIndex].wrapModes >> 2) & 0x3;
offset.x
width
depth
wrapR
    height = max(height >> lod, 1);
    depth = max(depth >> lod, 1);
.GetDimensions(baseLevel, width, height, depth, numberOfLevels);
    width = max(width >> lod, 1);
    return int3(width, height, depth);
    return int2(width, height);
    uint width; uint height; uint numberOfLevels;
.GetDimensions(baseLevel, width, height, numberOfLevels);
    uint width; uint height; uint samples;
    int baseLevel = 0;
    uint width; uint height; uint depth; uint numberOfLevels;
.GetDimensions(width, height, samples);
    int baseLevel = samplerMetadata[samplerIndex].baseLevel;
    float u = xMajor ? -t.z : (yMajor && t.y < 0.0f ? -t.x : t.x);
    float v = yMajor ? t.z : (negative ? t.y : -t.y);
    bool negative = (xMajor && t.x < 0.0f) || (yMajor && t.y < 0.0f) || (zMajor && t.z < 0.0f);
    int face = (int)negative + (int)yMajor * 2 + (int)zMajor * 4;
    t.y = (v * 0.5f / m) + 0.5f;
    float2 tSized = float2(t.x * width, t.y * height);
    float2 dx = ddx(tSized);
    float2 dy = ddy(tSized);
    float lod = 0.5f * log2(max(dot(dx, dx), dot(dy, dy)));
    float m = xMajor ? t.x : (yMajor ? t.y : t.z);
    t.x = (u * 0.5f / m) + 0.5f;
    float width; float height; float layers; float levels;
    uint mip = 0;
 / t.z
 / t.w
    bool yMajor = abs(t.y) > abs(t.z) && abs(t.y) > abs(t.x);
    bool zMajor = abs(t.z) > abs(t.x) && abs(t.z) > abs(t.y);
.GetDimensions(mip, width, height, layers, levels);
    bool xMajor = abs(t.x) > abs(t.y) && abs(t.x) > abs(t.z);
    lod += bias;
    float2 sizeVec = float2(width, height);
    float2 sizeDdx = ddx * sizeVec;
    float2 sizeDdy = ddy * sizeVec;
    float lod = log2(max(dot(sizeDdx, sizeDdx), dot(sizeDdy, sizeDdy))) * 0.5f;
.GetDimensions(0, width, height, layers, levels);
    float2 tSized = float2(t.x * width, t.y * height);
    float dx = length(ddx(tSized));
    float dy = length(ddy(tSized));
    float lod = log2(max(dx, dy));
.GetDimensions(0, width, height, levels);
.GetDimensions(mip, width, height, levels);
    uint mip = uint(min(max(round(lod), 0), levels - 1));
    float width; float height; float levels;
    float lengthfaceddx2 = dot(faceddx, faceddx);
    float lengthfaceddy2 = dot(faceddy, faceddy);
    float lod = log2(max(lengthfaceddx2, lengthfaceddy2)) * 0.5f;
    mip = uint(min(max(round(lod), 0), levels - 1));
    float dudx = xMajor ? ddx[2] : (yMajor && t.y < 0.0f ? -ddx[0] : ddx[0]);
    float dudy = xMajor ? ddy[2] : (yMajor && t.y < 0.0f ? -ddy[0] : ddy[0]);
    float dvdx = yMajor ? ddx[2] : (negative ? ddx[1] : -ddx[1]);
    float dvdy = yMajor ? ddy[2] : (negative ? ddy[1] : -ddy[1]);
    float dmdx = xMajor ? ddx[0] : (yMajor ? ddx[1] : ddx[2]);
    float dmdy = xMajor ? ddy[0] : (yMajor ? ddy[1] : ddy[2]);
    float dfacexdx = 0.5f * (m * dudx - u * dmdx) / (m * m);
    float dfaceydx = 0.5f * (m * dvdx - v * dmdx) / (m * m);
    float dfacexdy = 0.5f * (m * dudy - u * dmdy) / (m * m);
    float dfaceydy = 0.5f * (m * dvdy - v * dmdy) / (m * m);
    float2 sizeVec = float2(width, height);
    float2 faceddx = float2(dfacexdx, dfaceydx) * sizeVec;
    float2 faceddy = float2(dfacexdy, dfaceydy) * sizeVec;
    uint mip = bias;
int(floor(width * frac(
int(floor(height * frac(
    float3 tSized = float3(t.x * width, t.y * height, t.z * depth);
    float dx = length(ddx(tSized));
    float dy = length(ddy(tSized));
    float lod = log2(max(dx, dy));
    float3 sizeVec = float3(width, height, depth);
    float3 sizeDdx = ddx * sizeVec;
    float3 sizeDdy = ddy * sizeVec;
    float lod = log2(max(dot(sizeDdx, sizeDdx), dot(sizeDdy, sizeDdy))) * 0.5f;
    float width; float height; float depth; float levels;
.GetDimensions(0, width, height, depth, levels);
.GetDimensions(mip, width, height, depth, levels);
Offset
Fetch
gl_image
[uint2(p.x, p.y)];
[p] = data;
    uint width; uint height; uint depth;
.GetDimensions(width, height);
[uint3(p.x, p.y, p.z)];
.GetDimensions(width, height, depth);
    uint width; uint height;
WARNING: 
ERROR: 
UNKOWN ERROR: 
Unsigned integers are unsupported prior to GLSL ES 3.00
Integer overflow
fatal error - scanner input buffer overflow
out of dynamic memory in yy_get_next_buffer()
fatal flex scanner internal error--end of buffer missed
out of dynamic memory in yy_create_buffer()
out of dynamic memory in yyensure_buffer_stack()
Floating-point suffix unsupported prior to GLSL ES 3.00
Float overflow
methods supported in GLSL ES 3.00 and above only
bit-wise operator supported in GLSL ES 3.00 and above only
unsupported value
arrays of arrays supported in GLSL ES 3.10 only
unsupported type
qualifier supported in GLSL ES 3.00 and above only
implicitly sized array supported in GLSL ES 3.00 and above only
memory exhausted
syntax error
cannot be a parameter type except for '(void)'
first-class arrays (array initializer) supported in GLSL ES 3.00 and above only
integer modulus operator supported in GLSL ES 3.00 and above only
interface blocks supported in GLSL ES 3.00 and above only
storage qualifier supported in GLSL ES 3.10 only
 supported in compute shaders only
 supported in vertex shaders only
 supported in GLSL ES 1.00 only
The layout qualifier specified multiple times.
The layout qualifier and invariant qualifier cannot coexist in the same declaration according to the grammar.
The invariant qualifier specified multiple times.
The precision qualifier specified multiple times.
Output layout location specified multiple times.
The invariant qualifier has to be first in the expression.
The interpolation qualifier specified multiple times.
 specified multiple times
Cannot have multiple different primitive specifiers
Cannot have multiple different invocations specifiers
Cannot have multiple different work group size specifiers
Cannot have multiple different max_vertices specifiers
qualifier sequence
Storage qualifiers have to be after layout qualifiers.
Precision qualifiers have to be after layout qualifiers.
Storage qualifiers have to be after interpolation qualifiers.
Precision qualifiers have to be after interpolation qualifiers.
invalid qualifier combination
Precision qualifiers have to be after storage qualifiers.
Precision qualifiers have to be after memory qualifiers.
case label type does not match switch init-expression type
duplicate default label
label statement nested inside control flow
no statement between the last label and the end of the switch statement
statement before the first label
duplicate case label
invalid pragma value - 'on' or 'off' expected
version number not supported
#pragma STDGL invariant(all) can not be used in fragment shader
webgl_debug_shader_precision
debug
optimize
iimc1;
iim2a1;
iim31;
iim21;
uimc1;
uim2a1;
uim31;
uim21;
imc1;
im2a1;
im31;
im21;
rx::IncompleteTextureSet::onDestroy
angle::DestroyThenDelete<class gl::Texture,class gl::Context>::operator ()
Mapping of internal index buffer would cause an integer overflow.
angle::DestroyThenDelete<class rx::TextureStorage,class gl::Context>::operator ()
GPU.ANGLE.D3DCompileMS
D3D compiler module not found.
HLSLCompiler::initialize
Error finding D3DCompile entry point.
rx::HLSLCompiler::ensureInitialized
 Retrying with 
Warning: D3D shader compilation failed with 
HLSL compiler had an unexpected failure, 
Vertex buffer is not big enough for the draw call.
Integer overflow in VertexDataManager::StoreStaticAttrib
Failed to allocate the streaming vertex buffer.
 is the maximum.
Renderbuffer format does not support 
 samples, 
Reserving 
 indices of 
 bytes each exceeds the maximum buffer size.
Vertex buffer overflow in VertexBufferInterface::getSpaceRequired.
rx::StreamingVertexBufferInterface::StreamingVertexBufferInterface
Internal error, new vertex buffer write position would overflow.
Unable to reserve 
 extra bytes in internal vertex buffer, it would result in an overflow.
8 8@8`8
float overflow
token too long
invalid expression
division by zero
out of memory
invalid character
invalid number
integer overflow
internal error
macro invocation chain too deep
unexpected #endif found without a matching #if
unexpected #else found without a matching #if
unexpected #else found after another #else
macro undefined while being invoked
Not enough arguments for macro
Too many arguments for macro
duplicate macro parameter name
macro redefined
predefined macro redefined
predefined macro undefined
unterminated macro invocation
unexpected end of file found in comment
unexpected token
invalid directive name
macro name is reserved
invalid line directive
extension directive must occur before any non-preprocessor tokens in ESSL3
shift exponent is negative or undefined
internal tokenizer error
#version directive must occur before anything else, except for comments and white space
#version directive must occur on the first line of the shader
invalid line number
invalid file number
invalid extension behavior
invalid extension directive
invalid version number
invalid version directive
unexpected #elif found without a matching #if
unexpected #elif found after #else
unexpected end of file found in conditional block
invalid extension name
macro name with a double underscore is reserved - unintented behavior is possible
unexpected end of file found in directive
unexpected token after conditional expression
unrecognized pragma
extension directive should occur before any non-preprocessor tokens
STDGL
?RSDS
edgeangle.pdb
.text$di
.text$lp00edgeangle.dll!20_pri7
.text$mn
.text$mn$00
.text$np
.text$x
.text$yd
.text$zs
.text$zy
.text$zz
.rdata$brc
.rdata$T$brc
.rdata$zz$brc
.idata$5
.00cfg
.CRT$XCA
.CRT$XCAA
.CRT$XCB
.CRT$XCL
.CRT$XCU
.CRT$XCZ
.CRT$XIA
.CRT$XIC
.CRT$XIZ
.CRT$XLA
.CRT$XLZ
.CRT$XPA
.CRT$XPZ
.CRT$XTA
.CRT$XTZ
.gehcont
.gfids
.giats
.rdata
.rdata$00
.rdata$r
.rdata$voltmd
.rdata$zETW0
.rdata$zETW1
.rdata$zETW2
.rdata$zETW9
.rdata$zz
.rdata$zzzdbg
.rtc$IAA
.rtc$IZZ
.rtc$TAA
.rtc$TZZ
.tls$
.tls$ZZZ
.xdata
.didat$2
.didat$3
.didat$4
.didat$7
.edata
.idata$2
.idata$3
.idata$4
.idata$6
.data$00$brc
.data$dk00$brc
.data$r$brc
.data$rs$brc
.data$zz$brc
.data
.data$00
.data$dk00
.data$zz
.bss$00
.bss$dk00
.bss$pr00
.bss$zz
.pdata
.didat$5
.rsrc$01
.rsrc$02
edgeangle.dll
_initterm
_initterm_e
api-ms-win-crt-runtime-l1-1-0.dll
_o___acrt_iob_func
_o___std_type_info_destroy_list
_o___stdio_common_vfprintf
_o___stdio_common_vsprintf
_o___stdio_common_vsprintf_s
_o__cexit
_o__configure_narrow_argv
_o__crt_atexit
_o__errno
_o__execute_onexit_table
_o__fdclass
_o__fdsign
_o__initialize_narrow_environment
_o__initialize_onexit_table
_o__invalid_parameter_noinfo_noreturn
_o__purecall
_o__register_onexit_function
_o__seh_filter_dll
_o__wcsicmp
_o_acosf
_o_acoshf
_o_asinf
_o_asinhf
_o_atan2f
_o_atanf
_o_atanhf
_o_atoi
_o_ceil
_o_ceilf
_o_cosf
_o_coshf
_o_exit
_o_exp2f
_o_expf
_o_floor
_o_floorf
_o_free
_o_fwrite
_o_isdigit
_o_log
_o_logf
_o_malloc
_o_mbstowcs_s
_o_modff
_o_pow
_o_powf
_o_realloc
_o_round
_o_roundf
_o_sinf
_o_sinhf
_o_sqrtf
_o_strcpy_s
_o_strtoul
_o_tanf
_o_tanhf
_o_wcstombs
__C_specific_handler
memset
api-ms-win-crt-private-l1-1-0.dll
api-ms-win-crt-string-l1-1-0.dll
GetModuleFileNameW
PathFindFileNameW
EventWriteEx
lstrcmpiW
GetLastError
RaiseFailFastException
RaiseException
SetUnhandledExceptionFilter
StrStrIW
StrCmpICW
GetCurrentProcessId
RtlGetSuiteMask
GetModuleHandleW
GetProcAddress
InitOnceExecuteOnce
QueryPerformanceCounter
GetCurrentThreadId
GetSystemTimeAsFileTime
InitializeSListHead
RtlCaptureContext
RtlLookupFunctionEntry
RtlVirtualUnwind
IsDebuggerPresent
UnhandledExceptionFilter
IsProcessorFeaturePresent
GetCurrentProcess
TerminateProcess
api-ms-win-core-libraryloader-l1-2-0.dll
api-ms-win-core-shlwapi-legacy-l1-1-0.dll
api-ms-win-eventing-provider-l1-1-0.dll
api-ms-win-core-string-obsolete-l1-1-0.dll
api-ms-win-core-errorhandling-l1-1-0.dll
api-ms-win-core-errorhandling-l1-1-2.dll
api-ms-win-core-shlwapi-obsolete-l1-1-0.dll
api-ms-win-core-processthreads-l1-1-0.dll
ntdll.dll
api-ms-win-core-synch-l1-2-0.dll
api-ms-win-core-profile-l1-1-0.dll
api-ms-win-core-sysinfo-l1-1-0.dll
api-ms-win-core-interlocked-l1-1-0.dll
api-ms-win-core-rtlsupport-l1-1-0.dll
api-ms-win-core-debug-l1-1-0.dll
api-ms-win-core-processthreads-l1-1-1.dll
iertutil.dll
?_Raise_handler@std@@3P6AXAEBVexception@stdext@@@ZEA
?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAA_JPEBD_J@Z
?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHD@Z
?pbase@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAA@XZ
?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXPEAD0@Z
?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ
??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@PEAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z
?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ
?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ
?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
?egptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
?gbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXH@Z
?setg@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXPEAD00@Z
?epptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ
?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXPEAD00@Z
?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAPEADXZ
?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADXZ
??0?$basic_ios@DU?$char_traits@D@std@@@std@@IEAA@XZ
??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAAXXZ
?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAAXXZ
?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA_JXZ
?uflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA_JPEAD_J@Z
?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA_JPEBD_J@Z
?setbuf@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAAPEAV12@PEAD_J@Z
?sync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
?imbue@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAAXAEBVlocale@2@@Z
??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ
??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UEAA@XZ
?width@ios_base@std@@QEAA_J_J@Z
?width@ios_base@std@@QEBA_JXZ
?flags@ios_base@std@@QEBAHXZ
?good@ios_base@std@@QEBA_NXZ
msvcp_win.dll
_invoke_watson
MemProtectHeapDestroy
MemProtectHeapUnrootAndZero
MemProtectHeapCreate
chakra.dll
HeapFree
HeapAlloc
GetProcessHeap
ResolveDelayLoadedAPI
DelayLoadFailureHook
api-ms-win-core-heap-l1-1-0.dll
api-ms-win-core-delayload-l1-1-1.dll
api-ms-win-core-delayload-l1-1-0.dll
?setw@std@@YA?AU?$_Smanip@_J@1@_J@Z
?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAADD@Z
??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAVios_base@1@AEAV21@@Z@Z
??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@J@Z
??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@H@Z
?setf@ios_base@std@@QEAAHHH@Z
?setf@ios_base@std@@QEAAHH@Z
?flags@ios_base@std@@QEAAHH@Z
??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QEAA@PEAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z
??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@I@Z
??1?$basic_istream@DU?$char_traits@D@std@@@std@@UEAA@XZ
??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UEAA@XZ
?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@D@Z
?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADD@Z
??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z
?write@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@PEBD_J@Z
??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@_K@Z
strncmp
strstr
TlsSetValue
TlsAlloc
TlsGetValue
TlsFree
VerSetConditionMask
VerifyVersionInfoW
LoadLibraryW
FreeLibrary
WaitForSingleObject
QueryPerformanceFrequency
CloseHandle
EnterCriticalSection
LeaveCriticalSection
InitializeCriticalSectionAndSpinCount
DeleteCriticalSection
SetEvent
ResetEvent
WaitForSingleObjectEx
CreateEventW
api-ms-win-core-sysinfo-l1-2-0.dll
api-ms-win-core-kernel32-legacy-l1-1-1.dll
api-ms-win-core-libraryloader-l1-2-1.dll
api-ms-win-core-synch-l1-1-0.dll
api-ms-win-core-handle-l1-1-0.dll
??0?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@PEAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z
??5?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@AEAI@Z
?fail@ios_base@std@@QEBA_NXZ
??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@M@Z
?precision@ios_base@std@@QEAA_J_J@Z
?unsetf@ios_base@std@@QEAAXH@Z
?classic@locale@std@@SAAEBV12@XZ
?imbue@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAA?AVlocale@2@AEBV32@@Z
??5?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@AEAM@Z
truncf
api-ms-win-crt-math-l1-1-0.dll
__CxxFrameHandler3
Sleep
??5?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@AEAH@Z
strcmp
memchr
memcmp
memcpy
memmove
.?AV<lambda_0296470f3aa677865b67e6d0cd54446b>@@
.?AV<lambda_1b3dd992f53350e8571a7fd65b6dbaae>@@
.?AV<lambda_8d5bc7bc0cac28deff49146e5fb64a2d>@@
.?AV<lambda_30752acf91dc37c42379b18b4ad5f90a>@@
.?AVtype_info@@
VS_VERSION_INFO
StringFileInfo
040904B0
CompanyName
Microsoft Corporation
FileDescription
Microsoft Edge Angle
FileVersion
11.00.22621.1 (WinBuild.160101.0800)
InternalName
EdgeAngle
LegalCopyright
 Microsoft Corporation. All rights reserved.
OriginalFilename
EdgeAngle.dll
ProductName
Microsoft Edge
ProductVersion
11.00.22621.1
OleSelfRegister
VarFileInfo
Translation
