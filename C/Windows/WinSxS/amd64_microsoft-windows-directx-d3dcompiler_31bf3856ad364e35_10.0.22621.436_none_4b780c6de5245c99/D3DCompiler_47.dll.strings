!This program cannot be run in DOS mode.
Rich}e
.text
`.rdata
@.data
.pdata
@.rsrc
@.reloc
WATAUAVAWH
 A_A^A]A\_
q0R^G'
q0R^G'
q:_0#
|$ AVH
VWAVH
p:_0#
p:_0#
p:_0#
@A^_^
q:_0#
\$ WH
@SVWH
L$ SUVWH
8_^][
\$ UH
M H1E
 H3E H3E
p:_0#
ntelA
ineID
L$ SUVWH
8_^][
H SUVWAVH
@A^_^][
H SVWH
H SUVWAVH
@A^_^][
H SVWH
t$ AWH
HcL$`
l$ WH
UWAVH
HcL$@
t$ WH
L$PE3
HcL$@
@SATH
9k0vZH
t$ fff
t$ WH
t$ WH
t$ WH
SVWAUAVH
0A^A]_^[
@UAUAVAWH
|$(E3
U fff
8A_A^A]]
@SVATAVH
(A^A\^[
8A8t H
|$ A;
(A^A\^[
@SVATAVH
(A^A\^[
8APt H
|$ A;
(A^A\^[
@SVATAVH
(A^A\^[
8Aht H
|$ A;
(A^A\^[
|$ AVH
@SUWAUAVH
 A^A]_][
WATAUAVAWH
 A_A^A]A\_
|$ AVH
t$ WAVAWH
D8t$HtM3
 A_A^_
@VAWH
l$(E3
t$ UWAVH
@A^_]
UAVAWH
t$pD;
A;^0r
@A_A^]
@A_A^]
9_0v2f
\$(E3
D$0E3
\$ UH
+CHHc
@VAUH
UAUAWH
A_A]]
@`A+@XD
B`+BXE
A_A]]
@`A+@XHc
@`A+@XA
@`A+@XE
@`A+@XA
@`A+@XE
B`+BXHc
}wA;X
@`A+@XHc
fA9\$
B`+BXHc
B`+BXHc
@SVWH
@SWAWH
PA__[
PA__[
UVAVH
 A^^]
 A^^]
@UAVAWH
0A_A^]
l$ H;
0A_A^]
UVAVH
@A^^]
B`+BXHc
@A^^]
T$0E3
@A^^]
WATAUAVAWH
 A_A^A]A\_
+AXLc
WAVAWH
 A_A^_
t#fA;
|$ E3
L9{@u
L9{Ht@
t$ WAVAWH
 A_A^_
s WATAUAVAWH
)D$@I
)D$ I
A_A^A]A\_
\$ VH
L$@E3
tVHc|$@
B`+BXHc
t$ WAVAWH
 A_A^_
tKHcD$@
UWAVH
HcD$@H
t$HHct$@H
t$H;D$@
 A^_]
 A^_]
@SVAWH
Hc\$0
C`+CXHc
C`+CXHc
|$ UATAUAVAWH
d$ E3
d$1u H
B`+BXHc
B`+BXHc
L$pD8d$0
D8d$1
B`+BXHc
D8d$2u$E
D8d$0
A_A^A]A\]
WAVAWH
 A_A^_
+AXLc
@UAUH
C`;CP
HcT$X3
@UVAVH
F`A+FXHc
N`A+NXHc
D9d$0
sEf9y
A+FXHc
L$8E3
N`A+NXHc
SUVWAVH
D$8H;D$P
u'fA;
A^_^][
d$8E3
UVWATAVH
@8|$PtH3
t19{ v'f
*;{ r
 A^A\_^]
 A^A\_^]
UVWATAUAVAWH
)D$@I
t#fff
t19{ v'f
*;{ r
`A_A^A]A\_^]
VATAUAVAWH
9{0v*f
*D;C0r
t29{@v(fff
2;{@r
 A_A^A]A\^
VWATAVAWH
(D$ H
(D$ H
(D$ H
(D$ H
(D$ H
0A_A^A\_^
|$ AVH
t$ WATAUAVAWH
t@D9l$Hv9H
Ex+EpHc
A_A^A]A\_
u$E;F
uHE;F
H;]`s
t$ WH
G`+GPH
l$ WH
9k0vOH
|$ AVH
H9{(t7
VWAUAVAWH
Ex+EpHc
uBA;N
0A_A^A]_^
A`A+AXHc
|$ AVH
D$(H;D$@
UVWATAUAVAWH
A`+AXHc
D$(Hc[
A_A^A]A\_^]
@SUVWATAUAVAWH
l$@E3
L$XH3
hA_A^A]A\_^][
@UVATAUAVH
`A^A]A\^]
`A^A]A\^]
|$ AVH
UVWATAUAVAWH
PA_A^A]A\_^]
t$ WATAUAVAWH
A_A^A]A\_
VAVAWH
@A_A^^
t*IcS
A+KHHc
t$ WATAUAVAWH
|$8fE;
A_A^A]A\_
@SWATAVH
t*D8m
HA^A\_[
|$ AUAVAW
D8\$Xt
|$8A_A^A]
B`A+BXA
C`+CXHc
@VATAUAVAWH
L$8fD
@A_A^A]A\^
D$pE3
@A_A^A]A\^
WATAUAVAWH
@A_A^A]A\_
WATAUAVAWH
+CXLc
+CXHc
t$0H;
+CXHc
@A_A^A]A\_
B`A+BXA
UATAVH
|$0D;
A;^0r
PA^A\]
PA^A\]
UAUAVH
|$PD;
D$BA3
A;]0r
pA^A]]
pA^A]]
VWAVH
\$8E3
t$ WAVAWH
Hct$0
@A_A^_
|$ AVH
A`+AXLc
D;Q0stH
+AXLc
t$ WH
C`;CPu{H
L$8HcT$0
WAVAWH
 A_A^_
l$ WAVAWH
 A_A^_
+A@+A
@UWAUAWH
8A_A]_]
G`+GXHc
8A_A]_]
G`+GXHc
@WAVH
H9\$H
@SUAVH
 A^][
 A^][
@WAVH
H9\$H
@SUAVH
 A^][
 A^][
@WAVH
H9\$H
@WAVH
H9\$H
@WAVH
H9\$H
@SUAVH
 A^][
 A^][
@WAVH
H9\$H
@WAVH
H9\$H
@SUAVH
 A^][
 A^][
@WAVH
H9\$H
@SUAVH
 A^][
 A^][
\$ WH
A1@,I
\$ VH
\$ VH
\$ VH
\$ VH
\$ VH
\$ VH
\$ VH
\$ VH
\$ VH
\$ VH
\$ VH
\$ VH
\$ VH
\$ VH
L$8H3
L$8H3
L$8H3
L$8H3
L$8H3
L$8H3
VWAVH
0A^_^
VWAVH
0A^_^
VWAVH
0A^_^
VWAVH
0A^_^
UVWAVAWH
L$@H3
PA_A^_^]
UVWAVAWH
L$@H3
PA_A^_^]
UVWAVAWH
L$XH3
`A_A^_^]
UVWAVAWH
L$XH3
`A_A^_^]
UVWAVAWH
L$PH3
`A_A^_^]
UVWAVAWH
L$@H3
PA_A^_^]
UVWAVAWH
L$@H3
PA_A^_^]
L$pE3
L$pE3
t$ AWH
H9t$Pu
t$ AWH
H9t$Pu
t$ AWH
H9t$Pu
t$ AWH
H9t$Pu
t$ AWH
H9t$Pu
t$ AWH
H9t$Pu
t$ AWH
H9t$Pu
t$ AWH
H9t$Pu
t$ AWH
H9t$Pu
t$ AWH
H9t$Pu
t$ AWH
H9t$Pu
@UWAVAWH
(A_A^_]
d$`E3
(A_A^_]
(A_A^_]
@UWAVAWH
(A_A^_]
d$`E3
(A_A^_]
(A_A^_]
UVAVH
 A^^]
 A^^]
 A^^]
VAVAWH
 A_A^^
 A_A^^
 A_A^^
VAVAWH
 A_A^^
 A_A^^
 A_A^^
VAVAWH
 A_A^^
 A_A^^
 A_A^^
UVAVH
 A^^]
 A^^]
 A^^]
@UWATAWH
(A_A\_]
l$`E3
(A_A\_]
(A_A\_]
@SUVWAWH
A__^][
@SUVWAWH
v$fff
A__^][
@VATAVAWH
8A_A^A\^
l$hA;
8A_A^A\^
L$ UATAUH
@A]A\]
@A]A\]
@WATAVAWH
8A_A^A\_
l$hA;
8A_A^A\_
L$ UATAUH
@A]A\]
@A]A\]
WATAUAVAWH
 A_A^A]A\_
WATAUAVAWH
 A_A^A]A\_
WATAUAVAWH
 A_A^A]A\_
WATAUAVAWH
 A_A^A]A\_
WATAUAVAWH
 A_A^A]A\_
WATAUAVAWH
 A_A^A]A\_
WATAUAVAWH
 A_A^A]A\_
WATAUAVAWH
 A_A^A]A\_
|$ AVH
|$ AVH
|$ AVH
|$ AVH
|$ AVH
|$ AVH
|$ AVH
|$ AVH
t$ WH
UVWATAUAVAWH
)D$@I
t#fff
`A_A^A]A\_^]
|$ UAVAWH
A_A^]
|$ UAVAWH
A_A^]
t$ WH
t$ WH
t$ WAVAWH
 A_A^_
t$ WH
CX tpH
A`+AXHc
VWAWH
|$ AVH
t$ WH
t$ WH
t$ WH
@UVATAUAVH
A^A]A\^]
uQ8]o
r6A8\$(
8]wt9
A^A]A\^]
l$ VWAWH
PA__^
r.8](
H9\$pt'
PA__^
@SUVH
K(D8q
CH+C@Hc
UVAVH
0A^^]
0A^^]
t$ WH
VWAVH
0A^_^
0A^_^
l$ VWAWH
`A__^
r*8^(
L$HuGH
`A__^
t$ WH
t$ WH
@VWAVH
PA^_^
PA^_^
PA^_^
PA^_^
PA^_^
PA^_^
PA^_^
l$ VWAWH
`A__^
`A__^
t$ WH
t$ WH
|$ AVH
|$ AVH
l$ VH
CH+C@Hc
@WATAVH
L$HH3
pA^A\_
\$ AVH
@VWAVH
`A^_^
`A^_^
UVAVH
0A^^]
0A^^]
UWATH
t$ WH
VWAVH
0A^_^
0A^_^
@UWATAUH
xA]A\_]
xA]A\_]
@UVAVAWH
8A_A^^]
8A_A^^]
t$ WH
@UWAVH
@A^_]
D$`9D$0u
D$4+D$8
@A^_]
@UVWAVH
L$XH3
hA^_^]
t$ WH
@UWAVH
@A^_]
D$`9D$0u
D$4+D$8
@A^_]
t$ WH
L$(E3
@UVWAWH
hA__^]
d$8H9
r0D8g(
hA__^]
@SWAVH
 A^_[
SUWAVH
XA^_][
XA^_][
@UWATAVH
HA^A\_]
HA^A\_]
HA^A\_]
UVWAVAWH
A_A^_^]
VWAVH
@A^_^
@A^_^
SWAVH
pA^_[
A`+AXHc
A`+AXHc
A`+AXHc
A`+AXHc
A`+AXHc
pA^_[
pA^_[
@USAVAWH
A_A^[]
A_A^[]
A_A^[]
L$ E3
t$ WH
UVAVH
 A^^]
A`+AXHc
 A^^]
t$ WH
A`+AXHc
@UWAUAVH
L$HfD
A^A]_]
@VWAVH
`A^_^
`A^_^
`A^_^
@UVWAUH
xA]_^]
xA]_^]
xA]_^]
l$ WH
t$ WH
L$HE3
@SUAVH
 A^][
 A^][
t$ AVH
@UAWH
A+FXHc
F`A+FXHc
t$ AVH
@SWAVH
 A^_[
 A^_[
UVAVH
 A^^]
 A^^]
l$ AVH
@UAVH
r)D8y(t0H
r1D8}(
u,D8}(
+CXHc
VWATAVAWH
A_A^A\_^
\$ ATAVAWH
@A_A^A\
@A_A^A\
@UVATAUH
(A]A\^]
(A]A\^]
ATAVAWH
<$u9H
!<_u E2
r1A8w(
d$0E3
A_A^A\
t$ AVH
CP@t,H
r1@8k(
u/@8k(
:@8k(
fA9,wu
UVAVH
d$`D;
D$BA3
A;^0r
pA^^]
pA^^]
A`+AXHc
A`+AXHc
t$ WH
A$;A s
L$0H3
@UWATAVH
(A^A\_]
(A^A\_]
(A^A\_]
@SVATAWH
(A_A\^[
(A_A\^[
(A_A\^[
VWAVH
0A^_^
0A^_^
AH+A@Hc
@UVWH
@USVWH
9E`u%H
@UAUAVAWH
(A_A^A]]
(A_A^A]]
(A_A^A]]
@VAUAVAWH
(A_A^A]^
d$ H;
(A_A^A]^
(A_A^A]^
\$ WH
H;QXv
WATAUAVAWH
fB9DE
 A_A^A]A\_
|$ AVH
D$@H;
WAVAWH
 A_A^_
Apu'H
Axu#H
L9ApH
L9AxH
D8AXH
D8AYH
@USVWATAUAVAWH
T$@E3
f9D$@
T$pE3
H9|$0
A_A^A]A\_^[]
SVWAVH
D$0<.w
A^_^[
H9\$H
vef9\$dH
@SVATAUAWH
uDHcl$x
@A_A]A\^[
x AVH
l$ E3
@SUVWAUAVH
@8|$ht@3
t39{ v)
*;{ r
(A^A]_^][
(A^A]_^][
UVWATAUAVAWH
HcE`H
`A_A^A]A\_^]
UATAVH
|$0D;
A;^0r
PA^A\]
PA^A\]
UVWATAUAVAWH
>NB09
v.fA;
t?fA;
l$hE3
A_A^A]A\_^]
HcD$0H
|$ UH
H+E'H
t$ WH
D$HHc
L$PH3
@USWH
@USVATAUAVAWH
9D$hul
D$PD;D$Tw
D$P+D$T
L$pM;
D$@E3
D$@E3
D$LA;
A_A^A]A\^[]
H9D$0
H9D$0
@USVWAVH
A^_^[]
uGHcB
t$ WH
UWAVH
fA;DP
fA;DQ
fA;DQ
fA;DQ
fA;DQ
fA;DQ
fA;DQ
fA;DQ
fA;DQ
fA;DQ
fA;DQ
fA;DQ
fA;DQ
fA;DQ
fA;DQ
fA;DQ
fA;DQ
fA;DQ
fA;DQ
fA;DQ
U8LcE8A
E8xYLc
fA;DQ
fA;DQ
fA;DQ
fA;DQ
fA;DQ
fB;DB
\$ UVWAVAWH
fA;DP
fC;DA
fA;DP
A_A^_^]
@USWH
@SVWH
L$XH3
@USWH
u89D$8u2H
\$ WH
SAVAWH
A_A^[
@USWATAVAWH
fC;LA
t$HuAI
u&D9u
x9L9t$Hu
H9D$@v
L9w@uJ
A_A^A\_[]
VWAVH
D$0E3
@A^_^
UWATAVAWH
u&9}0u!H
uC9u0t>H
t'9}Pt 
A_A^A\_]
@USWATH
D9t$d
D$hH;
D$hH;D$X
D$hH;D$X
AH;D$ps:H
|$PD;
L$xH9M
A\_[]
EL$0A
@WATAUH
t$0E3
D8d$htL3
U fff
D8d$htL3
U fff
D8d$htL3
U fff
@A]A\_
VWATAUAWH
 A_A]A\_^
 A_A]A\_^
@VWATAUAWH
 A_A]A\_^
y(fff
@UVWATAUAVAWH
t.D8O
t-D8g
t.D8g
t(D8g
\$p;o4
L$h;o4
 A_A^A]A\_^]
SUWATAUAWH
(A_A]A\_][
(A_A]A\_][
UWAVH
SUVWATAUAVAWH
XA_A^A]A\_^][
@USVWATAUAVAWH
D$HE3
D$XL;
A_A^A]A\_^[]
T$(L+
T$PL+
T$(H+
H#D$pH
D$HE3
D$0+C H
|$ UATAUAVAWH
D$PE3
l$hE2
A_A^A]A\]
\$ UVWH
D$0 t
\$ UVWH
T$pL#
@UAUAVAWH
|$(E3
U fff
8A_A^A]]
@SVWH
@VWATAUAVAWH
L9d$@
A_A^A]A\_^
D$HH;D$`u
UVATAVAWI
D$@E3
D$HIc
D8|$Du
A_A^A\^]
UVWATAUAVAWH
PA_A^A]A\_^]
@UWAUH
t$ UH
@SUVH
@(@8s(t
@USVWH
|$`fff
h_^[]
@UAVAWH
@(D8}(t5L
PA_A^]
UVATAUAWH
@(D8e(t;L
PA_A]A\^]
@UAVAWH
@(D8}(tZL
PA_A^]
@UAVAWH
@(D8}(tZL
PA_A^]
@UAVAWH
PA_A^]
@SUAVH
PA^][
@SAVAWH
PA_A^[
\$0E;
tffff
@UAUAVAWH
|$(E3
U fff
8A_A^A]]
|$ UATAUAVAWH
E0A+U $
A+U,A+
A_A^A]A\]
@UWAUH
D9|$Pt
L$HD+o 
A+L$,;
E+|$,E+
|$HE3
T$@A;
Dt$pD
@USAVH
`A^[]
@UAUAVAWH
|$(E3
U fff
8A_A^A]]
L$PH3
@USVWAUAVAWH
`A_A^A]_^[]
L$ SUVWATAWH
t$@E3
D+D$0A
HA_A\_^][
HA_A\_^][
USVWAUAVAWH
pA_A^A]_^[]
L$PH3
L$PH3
@USAWH
D$`E3
T$XD+
D$@t)H
\$@E3
l$HE3
@SVWH
refE;
D$(fA
l$xE3
|$ E3
d$8D9CpvE
D;Kpr
@SUVH
fw2Hc
|$ UAVAWH
A_A^]
fF9<@u
fD9|A
fD9<xu
HcD$0H
@UWATAVAWH
!<arch>
fD9<_u
        
/       H;
//      H;
< tD</t@H
f9D$B
A_A^A\_]
|$xtoH
tV9l$puPH
|$ E3
VWATAVAWH
9ypvR
 A_A^A\_^
@USVWAVAWH
w5tg=
d:t$=
D;|$ 
A_A^_^[]
\$ VAVAWH
 A_A^^
A8Hcl
 A_A^^
@SVWH
A(tHH
D$0E3
t$ WATAUAVAWH
!<arch>
f9D$2t
D$<H;
D$DH;
|$$L;
9S@v6
 ;S@r
9S`v,
9SPv1
L$hH3
A_A^A]A\_
\$ UVWATAUAVAWH
l$@E3
A_A^A]A\_^]
@SVAWH
+FHHc
D9g0v!
PA_^[
L$ SVAUAVAWH
`A_A^A]^[
|$XH;
`A_A^A]^[
VAVAWH
 A_A^^
 A_A^^
CP+CHHc
D9X,tNI
D9X,t
t$ WH
L9P8tEI
L9P8t
t$ WH
CP+CHHc
WATAUAVAWH
A_A^A]A\_
|$ AVH
t$xE3
u+9h u&9X$u!D9X
@SUVWAUH
@A]_^][
UWATAVAWH
A_A^A\_]
@USWATH
A\_[]
A\_[]
l$ VWAVH
t$pE3
HcT$0H
@SUVWAWH
T$PfD
L$xH3
A__^][
@SUVWAVH
T$@E3
T$@fD
L$XH3
`A^_^][
@SVAUAVH
XA^A]^[
@SWAUAVH
8A^A]_[
8A^A]_[
l$pHcl$`H
8A^A]_[
L$XE3
@UVWH
HcT$0H
t$ WAVAWH
t$`9{pvSfff
A_A^_
USVWATAUAVAWH
fw%Ic
}oHc]wD
A_A^A]A\_^[]
UVWATAUAVAWH
A_A^A]A\_^]
|$ AVH
tUD9C
D)0D;C
swfHc
D$0E3
D$0E3
t$ WAVAWH
D$ E3
@A_A^_
t$ WAVAWH
D$ E3
@A_A^_
UVWAVAWH
A_A^_^]
UVWAVAWH
A_A^_^]
@USWAUAVH
T$ fD
t$(fD
T$ fD
T$ fD
A^A]_[]
@UVWATAUAVAWH
\$HH;\$`
A_A^A]A\_^]
@SUVWAVAWH
A_A^_^][
r.@8s
@SUVH
D$xL+
t=fD9s
t$ WATAUAVAWH
 A_A^A]A\_
SVATAVAWH
|$$A+
`A_A^A\^[
UWATAUAWH
PA_A]A\_]
t$@f;
L;}8r 
PA_A]A\_]
t$ WAVAWH
D$ E3
@A_A^_
l$ VWATAVAWH
D$ E3
A_A^A\_^
t$ WAVAWH
D$ E3
@A_A^_
t$ WAVAWH
D$ E3
@A_A^_
t$ WAVAWH
D$ E3
@A_A^_
l$ VWATAVAWH
D$ E3
A_A^A\_^
UWAVH
PA^_]
PA^_]
l$ VWAVH
D$ E3
l$ VWAVH
D$ E3
t$ WAVAWH
D$ E3
@A_A^_
@UVAVAWH
D$ E3
HA_A^^]
t$ WAVAWH
D$ E3
@A_A^_
VWAVH
D$ E3
@A^_^
t$ WAVAWH
0A_A^_
VWAVAWH
XA_A^_^
Ic^4H
tVLcW
D$0I;
$A+?A
XA_A^_^
D$`E3
@USVWATAVAWH
D$$E3
D$@E3
u(D8d$HttH
\$`u"D8f
A_A^A\_^[]
l$ VWAVH
D$ E3
t$ WAVAWH
D$ E3
@A_A^_
@USVWATAUAVAWH
L$(E3
vgfA;
A_A^A]A\_^[]
t$ WAVAWH
@A_A^_
t$0A1
@SUVWAUH
PA]_^][
PA]_^][
WAVAWH
D$ E3
@A_A^_
WAVAWH
D$ E3
@A_A^_
VAVAWH
|$pu+H
PA_A^^
UVAWH
|$purH
PA_^]
UVWATAUAVAWH
A_A^A]A\_^]
VAVAWH
|$pu+H
PA_A^^
VWAWH
PA__^
\$ UVWH
D$0E3
\$ UVWH
D$0E3
\$ UVWH
D$0E3
VWAVH
tA+(L
@A^_^
UATAUAVAWH
r.D8k
@A_A^A]A\]
|$ UATAUAVAWH
r.D8n
A_A^A]A\]
UATAUAVAWH
r.D8n
@A_A^A]A\]
t$ WH
D$ E3
VAVAWH
|$pu+H
PA_A^^
VAVAWH
|$pu+H
PA_A^^
t$`E3
VWAVH
@A^_^
@SUVWATAUAVH
t#fff
D$,Hk
@A^A]A\_^][
@A^A]A\_^][
@SUVWATAUAVH
D$,Hk
@A^A]A\_^][
@A^A]A\_^][
|$ AVH
L$0H;
\$ UVWH
d$pE3
D8e@uaD
rQD8c
fE9$~u
UVWATAUAVAWH
@A_A^A]A\_^]
@UWATAUAVH
pA^A]A\_]
|$ UATAUAVAWH
A_A^A]A\]
@SUWAVH
hA^_][
t$ WAVAWH
tafA;
@A_A^_
@USVWATAUAVAWH
A_A^A]A\_^[]
SUVWAWH
D$4E3
PA__^][
PA__^][
@SUVWAVH
D$@E3
PA^_^][
PA^_^][
UVWATAUAVAWH
0A_A^A]A\_^]
t7fA;
)D$PE
|$ UATAUAVAWH
A_A^A]A\]
@SVWH
l$ VWAVH
|$ UATAUAVAWH
A_A^A]A\]
VWAVH
L$hfA
@A^_^
@SUWAWH
A__][
t$ WAVAWH
D$ E3
u&D8~
@A_A^_
)D$PH
T$ E3
@USVATAVAWH
A_A^A\^[]
UwD9'tY
A_A^A\^[]
|$ UH
r+@8s
r+@8s
r*@8s
r+@8s
u(@8s
@UVAVH
D$ E3
pA^^]
SWATAUAWH
A_A]A\_[
@UATAUAVH
(A^A]A\]
(A^A]A\]
(A^A]A\]
9D$,t
t$ WH
@USWAVAWH
A_A^_[]
A_A^_[]
t$ WAVAWH
@A_A^_
t$ WAVAWH
D$ E3
@A_A^_
@UWAUH
r.@8w
D$(HcT$pL
r1@8u
VWAVH
D$ E3
@A^_^
|$ AV
D$xE3
WATAUAVAWH
 A_A^A]A\_
fE9.u
|$ AVH
|$(E3
l$ VWATAVAWH
f9,yu
fA9,wu
A_A^A\_^
@SUVWATAVAWH
A_A^A\_^][
|$ E3
D$8E3
D$(E3
D$(E3
WAVAWH
0A_A^_
VWATAVAWH
@A_A^A\_^
l$pE3
sSHcS
SUVWAUAWH
XA_A]_^][
L$4A+
_Pf9C
XA_A]_^][
|$ ATAVAWH
 A_A^A\
H UWATH
8]gt/
t$ WAVAWH
 A_A^_
VWAVH
@A^_^
|$ AVH
|$@fD9c
D$(H;
;D$0s@H
^@fD9c
w#fD9c
t$ WAVAWH
 A_A^_
VWAVH
 A^_^
e$H;X
@USWH
L$ fD
SWATAUAVAWH
8A_A^A]A\_[
l$0D;|$ps
8A_A^A]A\_[
H9~(tN
WAVAWH
A`A+AXLc
~@H;~0tM
u!fA+
H;N0u
A`A+AXHc
 A_A^_
D9G(v%
2D;G(r
t$ WH
;S u8D;C$w2
t$ WH
T$4A;
;L$8r!2
t$ UWAVH
,8\$8t$H
r+8\$8t+H
USVATAUH
A]A\^[]
A]A\^[]
@SVWH
u/8\$(t%H
u+8\$(t!H
D$$E3
T$,fD
t]H;C@tWD
L9AHu<
A@+A 
t$ UWAUAVAWH
D9h,t
H;p s
G +w0
A_A^A]_]
|$ UH
tif9s0tcH
UWAVH
UWAVH
AX+A8
8O<u<
|$ UAVAWH
A_A^]
D$$E3
D$$E3
UAVAWH
PA_A^]
t$ WH
\$8E3
t$ UWAUAVAWH
D$$E3
A_A^A]_]
|$ UATAUAVAWH
A8uAuJM
A8uAu"M
I9u(@
A_A^A]A\]
D$ 9C(tqH
HcCpH
UVWATAUAVAWH
|$4fA
|$0;|$D
D$<fA
l$8fA;
D;l$0
D$<fA
|$8fA
D;l$H
D;l$Hs
D$8fff
D;l$Ds
D;l$0
PA_A^A]A\_^]
L$0H;
ACfff
F$f9C
tLfA;
tFfA;
t fA;
UATAVH
|$0D;
A;^0r
PA^A\]
PA^A\]
A`A+AXHc
u:fA+
A`A+AXHc
|$ UAVAWH
A_A^]
t$09s t
A`+AXHc
B`+BXHc
B`+BXHc
t_fff
@SAVH
{h;{l
{h;{l
UVWATAUAVAWH
G$f9A
@A_A^A]A\_^]
VpfA;Z
9A$u?D
l$ VWAVH
C Hcp
{xH;O
H9khtbH
@A^_^
A`A+AXLc
A`A+AXHc
A`A+AXHc
H;B0t
B@fD9@
H;H r
f99t!H
t$ WATAUAVAWH
G(D9x,tKH
H;X sAH
tQfA+
G(D9x,t
 A_A^A]A\_
D9x,t
H;X r
D88uJ
v-fA;
t$ WATAUAVAWH
D9t$,
H;_8uxA
D9o t8H
A_A^A]A\_
WATAUAVAWH
 A_A^A]A\_
t$ WATAUAVAWH
{XH;{Hu.
 A_A^A]A\_
u$fA;
L$PE9
B`+BXHc
l$HE3
uED9B
tyHcWpH
;C8u=H
d$(E3
L9c0t
A`A+AXLc
A`A+AXHc
UATAUAVAWH
 A_A^A]A\]
L$0t"L
\$ UVWATAUAVAWH
} D;8
} D;8
0A_A^A]A\_^]
WAVAWH
 A_A^_
@USWATAWH
A_A\_[]
 u+8\$(t,H
t$ WH
t$@Lc
L$ SUVWAVH
 A^_^][
 A^_^][
@USVWAVH
D9u@t
T$ E3
PA^_^[]
@USWH
9t$0t
9t$4t
9t$0u
9t$0t
9t$4t
9t$8t
D$0E3
u?9t$0v9
;t$0r
@USWAVAWH
A_A^_[]
T$(E3
fD9$Au
fD9$Su
fD9dC
@u6fD
fF9$Cu
fD9ds
A_A^_[]
A_A^_[]
|$ AVH
UVWATAUAVAWH
D$@E3
PA_A^A]A\_^]
UVWATAUAVAWH
D$PE3
A_A^A]A\_^]
@SUATAWH
(A_A\][
t$ WATAWH
D9{,u
 A_A\_
l$H@2
@$3C$
A1@$A
H$3K$
@SUVWH
|$$A;
\$ WH
@SWAWH
D9{,t=
@A__[
WATAUAVAWH
A_A^A]A\_
A`A+AXLc
t$8E3
t$8E3
t$0E3
A`A+AXHc
D;C,r
D;C,r
D;C0sD
D;C0r
3@8k@t+H
x$@8k@t$H
T$@E3
T$@E3
A+HHL
D;C,r
|$hE3
Mo;C$
D;F,r
t$P@8
BV(D+F
|$8D;
WATAUAVAWH
 A_A^A]A\_
@SVWAVH
D$HE3
A^_^[
@USWH
UVATAVAWH
D$PE3
t{L9|$P
t|L9|$P
 A_A^A\^]
 A_A^A\^]
l$0thH
|$ AVH
9k0vWH
v5fff
@UVAUAWH
xA_A]^]
xA_A]^]
xA_A]^]
@USWH
H9|$Ht
s(H9{ 
9{hv$A
D;Chr
D;Chr
CD tU
D$pf;T$Du
D;D$\t-H
UVATH
D$pA+
t$pHc
fD9tx
UATAUAVAWH
A_A^A]A\]
Hc]HH
Lc}HH
A_A^A]A\]
UVWATAUAVAWH
A_A^A]A\_^]
\$(E3
D$(E3
8\$TtLH
UWATH
VWAVH
t$ ATAVAWH
D$@E3
L$@E3
A_A^A\
@SVWAVH
A^_^[
UVWATAUAVAWH
8D$1t(A
L$0$?
HcD$8H
@A_A^A]A\_^]
VWATAVAWH
HcD$0H
@A_A^A\_^
@SUWH
VAVAWH
 A_A^^
@USVWATAUAVAWH
D$(E3
D$XE3
|$pE3
A_A^A]A\_^[]
UVWATAUAVAWH
D$8E3
H;D$HuGI
H;D$Pt
L$XH3
`A_A^A]A\_^]
UVWATAUAVAWH
A_A^A]A\_^]
T$PE3
D$P;D$Xu_3
;\$Pr
D$(H9
H;D$0uPL
L$8H3
L$8H3
GHt6H
)D$@f
)L$0D
)T$ D
)$$fD
(T$ D
(L$0D
(t$`f
UUUU+
@UVAWH
0A_^]
0A_^]
\$ UVWATAUAVAWH
D$8E3
A_A^A]A\_^]
|$ AVAW
|$0A_A^
WATAUAVAWH
 A_A^A]A\_
8A(tXH
=NOTMu
=MINIu
|$ UH
D$(E3
D$XfE
UVWATAUAVAWH
 A_A^A]A\_^]
|$ AVH
|$ ATAVAWH
 A_A^A\
|$ AVH
t$ UH
\$ WH
|$ AVH
|$ AVH
@8kpt H
@8{pt
UVWATAUAVAWH
tPf9l^
A_A^A]A\_^]
\$ UVWATAUAVAWH
A_A^A]A\_^]
WAVAWH
 A_A^_
 A_A^_
VWAWH
0A__^
t$Xu]D
0A__^
@SUVWAVH
A^_^][
\$ UVWATAUAVAWH
f94Zu
A_A^A]A\_^]
UVWATAUAVAWH
0A_A^A]A\_^]
9D$@u-H
|$ AVAW
|$0A_A^
t$ WATAUAVAWH
@8kpu
 A_A^A]A\_
t$ WH
@SWAUAVAWH
\$Xff
A_A^A]_[
@SUATAUAWH
fD94_u
A_A]A\][
@SUVWATAUAVAWH
A_A^A]A\_^][
fD9$Gu
fD9$_u
\$ UVWH
\$ UVWATAUAVAWH
A_A^A]A\_^]
UAVAWH
A_A^]
K8+K0
t$ WH
E|$PH
UVWATAUAVAWH
A_A^A]A\_^]
t$ AVH
@8kpu
@USVWATAUAVH
Lc}HE
HcuHu0L
@A^A]A\_^[]
EH9E@
@8spt H
t$0E3
WATAUAVAWH
)t$PA
|$8D#
(t$0L
(t$PL
A_A^A]A\_
(t$0E
t$ WAVAWH
T$(E3
ttHcL$`
@A_A^_
L$0E3
L$ E3
@SUVWAUH
T$0E3
@A]_^][
@UWATAVH
8A^A\_]
8A^A\_]
UATAUAVAWH
A_A^A]A\]
UVWAVAWH
L$pH3
A_A^_^]
|$ AVH
9\$<u
9\$Xu
D$0E3
@SUVWATAW
)D$0E;
A_A\_^][
@UVAUAVAWH
0A_A^A]^]
t$ A;
9|$hu
0A_A^A]^]
WATAUAVAWH
|$ E3
@A_A^A]A\_
@VAUH
VWATAUAWH
 A_A]A\_^
f9A8u
UVWATAUAVAW
L$8E3
H9\$8
A_A^A]A\_^]
WATAUAVAWH
\$0E3
@A_A^A]A\_
WAVAWH
l$ E3
0A_A^_
t$ E3
SUVATAUAVAWH
H;t$ t
@A_A^A]A\^][
SUVAUAVAWH
L$ E3
s fff
L$0fff
H;\$ t
HA_A^A]^][
UVWATAUAVAWH
)D$PH
(t$@H
t$PE3
(t$`H
pA_A^A]A\_^]
t$ WH
x2H9\$0u+H
9t$Xt
@SUVWAV
D$@Ic
L$8E3
xFH9\$8u?H
D9|$0u
A^_^][
|$ ATAVAWH
|$ E3
0A_A^A\
|$ E3
|$ AVH
WATAUAVAWH
L$8E3
xGH9\$8u@I
9l$0u
@A_A^A]A\_
|$ AVH
l$ E3
t$ WH
L$@E3
xGH9\$@u@H
9t$Hu
\$ WH
T$0E3
\$ UVWATAUAVAWH
f94Zu
A_A^A]A\_^]
@SUVWATAVAWH
A_A^A\_^][
@SUVWATAUAVAWH
A_A^A]A\_^][
9\$Xu
@SUWAVAWH
 A_A^_][
USVWATAUAVAWH
L$8E3
|$@E3
t$,E2
L$h+D$,A
D$ I;
T$0E;
A_A^A]A\_^[]
|$ UATAUAVAWH
A_A^A]A\]
|$ UATAUAVAWH
A_A^A]A\]
@SUVWAUAVH
T$ ff
Et$(H
T$0E3
L$`H3
xA^A]_^][
@USVWAUAWH
D$@E3
L$ E3
L$@E3
A_A]_^[]
@SUVWATAVAWH
t$@E3
D$P9C
t$(E3
t$8E3
A_A^A\_^][
@UWAUH
|$ H;
T$hE3
L$`H;
T$hH;|$p
@A]_]
t$ WATAUAVAWH
D$$&inF
D8)uN
L$0H3
A_A^A]A\_
9BSJBH
d$0E3
VWAVH
 A^_^
|$ AVH
|$ AVH
UAVAWH
t$pD;
A;^0r
@A_A^]
@A_A^]
UAVAWH
L$0M;
`A_A^]
VATAVH
D$ M;
T$ Hk
D$ Hk
`A^A\^
|$ AVH
UVWATAUAVAWH
 A_A^A]A\_^]
UVWATAUAVAWH
|$ M;
|$xE3
|$ M;
0A_A^A]A\_^]
UVWATAUAVAWH
|$ M;
D$XfA
|$ M;
|$ fE
A_A^A]A\_^]
UVWATAUAVAWH
 A_A^A]A\_^]
WATAUAVAWH
 A_A^A]A\_
L$ UVWATAUAVAWH
L$`H;
 A_A^A]A\_^]
L$ WATAUAVAWH
\$PHk
 A_A^A]A\_
t$ WATAUAVAWH
D$PH;
 A_A^A]A\_
UVWATAUAVAWH
@A_A^A]A\_^]
|$ UATAUAVAWH
A_A^A]A\]
|$ UATAUAVAWH
A_A^A]A\]
@SUVWATAUAVAWH
T$0H+
L$hL;
L$xH3
A_A^A]A\_^][
|$ AVH
|$ ATAVAWH
 A_A^A\
|$ AVH
@UVAVAWH
D$ fD
D$(H;
A_A^^]
@SUVWAVH
A^_^][
|$ AVH
G(+G 
t$ WH
l$@+C
t$Hu1
WATAUAVAWH
A_A^A]A\_
f9<^u
f9<^u
d$ Ic
@84)u
@84+u
WAVAWH
 A_A^_
L$0H3
H+D$ u
H+D$(3
L$0H3
L$0H3
fA!F$A
A8<(u
Fh+F`
F`H9~Xu
|$ AVH
s3fA;
B fE;
s4fA;
B fE;
s]fA;
fA;q4s)
fE;A4r
s2fA;
W fD;
W fD;
fA;p4s
fA;P4r
WAVAWH
\$HfD
PA_A^_
WAVAWH
\$HfD
PA_A^_
VWAUAVAWH
0A_A^A]_^
t$ WH
@SAWH
l$(f;^ H
I"fD;
tAfD;I s:H
f;_ sdM
@ A+@
+D$ H
F fA;
D$ +D$(A
fD94^u
l$0Lc
\$(M9t$
fE94_u
l$0Lc
fD94Xu
D$ A+
l$0Lc
D$ +D$(A
@SVWH
SUVWAVH
D$8H;D$P
u'fA;
A^_^][
t$ WAVAWH
90uKH
 A_A^_
t$ WH
)D$ H
UVAUH
L$xE3
E|$xD
PA]^]
PA]^]
WAVAWH
 A_A^_
t$ WATAUAVAWH
fD;i 
W&fA;
V&fA;
n8fD9t$Bun
t"fA;
T$JfA;
L$8E3
L$PH3
A_A^A]A\_
d$8Lc
L;l$0
|$ AVH
@SUVWH
thD8f@u
tHD8f@u
X_^][
X_^][
@SUVWAWH
@A__^][
L$*A+
@A__^][
UVWATAUAVAWH
A_A^A]A\_^]
t$ WATAUAVAWH
0A_A^A]A\_
USATI
L$XE3
(D$pf
D9{(udL9s
u^H9s
|$XE3
(D$pH
(D$pf
D$D9C(ucL9{
u]L9s
(D$Pf
D$Pf;
USVWATAUAVAWH
;fD!c$D
Gh+G`
F f3B$f
D9}Pt'H
L9;u'L
xA_A^A]A\_^[]
@USVWATAUAVAWH
D$(E3
A_A^A]A\_^[]
l$@H9
H9t$@uJ
VWAVH
 A^_^
A8^@u
t79t$`u1H
t59\$hu/H
@8o@u
tD@8o@u
@8o@u
u"@8o@u
t$P@8o@u
@SVWH
UATAUAVAWH
 A_A^A]A\]
M9,$u
 A_A^A]A\]
@SUWAUAWH
(D$ f
|$ 9k(u
A_A]_][
UATAWI
D$8Ic
f3F$f
D$8+D$@
t$@Lc
H;t$p
A_A\]
UVWAVAWH
 A_A^_^]
 A_A^_^]
f;A s 
fA;A r
t$ WATAVH
 A^A\_
tHH9\$0tA
tHH9\$0tA
@UVWATH
hA\_^]
UVWATAUAVAWH
f;S$u
@A_A^A]A\_^]
l$0f;{4vUH
t$ WH
|$ AVL
|$(A^
u<D;K
|$(A^
t$ WAVAWL
u>D;W
t$8A_A^_
|$ AVH
t6f;q s0H
f;Q s|H
t$ WH
@UAVH
A fD9
\$XI;
l$hH;
T$HfD;
f;{4v<H
D$0Hc
fD;e 
D$8+7;
D$HfA
E fD;
|$ AVH
+.tXL
f;Q swH
f;Q swH
f;Q s|H
(D$ H
t$ WH
UVWATAUAVAWH
 A_A^A]A\_^]
WATAUAVAWH
 A_A^A]A\_
UVWATAUAVAWH
@A_A^A]A\_^]
9_0vWH
@SUATAWH
XA_A\][
XA_A\][
@SUVWAVH
A^_^][
D$, t2
D$, t2
f9APu0
HcD$0H
t$ WATAUAVAWH
L$RD9
GX+GP
GX+GP
GX+GP
O fA;H s
 A_A^A]A\_
L$xE+
D$PA;
D$PHk
D$PHk
D$PHk
D$PHk
F@+F8
d$ptaA
l$0E3
D$XE9F
D$XA;F
@WAWH
H9\$X
|$ ATAVAWH
 A_A^A\
@SUVWAVH
0A^_^][
0A^_^][
D$(D+D$ H
@USVWH
X_^[]
tgfD9g
K fA;J s
X_^[]
C fA;B s
t$ WAVAWH
A_A^_
\$ UVWAVAWH
fA;@ s
f94_u
A_A^_^]
A fA;C sRD
@UVWATAWH
Q fA;
E9`0tlH
G f;B s
D;B,|VI
W fA;P s
IcA,H
fA;P s
W fA;P s
A_A\_^]
@SUVWAVH
f;B s
f9<Cu
A^_^][
@SVWH
@SVWH
C f;B s#
C f;B s
l$ VWAVH
UVWATAUAVAWH
v4fff
 A_A^A]A\_^]
t$ WAVAWH
D8t$HtM3
 A_A^_
|$ ATAVAWH
t,9_0v
 A_A^A\
VWATAVAWH
|$0H;
L$HH3
A_A^A\_^
L$ USATH
D9y0u@
AX+AP
KPL9{Hu
L99u7
D9y0u
KX+KP
C f;B s
L$@H3
C f9APu
D$8E3
L$@H3
UVWATAUAVAWH
G f;B s
L9_(toI
L9_(tlH
l$LfA
D$PfE9V
l$|fA
A_A^A]A\_^]
@USWAUAVH
PA^A]_[]
PA^A]_[]
|$ AVH
\$ UVWATAWH
A D+yx
T$hfA;A s
0A_A\_^]
T$`E3
t$pf;B s
f3O$f
f1O$H
0A_A\_^]
|$ AUAVAWH
EXA+EPA
I9}Hu
EXA+EPA
MPI9}Hu
 A_A^A]
VWAVH
C f9AP
C f9APuvH
0A^_^
t$ WAVAWH
T$XE3
0A_A^_
fD;B 
P fA;
A9y(~pfA;
H9{Hu
Hcr(H
fD;B s
fD;B s
f9D$"t
L$0H3
@SWAVH
Y fE;
t$xf9Z&u
R(fE;
@A^_[
|$0Lc
P fA;
a(fA;
Y,fA;
t99t$`u3I
@A^_[
@USAVH
I94$u
F f;B s
A+<$I
A1F8A8O
A1F8A8O
A1F8H
UVAUAWH
XA_A]^]
t$PE3
XA_A]^]
XA_A]^]
VATAUAWH
Q fA;
fA9@&u
xA_A]A\^
t$`L9?
F f;B s
D$ E3
xA_A]A\^
UVATAWH
Q fA;
fA9@&u
A_A\^]
L$HfA;
\$H+|$HL
T$0E3
A_A\^]
VWAVH
9\$Pt
0A^_^
f;A s
|$`A98A
9|$`u
@UWATH
pA\_]
pA\_]
|$ UATAUAVAWH
P fA;
T$ fA;P s
D$ f;B s
B09D$P
HcD$P
L$HE3
L$XfE;}
L$XE3
|$(E3
A_A^A]A\]
t$ WH
BL$hD
D$4E3
D$0E3
L$0+L$4t
UAVAWH
t$pD;
A;^0r
@A_A^]
@A_A^]
@VWAWH
 A__^
@8w8t
 A__^
\$ VH
HcD$(B
HcD$(
|$(E3
A fA;@ s
WAVAWH
 A_A^_
9_0vWH
9_0vWH
@SUWAWH
(A__][
(A__][
WATAUAVAWH
D;L$p
;\$ps8D
 A_A^A]A\_
|$ ATAVAWH
0A_A^A\
t:9}gu5H
u.H9uwu(H
WATAUAVAWH
A_A^A]A\_
t$ AVH
s WATAUAVAWH
A_A^A]A\_
tUD8(tPH
l$0E3
t$ WATAUAVAWH
t2fff
A_A^A]A\_
SAUAVH
A^A][
9l$@u'
D9t$@u#
|$$H9
D$0@8
|$ 9D$Xu/
|$ D9
|$ AVH
@SUVWATAUAVAWH
f94Zu
A_A^A]A\_^][
wCt-=\
t$ WAVAWH
D8t$HtM3
 A_A^_
t$ WAVAWH
D8t$@tH
 A_A^_
L$8D+L$0A
@USVWATAUAVAWH
xA_A^A]A\_^[]
l$ WH
D$PD;
w3fA+
w8fA+
UATAUAVAWH
Exf9x
tP9\$\t
D$8H;D$Pr
L$xH;M
A_A^A]A\]
@SAVH
T$ E3
HcD$pH
T$ E3
HcD$@H
WAVAWH
0A_A^_
VWAVH
0A^_^
UAVAWH
t$pD;
A;^0r
@A_A^]
@A_A^]
UAVAWH
t$pD;
A;^0r
@A_A^]
@A_A^]
SUVWATAUAVAW
T$TH;
T$XA3
T$TH;
T$XA3
    3
A_A^A]A\_^][
VWAVH
 A^_^
@USVWAWH
D$\E3
D$(E3
\$PM;
l$XE+
d$dE3
T$@E3
T$8E3
|$`MPDB
A__^[]
|$0=NB10u7I
2=RSDSuQI
@SUAVH
\$XH+
@SUWH
UVWATAUAVAWH
D$pI+
A_A^A]A\_^]
@SUVH
f9D$@
L$pH3
UVWAVAWH
fD9t$`u
D$8E3
A_A^_^]
t$ WH
D$8E3
l$ VWATAVAWH
A_A^A\_^
H;D$`
t$ WH
D$0=NB10t
=RSDSu
\$`E3
D$ E3
t$8E3
L$hE3
|$ AVH
@SUWAVAWH
A_A^_][
@SUVWAUAVAWH
D8|$Ht7
A_A^A]_^][
UVWATAUAVAWH
D$(E3
A_A^A]A\_^]
VWAVH
(D$ H
u0H9t$Pt)
0A^_^
D$(E3
@SUVWATAUAWH
T$xL+
tPH9/u,H
D$xH+
u(H9D$pt6H
0A_A]A\_^][
T$ E3
@SAWH
@UWAVAWH
(A_A^_]
(A_A^_]
(A_A^_]
|$ ATAVAWH
 A_A^A\
@VAUAVAWH
(A_A^A]^
(A_A^A]^
(A_A^A]^
@VAUAVAWH
(A_A^A]^
d$ H;
(A_A^A]^
(A_A^A]^
H;Q v
|$ AVH
@SVWH
T$PHc
T$PHc
T$PHc
T$PHc
UVWATAUAVAWH
D$(H;
H;|$(
0A_A^A]A\_^]
|$ AVH
|$(H;|$@sPH
\$(H;\$@r
t$ WAVAWH
 A_A^_
@SUVWATAUAVAWH
A_A^A]A\_^][
@SUVWATAVAWH
A_A^A\_^][
ATAUH
|$@fff
HA]A\
HA]A\
HA]A\
ATAUH
D$(L;
D$ L;
t$Hff
UVWATAUAVAWH
l$pM;
 A_A^A]A\_^]
SUVWATAUAVAWH
l$ M;
8A_A^A]A\_^][
|$ ATAVAWH
A_A^A\
{Hf!CP
t$ AWH
USVWATAUAVAWH
@8}gtH3
f;p r
A_A^A]A\_^[]
@UVWAUH
HcD$$
fA9D$
d$PA;
t$:fA
t$@fD
A]_^]
)D$@f
)L$0D
)T$ D
)$$fD
(T$ D
(L$0D
(t$`f
UUUU+
l$0D;
L$ UVWATAUAVAWH
tA@8t$pu:@8
0A_A^A]A\_^]
@VATAVH
f9,^u
A^A\^
UVWATAUAVAWH
G(f;H 
fA;I 
HcD$$
Lcd$$L
l$XL9l$Hu
fA;A 
f;H I
A_A^A]A\_^]
WATAUAVAWH
 A_A^A]A\_
t$ WH
t,H9P
l$ VWATAVAWH
t3f9k
@A_A^A\_^
t$ WAVAWH
HcD$ 
9w`v(
*D;G`r
H;w`r
A_A^_
|$ AVH
@SVWH
t$ WATAUAVAWH
r`wmL
 A_A^A]A\_
\$ WH
L$ E3
+|$@D
l$ WATAWH
 A_A\_
v4fff
L$@H;
D$`+D$hA
+|$`A+
E0L9<
D$`+D$hA
L9|$`u
A H+A
l$ VWAVH
 A^_^
 A^_^
 A^_^
 A^_^
VWATAVAWH
}AfD;
 A_A^A\_^
?I;<$w
H;;t_r
UVATAUAVAWH
D;fx~
H9^hu
8A_A^A]A\^]
8A_A^A]A\^]
UVWATAUAVAWH
EL$ 3
A_A^A]A\_^]
WAVAWH
0A_A^_
UVWAVAWH
 A_A^_^]
 A_A^_^]
H9l$Xt#H
T$XE3
 A_A^_^]
 A_A^_^]
WATAUAVAWH
t$ H;
0A_A^A]A\_
L$8H3
l$ VWAWH
0A__^
@SVWAWH
Hcl$HH
;D$L|^H
L$PH3
xA__^[
VWAVH
0A^_^
0A^_^
0A^_^
0A^_^
l$(E3
D$`9A
D$`A;G
t$ WH
@SUVWATAUAVH
A^A]A\_^][
@SVAUH
pA]^[
D$0+D$8
pA]^[
l$ VH
D;A8s
D;A8s
D;K8r
D;Q8r
t$ A^
t$ A^
@SAVH
UWAVH
 A^_]
 A^_]
t$ WAVAWH
D8t$HtH3
 A_A^_
WAVAWH
 A_A^_
SUVWATAUAVAWH
A f;B s
C f;B s
A+N8E3
HA_A^A]A\_^][
@USVWATAWH
L9/uNL
A_A\_^[]
t$ WAVAWH
A_A^_
D$x@8x8u
HcD$h@8<
VWAWH
pA__^
D$h@8x8u
HcD$X@8<
pA__^
@SUVWAUAWH
HcT$0L
D$x@8x8u
HcD$h@8<
A_A]_^][
@SUVWH
8_^][
8_^][
UAVAWH
t$pD;
A;^0r
@A_A^]
@A_A^]
WAVAWH
 A_A^_
UVWATAUAVAWH
D$pD+d$ D
0A_A^A]A\_^]
|$ AVH
|$ AVH
|$ AVH
WATAUAVAWH
L9i0u
P$;S$
P(;S(
tUfff
 A_A^A]A\_
@SUVWH
@SUVWAVH
A^_^][
@SUVWAVH
A^_^][
@SUVWAVH
A^_^][
@SUVWAVH
A^_^][
\$ UVWAVAWH
A_A^_^]
@SUVWATAVAWH
A_A^A\_^][
HcC<H
P$HcC<H
WAVAWH
 A_A^_
UVWATAUAVAWH
X IcD$<M
tNy)D
0A_A^A]A\_^]
HcC<H
VWAWH
IcF<I
 A__^
|$ AVH
IcB<B
HcA<L
t&fA9Q
HcA<H
IcI<M
IcA<H
W IcA<B
O$IcA<B
_(IcA<B
X HcG<L
l$ VWATAVAWH
f9|FBH
A_A^A\_^
|$ AVH
HcF<H
l$ VWATAVAWH
HcC<H
A_A^A\_^
HcB<L
t/fA9A
HcA<H
t$ WH
t$ WATAUAVAWH
D$PA+
 A_A^A]A\_
WAVAWH
A+7t'
 A_A^_
t$ AVH
WAVAWH
 A_A^_
l$ VWAWH
G@+G8
G@+G8
G@D+G8H
G@;G8x
Gp+Gh
GpD+GhH
Gp;Ghx
0A__^
WAVAWH
 A_A^_
@WAWH
AP;AHx
VWAVH
 A^_^
|$ AVH
SVWAVH
8A^_^[
WAVAWH
\$8H;
A_A^_
WAVAWH
0A_A^_
|$ AVH
|$ AVH
@SUVWAVAWH
A_A^_^][
{ AVH
{ AVH
pKSr*>i
UWATAVAWH
L$ E3
A_A^A\_]
t$ WH
t$ WH
VWATAVAWH
 A_A^A\_^
@USVWATAUAVAWH
T$`H;
L$`H;T$`sA
H+T$X
D8l$xt
A_A^A]A\_^[]
UATAUAVAWH
@8|$x
@8|$xt
A_A^A]A\]
UATAUAVAWH
A_A^A]A\]
x AVH
t$ UWATAVAWH
D$XSHEXH
D$\SHDRH
H+|$HH
A_A^A\_]
VWATAVAWH
RDEFH
PCSGH
PSG1H
ISGNH
ISG1H
OSGNH
OSG5H
OSG1H
LFS0H
ILDNH
IFCEH
Aon9L
XNAPI
XNASI
A_A^A\_^
WAVAWH
0A_A^_
@USVWAVH
@A^_^[]
XFt9=
PLt2=
VLt+=
XTt$=
pqSz@
S2$/H
\$ UVWH
DBUGL
L$hH3
VWAVH
D$xSDBGH
D$xSPDBH
\$ E3
D$hSHEXH
D$lSHDRH
@A^_^
H!|$`H
xturH
UVWATAUAVAWH
\$PE3
D9d$Dv
D;t$Dr
A_A^A]A\_^]
L;T$X
\$@I+
H9^Pt&E
8\$@u
UVWATAUAVAWH
|$xD8y
D9p$t
PLtw=
VLtg=
XTtK=
D$pL;
<$TEXTu^3
L$JfD
w|tYA
0wjt\A
Jwjt\A
Uwjt\A
D$@@2
D85E)-
d$@E3
E94$L
A_A^A]A\_^]
WATAUAVAWH
CTABH
D$`H;
rTH;L$`sMD
|$XE2
D$P;F
H;l$`
D$(fI
A_A^A]A\_
UVWATAUAVAWH
(D$`H
D$(E3
A_A^A]A\_^]
L$ UVWATAUAVAWH
PA_A^A]A\_^]
8\$pt%M
8\$hu
8\$hu29\$`vGH
;\$`r
UVWATAUAVAWH
(s>E3
(s>E3
A_A^A]A\_^]
UVWATAUAVAWH
d$QI9n`u
I9nPtE@8k
l$HE3
l$@E3
l$@E3
L$P@2
l$@E3
I9V`u
I9VPt1E
I9VPH
`A_A^A]A\_^]
UVWATAUAVAWH
D$pM9
D9D$huJ@
D9D$Hu7E
pyQVr
p`Tr5
pJYTn
D9D$H
9D$tt
fE9DE
T$PL+
A_A^A]A\_^]
\$ UVWATAUAVAWH
t2;N$sEL
;^Ds+A
D$8;D
D$8Hk
A_A^A]A\_^]
UWATAVAWH
9}@tPH
p1WzI
A_A^A\_]
UVWATAUAVAWH
D$PD9t
A_A^A]A\_^]
\$ UVWATAUAVAWH
|$0f;~
D$HE;
f;~ sI
L$pH3
A_A^A]A\_^]
WATAUAVAWH
D$(fI
A_A^A]A\_
PRESH
D$hE3
;\uyH;
WAVAWH
t$ E3
0A_A^_
WAVAWH
0A_A^_
UVWATAUAVAWH
phT0~
psZ^n
T$pE3
T$xE3
D!d$hE3
D$pD8o$uc
A_A^A]A\_^]
UVWATAUAVAWH
        
        
`A_A^A]A\_^]
L$@H3
CLITH
UVWATAVH
PA^A\_^]
@USVWATAUAVAWH
pzR0-
hA_A^A]A\_^[]
UATAUAVAWH
pI]T/
pI]T/
A_A^A]A\]
UVWATAUAVAWH
PA_A^A]A\_^]
UATAUAVAWH
L;}'r
A_A^A]A\]
L$ E3
@USVWATAVAWH
A_A^A\_^[]
x AVH
x ATAVAWH
 A_A^A\
UVWATAUAVAWH
D8t$ht
D$@E3
L$Pv4H
phUX!
D$xE3
A_A^A]A\_^]
UVWATAUAVAWH
\$0D9{
A_A^A]A\_^]
UVWATAUAVAWH
`A_A^A]A\_^]
UVWATAUAVAWH
A_A^A]A\_^]
WATAUAVAWH
D$HE3
A_A^A]A\_
UATAUAVAWH
A_A^A]A\]
WAVAWH
@A_A^_
UVWATAUAVAWH
pA_A^A]A\_^]
UVWATAUAVAWH
A_A^A]A\_^]
H UATAUAVAWH
A_A^A]A\]
x AVH
L$`E3
VWAVH
0A^_^
VWATAVAWH
 A_A^A\_^
WATAUAVAWH
0A_A^A]A\_
WAVAWH
0A_A^_
VWAUAVAWH
!|$09
D$@;h
\$0D;
A_A^A]_^
x AVH
x AVH
t}A9H
CTABL
UVWATAUAVAWH
D$(@2
D$(E3
D$ E2
t$@D;t$h
A_A^A]A\_^]
UVWATAUAVAWH
`A_A^A]A\_^]
9{,vj
9{Lv^;{Ls
t@;{Ls
{t@8{xt
{\@8{`t
WATAUAVAWH
t$pM+
 A_A^A]A\_
t$ WH
t$ WH
t$ WAVAWH
 A_A^_
WAVAWH
u/;o\s
2;o\s
";o\s
 A_A^_
WAVAWH
 A_A^_
WAVAWH
 A_A^_
qCX4r
qCX4r
qCX4r
WAVAWH
 A_A^_
WAVAWH
 A_A^_
UVWATAUAVAWH
A9_Lu-I
D;f,s
t7A9^4u
g@E;wL
F,A9E,t
A;m,s
A A9B u I
PA_A^A]A\_^]
_ D;G,s
WATAUAVAWH
A;n,s
A_A^A]A\_
WAVAWH
;\$xsWH
A_A^_
WAVAWH
;\$xshH
A_A^_
WAVAWH
;\$xsWH
A_A^_
WAVAWH
;\$xsqI
A_A^_
UVWATAUAVAWH
]XD9g,
D;g,s
T$,A;
E;t$,s
E9t$,
E;t$,s
E;t$,
A;ELs
D;oTs
uX9_,v]A;\$
E@A;D$,s
eXE;eTs
E@A;D$,
A_A^A]A\_^]
` UAVAWH
A_A^]
UAVAWH
RDEFH
A_A^]
UVWATAUAVAWH
D;|$d
;T$0s
;T$0s
A_A^A]A\_^]
t$ WATAUAVAWH
L$0@:
A_A^A]A\_
L$ E3
USVWATAUAVAWH
A8_8u
A8\$8u
EPD;h,|
E;|$,|
EPD;h,s
E;|$,s
8X8u*8X9u%A
A8\$8u,A8\$9u%A
H9]xt$L
mHD8m
D$`D;P
EX9B8uaI
Ep9B8uEA
A;Fds
A;D$ls
A;GTs
hA_A^A]A\_^[]
WAVAWH
;|$hI
 A_A^_
WAVAWH
0A_A^_
x ATAVAWH
O D;E,sdI
0A_A^A\
\$ UVWATAUAVAWH
D$X@8
D$4A;D$
v@I9?t2I
A;ELs
A_A^A]A\_^]
WAVAWH
|$ *K
@A_A^_
` UAVAWH
d$ *C
@A_A^]
WAVAWH
@A_A^_
x AVAWM
|$0A_A^
` UAVAWH
0A_A^]
x AVH
WATAUAVAWH
0A_A^A]A\_
L$0!D$(H
L$PH3
L$0!D$(H
L$PH3
L$0!D$(H
L$PH3
L$PH3
L$PH3
L$PH3
x AVH
x AVH
\$0E3
\$ E3
\$ E3
\$ E3
gsnIc
8gtSE9
x AVH
?_u<3
UVWATAUAVAWH
)D$PD;
D$8D;
D$8D;
A_A^A]A\_^]
UVWATAUAVAWH
)D$PD;
T$xD;
(D$PD;
A_A^A]A\_^]
UVWATAUAVAWH
L$8D;
(D$ A
D$ D;
A_A^A]A\_^]
UATAUAVAWH
)L$@D;
T$0D;
(D$@H
(D$ A
L$ D;
T$@E3
A_A^A]A\]
T$PE3
9kDva
H9)tA;{Ds
kD@8kHt
SUVWATAUAVAWH
8A_A^A]A\_^][
WAVAWH
(D$0H
@A_A^_
x AVH
t$ WH
t$ WH
t$ WH
VWAVH
 A^_^
t$ WAVAWH
 A_A^_
VWAVH
 A^_^
t$ WH
t$ WH
t$ WH
VWAVH
 A^_^
x AVH
x UATAUAVAWH
D8I(v+E
D:I(r
A;Els
8PHu$
H@8Q9
AHD9X
Q@D;J
t<D8W
A_A^A]A\]
x UATAUAVAWH
vRD8o
A_A^A]A\]
fD9n 
D;B\s
D;B\s
D;B\s
E;4$s
D9olv!D;ols
E;4$s
E;}Tr
wEE;UTs
A;uls
A;uTs
E9,$v
E9,$v
ChD9h
B4;Als
J@D9Y
x UATAUAVAWH
A;|$<s
l$`A;t$<s
A9D$l
A9D$T
D;@ts
A_A^A]A\]
u*D:I
UVWATAUAVAWH
A_A^A]A\_^]
USVWATAUAVAWH
GhD9h
OhD9i
OhD9i
A@D9P
9Z$vN;
XA_A^A]A\_^[]
VWATAVAWH
0A_A^A\_^
@SUVWAVH
A^_^][
@SUVWAVH
A^_^][
t$ WH
UVWATAUAVAWH
L$(E3
JHD9y
ChD9`
D8d$T
ChD9`
A_A^A]A\_^]
UVWATAUAVAWH
D$`H9D$P
LcD$pH
D$`H9D$P
Lcd$pH
D9l$@v
SHEXD
A_A^A]A\_^]
UVWATAUAVAWH
Et$H3
K"9t$4u
pA_A^A]A\_^]
UVWATAUAVAWH
A_A^A]A\_^]
@USVWAVH
8\$!u
A^_^[]
UVWATAUAVAWH
0A_A^A]A\_^]
SUVWATAUAVAWH
D$4D9
L$0M+
D$0L+
XA_A^A]A\_^][
UVWAVAWH
STATI
SFI0A
A_A^_^]
@SUVWH
@SUVWAVH
A^_^][
\$ UVWH
\$ UVWH
\$ UVWH
|$ UAUAVH
A^A]]
UVWATAUAVAWH
0A_A^A]A\_^]
UVWATAUAVAWH
0A_A^A]A\_^]
UVWATAUAVAWH
T$xL!d$hH
D$XD!d$HL
D!d$PH
L!d$XH
D$`E3
L!d$ H
D!l$DD;
D8l$@t3A
RDEFI
A_A^A]A\_^]
t$ WH
t$ WH
UVWATAUAVAWH
L$@A;
CHD8X2
T$1D:S(
D8\$2tLH
GhD9X
uAL9_xt;H
D8\$0t
T$4D;
A_A^A]A\_^]
t$ WH
t$ WH
t$ WH
UVWATAUAVAWH
\$ E3
\$ E3
0A_A^A]A\_^]
h AVH
D8D$`u
L$ SVWH
UVWATAUAVAWH
A;N vDH
A;F4t/H
A;F,w
F,A;FHt5A;FLt/H
FX;CX
F\;i,s
s}A;u
@A_A^A]A\_^]
Aon9E3
Aon9H
A;@,s
x ATAVAWD
|$8A_A^A\
A;@,s
D;@ts
8D$(t
UVWATAUAVAWH
H9_Pt L
H9YHu
A88XDu
WhH9YH
p$D;v
v#D8~
PA_A^A]A\_^]
SUVWATAUAVAWH
l$0;i
s(C8\
l$0u0H
HA_A^A]A\_^][
v&@8k
(D$ D
l$xE3
D!T$0
D!T$4
D$$fD
v&D8S
(D$ E3
WAVAWH
0A_A^_
x AVH
t$xE3
l$pD8
v&D8W
(D$ E3
VWATAVAWH
0A_A^A\_^
=SFI0tI=RDEFtI=STATtB=CRPTt;=SHEXt
SFI0A
UVWATAUAVAWH
L$`H;
GP;pt
D$pD8o
t:D8o
t$PL+t$XI
D$`H9D$P
H+D$XL
SHEXL
A_A^A]A\_^]
UATAUAVAWH
A_A^A]A\]
\$ UVWAVAWH
A_A^_^]
x AVH
WATAUAVAWH
 A_A^A]A\_
@SUVWATAVAWH
D$HIc
L$HH3
PA_A^A\_^][
VWAVH
0A^_^
l$ VWATAVAWH
 A_A^A\_^
E;~@v.A8~Iu
USVWATAUAVAWH
v,E8l$
k,E;n
D;C,s
1E9oD
E;oDs
hHE;E,s:I
A9A,t:I
E;a,s
C$9F,t6M
u5D;C
C,9F4u'
C49F<u
SHEXH
SHDRH
RDEFH
EgA;A
A;zts
E;Bts
A_A^A]A\_^[]
t$ WATAUAVAWH
H!l$HL
t$@D;
A;N vBH
A;F,v=A
L$PH3
A_A^A]A\_
r;w23
r9w03
rowfH
UVWATAUAVAWH
PA_A^A]A\_^]
x AUAVAWH
(t$@L
(|$0I
A_A^A]
@USVWATAUAVAWH
L$pE3
A_A^A]A\_^[]
A;P r
VWAUAVAWH
A;E w
\$ H;
E;M r
L$@H3
A_A^A]_^
x AVH
UVWATAUAVAWH
\$xE3
T$HL#
L$0E3
!\$tE3
A_A^A]A\_^]
t$0E3
SUVWATAUAVAWH
L$ E3
A_A^A]A\_^][
WAVAWH
0A_A^_
UVWATAUAVAWH
L$pH!]
D$`E3
D$`E3
D$pE3
A_A^A]A\_^]
WATAUAVAWH
0A_A^A]A\_
;w't9
zwLtF
sw$t?
t$ WATAUAVAWH
A_A^A]A\_
T$0E3
@USVWATAUAVAWH
A_A^A]A\_^[]
x ATAVAWH
rZA;@
0A_A^A\
@USVWATAUAVAWH
A_A^A]A\_^[]
WATAUAVAWH
|$,E3
D9C v'H
D;C r
A_A^A]A\_
@USVWATAUAVAWH
!t$`M
D$`E3
|$TE3
D;\$Ts.E3
D;W s H
tdL;T$XtSA
A;P s'I
|$` r
A_A^A]A\_^[]
@USVWATAUAVAWH
!\$DA8X
D$DE3
|$D r
A_A^A]A\_^[]
\$ UVWATAUAVAWH
A_A^A]A\_^]
WAVAWH
rWA;@
0A_A^_
WATAVH
C(H98u
A9@@v
 A^A\_
A;P r
SUVWATAUAVAWH
A9] v%I
A;} r
XA_A^A]A\_^][
E 9A 
Hcl$4
E9E v
E;E r
H WATAUAVAWH
tyr~D
0A_A^A]A\_
UATAUAVAWH
(t$`L
(|$PI
A_A^A]A\]
UVWATAUAVAWH
|$ M;
H9EHt
PA_A^A]A\_^]
UVWATAUAVAWH
MHs<I
H9]Hu
H9]Hu
PA_A^A]A\_^]
t$ WH
t$ WH
t$ WH
UVWATAUAVAWH
t09] v+H
 A_A^A]A\_^]
tSA9|$
u8A9|$
wfA9|$
@USVWATAUAVAWH
A_A^A]A\_^[]
x ATAVAWH
 A_A^A\
WAVAWH
 A_A^_
@USVATAUAVAWH
t$4D;t$8
A_A^A]A\^[]
x AVH
@USVWATAVAWH
D;t$@sCE
A_A^A\_^[]
@SUVWAVH
A^_^][
USVWATAUAVAWH
6H;]Pu
2H;]Pu
HA_A^A]A\_^[]
UVWATAUAVAWH
@A_A^A]A\_^]
VWATAVAWH
 A_A^A\_^
UVWATAUAVAWH
D9\$Pt
H9|$Xur
H9|$Xu
H9|$X
t$@E3
tcD9X
A_A^A]A\_^]
T$ E3
L$`H3
WAVAWH
 A_A^_
D9A v
E;Q r
E;H r
WATAUAVAWH
0A_A^A]A\_
A8H9A0
x ATAVAWH
0A_A^A\
x AVH
@USWATAUAVAWH
|$|E3
|$pD;
|$@D;
A_A^A]A\_[]
USVWATAUAVAWH
wNtFA;
D;|$t
A_A^A]A\_^[]
x AVH
H WATAUAVAWH
t$DA;
A_A^A]A\_
H WATAUAVAWH
A_A^A]A\_
t$ WH
D$hE3
WATAUAVAWH
0A_A^A]A\_
\$ UVWATAUAVAWH
L$`H3
pA_A^A]A\_^]
VWATAVAWH
sMA;w
uJA;w
A_A^A\_^
WAVAWH
;{ sQH
 A_A^_
WATAUAVAWH
A_A^A]A\_
;{ s4H
WAVAWH
sMD8~Hu1H
D8~HuCH
D;s sDH
;k s,H
$0< u
;s s@H
 A_A^_
t$ WATAUAVAWH
@@A9D$@sXA
D;|$Ls
@@A9D$@s9H
A_A^A]A\_
w<teA
w(tX-
wKt -
p WATAUAVAWH
|$h;{0vkH
H!s8H
0A_A^A]A\_
USVWATAUAVAWH
H;F uDH
b(D;u
A_A^A]A\_^[]
x ATAVAWH
 A_A^A\
VWATAVAWH
 A_A^A\_^
t$ WATAUAVAWH
0A_A^A]A\_
USVWATAUAVAWH
W>~/x
A_A^A]A\_^[]
UVWATAUAVAWH
t$@E3
!@uCH
H!\$0D#
PA_A^A]A\_^]
p WAVAWH
 A_A^_
x UATAUAVAWH
L$pD;
D$tD;
9C<u[I
E9V vRM
D8T$X
D$`E;
D$`H9
\$PE;
znulD
D8T$@
D$`fB
A_A^A]A\]
x UATAUAVAWH
D$DA;
9J@s_I
D8\$H
T$xE3
d$ptMH
t$`D;
M9.ulE
T$PE3
D8\$@
T$PE3
\$(Hc
A_A^A]A\]
UATAUAVAWH
J(H99t
J(L91t
ju|L;
A_A^A]A\]
UVWATAUAVAWH
z)u'H
z'u%H
z9u7E
z8u6E
z*u(8E
A_A^A]A\_^]
L$(E3
L$ E3
UVWATAUAVAWH
A_A^A]A\_^]
x UATAUAVAWH
E9Y<u
D9g vEH
E9X<u
L!T$0H
t$(E3
D;O s5L
D;G r
A9B<u
E9X<u
!@u;H
A_A^A]A\]
x UATAUAVAWH
d$X9~
l$`D9m
D$pE3
D$`9E
A_A^A]A\]
@SUVWATAUAVAWH
A_A^A]A\_^][
UVWATAUAVAWH
D$8M;
.}`zTuRI
A_A^A]A\_^]
zNuLA
.M`z<u:I
/t$0w
D$8I;
UVWATAUAVAWH
A;D$ w7I
1A;D$
!@uDH
D9]PA
D;F A
`A_A^A]A\_^]
x AVH
@0I9B0~
@8I9B8}
I#J I
J I3@(H#
B8I9B0t
USVWATAUAVAWH
D$@L;
t$ A;
A_A^A]A\_^[]
UVWATAUAVAWH
@@9A@w:H
pA_A^A]A\_^]
x UATAUAVAWH
A_A^A]A\]
UVWATAUAVAWH
F@A9B@
A_A^A]A\_^]
xguAH
D;C r
@USVWATAUAVAWH
H9L$Xt_H
u-H9}
A@9B@r
T$HE3
A_A^A]A\_^[]
L$ VWAVH
 A^_^
x AVH
(t$ H
(t$0H
@SVWH
q9]0<
x AVH
x AVH
x AVH
WAVAWH
D$`H%
 A_A^_
x AVH
WAVAWH
 A_A^_
WAVAWH
 A_A^_
p AWH
t$ WAVAWH
L$@E3
E9Q v
E;Q r
 A_A^_
L$pH3
WAVAWH
 A_A^_
WAVAWH
D;t$`s7M
 A_A^_
x AVH
x AVH
)D$ L
(D$ H
UVWATAVH
$0< t#H
/=t~&
(|$0H
PA^A\_^]
(t$ H
VWATAVAWH
 A_A^A\_^
L$ VWATAVAWH
 A_A^A\_^
WAVAWH
(|$@L
A_A^_
x AVE3
|$(A^
T$@E3
T$pE3
D$0E3
UVWATAUAVAWH
@8u`t@I
0A_A^A]A\_^]
T$pE3
T$0E3
T$pE3
WAVAWH
0A_A^_
T$pE3
T$0E3
T$`E3
T$ E3
rcwZH
rowfI
rbwYI
r9w0I
r{wrH
rKwBA
r9w0I
rbwYH
rHw?H
@@A;@@t
B`A8C`t
WATAUAVAWH
 A_A^A]A\_
VWAVH
)t$@H
)|$0H
@uVHc
@9|$p}
(|$0H
PA^_^
VWATAVAWH
0A_A^A\_^
p AWH
z3u1I
B0IcB8I
L$8E3
D$8E3
$0< u
t$ WH
zRuPH
D$(L;
D$8I;
(t$ H
(|$ H
@8I9@0
L$ E3
L$`E3
p9]0<
p9]0<
q9]0<
WATAUAVAWH
0A_A^A]A\_
x AVH
VWATAVAWH
 A_A^A\_^
UVWATAUAVAWH
A_A^A]A\_^]
D!d$(L
@USVWATAUAVAWH
A_A^A]A\_^[]
D$0E3
D$ E3
WATAUAVAWH
A_A^A]A\_
UVWAVAWH
PA_A^_^]
t$ WH
WATAUAVAWH
0A_A^A]A\_
USVWATAUAVAWH
xA_A^A]A\_^[]
@USVWATAUAVAWH
t$ E3
A_A^A]A\_^[]
VWAWH
wvt)-
@A__^
@USVWATAUAVAWH
D$pE3
\$@A#
D$HD;
|$`D;
D$@E;
A_A^A]A\_^[]
E9K v%I
A;[ r
D8L$0H
E9S v!M
A;[ r
D8T$@H
L$0D9I
D8L$0A
D$ fI
l$ VWATAVAWH
l$xE3
A_A^A\_^
q!SRD
x ATAVAWH
0A_A^A\
VWATAUAVH
M;C0}
I;S8~
(|$`L
A^A]A\_^
\$ UVWAVAWH
90u&H
2C\A"
2C\A"
@A_A^_^]
x ATAUAWH
0A_A]A\
\$(E3
WATAUAVAWH
9s v}H
A@9G@v
9G@v*H
G@9F@s
 A_A^A]A\_
x AVH
x ATAUAVAWA
|$@A_A^A]A\
x AVH
;w svH
K8I;J0
C8H9C0
K0I;J8
C0H9C8
K0I;J8
K8I;J0
B0H9C8
J8H9K0
H9C0u
H9K0u
H9K8u
@8I9B0u"A
z2u0fA
ATAVAWH
 A_A^A\
G@+C@H
C\2G\$
S\2G\$ 2
VWAVH
;~ stH
 A^_^
;C w(H
;C w)H
s09>v!H
f91t6
UVWATAUAVAWH
F,A!v0
U@!u@
F,A!v0
PA_A^A]A\_^]
ww t<
ww t6
t$ WATAUAVAWH
A@9G@H
A_A^A]A\_
Qw/t_
wBt9-
gw*tV
Hw7t-
RwStA
Kw/t"
w/t$-
wWt,-
wHt$-
D$@E3
UVWATAUAVAWH
D;M`N
@A_A^A]A\_^]
C@A9A@v
UVWATAUAVAWH
PA_A^A]A\_^]
WATAUAVAWH
UUUUM
A_A^A]A\_
SUVWATAUAVAWH
xA_A^A]A\_^][
WATAUAVAWH
A_A^A]A\_
WATAUAVAWH
|$0Ic
A_A^A]A\_
WATAUAVAWH
A_A^A]A\_
UVWATAUAVAWH
@A_A^A]A\_^]
WATAUAVAWH
A_A^A]A\_
WATAUAVAWH
A_A^A]A\_
UVWAUAVAWE3
L$H#L$P
D#D$`
u4D#L$XD
#D$p;
 sRA;
\$@A_A^A]_^]
WAUAWE3
D8T$Pt
D8T$Pt
D8T$Pt
t$8A_A]_
E;S s
p AWE3
t$(A_
x ATAVAWE3
|$8A_A^A\
` AVAWA
d$0A_A^
` AUAVAWA
D;\$@
d$8A_A^A]
` AUAVAWM
D;\$@
d$8A_A^A]
` AVAWA
d$0A_A^
` AVAWA
d$0A_A^
UVWATAUAVAWH
(t$`L
(|$PI
A_A^A]A\_^]
x AVH
D9T$Pw%A
D;D$Ps
WAVAWH
0A_A^_
x AUAVAWE3
|$8A_A^A]
x AVAWE3
|$0A_A^
UVWAVAWH
0A_A^_^]
H9D$ u
D$x9D$pu
UVWATAUAVAWH
0A_A^A]A\_^]
H9D$ uTLc
UVWATAUAVAWH
0A_A^A]A\_^]
H9D$ uVLc
SUVWATAUAVAWH
8A_A^A]A\_^][
D$ H9D$(u
SUVWATAUAVAWH
hA_A^A]A\_^][
WATAUAVAWH
A_A^A]A\_
p AWA
t$(A_
` AUAVAWM
d$8A_A^A]
VWATAUAVH
(t$PL
(|$@I
A^A]A\_^
x ATAUAVAWE3
|$@A_A^A]A\
x AUAVAWE3
|$8A_A^A]
x ATAUAVAWE3
D;\$H
|$@A_A^A]A\
x AVAWE3
|$0A_A^
` AVAWA
d$0A_A^
` AUAVAWA
D;\$@
d$8A_A^A]
` AUAVAWM
D;\$@
d$8A_A^A]
UVWATAUAVAWH
0A_A^A]A\_^]
H9D$ uA
UVWATAUAVAWH
0A_A^A]A\_^]
H9D$ uB
VWATAUAVAWM
 s9D;
l$PA_A^A]A\_^
` AUAVAWM
 s0E;
d$8A_A^A]
p AWA
t$(A_
p AWE3
t$(A_
 s$E;
x AVH
D$ )A
D$ 3A
D$ =A
D$ GA
D$ QA
D$ ZA
D$ [A
D$ #A
D$ -A
D$ VA
D$ `A
D$ jA
D$ tA
D$ ~A
D$ "A
D$ KA
D$ VA
D$ `A
D$ jA
D$ tA
D$ &A
D$ OA
D$ YA
D$ cA
D$ mA
D$ wA
UVWATAUAVAWH
@A_A^A]A\_^]
UVWATAUAVAWH
@A_A^A]A\_^]
UVWATAUAVAWH
0A_A^A]A\_^]
\$ UVWATAUAVAWH
syM9r(uVH
@A_A^A]A\_^]
UVWATAUAVAWH
p@S<_.E
p@S<_.E
 A_A^A]A\_^]
WAVAWH
A_A^_
t$ WATAUAVAWH
D$`E3
T$8M9
;D$0uRL
|$(A;
H9yHu
L$`H3
A_A^A]A\_
UVWATAUAVAWH
D8aQu
F@9A(u
d$hE;
|$`E;
 A_A^A]A\_^]
|$ UATAUAVAWH
D!l$ E3
A_A^A]A\]
x ATAVAWHc
|$8A_A^A\
A9P vjI
E;P r
SUVWATAUAVAWH
D$<@2
\$hM9
T$4D;
L$pM9
d$XD9w 
L$`D;w 
D;w s
A9t$ vd3
A;t$ r
A_A^A]A\_^][
x ATAVAWH
|$`I;
 A_A^A\
WAVAWH
A_A^_
h UAVAWH
$`<`ucD8
pHQ2{
$`< u!H
A_A^]
USVWATAUAVAWH
CH9JHt
D9n vcH
D;^ r
E8hLt
u`;V r
mPD9n 
HA_A^A]A\_^[]
UVWATAUAVAWH
PA_A^A]A\_^]
UVWATAUAVAWH
E@9C@
EP;C sGH
`A_A^A]A\_^]
UVWATAUAVAWH
;{ sLH
(|$`H
A_A^A]A\_^]
x ATAVAW
|$8A_A^A\
SUVWATAUAVAWH
T$ A;
8A_A^A]A\_^][
t$ WH
t$ WATAUAVAWH
&sEE9
r5I3G
 A_A^A]A\_
D9J v
D;J r
p WATAUAVAWH
A9@0s
A9h0t
A9A8s
C@A9A(v
A9H8s
C@A9@(v
D;C r
A_A^A]A\_
x AWH
C8A;B8A
x AVH
}@9x(v
h09x8s
t:9{xv
t79{xv
x AVH
UVWATAUAVAWH
@A_A^A]A\_^]
x ATAVAWH
 A_A^A\
VWAVH
tJA8Y u8A;Y
 A^_^
t$ WATAUAVAWH
 A_A^A]A\_
UVWATAUAVAWH
@A_A^A]A\_^]
t$ WATAUAVAWH
D8o:u
D8o9u
D8l$XtuH
D8o`u
E8o9u
D8l$Xu
 A_A^A]A\_
t$ WH
t$ WAVAWH
@A_A^_
t$ WATAUAVAWH
L$@E;
|$DD;
;l$lsL
A_A^A]A\_
L$ UVWATAUAVAWH
pA_A^A]A\_^]
UVWATAUAVAWH
A9F<r
t$HA;
A_A^A]A\_^]
UVWATAUAVAWH
B D9A
|$4;|$8sn;{
A_A^A]A\_^]
UVWATAUAVAWH
L$ A;
s]A;}
T$@E3
T$@E3
A_A^A]A\_^]
t$ WH
UVWATAVH
A^A\_^]
UWATAVAWH
A_A^A\_]
@SUVWATAVAWH
;|$0s
D$@E3
A_A^A\_^][
VWAVH
t$`E3
 A^_^
VWAVH
A8C u
0A^_^
T$@E3
WATAUAVAWE
\$0A;
t$HA_A^A]A\_
UVWATAUAVAWH
F@A9C@
A_A^A]A\_^]
x AVH
D9C v
D;C r
x UATAUAVAWH
A_A^A]A\]
@USVWATAUAVAWH
A_A^A]A\_^[]
s WATAUAVAWH
D$(D+
A_A^A]A\_
WATAUAVAWH
A_A^A]A\_
UVWATAUAVAWH
!t$|H
t$TD;
uFJcD5
D$0E3
D3D$X
A_A^A]A\_^]
UVWATAUAVAWH
D3E_H
A_A^A]A\_^]
@USVWATAUAVAWH
B@9B@
D8mwtf
A_A^A]A\_^[]
WATAUAVAWH
 A_A^A]A\_
x ATAUAVH
(t$@L
(|$0I
A^A]A\
SUVWATAUAVAWH
L$0Lc
L$0Hc
HA_A^A]A\_^][
UVWATAUAVAWH
t$ D#
0A_A^A]A\_^]
UWAVH
z"u H
z/u-H
(t$`L
(|$PI
(t$`H
x AVH
.D$Pz
.D$Pz
(D$0H
UWAVH
z"u H
z/u-H
(t$`L
(|$PI
UWATAVAWH
/Ewr%H
A_A^A\_]
x AVH
.D$Pz
.D$Pz
(D$0H
zuWD+
USVWATAUAVAWH
D$0L!l$(L!l$ M
H!|$8H
H!|$0H
L!l$8H
L!l$0H
D$0H!|$(H!|$ 
A_A^A]A\_^[]
SUVWATAUAVAWH
L$0Hc
L$XI#
\$HI#
L9l$0L
Bl$0L9L$8I
BL$8I
H9D$hu(I
D$0I;
t$8M;
L9l$0I
B\$0I
L9L$8H
G|$8H9t$PL
L|$PM;
L9l$0I
G\$0L9L$8H
G|$8H
xA_A^A]A\_^][
(D$0H
WAVAWH
)d$@D
)l$0D
)t$ H
z+u)fE
z"u I
z+u)A
(t$ L
A_A^_
p WAVAWH
(t$0H
@A_A^_
UVWATAUAVAWH
A_A^A]A\_^]
L$ E3
WATAUAVAWH
)\$0D
z"u fD
(|$pL
A_A^A]A\_
x AVH
YT$ H
UWATAVAWH
(|$pL
A_A^A\_]
x AVH
UWATAVAWH
/Ewr$H
(|$pL
A_A^A\_]
UVWATAUAVAWH
PA_A^A]A\_^]
SUVWATAUAVAWH
D$PuNIc
t$8E3
t$ Lc
t$@E3
L$(Hc
l$@I;
L$(I;
T$HI;
hA_A^A]A\_^][
)t$ H
z"u H
(t$ H
)l$0D
)t$ H
(t$ L
HcD$@t
HcD$DH
x UAVAWH
/E0v%H
/E0vG
z"u H
z"u H
(t$ H
0A_A^]
UVWAVAWH
)\$@D
)d$0H
A_A^_^]
zEuCH
UVWAVAWH
)t$@H
(t$@H
PA_A^_^]
UVWATAUAVAWH
z9u7f
z1u/A
(t$PH
`A_A^A]A\_^]
UUUUH
3333M
UVWATAUAVAWH
@A_A^A]A\_^]
UVWATAUAVAWH
 A_A^A]A\_^]
L$@fD
t$ WAVAWH
D$`fA+
0A_A^_
u&D9\$(t
D9\$(t
u+D9\$(t$
D9\$(t
D9\$(u
D9\$(t
(t$ H
USVWATAUAVAWH
hA_A^A]A\_^[]
x ATAVAWH
@A_A^A\
|$ UATAUAVAWH
W>~/x
W>~/x
A_A^A]A\]
USVWATAUAVAWH
L$PE3
(|$pE3
(D$`E;o
?L9w0u
L;w0H
)D$PD
(D$P3
A_A^A]A\_^[]
{ ATAVAWH
A_A^A\
\$ UVWATAUAVAWH
T$hM;
L$hI9
D$hL;
A_A^A]A\_^]
Z0L;Z8tgI
BZ8E3
H;J0t
H;J8u
VWATAVAWH
A_A^A\_^
9ADr'w
BH9AHr
JPA9HPr
x UATAUAVAWH
D!R0H;
A!F D
@@;A@
A9F@s
W>~/x
W>~/x
E8H9EH
@8|$`t
@8|$`
C@;A@
A9F@s
M@;H@
A9N@v
d$(D3
D!|$xD
L$tD;
A_A^A]A\]
SUVWATAUAVAWH
@@9F@
d$PE;
d$0D3
xA_A^A]A\_^][
x AUAVAWD
|$8A_A^A]
x UATAUAVAWH
!t$LH
A;A w4I
t$PE;
uAD9d$0u:L
E0E9` u0I
D;d$0
E9F v2I
E;F r
A;v sGI
E@9A@s
D;t$0s1J
A9U v(I
A;U r
XTu)H
A_A^A]A\]
h VWAVH
l$(E3
0A^_^
x ATAVAWH
 A_A^A\
x AVH
@USVWATAUAVAWH
ewD9a
L9q(u6H
t-D9a<t
D;mwvbD
M9q(uSM
D8egu
A_A^A]A\_^[]
\$ UVWATAUAVAWH
M9P(u
T$@Ic
T$d;T$@
D$`E3
l$HD;
l$HteH
L$P+L$@
L$PtaD
D$(E3
A_A^A]A\_^]
t$ WATAUAVAWH
 A_A^A]A\_
UVWATAUAVAWH
L$HD!d$TA
KL9JLu
29CLu3H
A_A^A]A\_^]
x AVH
E;CLs
twE;CLvqI
CL9CLu
A;HLt
D;@LH
SUVWATAUAVAWH
D$8H;
HA_A^A]A\_^][
UVWAVAWH
L$@H3
PA_A^_^]
VWAVH
r`u7H
L$@H3
VWAVH
p!SRD
p!SRD
 A^_^
x UATAUAVAWH
D$tA;
T$pA;
|$xD;
D$tD;
T$pD8|
D$`E3
E9x v
A;P r
D8zHu
A_A^A]A\]
@`9B`s
UVWATAUAVAWH
E9X v{I
E;X r
D9B v
D;B r
@`9A`
PA_A^A]A\_^]
UVWATAUAVAWH
D9PPt)E
D$ E3
D$ E3
UP8]Ht
t{A9^ tu=
A;C0v
C0A9C
@A_A^A]A\_^]
A9HHu
SUVWATAUAVAWH
D$@D;
A_A^A]A\_^][
USVWATAUAVAWH
A_A^A]A\_^[]
x ATAVAWH
 A_A^A\
x AVH
W>~/x
W>~/x
UVWATAUAVAWH
FHA9GHu\
FHA9FH
A_A^A]A\_^]
UVWATAUAVAWH
D!T$@E3
|$D;^ 
l$PE3
+D9d$@u
x)I9^
`A_A^A]A\_^]
D9HPrkA
E;C r
A9[ v>I
A;{ r
A9[ v
A;[ r
SUVWATAUAVAWH
E9H`u^
8A_A^A]A\_^][
UVWATAUAVAWH
@A_A^A]A\_^]
x AVH
USVWATAUAVAWH
D;C r
A9v vlD
EPA;v r
9S viH
O@9H@
A_A^A]A\_^[]
SUVWATAUAVAWH
L$0H;
D$XH;
t$(H;
E9a v~I
A;Q s
hA_A^A]A\_^][
D8YHt"H
x AVH
W>~/x
UVWATAUAVAWH
T$hH;
\$hE9]
l$hA;m
 A_A^A]A\_^]
|$ UATAUAVAWH
D;u0s&C
A_A^A]A\]
t$ UWATAVAWH
H9E8u
D$@E3
e@H9E
A_A^A\_]
x UATAUAVAWH
E8nqt
thD9I
t0D9I
D9L$<t
D9L$<t
A_A^A]A\]
WAVAWH
v$A;V
p9]0<
0A_A^_
x AVH
WATAUAVAWH
A_A^A]A\_
H9Jhu
UVWATAUAVAWH
d$0A+
`A_A^A]A\_^]
UVWATAUAVAWH
@A_A^A]A\_^]
SUVWATAUAVAWH
8A_A^A]A\_^][
WATAUAVAWH
sDE;V
A_A^A]A\_
UVWATAUAVAWH
D;u`sQH
`A_A^A]A\_^]
x ATAVAWH
"uuE3
 A_A^A\
x AVH
{ AUAVAWH
A_A^A]
{ AUAVAWH
A_A^A]
WATAUAVAWH
A_A^A]A\_
WATAUAVAWH
;kHrt;kLwo3
0A_A^A]A\_
@SUVWATAUAVAWH
)t$@E2
(t$@H
XA_A^A]A\_^][
@SUVWATAUAVAWH
D$(I;4$unL
8A_A^A]A\_^][
x UATAUAVAWH
D$pA;
D$lE;B
D;L$hsbD
D9l$D
@8t$@@
A_A^A]A\]
UVWATAUAVAWH
A;P r
D;K r
D;B s?H
E9r v/I
E;J r
H9BHu
]XD9s
D9s v%L
E9k@H
0A_A^A]A\_^]
{@v6H
;{@tU
D9C vOH
D;C r
UATAUAVAWH
A_A^A]A\]
UVWATAUAVAWH
9j(u{H
0A_A^A]A\_^]
E9H vaI
E;H r
E9H v=I
E;H r
E9H v
E;H r
@USVWATAUAVAWH
xA_A^A]A\_^[]
x AVL
A;Z r
E;Y r
A;Q r
|$ UATAUAVAWH
t$XD8
D$xD;f 
t$XE9
d$hE9
\$XE;
D9n vYL
D;F r
E9n th
t$@L+
D;J(u
D;J8u
l$XA;
t$HE3
E9n v$M
t$HE3
|$p;|$T
B8D$@u
D$hE3
t$HD8
T$`9t
A;N s
t$@E8
E;B sQ
l$pE;
L+T$XE
E;F s(I
E;~ u
M9p0u
d$TL9t$xu1H
E9n vwI
E;V r
A_A^A]A\]
@SUVWATAUAVAWH
@@A9F@
T$XM+
@@A9F@vkH
F@A+B@
D$@I;
A_A^A]A\_^][
UVWATAUAVAWH
\$hE3
T$`E3
|$pE9}
|$pE;}
D$p;E
|$`tUH
A_A^A]A\_^]
D$XE;
|$XE3
8L$Tt
x AVH
SUVWAUAVAWH
 A_A^A]_^][
USVWATAUAVAWH
kht[9s v
D;s r
UgD9c v"L
D;s r
D8uot*H
A_A^A]A\_^[]
USVWATAUAVAWH
BHL;p
AHL;@
;FLvP;NPw
;FLrF
F0D8e
A_A^A]A\_^[]
BhD;@
J@A9I@r
J@A9H@r
x AUAVAWH
D9@@D
|$8A_A^A]
B@D9A@s
C`D9@
C`D;@
C`D;@
|$ AVH
t$ WH
E9Z v$I
E;Z r
t$ WATAUAVAWE3
@89C@u
Q v0D
t$HA_A^A]A\_
t$ WATAUAVAWH
\E9bDuSI
J`D9a
I;X(u
D9fDu:A
0A_A^A]A\_
@USVWATAUAVAWH
E9BLs
D!}gH
D!zDA
rXE9B
D9s vrH
W>~/x
D;s r
A_A^A]A\_^[]
x AVH
r`H9x(t?A
x AVH
tbD;R
G`A9X
USVWATAUAVAWH
|$DE;
A_A^A]A\_^[]
L$xE;
L$xD;
T$LH9}
;\$Ds
;V s)H
D$XfD
.T$hz
XL$hf
L$XE3
@8|$Lu8H
;D$dv8
u:@8|$At3H
@8|$AtIH
 u1H;
D$BfD
u'@8|$@t E
@8|$L
8z[uYA
Xz.u,fF
8z#u!H
wWD:t$@sPD;D$dr
T$hD;
D;T$D
\$XE;
u:@8|$Bu
@8|$Hu
A8>u>L
Xz(u&fD
A88uHI
L$hL+
B8|,P
|$AIc
@8>u~L
D$BfD
B8|4P
@8|$HtP
@8|$Ht
@8|$BuL
@8|$@
L$@A9z
zIuGfD
z@u>L;
D$(9A@sFI
WAVAWH
W>~/x
W>~/x
 A_A^_
VWATAUAWH
l$hE2
YD$h=
0A_A]A\_^
\$ UVWATAUAVAWH
A_A^A]A\_^]
UVWATAUAVAWH
A_A^A]A\_^]
UVWATAUAVAWH
E;F<s I
E;G<s I
 A_A^A]A\_^]
UVWATAUAVAWH
@A_A^A]A\_^]
D$ D;
D$8I9
D;l$(
UVWATAUAVAWH
E9Y vqI
E;Y r
A;P8A
\$xE3
\$0A;
T$0E;
t$XE3
T$0D;N
\$4E3
d$pu%H
d$pt(D
|$0E3
|$8D;
l$XE3
d$4D;
D$<E3
\$4D;
l$XtV
A_A^A]A\_^]
UVWATAUAVAWH
L$0A;
L$PH3
`A_A^A]A\_^]
WATAUAVAWH
D$`A;
0A_A^A]A\_
UVWATAUAVAWH
A_A^A]A\_^]
UVWATAUAVAWH
A_A^A]A\_^]
UVWATAUAVAWH
n ;j 
D$(9G@
l$,A;
;_ s&M
|$H;n u
PA_A^A]A\_^]
SUVWATAUAVAWH
L$4E3
l$P;*
I9R@tHL
A;R<s-I
$A9@@
\$@E;
d$8E3
A_A^A]A\_^][
t$ WATAUAVAWH
 A_A^A]A\_
r2w)A
9s,v#;s,s
9sLv#;sLs
9slv#;sls
sl@8spt
sL@8sPt
s,@8s0t
o(9o<v
ox9oTv
WAVAWH
 A_A^_
x AVH
VWATAVAWH
d$xD;d$p
;T$ps'
;T$ps'
 A_A^A\_^
UVWATAUAVAWH
0A_A^A]A\_^]
qqSz@
qhT0~
qhT0~
qI]T/
qI]T/
;A<s5L
D$0E3
D$0E3
q0X8W
qKSr*>i
q)RRJ
S2$/H
qsZ^n
qsZ^n
qhPtE
;A,s9L
P;A,r
E;A|s%I
UVWATAUAVAWH
Aon9I
SHEXH
SHDRH
SFI0H
RDEFH
STATH
LFS0H
D$0A;
A_A^A]A\_^]
x UATAUAVAWH
A_A^A]A\]
UVWATAUAVAWH
Aon9H
SHEXH
SHDRH
SFI0H
RDEFH
STATH
ISGNH
ISG1H
OSGNH
OSG5H
OSG1H
PCSGH
PSG1H
A_A^A]A\_^]
WATAUAVAWH
0A_A^A]A\_
t$ WATAUAVAWH
A_A^A]A\_
x AVH
l$`H;
VWATAVAWH
=LIBFuJH
C D;P
s=D;V
t%D;V
C D;P
 A_A^A\_^
@SUVWATAUAVAWH
;u,s8
L$0;M0
A_A^A]A\_^][
@SUVWATAUAVAWH
;n,s=
A_A^A]A\_^][
UWAVH
HcT$@H
UWAVH
HcT$@H
UVWATAUAVAWH
@A_A^A]A\_^]
UVWATAUAVAWH
=RPLYt'
L$PH;
@8|$0t
A_A^A]A\_^]
@SVWAVAWH
PI;?tTH
A_A^_^[
@USVWATAVAWH
A_A^A\_^[]
@USVWATAUAVAWH
LIBFH
A_A^A]A\_^[]
H WATAUAVAWH
A_A^A]A\_
UATAUAVAWH
T$XE3
A_A^A]A\]
@USVWATAUAVAWH
D$pRPLYH
L$0E3
A_A^A]A\_^[]
\$ UVWATAUAVAWH
t$`D9q4t
D9t$|v&H
D$P H
D$P H
D$|E3
D$P H
A_A^A]A\_^]
UVWATAUAVAWH
L!t$ L
SDTL@2
=PCSGu
PSG1E3
D$PE3
OSGNA
A_A^A]A\_^]
81u L
@SUVWATAUAVAWH
A_A^A]A\_^][
D$(E3
WATAUAVAWH
x+9\$pr
0A_A^A]A\_
UATAUAVAWH
RTS0A
A_A^A]A\]
UAVAWH
SHEXE2
=SDBG
Ptv=RTS0t?=SPDBth=SMIDt
=RDEFtk=PERFu
SDTLt
STATt)
CRPTt
PRIVt
RPLYu
A_A^]
s WAVAWH
9t$`r
0A_A^_
qb]:0.
L$0fA
UVWATAUAVAWH
BSCDH
A_A^A]A\_^]
UVWATAUAVAWH
SMIDtI
A_A^A]A\_^]
q;SXy7y
t$ WH
t$ WH
t$ WH
RD11t
WAVAWH
 A_A^_
WAVAWH
 A_A^_
x AVH
UATAUAVAWH
<!D;{
v&A8F
A_A^A]A\]
L$XE3
E;S<s~I
tR;Z uF
B0A9@
B4A9@
B8A9@
B(A9@
@SUVWATAVAWH
A_A^A\_^][
t$ WATAUAVAWH
uH!\$`L
 A_A^A]A\_
WATAUAVAWH
 A_A^A]A\_
~89>v
w-t{A
L$ UH
l$ VWAVH
H9;t|L
A8<6u
@SUVWH
x ATAVAWH
<0|;<9~?
9_t2H
 A_A^A\
x ATAVAWH
 A_A^A\
@UATAUAVAWH
?#uYH
A_A^A]A\]
x AVH
WAVAWH
;_t43
0A_A^_
:u'H;u
x ATAVAWH
l$HA+
 A_A^A\
:0umE3
8.uOE
t$ WAVAWH
 A_A^_
WAVAWH
;xuoH
 A_A^_
\$ VWAVH
D$ H=
 s,E3
L$hH3
pA^_^
x AUAVAWH
 A_A^A]
8\u9H
8*uhH
9\uNH
D$(L+
\$ UVWH
L$ UH
@SUVWAVAW
9C<rzL
0<0ti
A_A^_^][
x AVH
t$ WH
x ATAVAWH
A_A^A\
VWATAVAWH
@A_A^A\_^
{ AVH
@TA;CTv
WAVAWH
;GHsDD
 A_A^_
D$0.H
USVWATAUAVAWH
D$l9E
A_A^A]A\_^[]
L$lA;
T$lA;
D$h9E
HcD$4
D$09E
D$ 9D$$
C H!S !SPH
%t#A+
BtHA+
x AVH
q@S<_.E
q@S<_.E
q@S<_.E
q@S<_.E
q@S<_.E
q@S<_.E
p@S<_.E
UVWATAUAVAWH
`A_A^A]A\_^]
UVWATAUAVAWH
8tJA+
Bt"A+
9|$Tuk9|$XueD
D$`D;8D
A_A^A]A\_^]
D9T$0r
{ AVH
WATAUAVAWH
A_A^A]A\_
 HcA@H
D$0<H
D$0>H
x AVH
OHH9K
UVWATAUAVAWH
pA_A^A]A\_^]
qcU6J>-
qcU6J>-
VWAVH
BT$t@
ET$xH
pcU6J>-
qcU6J>-
WATAUAVAWH
$supu
pcU6J>-
pcU6J>-
A_A^A]A\_
qcU6J>-
qcU6J>-
pcU6J>-
BH9AHu H
B@9A@
BH9AHu(
BL9ALu H
9A@u%H
GPH9FPu
GX9FXu
B@H9A@u H
H#D$0H
s WAVAWH
0A_A^_
VWAVH
0A^_^
s WATAVH
9sLv)
0A^A\_
@SVWH
L$HH3
x AVH
J(A;H(u^
@08B0
@18B1
@28B2
@38B3
x AVH
UVWATAUAVAWH
H;FXt
I;GXt
A_A^A]A\_^]
L$ UVWATAUAVAWH
0A_A^A]A\_^]
WATAUAVAWH
A_A^A]A\_
VWATAVAWH
)t$PH
L$@H3
(t$PI
A_A^A\_^
u&@8s\uD@8s]u
x ATAVAWH
 A_A^A\
x AVH
|$ UATAUAVAWH
A_A^A]A\]
x AVH
H!*H9
|$(}D
L$ SVWH
D$0E3
D;T$(s
D;T$(s
D;T$(s
UATAUAVAWH
H;K sq
A_A^A]A\]
I9A r
UVWATAVH
D97u)@8o
 A^A\_^]
l$ WH
UATAUAVAWH
M9'tnI
A_A^A]A\]
@SUVWATAVAWH
@A_A^A\_^][
x ATAVAWH
0A_A^A\
x AVH
WAVAWH
0A_A^_
UVWATAUAVAWH
H9\$@uXI
A_A^A]A\_^]
D$89D$0
UVWATAUAVAWH
H09O0
H09O0
H0)O0
H09O0
#tjA+
H0!O0
H09O0
H09O0
H09O0
D9o0t
D9h0A
H01O0
D9o0u
D9h0A
D9o0u
A_A^A]A\_^]
L$ SVWAVH
(A^_^[
t$ UWAVH
t D9q
x AVH
@SUVWAVAWH
A_A^_^][
x AUAVAWH
 A_A^A]
uw9{\u
GhH9Chu
Gp9Cp
C09G0ua
C49G4uY
C89G8uQ
CP8GPuIH
CXH9GXu?
C`9G`u7H
C09G0u
C8H9G8u
C(9G(u
C(9G(
S(;2u4
CH9GHu,A
@UATAUAVAWH
A_A^A]A\]
u8D9@8u`H
x AVH
t$ WAVAWH
p@S<_.E
|$0E3
A_A^_
UVWATAUAVAWH
!\$(I
l$0E3
H!\$ H
A_A^A]A\_^]
UATAUAVAWH
L$ E3
A_A^A]A\]
VWAVH
@A^_^
s WATAUAVAWH
F(I![
H!\$ H
L$XH;
A_A^A]A\_
x ATAVAWH
t$0E3
H!\$ 3
@A_A^A\
t$ WATAUAVAWH
!\$(E3
t;H!X
H!\$ H
A_A^A]A\_
L$ UVWATAUAVAWH
T$8E3
D$ E2
D$8E3
A_A^A]A\_^]
VWATAVAWH
tFH9q
@A_A^A\_^
p@S<_.E
UVWATAUAVAWH
!|$(E3
d$0E3
H!|$ 
p@S<_.E
`A_A^A]A\_^]
|$ UATAUAVAWH
p@S<_.E
A_A^A]A\]
UVWATAUAVAWH
H!t$0H
A_A^A]A\_^]
x ATAVAWH
tc8\$pt
0A_A^A\
s WAVAWH
H!\$ 3
A_A^_
x ATAVAWH
(t$0H
@A_A^A\
x AVH
x AVH
UVWATAUAVAWH
pA_A^A]A\_^]
WAVAWH
l$0E3
@A_A^_
s WAVAWH
W H!p
0A_A^_
UATAUAVAWH
A_A^A]A\]
x AVH
x AVH
UVWATAUAVAWH
L!|$ H
_tPA+
\$HI;
A_A^A]A\_^]
@0H9A0t
WAVAWH
A_A^_
x AVH
p@S<_.E
H9_Ht
UATAUAVAWH
9D$Du
H3D$pH
D$|E3
D$|E3
A_A^A]A\]
x AVH
VWATAVAWH
u"8\$puYL
FhH9EHu
 A_A^A\_^
!D$ E3
VWAVH
@A^_^
D$Xu\H
VWAVH
 A^_^
WAVAWH
HcB@H
H9X@tGH
@A_A^_
x ATAVAWH
t$`L;
 A_A^A\
!D$ E3
QpI;Axu
x AVH
E9H@t
x AVH
\$(E3
x AVH
D$ H#
D$ H#
x UATAUAVAWH
u@E8}Pt
$0< uA
A_A^A]A\]
p WAVAWH
Hc.D8~
D$0E3
A_A^_
t$ WAVAWH
@(L;@(t5L
@(M;G(t9H
A_A^_
9B8u#H
u!H9BHu
I9BHt?
I9BHt
x ATAVAWH
H9ZPt>I
 A_A^A\
buB9w
UVWATAUAVAWH
PA_A^A]A\_^]
@USVWATAUAVAWH
|$PE;
E;2sIH
u78\$@u,
L$xE3
t$@E;
|$Pt L
L$xE3
D$pH9_
A_A^A]A\_^[]
VWAVH
@A^_^
WAVAWH
 A_A^_
x AVH
UVWATAUAVAWH
`A_A^A]A\_^]
H!}P@8
@8x\t
C8<&u
H!|$0D
H!|$(I
EH!|$0I
H!|$(I
VWATAVAWH
A_A^A\_^
G@9C@u"L
UVWATAUAVAWH
0A_A^A]A\_^]
GDA9GD
UVWATAUAVAWH
|$h;D$`t
9T$,s
A_A^A]A\_^]
WATAVH
tDH98t?
 A^A\_
t$ WAVAWH
t'HcT$DH
A_A^_
UVWATAUAVAWH
@A_A^A]A\_^]
x AVH
D$`tgH
WATAUAVAWH
H!|$8H
A_A^A]A\_
t$ WATAUAVAWH
$H;H`u
$`<`u-
$B<Bu-
0A_A^A]A\_
H WATAUAVAWH
A9XPt
0A_A^A]A\_
x AVH
L$0E3
WAVAWH
0A_A^_
UATAUAVAWH
A_A^A]A\]
x AUAVAWH
|$0E3
H!|$ 3
@A_A^A]
x AVH
VWATAVAWH
A_A^A\_^
t$ WATAUAVAWH
D$PxH
 A_A^A]A\_
x AVH
D$ H;
t$ WATAUAVAWH
<{u8@8
4<}u0@8
u'9oxu"H
&tJ<+t<<-t.<<t <>t
 A_A^A]A\_
x ATAVAWH
0A_A^A\
VWAVH
H!\$PH
0A^_^
@SVWH
l$ VWAUAVAWH
D$0E3
H!\$ 3
D$@H;
A_A^A]_^
UVWATAUAVAWH
D$@E3
T$0E3
D;L$ s-E
t$HL+
L$HL+
A_A^A]A\_^]
T$HH+
T$HH+
t$HL+
T$PH+
t$PL+
D$HH+
T$HH+
T$HH+
D$PL+
l$PE3
D$PH+
d$HD;
T$PH+
L$HL+
E;H4r
USVWATAUAVAWH
E49D$4t
D;\$4
D;\$4
D;\$4
9|$4td
F0A9E0w[
F4A9E4wR3
|$8E3
D;\$4s`A
T$8E3
\$XE3
D;t$4
z6u4f
t$XE3
|$PE3
D;\$4
D;D$4
D;\$4
D$HH3D$@
D$HH#D$@
T$@@"
D$@@"
A_A^A]A\_^[]
WAVAWH
0A_A^_
x AVH
x ATAVAWH
D$pA8C
2D8T$xu
0A_A^A\
WATAVH
l$0E3
A^A\_
WATAUAVAWH
A_A^A]A\_
x AVH
@SUVWATAVAWH
@8<)u
L$@H3
PA_A^A\_^][
x AVH
x AVH
WAVAWH
0A_A^_
WAVAWH
0A_A^_
WAVAWH
 A_A^_
VWAVH
 A^_^
L$ E3
VWATAVAWH
A_A^A\_^
WATAUAVAWH
A_A^A]A\_
WAVAWH
0A_A^_
WAVAWH
 A_A^_
WAVAWH
@A_A^_
tuH!x
@UATAUAVAW
T$(E3
D$HE3
T$HE3
D$0E3
A_A^A]A\]
vw'tV
Uw%tJ
cw/t^
lw/t^
Yw;tv
Fw"tv
hw t@
sw%tJ
Qw/t^
ww t@
hw,t]
ow t@
bw/tY
Fw"tS
#w$tC
gw t>
P#uxH
WAVAWH
 A_A^_
x AVH
x ATAVAWH
 A_A^A\
D$@E3
\$`D#
WAVAWH
 A_A^_
t$ WH
L$0H;
x AVH
VWATAVAWH
L$hA;P
 A_A^A\_^
H;O@r
H;O@s
x ATAVAWH
H;A@w
H;G@vIL
,>H;o8v
 A_A^A\
WATAUAVAWH
w0H;O@vLD+G@L
, H;n
OPH;N
 A_A^A]A\_
A;BTse
;BSCDu}f
q1[8''Y
x UATAUAVAWH
9wTv4H
A_A^A]A\]
-0000tK-
ISGNA
OSGNA
x UATAUAVAWH
D$$D;
|$ ug
A_A^A]A\]
WATAUAVAWH
 A_A^A]A\_
|$ UH
@SUVWATAUAVAWH
(A_A^A]A\_^][
|$ AVH
WAVAWH
 A_A^_
WATAUAVAWH
DXBCfD
 A_A^A]A\_
UVWATAUAVAWH
:DXBC
H+D$ u
H+D$(H
H+D$ u
H+D$(H
L$0H3
@A_A^A]A\_^]
\$ UVWATAUAVAWH
8sIE;
QZ^&E
A_A^A]A\_^]
\$ UVWATAUAVAWH
8sHE;
QZ^&E
A_A^A]A\_^]
L$ E3
L$ E3
L$ E3
L$ E3
UVWATAUAVAWH
T$ D;
D;T$ v
@8<(u
L$`H3
pA_A^A]A\_^]
UVWATAUAVAWH
\$ E3
0A_A^A]A\_^]
UVWATAUAVAWH
\$ E3
0A_A^A]A\_^]
UVWATAUAVAWH
T$ D;
D;T$ v
@8<(u
L$`H3
pA_A^A]A\_^]
x ATAVAWH
 A_A^A\
@USVWATAUAVAWH
tUfA;
uJ;_@u
;G@u/I
t$HE3
A_A^A]A\_^[]
t$ WATAUAVAWH
L9p(u
L$8E3
D9g|u
D9g|t
T$0E3
L$0H9M
A_A^A]A\_
WAVAWH
A_A^_
UVWATAUAVAWH
LcOhE
u\HcGhH
u3HcGhH
A_A^A]A\_^]
\$ UVWATAUAVAWH
McL$hD
M9n@u
A_A^A]A\_^]
x UATAUAVAWH
A_A^A]A\]
x AVH
UWATAVAWH
A_A^A\_]
t$ WATAUAVAWH
D9h(u
D9m,t
L9i@t
E9o,t&A
c|M9o@t
t99P(A
L9h@t#H
C|D9kht
D9khu'A9Q8u!
hQumE
h0u[E
h/u*I
D9h0H
D9khu(A
A(D9khuB
D9i,u
D9i0u
D9i<ttH
 A_A^A]A\_
L$ SW
VWAVH
UATAUAVAWH
A_A^A]A\]
x AVH
\$ UVWATAUAVAWH
D87tIH
@A_A^A]A\_^]
UVWATAUAVAWH
D9g4t)H
D9g4t)H
D9h0t
(D9g,t
D9g,t
G0L9g@u
,tKA+
4t"A+
A_A^A]A\_^]
!@8k!
fA;8thD
fA;9tLfE;
tFfA;
@UATAUAVAWH
A_A^A]A\]
x AVH
x ATAVAWH
D8$)u
fD9dE
 A_A^A\
WAVAWH
 A_A^_
H9:tPD
x AVH
x AVH
SUVWATAUAVAWH
D$PD;
XFtKH
hA_A^A]A\_^][
UVWATAUAVAWH
`A_A^A]A\_^]
uWD9J 
x AVH
{ UATAUAVAWH
A_A^A]A\]
WAVAWH
x%t!L
0A_A^_
s WAVAWH
D$ H#
0A_A^_
t$ WAVAWH
80uNH
80u,M
A_A^_
|$ UH
UATAUAVAWH
A;P4sWE;
A_A^A]A\]
x AVH
UVWATAUAVAWH
H!\$@L
D$@E3
\$(E3
D$(E3
A_A^A]A\_^]
L$ UVWATAUAVAWH
PA_A^A]A\_^]
A;GLt4
@USVWATAUAVAWH
T$@E3
T$0E;
D9@8tBH
A_A^A]A\_^[]
K VWATAUAVH
A^A]A\_^
VWATAVAWH
L9vXt
A_A^A\_^
x AVH
VWAVH
 A^_^
WATAUAVAWH
 A_A^A]A\_
x AVH
x UATAUAVAWH
A@D9`
A L9`
A_A^A]A\]
x AVH
UVWATAUAVAWH
D9h8u
H+F H
D9j8t
F@9P u(D9i8u
tpE9a
0A_A^A]A\_^]
x AVH
nPH;3
x AVH
x AVH
UVWAVAW
A_A^_^]
K@!s<H
UVWATAUAVAWH
pqSz@
phT0~
D;t$<s`I
!|$8E2
!|$<H
@8|$@t
A_A^A]A\_^]
t$ WAVAWH
0A_A^_
L$ E3
UVWATAUAVAWH
t!!X8E
!XP!XH!XL
I9]PH
AX@8p
t!!X8E
!XP!XH!XL
7tNA+
A_A^A]A\_^]
VWATAVAWH
t}H9X
A_A^A\_^
L$ VWAVH
 A^_^
x ATAVAWH
 A_A^A\
i4;j4u
B 9A 
HcQ u6
l$ VWAVH
 A^_^
UVWATAUAVAWH
0A_A^A]A\_^]
UVWATAUAVAWH
XFvsH
t$HE3
PA_A^A]A\_^]
t$ WATAUAVAWH
 A_A^A]A\_
t$ WAVAWH
 A_A^_
WATAUAVAWH
ug9_8ubH
tYD9o
 A_A^A]A\_
WATAUAVAWH
t6E80t1H
D$ E3
0A_A^A]A\_
t$ WATAUAVAWH
L9;uC
t^E88tYI
 A_A^A]A\_
UVWATAUAVAWH
D$ M#
L$`E3
D9l$Ht
A_A^A]A\_^]
\$ UVWATAUAVAWH
D$`E3
D$XE3
D$(E3
t8D9|
D$@E3
D$8E3
A_A^A]A\_^]
x AVH
UVWATAUAVAWH
@A_A^A]A\_^]
@USVWAVAWH
xA_A^_^[]
@SUVWAVAWH
T$0E3
9\$<v&H
;\$<r
L$HH3
XA_A^_^][
@USVWATAUAVAWH
hA_A^A]A\_^[]
@SUWAVH
L$8H3
HA^_][
@USVWATAUAVAWH
A_A^A]A\_^[]
@USVWATAUAVAWH
A_A^A]A\_^[]
x AVH
t<;*u#H
UVWATAUAVAWH
A_A^A]A\_^]
m\IcV 
;uTs3H
;u\s0H
;u`s3H
;uhs0H
T$PE3
T$@E3
UVWATAUAVAWH
t/E;'u
pA_A^A]A\_^]
UVWATAUAVAWH
w0!\$xE3
l$xJ9
t@H!X
0A_A^A]A\_^]
|$(E3
\$ UVWATAUAVAWH
D$pI9
D$hD;
F@D;x
F@D;x
F@D;x
F@D;x
L$xE3
A_A^A]A\_^]
WAVAWH
 A_A^_
D$8E3
WAVAWH
 A_A^_
@USVWATAUAVAWH
A9^8u
D8,1u
l$PE3
D$XE3
A_A^A]A\_^[]
USVWATAUAVAWH
M A9u8u
H!p(H!p
!0!p0H
ELA+E
A_A^A]A\_^[]
x AUAVAWH
A_A^A]
L$ UVWATAUAVAWH
H!\$PH
A_A^A]A\_^]
UATAUAVAWH
A_A^A]A\]
x ATAVAWH
A_A^A\
H UATAUAVAWH
u"H9z
H9z(u
T$PE3
T$0E3
L!|$ H
A_A^A]A\]
WATAUAVAWH
D$0L9,
u!L9j
A_A^A]A\_
` AUAVAWH
A_A^A]
UVWATAUAVAWH
&t'A+
,tXA+
4tOA+
A_A^A]A\_^]
VWATAVAWH
 A_A^A\_^
VWAUAVAWH
CTABH
D$pH;
0A_A^A]_^
UVWATAUAVAWH
D!f<D!f8D!f@D!fH3
`A_A^A]A\_^]
UATAUAVAWH
A_A^A]A\]
USVWATAUAVAWH
I9GPt
A_A^A]A\_^[]
9y8u&H
\$PE3
D$HE3
UVWATAUAVAWH
D$(E3
A_A^A]A\_^]
WAVAWH
H9Zpu
@A_A^_
k VWAUAVAWH
KxD;|$`
tTH!x
H!~(D
t6D9h
 A_A^A]_^
x UATAUAVAWH
A_A^A]A\]
L9pHu
USVWATAUAVAWH
E9Q8unM
L$ E3
|$pE3
A_A^A]A\_^[]
UVWATAUAVAWH
A_A^A]A\_^]
{ AVH
D$0H9xH
UVWATAUAVAWH
~DE!'E3
@A_A^A]A\_^]
UVWATAUAVAWH
 t?A+
2t4A+
A_A^A]A\_^]
D9T$hu4D9T$pu-A
D9L$`u
D9T$hu
D9T$pu
D9L$`
D9L$`
D9T$h
D9T$p
D9L$`u
D9T$h
D9T$p
D9L$`u
D9T$hu
D9T$ptGA
D9L$`t-L
D9L$`u
D9T$hu
D9T$pt
D9T$pu/A
UUUUUUU
UVWATAUAVAWH
@A_A^A]A\_^]
UVWATAUAVAWH
0A_A^A]A\_^]
yl@8ypt
{T@8{Xt
{<@8{@t
{$@8{(t
q9]0<
x ATAVAWH
{(t9H
;C@u H
0A_A^A\
\$(E3
h UAVAWH
A_A^]
VWAVH
!j8!j<
0A^_^
x AUAVAWH
9z vZH
D;B r
A9H8s
A9H<s
A9X@v
@8;E8
@<;E<
@@;E@
 A_A^A]
x AVH
x AUAVAWH
9z vZH
D;B r
A9H8s
A9H<s
A9X@v
A;F4A
@8A;F8A
@<A;F<A
@@A;F@A
 A_A^A]
qHQ2{
UVWATAUAVAWH
@A_A^A]A\_^]
E;S s
9L$Xt%L
UVWATAUAVAWH
BhD;X
T$pE3
 A_A^A]A\_^]
UVWATAUAVAWH
A_A^A]A\_^]
x AVH
USVWATAUAVAWH
D8p`tg;
XA_A^A]A\_^[]
x AVL
|$(A^
t$ WAVAWH
 A_A^_
UVWATAUAVAWH
M@8Mp
pA_A^A]A\_^]
SUVWATAUAVAWH
T$H@8
L9R(u@H
L9R(uXH
hA_A^A]A\_^][
M9P(u
L9Q(u
UVWATAUAVAWH
ExtkH
L9i(u2H
`A_A^A]A\_^]
UVWATAUAVAWH
W>~/x
@A_A^A]A\_^]
SUVWATAUAVAWH
H!\$ E3
H!\$PE3
H!\$HE3
D$(E3
L$XE3
D$HE3
L$ E2
\$4E;
D$0A;
T$DA;
^ D;] 
T$DE;
\$0A;
D$(C9,
xA_A^A]A\_^][
t$ WAUAVH
 A^A]_
A,+B,
B@A9A@w/r(M;
BH9AHr
x UATAUAVAWH
@tzI3E
B8D;G@r4
A_A^A]A\]
|$ AVH
D!D$0H
T$PD!D$(
XTtg;
H WATAUAVAWH
8\$pt
 A_A^A]A\_
UVWAVAWH
prX2w?
0A_A^_^]
\$ UVWH
\$ UWAVH
0A^_]
\$ WH
|$ UATAUAVAWH
D$xDBUGH
T$hE3
D$hfB
|$XE3
\$P;]
L$TE3
u1A;XHu+A
L$TfA
A_A^A]A\]
@USVWAVAWH
L$ E3
HA_A^_^[]
@USVWH
L$ E3
H_^[]
UWAVH
@A^_]
@SUVWATAUAVAWH
T$`A;
A_A^A]A\_^][
UVWATAUAVAWH
`A_A^A]A\_^]
q3Q:3
@USVWAVH
@A^_^[]
USVWATAUAVAWH
EgE;G
D9'uJE;
9_ t4;G s
;G$sx
9_(t4;G(s
;G,s#
EgE;G
D$(A#
A_A^A]A\_^[]
@USVWAVAWH
HA_A^_^[]
@USVWH
H_^[]
9S vUH
{ AVH
D$`L;
|$ UH
UVWATAUAVAWH
l$|A;
t$|A;
D$xA;
l$|E3
A_A^A]A\_^]
WAVAWH
 A_A^_
WATAUAVAWH
 A_A^A]A\_
\$ UVWATAUAVAWH
A_A^A]A\_^]
L$@tmA
WATAUAVAWH
 A_A^A]A\_
;T$Ps
\$ UVWATAUAVAWH
PCSGt*
D$hOSG1
D$hISG1
D$hPSG1H
OSGNu
D$hOSG5H
W>~/x
&t8A+
A_A^A]A\_^]
t$aD;U
L9j(u
D$xE;
D8l$`u
W>~/x
W>~/x
W>~/x
$`< u
u=A8O
PCSGu6
D8t$`H
UVWATAUAVAWH
W>~/x
 A_A^A]A\_^]
x UATAUAVAWH
\$hE;
D;D$ps
D9~Dv-E
D;NDr
D$ E3
D8l$Tt>
A_A^A]A\]
@USVWATAUAVAWH
HA_A^A]A\_^[]
x AWH
USVWATAUAVAWH
E9a,t~
t#D9`,t
A;D$,u
A_A^A]A\_^[]
A;@,u
qrX2w?
VWAVH
L$@H3
SUVWATAUAVAWH
D$DD;
H;D$HuRH
D$HH9
L$HI;
D9G v
D;G r
A_A^A]A\_^][
UVWATAUAVAWH
D$0vH
A_A^A]A\_^]
\$PE3
D$0sL
\$XE3
D$0sL
D$0tL
D$0vH
\$XE3
D$0sL
p1[RR.e
W>~/x
D9q<u
D$0cH
D$ E3
D$0cH
D$ E3
D$0bH
D$0iH
ISGNH
OSGNE3
p3Q:3
STATH
d$ E3
VWAVH
 A^_^
$(<(u
W>~/x
USVWATAUAVAWH
d$ E3
|$HL9
d$ E3
D8ewu
A_A^A]A\_^[]
W>~/x
UVWAVAWH
@8t$0t
A_A^_^]
W>~/x
W>~/x
W>~/x
W>~/x
W>~/x
W>~/x
K UVWATAUAVAWH
A8~5u
A;V r
D;N rMH
$0< up
t\@8~4
 t>9|$Ht
t3@8~4t-
PA_A^A]A\_^]
UVWATAUAVAWH
W>~/x
L$8H3
@A_A^A]A\_^]
x ATAVAWH
 A_A^A\
@SUVWATAUAVAWH
D$0D;
T$@D;
E@9F@
D$0H9D$8u
XA_A^A]A\_^][
x UATAUAVAWH
A_A^A]A\]
UVWATAUAVAWH
A_A^A]A\_^]
9|$Pv
y ;T$Pr
UWATAVAWH
A_A^A\_]
x UATAUAVAWH
|$T w
|$T v
D$`H9E
T$xD;
|$XD;
A_A^A]A\]
x UATAUAVAWH
T$TE3
z+u)I
z+u)I
T$PE3
A_A^A]A\]
x UAVAWH
A_A^]
t$ WATAUAVAWH
C(E;{ s
A;h8D
t%D9k 
A_A^A]A\_
t$ WH
t$ WATAUAVAWH
L$PL9
E9s v}A
E;K r
L$pH3
A_A^A]A\_
UVWATAUAVAWH
C8A9A@w1A
T$(A9S8A
T$(M;
9D4Pu
9D4`u
E9C s
E9A E
A;M sFI
D$ E3
D8|$!
@89B8s
A_A^A]A\_^]
WATAUAVAWH
A_A^A]A\_
q1[RR.e
x UATAUAVAWH
A_A^A]A\]
x ATAVAWH
A_A^A\
D$ u%L
WAVAWH
$`< twH
A_A^_
WATAVH
@A^A\_
A9P v)I
A;P r
WATAUAVAWH
A_A^A]A\_
API9CPt
UVWATAUAVAWH
`A_A^A]A\_^]
L$(E3
x UATAUAVAWH
D;d$D
D$@A;
!|$ H
!|$ I
A_A^A]A\]
WAVAWH
 A_A^_
x UATAUAVAWH
E8`ht
A_A^A]A\]
x ATAUAVH
0A^A]A\
W>~/x
AtAon9
@tXNAS
@tXNAPE
WATAUAVAWH
 A_A^A]A\_
@USVWATAUAVAWH
;Ugs|
u1L9d
A_A^A]A\_^[]
UVWATAUAVAWH
@A_A^A]A\_^]
WATAUAVAWH
A;V@r
0A_A^A]A\_
x UATAUAVAWH
W>~/x
W>~/x
W>~/x
W>~/x
W>~/x
W>~/x
A_A^A]A\]
UATAUAVAWH
(t$`L
(|$PI
A_A^A]A\]
WATAUAVAWH
E$A2D$$$
A2E$A
A2L$$
A2T$$
U$A2D$$$
 A_A^A]A\_
WATAUAVAWH
E;G@r
ty@8{:t
@8{9uTH
 A_A^A]A\_
x ATAVAWH
XptjD8c
tdD9c
t7D8g8t+D8g9t%L
0A_A^A\
WATAUAVAWH
0A_A^A]A\_
WAVAWH
 A_A^_
\$ UVWATAUAVAWH
H!t$xL
0A_A^A]A\_^]
WAVAWH
@A_A^_
x AVH
t$ WH
t$ WAVAWH
 A_A^_
t$ WH
t$ WAVAWH
 A_A^_
WATAUAVAWH
;}LwaA;~@s[I
x}A;^@s
0A_A^A]A\_
t$ WATAUAVAWH
0A_A^A]A\_
I;C u
I;K u
x AVH
x UATAUAVAWH
A_A^A]A\]
(D$pH
SDBGI
@USVWATAUAVAWH
w$vyH
pi[v+
\$8E3
D;l$Ts
T$hE9p,I
A_A^A]A\_^[]
@USVWATAVAWH
A;F$r
A;F$s
t(E9Y
pA_A^A\_^[]
UVWATAUAVAWH
`A_A^A]A\_^]
\$ UVWATAUAVAWH
A_A^A]A\_^]
|$ UATAUAVAWH
L9f(tED
L9f0tDA
D8$:u
A_A^A]A\]
@USVWATAUAVAWH
L!d$PA
D!d$X
D!d$\
v,D8g
H!D$8
A_A^A]A\_^[]
@USVWATAVAWH
A_A^A\_^[]
@USVWATAUAVAWH
A_A^A]A\_^[]
@USVWATAUAVAWH
LcmwD
A_A^A]A\_^[]
USVWATAUAVAWH
u+D9V
+EgE3
EgD8]
A_A^A]A\_^[]
UVWATAUAVAWH
D;MDf
u_D9U
tCM;7u:H
p@S<_.E
0A_A^A]A\_^]
SUVWATAUAVH
|$`fD#
M9N`u
L$PE3
pA^A]A\_^][
@USVWATAUAVAWH
A_A^A]A\_^[]
@USVWATAUAVAWH
A_A^A]A\_^[]
UWAVH
\$ UVWATAUAVAWH
A_A^A]A\_^]
@USVWAVAWH
A_A^_^[]
UATAUAVAWH
A_A^A]A\]
USVWATAUAVAWH
A8|$:t
t4H9=(
hA_A^A]A\_^[]
@USVWATAUAVAWH
LcmwM
A_A^A]A\_^[]
UAVAWH
A_A^]
UVWAVAWH
A_A^_^]
t$ WAVAWH
A_A^_
@USVWATAUAVAWH
L$PE3
A_A^A]A\_^[]
\$ UVWATAUAVAWH
d$PfD
D9d$h
D3DSHDR
A_A^A]A\_^]
UVWATAUAVAWH
D;r$siA
pA_A^A]A\_^]
\$ UVWATAUAVAWH
E9U@t
PA_A^A]A\_^]
@USVWATAUAVAWH
T$xHc
~0$rCI
I9\$HtrA
t$`8\$PtzMc
A_A^A]A\_^[]
UVWATAUAVAWH
HcD$DH
;\$xsq
A_A^A]A\_^]
@USVWATAUAVAWH
wH;wL
XA_A^A]A\_^[]
UVWATAUAVAWH
t$p;F
D;d$ps(H
 A_A^A]A\_^]
VWAVH
 A^_^
9Y$v{A
D;A$r
@USVWATAUAVAWH
FHE;FL
A;~LwfH
Ew;x@s]M
9]gt$A
A_A^A]A\_^[]
x ATAVAWH
E;N@r
tt@8y
0A_A^A\
WATAUAVAWH
 A_A^A]A\_
x ATAVAWH
 A_A^A\
H WATAUAVAWH
CH9FHt9A
0A_A^A]A\_
t$ WH
D!qpH
x AVH
ATAVAWH
0A_A^A\
t$ WATAUAVAWH
0A_A^A]A\_
USVWATAUAVAWH
A9] v+L
E;E r
hA_A^A]A\_^[]
UVWATAUAVAWH
A;E@s
T$0A;Q
D$8E3
PA_A^A]A\_^]
o89o@v#H
kH9oPv#H
WATAUAVAWH
u?D;wHs
wHD;wLv
 A_A^A]A\_
H9(u(A
WAVAWH
FD9F@
 A_A^_
WAVAWH
GX9GPu{
 A_A^_
A;R$r
A9RPv
A;RPr
E;Z@sCI
A;RPr
A;R$s2I
x ATAVAWH
9Q$v'L
A_A^A\
@SUVWAVH
D$@E3
L$@H3
PA^_^][
\$ UVWH
D$HE3
L$HH3
q9]0<
UVWATAUAVAWH
\$xD9n
l$XE3
D$0cH
;D$lv
D$dL9
;D$pv
D$pL9
G9D9)D
T$xE3
XTuJH9
D$hE;
E;W u@M
D$lE3
CTABA
CLI4A
FXLCA
A_A^A]A\_^]
VWAUAVAWH
L$XH3
`A_A^A]_^
)t$ H
(t$ H
)t$@H
D$PE3
WATAUAVAWH
 A_A^A]A\_
q9]0<
\$ UH
UVWATAUAVAWH
0A_A^A]A\_^]
\$ UVWAVAWH
;D$8u
;D$<u
L$@H3
PA_A^_^]
t$ WH
t$ WH
t$ WH
UVWATAUAVAWH
L$ A;
@A_A^A]A\_^]
t$ WH
UVWATAUAVAWH
L$ A;
@A_A^A]A\_^]
t$ WAVAWH
 A_A^_
t$ WH
t$ WH
x AVH
@ u'I
WAVAWH
@A_A^_
x AVH
x AVH
UVWATAUAVAWH
PA_A^A]A\_^]
I(A9K(t
@SUVWAVH
Yti>T
L$(E3
A^_^][
UWAVH
Yti>T
Yti>T
D$(E3
UWATAVAWH
Yti>T
Yti>T
L$(E3
A_A^A\_]
Yti>T
UVWATAUAVAWH
@8|$4
A_A^A]A\_^]
x UATAUAVAWH
E9Y L
Yti>T
Yti>T
T$8E3
Yti>T
D$ E3
Yti>T
l$0E3
Yti>T
l$0E3
A_A^A]A\]
x UATAUAVAWH
Yti>T
Yti>T
l$8E3
Yti>T
l$8E3
A_A^A]A\]
Yti>T
t$8E3
UWAVH
Yti>T
Yti>T
x UAVAWH
Yti>T
Yti>T
D$(E3
A_A^]
UWATAVAWH
Yti>T
AptKE
E9{ v;M
Yti>T
Yti>T
|$0E3
Yti>T
A_A^A\_]
Yti>T
Yti>T
|$8E3
Yti>T
D$ E3
x UATAUAVAWH
Yti>T
Yti>T
A_A^A]A\]
x AVH
UVWAVAWH
A_A^_^]
UWAVH
Yti>T
Yti>T
t$0E3
Yti>T
t$8E3
UWAVH
Yti>T
E;F r
Yti>T
E;A sWI
t$ UWAUAVAWH
Yti>T
L$`E3
Yti>T
D$ E3
A_A^A]_]
UWAVH
Yti>T
T$`E3
Yti>T
t$0E3
|$ AVH
Yti>T
L$PE3
UWAVH
Yti>T
t$ E3
Yti>T
D$(E3
WAVAWH
 A_A^_
x UATAUAVAWH
Yti>T
E;A A
Yti>T
Yti>T
D8l$Yu
Yti>T
D$(E3
Yti>T
l$0E3
Yti>T
D$ E3
Yti>T
D$(E3
A_A^A]A\]
UVWATAUAVAWH
tr9i<t&
A_A^A]A\_^]
UVWATAUAVAWH
A_A^A]A\_^]
VWAVH
Yti>T
x UATAUAVAWH
Yti>T
Yti>T
Yti>T
l$8E3
A_A^A]A\]
UVWATAUAVAWH
Yti>T
A_A^A]A\_^]
x AVH
Yti>T
t$8E3
x UATAUAVAWH
Yti>T
Yti>T
A_A^A]A\]
UWAVH
Yti>T
t$ E3
Yti>T
D$(E3
@SUVWH
@SUVWH
@SUVWH
@SUVWH
@SUVWAVH
A^_^][
t$ WATAUAVAWH
A_A^A]A\_
@SUVWAVAWH
A_A^_^][
@SUVWAVH
A^_^][
@SUVWAVH
A^_^][
@SUVWAVH
A^_^][
\$ UVWATAUAVAWH
Yti>T
Yti>T
l$8E3
Yti>T
l$8E3
A_A^A]A\_^]
\$ UVWATAUAVAWH
Yti>T
Yti>T
A_A^A]A\_^]
H WATAUAVAWH
;w^tD
Uwstg
ewit]
wVtM-
0A_A^A]A\_
 !""#$ ==%&======'(=====)*+,===================-.-=/=============0=======12=3456789:;;;;;;;;;;;;;;;;;;;;;<
x AVH
p WATAUAVAWH
D$pD;~4
A_A^A]A\_
WAVAWH
 A_A^_
UVWATAUAVAWH
8\$Ht
8\$`t
A_A^A]A\_^]
D;|$hr
tcA8_,t]H
t(A8_-t"
t(A8_.t"
;t$0r
p WAVAWH
A_A^_
UWAVH
UVWATAUAVAWH
Yti>T
E;A A
6A;A 
Yti>T
Yti>T
D$ E3
Yti>T
Yti>T
l$8E3
D8l$Pu
D8l$Qu
D8l$Rt"H
A_A^A]A\_^]
x UATAUAVAWH
Yti>T
Yti>T
d$0E3
A_A^A]A\]
Yti>T
Yti>T
t$ WAVAWH
D$XHc
Yti>T
L$(E3
A_A^_
UWAVH
Yti>T
Yti>T
D$(E3
x UATAUAVAWH
W>~/x
D$ @8t$@t-
@8t$@t2I
D$ @8t$@
@8t$@t
@8t$@t
@8t$@thI
L$D$`< u
W>~/x
A_A^A]A\]
UVWATAUAVAWH
A_A^A]A\_^]
UWAVH
Yti>T
Yti>T
D$(E3
UWATAVAWH
Yti>T
Yti>T
Yti>T
D$(E3
A_A^A\_]
Yti>T
D$ E3
x UATAUAVAWH
t$TD8L$Pt
Yti>T
D8L$Q
Yti>T
Yti>T
9D$lu
D$`D8l$Pu
Yti>T
Yti>T
l$8E3
Yti>T
l$8E3
A_A^A]A\]
UWATAVAWH
Yti>T
Yti>T
Yti>T
D$(E3
Yti>T
t$0E3
A_A^A\_]
UWAVH
Yti>T
E9q v;M
Yti>T
UWAVH
Yti>T
Yti>T
Yti>T
Yti>T
t$0E3
UWATAVAWH
Yti>T
Yti>T
Yti>T
D$(E3
Yti>T
t$0E3
Yti>T
Yti>T
A_A^A\_]
t$ UWAUAVAWH
Yti>T
Yti>T
Yti>T
D$(E3
Yti>T
|$0E3
Yti>T
D$(E3
A_A^A]_]
UVWATAUAVAWH
Yti>T
A;A v
Yti>T
Yti>T
D$ E3
Yti>T
D$(E3
Yti>T
|$0E3
Yti>T
Yti>T
Yti>T
D$(E3
D8|$Xu
D8|$Yu
D8|$Zt I
Yti>T
|$0E3
A_A^A]A\_^]
x UATAUAVAWH
Yti>T
D9t$P
t$PE3
Yti>T
A_A^A]A\]
x UATAUAVAWH
Yti>T
Yti>T
D$`E3
A_A^A]A\]
UWATAVAWH
Yti>T
Yti>T
Yti>T
A_A^A\_]
UWATAVAWH
Yti>T
Yti>T
Yti>T
A_A^A\_]
Yti>T
l$ VWAVH
|$8*A
t$ UWATAVAWH
A_A^A\_]
UWATAVAWH
Yti>T
Yti>T
Yti>T
A_A^A\_]
x UATAUAVAWH
Yti>T
Yti>T
D$`E3
A_A^A]A\]
UWATAVAWH
Yti>T
Yti>T
Yti>T
A_A^A\_]
x UATAUAVAWH
Yti>T
Yti>T
A_A^A]A\]
x UATAUAVAWH
Yti>T
Yti>T
A_A^A]A\]
UVWATAUAVAWH
A_A^A]A\_^]
x ATAVAWH
W>~/x
0A_A^A\
@SVWH
L$HH3
x AVI
|$(A^
UVWATAUAVAWH
`A_A^A]A\_^]
;D;o$s
MX;H4s
t$ WAVAWH
p@S<_.E
 A_A^_
SUVWATAUAVAWH
p@S<_.E
A;Jls!H
C0A;BTs
8A_A^A]A\_^][
WAVAWH
D$@fB
 A_A^_
x AUAVAWH
D9C$vUD;C$s
D;C$r
D9K$vXL
D;K$s
D;K$r
9K$v ;K$s
P4;K$r
A_A^A]
UVWATAUAVAWH
p@S<_.E
p@S<_.E
;]<rrH
 A_A^A]A\_^]
t$ WATAVH
D$`E3
9O$v#;O$s
0A^A\_
VATAUAVAWH
A_A^A]A\^
UVWATAUAVAWH
D!|$|D!}
p0D;s
v(D8{
p1[RR.e
L$0D!|$(D
D$tA;
L!|$XE3
L!|$PH
L!|$HA
D$0sL
d$(u'D
D$xA9
A_A^A]A\_^]
t$PE3
D$0tL
D$tA9
D$0uL
t$PE3
D$0uL
D$tA9
OSGNH
PCSGI
PCSGE
OSGNH
\$(E3
skE;u
SFI0H
STATH
RTS0H
\$ E3
W>~/x
W>~/x
W>~/x
W>~/x
W>~/x
W>~/x
W>~/x
$`<`u5H
W>~/x
W>~/x
$`< u(H
W>~/x
W>~/x
t$ WH
W>~/x
L$@H3
@SUVWATAUAVAWH
SHDRD
T$xA"
SGtGA+
(A_A^A]A\_^][
q1[RR.e
WAVAWH
p1[RR.e
 A_A^_
VWATAVAWH
|$(D3
T$HE3
A_A^A\_^
Ht'A+
w<t.-
wKt=-
wEt:-
q!SRD
t$ WH
w&D;B
w D9J
@SUVWATAUAVAWH
T$@D;
\$HD;
9A@w:I
\$HE3
A_A^A]A\_^][
q9]0<
qHQ2{
H WATAUAVAWH
@8|$pt
 A_A^A]A\_
W>~/x
T$HH9
@USVWATAVAWH
W>~/x
wttkA
pA_A^A\_^[]
prX2w?
q3Q:3
wPtu-
wDtm-
wUt,-
W>~/x
qrX2w?
x AVH
W>~/x
@SUVWATAUAVAWH
D$(A"
HA_A^A]A\_^][
UVWATAUAVAWH
W>~/x
PA_A^A]A\_^]
q1[RR.e
W>~/x
q!SRD
x ATH
t$ WATAUAVAWH
W>~/x
vG8\$0uAI
L$hH3
A_A^A]A\_
W>~/x
@SUVWAUAVAWH
W>~/x
L$HH3
PA_A^A]_^][
q9]0<
UVWATAUAVAWH
l$XE3
D$0cH
;D$xv
D$pL9
G9D9)
|$tE3
D$pA;
A_A^A]A\_^]
XTuJI
t!D90w\A
D9(wQM
E;o uFE;
PRSIH
CLITH
FXLCH
D;d$t
UWAUAVAWH
L$XH3
`A_A^A]_]
q9]0<
t2H9p
WATAUAVAWH
 A_A^A]A\_
\$ UVWATAUAVAWH
W>~/x
W>~/x
L$`H3
pA_A^A]A\_^]
q3Q:3
|$ UATAUAVAWH
W>~/x
L!l$0L
A_A^A]A\]
x AVH
W>~/x
qrX2w?
WAVAWH
W>~/x
0A_A^_
W>~/x
W>~/x
L$0H3
s WAVAWH
A_A^_
s WAVAWH
A_A^_
|$ ATAVAWH
A_A^A\
|$ ATAVAWH
A_A^A\
q1[RR.e
x ATAVAWH
(t$PL
(|$@I
A_A^A\
\$ UVWAVAWH
D!D$(D
L!D$ I
A_A^_^]
@SUVWAVH
L$`H3
pA^_^][
|$ UH
q!SRD
x AWH
x UATAUAVAWH
L$xE3
T$pE;
W>~/x
D$HE2
A_A^A]A\]
t9D8|$Mu+
E!|$ D!|
D$XE2
D$XA;
D$HA;
t$ WATAUAVAWH
W>~/x
W>~/x
L$`H3
A_A^A]A\_
L$HH3
q9]0<
T$XH9
@USVWATAVAWH
W>~/x
wltcA
pA_A^A\_^[]
q3Q:3
wuti-
wvtj-
W>~/x
qrX2w?
WAVAWH
W>~/x
 A_A^_
x AUAVAWH
VLu9D
 A_A^A]
q1[RR.e
q!SRD
x AWH
t*H9p
t$ WAVAWH
A_A^_
VWAUAVAWH
A_A^A]_^
ucD;r s]D;
t$ WAVAWH
A_A^_
x UATAUAVAWH
C@9B(E
A_A^A]A\]
B@9A@H
\$ UVWATAUAVAWH
W>~/x
8\$`uyH
vC8\$hu=H
 A_A^A]A\_^]
L$HH3
?<?u'H
LcD$DD
t$ UWATAUAVH
H9C@u%J
NHD8uwt
D8uot
H#F@H
D8uot
D8uwu
H#C@H
F8H9F0t
\$PH9C0t
A^A]A\_]
UVWATAUAVAWH
H9G@u
A_A^A]A\_^]
` UAVAWH
A_A^]
WAVAWH
 A_A^_
x AVH
WATAUAVAWH
 A_A^A]A\_
` UAVAWH
H9C@u
H#K@H
(t$@L
A_A^]
|$ UATAUAVAWH
A_A^A]A\]
x AVH
H UATAUAVAWH
MpI9A@u
A_A^A]A\]
USVWATAUAVAWH
 ;EhuL
DS E3
D$xE3
;Mp}#L
A_A^A]A\_^[]
WAVAWH
(t$ H
(t$0H
@A_A^_
x ATAVAWH
(L$ H
0A_A^A\
WATAUAVAWH
 A_A^A]A\_
|$(A^
t$ WH
x AVH
UATAUAVAWH
!|$(E
A_A^A]A\]
K SWH
K SWH
9\$`u
9|$(tD2
9\$`u
WATAUAVAWH
 A_A^A]A\_
x ATAVAWH
@A_A^A\
r{wrI
rNwLA
r<w3A
r*w!A
WATAUAVAWH
D9O8u
D9O8t
L$(E3
A_A^A]A\_
UVWATAUAVAWH
L9|$ht
|$BL9}
u5D9p4u/L9v(t
D9p8u#E3
A_A^A]A\_^]
|$AD8l$BtFA
L9l$huy
L9n(L
VLtKL
D9+up@
T$hE2
L$pD9i
PLulH
k UAVAWH
A_A^]
@USVWATAUAVAWH
H!t$83
A_A^A]A\_^[]
WATAUAVAWH
A_A^A]A\_
x AUAVAWH
@A_A^A]
p9]0<
UVWAVAWH
0A_A^_^]
t$ E3
UVWATAUAVAWH
E9fHt
A_A^A]A\_^]
L$ E3
A9^0t
\$ UVWATAUAVAWH
D$pu9H
D$`E3
u/HcM
D3D$PI
A_A^A]A\_^]
UVWATAUAVAWH
PA_A^A]A\_^]
\$ UVWATAUAVAWH
A_A^A]A\_^]
Eg90u
u&M9Q
W>~/x
L$0E3
d$(D3
UVWATAUAVAWH
t;8D$pt
0A_A^A]A\_^]
t$ WAVAWH
A_A^_
UWATAVAWH
A_A^A\_]
@USWATAUAVAWH
A_A^A]A\_[]
\$ UVWATAUAVAWH
A_A^A]A\_^]
x ATAVAWH
A_A^A\
\$ UVWH
USVWATAUAVAWH
D$xHc
A_A^A]A\_^[]
x UATAUAVAWH
D9q,v
d$(E3
d$(E3
t$(E3
t$(E3
|$0D;
A_A^A]A\]
x AVH
USVWATAUAVAWH
EHE9_
!t$0H
!t$(L
hA_A^A]A\_^[]
UVWATAUAVAWH
T$cD"
D$xE3
p@S<_.E
D$mD9
p@S<_.E
t$iH9M
T$dE3
tHD9[ uBH
t0L9S0t&H
A_A^A]A\_^]
D8T$ct
D8T$du
D8T$ht
D8T$it
D8T$c
D8T$qt.
D8T$d
D9|$t
E9Wpu
A9Gpt
x AVH
@USVWAWH
A__^[]
UWAUAVAWH
A_A^A]_]
WAVAWH
l$pA;Y
0A_A^_
\$ UVWATAUAVAWH
;o t$
D8W(u
D8T$@tYL
D$pE8P)t
A_A^A]A\_^]
H9T$0
UVWATAUAVAWH
,L$XH
pA_A^A]A\_^]
L$`H;L$ht
L$pH3
p WATAVH
 A^A\_
H9_(t
UVWATAUAVAWH
L$0E3
L$XH3
`A_A^A]A\_^]
x AVH
D9C v
D;C r
VATAUAVAWH
A_A^A]A\^
x AVH
k VWAVH
WAVAWH
0A_A^_
p AWE
D;D$0
@tdHc
@t[Ic
t$(A_
UVWATAUAVAWH
)t$PI
(t$PH
`A_A^A]A\_^]
|$ E3
zkuiL
l$ VWAVH
D$XH9D$PuS
D$XH9D$Pu
L$`H3
p AWE
@tiIc
D;D$0
@t\Hc
t$(A_
WAVAWH
 A_A^_
WATAUAVAWH
A_A^A]A\_
VWAVH
 A^_^
L$`H3
@SUVWATAUAVAWH
L$4E3
ISG1E
d$@D;
D$HA9F,
G$9C$u0
G 9C u
L$8A;
D8d$0t
L$8D;
t$4E3
D8d$0D
A_A^A]A\_^][
x UATAUAVAWH
L9~(u6A;
CRPTH
SDTLH
SMIDH
SDBGH
SPDBH
STATH
SFI0H
RDEFH
ISGNH
ISG1H
OSGNH
OSG1H
RDEFH
ISGNH
D$ ISGN
OSGNH
D$ OSGNL
D$ OSGN
A_A^A]A\]
@USVWATAUAVAWH
W>~/x
s!D9t
A_A^A]A\_^[]
l$ VWAVH
L$@E3
;L$Hu
;L$Hu
x ATAVAWH
pcU6J>-
A_A^A\
UVWATAUAVAWH
$0< u
p<`t9H
$0< u
`A_A^A]A\_^]
UVWATAUAVAWH
$0< u
p<`t9H
$0< u
`A_A^A]A\_^]
WAVAWH
9H8v&L
 A_A^_
x ATAVAWH
9h@r{
-9j@r-M9
 A_A^A\
VWATAUAWH
A_A]A\_^
ATAVAWH
A_A^A\
UVWATAUAVAWH
A_A^A]A\_^]
UAVAWH
@A_A^]
@USVWATAVAWH
A_A^A\_^[]
x ATAVAWH
A_A^A\
WATAUAVAWH
x-u%H
A_A^A]A\_
x AVH
WAVAWH
A_A^_
t$ WH
t$ WH
t$ WH
H!D$8H
UVWATAUAVAWH
`A_A^A]A\_^]
@USVWATAVAWH
D8eHu
D8ePu
`A_A^A\_^[]
|$ UATAUAVAWH
v(D8e
A_A^A]A\]
UATAUAVAWH
A_A^A]A\]
UVWATAUAVAWH
H!^ !^(
A_A^A]A\_^]
UVWATAUAVAWH
`A_A^A]A\_^]
|$ UATAUAVAWH
8_uiH
8.u]H
A_A^A]A\]
)t$ H
8"t'f
(t$ H
UVWATAUAVAWH
A_A^A]A\_^]
D$ H#
D$p@8t$tt
E9HDv
E;HDr
|$(E3
|$(E3
WATAUAVAWH
l$ E3
k u3H
0A_A^A]A\_
L$ UVWATAUAVAWH
D$ H#
d$(E3
D;_Ds,A
PA_A^A]A\_^]
USVWATAUAVAWH
p@S<_.E
?$thH
L$pE3
~@D;vD
~@H9_(L
t$`E3
D;FDr
L#e8H
A_A^A]A\_^[]
WATAUAVAWH
0A_A^A]A\_
@SVWH
UVWATAUAVAWH
$0< u
p<`t9H
$0< u
$`<`u
pA_A^A]A\_^]
UVWATAUAVAWH
L9w(t
L9G(t
pA_A^A]A\_^]
UVWATAUAVAWH
E@D8}ptA
H#E@H
I9V(t
A_A^A]A\_^]
VWATAUAVH
D$ H#
W>~/x
0A^A]A\_^
UVWATAUAVAWH
l$0E3
$0< u
,t$xH
p<`t;M
L$XHc
$0< u
D$hHc
D9|$X
$0< u
p<`tBM
$0< u
D$hHc
$0< u
,t$xH
p<`tAM
$0< u
D$hHc
$0< u
p<`t?M
L$XHc
$0< u
D$pHc
D$0L!t$(A
D9t$X
$0< u
,t$xH
p<`t:M
L$XHc
$0< u
D$pHc
D$ E3
A_A^A]A\_^]
VWAUAVAWH
p@S<_.E
A_A^A]_^
@USVWATAUAVAWH
A_A^A]A\_^[]
UVWATAUAVAWH
p@S<_.E
p@S<_.E
D!d$(J
PA_A^A]A\_^]
\$ UVWATAUAVAWH
L$pE3
EwD;B
A_A^A]A\_^]
UVWATAUAVAWH
pA_A^A]A\_^]
s AWH
UWAVH
@USVWATAUAVAWH
t$XE3
D$4E3
|$8E3
|$ 3t
D9L$0vML
|$4D92u
A_A^A]A\_^[]
USVWATAUAVAWH
!t$xE
|$PA;
\$XE3
L$PA;
|$XE3
A_A^A]A\_^[]
` UAVAWH
A_A^]
USVWATAUAVAWH
p@S<_.E
L$tE3
L$pD;
z8/t4
T$hE3
\$hH;
A_A^A]A\_^[]
D$hE3
rYA;M0wGA
E4A9B4w=3
A;_0r
(D$0H
USVWATAUAVAWH
CPL9,
A_A^A]A\_^[]
u2I9H0w,E
s WATAUAVAWH
z<D;C
A_A^A]A\_
USVWATAUAVAWH
F t-H
@8t$tu(H
D$ Dk
@8t$t
D$ E3
v t=I
D8\$t
|$(E3
A_A^A]A\_^[]
B D;C E
6wEt"
Nw7t-
yw6t,
D;K L
D;K E
HcT$X
UVWATAUAVAWH
 A_A^A]A\_^]
UATAUAVAWH
A_A^A]A\]
UVWATAUAVAWH
PA_A^A]A\_^]
$p< u
x AVE2
|$(A^
@USVWATAUAVAWH
D3D$`H
A_A^A]A\_^[]
E;C sYI
@USVWATAUAVAWH
D$ tM
D$ uM
A_A^A]A\_^[]
D$(A+
UVWATAUAVAWH
M8H9]0tQH
;U@u2H
t(,0<
t(,0<
A_A^A]A\_^]
t$ WATAUAVAWH
A_A^A]A\_
@USVWATAUAVAWH
D9FHt4E
D$8E3
t2L9e
D$(E3
A(D;vH
L$xE3
A_A^A]A\_^[]
USVWATAUAVAWH
t6E9P
t0Ic@
T$ttDA
T$tt6A
L$xE;
D8D$st
D8D$pt
D8D$qt
D8D$p
uPD8D$rt"H
D8E`u
A;B v
B A;B,v
A_A^A]A\_^[]
@@D9KDvkM
D;KDr
UVWATAUAVAWH
L$xu#H
E`u6E3
tJL9#uAA
D9L$p
D;L$p
A_A^A]A\_^]
WAVAWH
D$(E3
A_A^_
UVWAVAWH
\$PHc
T$`Hc
pA_A^_^]
WATAUAVAWH
C"D8C0u
|$xtdH
D8k$u
H9F(uYH
D8k%u
D8k$u
D8k!u
tKD8k$uEJ
D8k!u
D8k t
D9k,u
D9[,t
D9k,u
 A_A^A]A\_
UVWAVAWH
D$@E3
A_A^_^]
@USVWATAUAVAWH
y8!u.H
A_A^A]A\_^[]
T$HH+
HcD$pH
D$pD;
D$xD8
t$hD9
t$hD9
\$(Hc
D$pD;
\$(Hc
D$pD;
` UAVAWH
A_A^]
UVWATAUAVAWH
L$xE3
A_A^A]A\_^]
D$`E3
\$ UVWATAUAVAWH
l$hL+
L$XE3
L$XA;
A_A^A]A\_^]
@USVWATAUAVAWH
|$Pu>H
@8|$P
u#@8|$Ru H
D$`D;
A_A^A]A\_^[]
@USVWATAUAVAWH
L$pL+
D9i@r
T$pH+
u=D8|$Pu6I
9D$TH
A_A^A]A\_^[]
UVWATAUAVAWH
D8D$Pt
A_A^A]A\_^]
UVWATAUAVAWH
d$HH+
A_A^A]A\_^]
VWAVH
 A^_^
@SVWH
D$ H;D$(u
L$pH3
L$ UVWATAUAVAWH
PA_A^A]A\_^]
UWAVH
@A^_]
D$HH9D$Pu
@USVWATAUAVAWH
L$pE3
u,@8|$@u%I
A_A^A]A\_^[]
@USVWATAUAVAWH
$0< u
p<`tDH
$0< u
$0< u
p<`tDH
$0< u
L9e u
A_A^A]A\_^[]
D$xE3
D$ E3
D$xE3
cPD8u
D$ E3
D$pE3
8\$pt'H
D$h8D$`tj@
x AUAVAWH
D8\$p
D8\$x
D8\$xt
tTD8\$xt>
0A_A^A]
\$ UVWATAUAVAWH
T$hI+
d$(E3
d$(E3
A_A^A]A\_^]
UWATAVAWH
A_A^A\_]
USVWATAUAVAWH
D8m_H
A_A^A]A\_^[]
|$ UATAUAVAWH
H9M@t
A_A^A]A\]
UVWATAUAVAWH
t+D9j
t*D9j
 A_A^A]A\_^]
|$ UATAUAVAWH
x`D8M@uZ
x3D8M@u-
D8M@t
A_A^A]A\]
UVWATAUAVAWH
A_A^A]A\_^]
x AVH
x UATAUAVAWH
L$`D;d$L
A_A^A]A\]
UVWATAUAVAWH
D;|$x
0A_A^A]A\_^]
UVWATAUAVAWH
D8|$`tF
D8|$`tlD8
D8|$`t
D8|$`
D8|$`
D8|$`
D8|$`t6H
T$hH;
L$pH;
8L$`t-8
A_A^A]A\_^]
UVWATAUAVAWH
P8L!*I
W8t[H
A_A^A]A\_^]
UVWATAUAVAWH
;T$|s$
D$pD9(u
|$pD9/
A_A^A]A\_^]
UVWATAUAVAWH
$0< u
p<`t@H
$0< u
$0< u
p<`t@H
$0< u
$0< u
p<`t@H
$0< u
$0< u
p<`t@H
$0< u
E8n8A
A_A^A]A\_^]
A0D;@0uaH
8;S(s
J0A9I0r
s WATAUAVAWH
L99uKA;
#HcI0E
0A_A^A]A\_
|$ UATAUAVAWH
uW@8}
r8@8}
A_A^A]A\]
UVWATAUAVAWH
D;\$|s
D;\$ds
Q0D;E
D;\$|s
slD;E
D;\$|s
D9_Lu
x D8|$`t
A_A^A]A\_^]
UVWATAUAVAWH
D8O;tpH
A_A^A]A\_^]
8\$Rt
 D$SE2
8\$bu
|$pE;:s
L$ !\$8L
MpH!\$0A
H!\$(H
!\$8H
H!\$0H
H!\$(L
0HcB0H
D8t$R
D$XE3
x AVH
t$ WATAUAVAWH
 A_A^A]A\_
9yLv`D
t9;{Ls
x ATAVAWH
D;qLs
 A_A^A\
D9I(vbE;J
E;H(r
WAVAWH
 A_A^_
USVWAUAVAWH
D8}gu
A_A^A]_^[]
UVWATAUAVAWH
A_A^A]A\_^]
CPL94
USVWATAUAVAWH
tnL9EwthE3
x)D8}gt#A
$0< u
p<`t@H
$0< u
D$XHc
D9D$X
$0< u
p<`tAH
$0< u
D9D$X
$0< u
p<`tAH
$0< u
D9D$X
$0< u
p<`tAH
$0< u
8T$Pt.I
A_A^A]A\_^[]
@USVWATAUAVAWH
T$lE;
D8L$ft"E
L9Mpt5L9M(t/A
D8L$gtW
x5D8L$eu.
D8L$et
D8T$ft
L$dD;
D8T$gu
uXD8L$fuFD8
D8L$gu
D8L$f
T$lE3
t$iL9M(u
T$lE3
"L$gD
D8L$et
T$hD8L$`u<
|$puHH
D$lA;
uiD8M t
I9I@u.H
D8L$d
D8M tyD8
@@9B@
t$`u:@
t$`D9
H;U8uPH
t$(E3
D8l$iu
F8H9F0t
|$qD8l$eu
D8l$et
D$et{
xR@8|$iuKL
x7@8|$eu0H
trD8|$gtk
D8|$ht=
u/D8|$pu(
A_A^A]A\_^[]
@USVWATAUAVAWH
A_A^A]A\_^[]
t$aD;
D$tD;
D8d$qu"D8
UVWATAUAVAWH
A_A^A]A\_^]
UVWATAUAVAWH
(t$pH
A_A^A]A\_^]
WATAUAVAWH
A_A^A]A\_
UVWATAUAVAWH
(|$pL
A_A^A]A\_^]
@USVWATAUAVAWH
D$dEk
D$hA;
A_A^A]A\_^[]
@USVWATAUAVAWH
A_A^A]A\_^[]
@USVWATAUAVAWH
A_A^A]A\_^[]
@USVWATAUAVAWH
t}HcE
tgHcE
A_A^A]A\_^[]
\$ UVWATAUAVAWH
!\$(H
!\$ L
d$(E3
t$(E3
l$ E3
l$ E3
T$ E3
D;A4r
A_A^A]A\_^]
 !"#$%&'()*+,-./0123456789:;<=>?@
ABCDEFGHIIIJKKJKKLMNOPPPQPPPPPPRSTUVWXYZ[\]^_`abcdefghijklmnopqrs
UVWATAUAVAWH
H9}hu
pA_A^A]A\_^]
UVWATAUAVAWH
H9upu
pA_A^A]A\_^]
UVWATAUAVAWH
woteD
A_A^A]A\_^]
22 !"222#2$2%2&222'()*'22222+,-.+22222/01
RRRRR
RRRRR
RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR
RRRRRRRRRRRRRRRRRRRRRRR
RRRRRR
 !!"##$$%%&''(RRRR))**+,,--
..//0++0012334556778899::;;<<=>>?RRRR@ABCDEFGHIJKGLLMNBOOPQ
UVWATAUAVAWH
|$hE3
D8\$Su
D8\$Pt
D8\$Q
D;|$\s
D8\$Rt
A_A^A]A\_^]
@SUVWAVAWH
A_A^_^][
UVWATAUAVAWH
H9]hu
$;upH
D8UxtTB
tiI9N
pA_A^A]A\_^]
@USVWATAUAVAWH
A_A^A]A\_^[]
\$ UVWATAUAVAWH
D$`H+
\$XI+
A_A^A]A\_^]
WATAUAVAWH
A_A^A]A\_
\$ UVWATAUAVAWH
T$PE3
A_A^A]A\_^]
USVWATAUAVAWH
A_A^A]A\_^[]
D8EOt
9EO}.H
D$(E3
x AVH
USVWATAUAVAWH
D$PA;
BD$xJ
T$pD;
A_A^A]A\_^[]
x AVH
x AVH
@USVWATAVH
A^A\_^[]
UVWATAUAVAWH
pA_A^A]A\_^]
UVWATAUAVAWH
E_u"L
A_A^A]A\_^]
WAVAWH
;\$ps>H
0A_A^_
@SVWH
p@S<_.E
L$XH3
uAH9p
L$ UVWATAUAVAWH
|$0E3
D$(E3
D$HE3
A_A^A]A\_^]
\$ UVWATAUAVAWH
D$XA;
A_A^A]A\_^]
to;_|t\;
T$8L;
}`L+u`L+
t$(E3
L$(E3
UVWATAUAVAWH
A_A^A]A\_^]
\$ UVWAVAWH
A_A^_^]
tTM9Q
WAVAWH
0A_A^_
VWAVH
 A^_^
VWAVH
 A^_^
VWAVH
 A^_^
VWAVH
 A^_^
@UVWH
@UVWH
\$ UVWATAUAVAWH
0A_A^A]A\_^]
p AWH
x UATAUAVAWH
D$`E3
L$hE3
L$hE3
A_A^A]A\]
WATAUAVAWH
LFS0H
t$(E3
A_A^A]A\_
t$ WATAUAVAWH
 A_A^A]A\_
x ATAVAWH
 A_A^A\
UVWATAUAVAWH
|$0E2
t$(D;
L$pH3
A_A^A]A\_^]
@USVWAUAVAWH
0A_A^A]_^[]
x AVH
K SWH
x UATAUAVAWH
D8w#t
D8w#t
L$pD8w#t
D8w#t
2D8w"t
D8w$t#H
D8w#t
D$PHcwHH
A;WTt
tCIcOT
IcGTH
IcGTH
IcGTH
D;\$H
A_A^A]A\]
UATAUAVAWH
H)t$XL
E9xDt*L
E9xDt
D$hD9
l$HE9l$
m E9l$
D$HF9l
T$XF8|
D$8B#D
D$@D;
L$PD;
l$@D;
@80u.I
D$pH;
A_A^A]A\]
t$ WATAUAVAWH
@8w"H
"tKA;
948u!
H_tT;
|9T(t
A_A^A]A\_
UATAUAVAWH
>Lt1D
D$ fI
t=D8g#t7D8`"t1D
tML9`
>Lt1D
uID9a
tED8g#t?H
D8` u4D
D8g#t9H
>:t;A
>,t5D
H(D9a
QD8c t"D8c"u
D8c u
D8c"t
A_A^A]A\]
UWAVH
u.D8s#t
D8s#t
uAD8s#t
D8s#t
D8s#t
u}D8s#
D8s#t
D8s#t
u}D8s#
D8s#t
D8s#t
{Hqt*H
 A^_]
 HcQHH
 HcQHH
 HcQHH
 HcQHH
 HcQHH
 HcQHH
 HcQHH
x UATAUAVAWH
D$8E3
D$HE3
L$@E3
D$8E3
D$HE3
L$PE3
D$8E3
D$HE3
L$PE3
A_A^A]A\]
D$8E3
T$@E3
L$PE3
D$hE3
L$PE3
D$@E3
t$X;t$H
D$@D;
D$8E3
@USVWATAUAVAWH
A_A^A]A\_^[]
u8@8s u
@8s"u
@8w$u5A
tB@8w$u4D
A84$t,A
t/A86t*E
yfA9u
\$@A9u
d$HD;
@8w#t
D$@D;
@80t 
@80t6D
@80t6D
D$ E3
@80t6D
@8w#u
#u@@8
@8w#u]
@8w#t-E
@8w$uJ9
@8w"u4D
uN@8w"tH
uN@8w"tH
@8w$uLD
@8w$uLD
@8w$uLD
E9L?XrcE
E9L?X
L?X;H
E9L?X
L?X@8
E9L?X
E9L?Xr
E9L?X
@80t:D
@80t:D
UVWATAUAVAWH
t$8D9D.
L$ E3
L$ E;
d$(D;o
uRfE9l
s,fC9T
PA_A^A]A\_^]
x AVH
L$`A+
L$ SVW
L$ SW
` AVH
x AVH
` UAVAWH
A_A^]
` UAVAWH
A_A^]
PLt0A
D8P)t
D8R)u
x ATAVAWH
 A_A^A\
H;Cpu
x UATAUAVAWH
A_A^A]A\]
x AVH
9DBUGu"H
L$ SUVWATAVAWH
0A_A^A\_^][
L$ SVWH
t$ WH
L$PH3
L$PH3
L$HH3
t$ WAVAWH
D$0E3
D$@D8
L$HH3
A_A^_
t$ WAVAWH
L$HH3
A_A^_
t$ WATAUAVAWH
d$DD9e
L$`E3
L$@E8
t$PL+
H9A thL
d$DD;e
L$pH3
A_A^A]A\_
VWATAVAWH
L$XH3
A_A^A\_^
HdusH
x AVH
D9wtt*
D9wlt L
D9wpttL
RD9wlt)
D9wtt
x ATAVAWH
t%D9q
t%D9p
E8p`t
phE8q`t
Bt9AtuP
Bd9AduH
0A_A^A\
UWAUAVAWH
A_A^A]_]
|$ UATAUAVAWH
A_A^A]A\]
A9@duJM
IuUD;
A9@du
D8A|t,D9
L$PH3
L$PH3
A ;Bd
x AVH
VWAVH
L$HH3
t$ WATAUAVAWH
|$LA81
H9A tcL
A_A^A]A\_
x AVH
Au)D;
WAVAWH
Yt@A;
@8z`t
jhA8y`t
0A_A^_
L9B u
98vWH
x UAVAWH
A_A^]
|$ UATAUAVAWH
A_A^A]A\]
tR9HtuM
.wUtJ
|$ UAVAWH
A_A^]
UVWATAUAVAWH
d$ E3
d$ E3
d$ E3
d$ E3
d$ E3
d$ E3
d$ E3
d$ E3
t$ E3
d$ E3
d$ E3
d$ E3
t$ E3
L$XH3
`A_A^A]A\_^]
L$PH3
t$ WATAUAVAWH
L$T9Jxt
t$\E2
L$pA;
A_A^A]A\_
UATAUAVAWH
fdu$L
Nh8SduG
D9Flt
A_A^A]A\]
x AVH
Qu'@8
D9wtu
9w|t!L
D9wtu:H
@0@84
@0@84
@0@84
t$ WATAUAVAWH
D8cdt
Au+D;
D9fhu!L
ul9~htgL
D9~htEL
D9fpt!L
9FtuX
u"D9^duNC
FhtAL
u-D;^ds'D9Fdw!L
G0F8$8t
G8F8$8t
O@F8$9t
L$PH3
A_A^A]A\_
UWATAUAVH
A^A]A\_]
L$`H3
XtkD+
x UATAUAVAWH
A_A^A]A\]
x UATAUAVAWH
A_A^A]A\]
L$PH3
UVWATAUAVAWH
l$ E3
l$ E3
l$ E3
l$ E3
l$ E3
l$ E3
l$ E3
l$ E3
l$ E3
l$ E3
t~E8h
txE8i
trD8i
tlD8o
tfE8o
t`E8j
L$PH3
`A_A^A]A\_^]
L$PH3
@SUVWATAUAVAWH
D9Axt
l$@@8/
L$PuuC
T$XE;
xA_A^A]A\_^][
@SUVATAUAVAWH
A8U`u#L
@A_A^A]A\^][
WAVAWH
Qu'@8
D9wtu
9o|t!L
D9wtu:H
@0@8,
@0@8,
@0@8,
A_A^_
t$ WATAUAVAWH
9~hu!L
9~pt!L
9Ftu[
u"D9^duQC
FhtDL
u0D;^ds*D9Fdw$L
L$HH3
A_A^A]A\_
UWATAUAVH
A^A]A\_]
L$`H3
x UATAUAVAWH
A_A^A]A\]
|$ UATAUAVAWH
A_A^A]A\]
]uHE;
l$ WH
|$ E3
|$ E3
t<A8{
t6A8z
t0A8y
t*A8x
t$@8z
L$PH3
L$PH3
@SUVWATAUAVAWH
XA_A^A]A\_^][
VWAUAVAWH
9FtuY
u"D9^duOC
FhtBL
u.D;^ds(D9Fdw"L
L$HH3
A_A^A]_^
L$hH3
x UATAUAVAWH
A_A^A]A\]
|$ UATAUAVAWH
A_A^A]A\]
UVWATAUAVAWH
D$PE3
d$ E3
d$ E3
d$ E3
d$ E3
d$ E3
d$ E3
d$ E3
d$ E3
d$ E3
d$ E3
d$ E3
d$ E3
d$ E3
d$ E3
d$ E3
t}D8`
twD8b
tqE8a
tkD8g
teD8e
t_E8f
tYD8f
L$PH3
`A_A^A]A\_^]
L$PH3
UVWATAUAVAWH
@A_A^A]A\_^]
WAVAWH
Qu'@8
D9wtu
9o|t!L
D9wtu:H
@0@8,
@0@8,
@0@8,
A_A^_
VWATAVAWH
9FtuX
u"D9^duNC
FhtAL
u-D;^ds'D9Fdw!L
L$HH3
A_A^A\_^
UATAUAVAWH
A_A^A]A\]
L$`H3
x UATAUAVAWH
A_A^A]A\]
|$4D9D$$u
D9D$(u
9|$0t
u&9l$0u L
L$@H3
|$ UATAUAVAWH
.D9[`u
u_D9[`uYH
uGD9[`uAH
A_A^A]A\]
l$ VWATAVAWH
D$PE3
|$ E3
|$ E3
|$ E3
|$ E3
|$ E3
|$ E3
|$ E3
|$ E3
|$ E3
|$ E3
|$ E3
tyE8{
tsE8y
L$PH3
A_A^A\_^
WATAUAVAWH
A_A^A]A\_
\$ UVWATAUAVAWH
ydA8y`u
@A_A^A]A\_^]
WAVAWH
Qu'@8
D9wtu
9o|t!L
D9wtu:H
@0@8,
@0@8,
@0@8,
A_A^_
t$ WATAUAVAWH
D9mltt
D9mpt"L
D9mhu"L
9EtuY
u"D9]duOC
EhtBL
u.D;]ds(D9Edw"L
t$0A;
L$XH3
A_A^A]A\_
UWATAUAVH
A^A]A\_]
L$`H3
x UATAUAVAWH
A_A^A]A\]
|$4D9D$$u
D9D$(u
9|$0t
u&9l$0u L
L$@H3
|$ UATAUAVAWH
A_A^A]A\]
x AUAV
|$0A^A]
x AUAV
|$0A^A]
x ATAVAWH
H@D8c
D9C`r*H
D9C`r
0A_A^A\
x ATAVD
|$0A^A\
WATAUAVAWH
A@D8c
HXD9k`r%H
D9[`r
D9k`r
D9[`r/A
D9k`s
/tTA+
D9[`rU
D9[`r9
D9[`r
0A_A^A]A\_
D9[`E
PdA8x`u
t$ WATAUAVAWH
 A_A^A]A\_
t$ WATAUAVAWH
 A_A^A]A\_
UVWATAUAVAWH
A94$v]L
A_A^A]A\_^]
UVWATAUAVAWH
A94$vPL
A_A^A]A\_^]
WATAUAVAWH
D$`E;
 A_A^A]A\_
WATAUAVAWH
D$`E;
 A_A^A]A\_
UVWATAUAVAWH
t$D@8
\$XE3
A_A^A]A\_^]
9D$4u
WAVAWH
 A_A^_
WAVAWH
H!x !x(
 A_A^_
VWAVH
0A^_^
\$ VWAVH
WAVAWH
@A_A^_
K SVWH
9C8rvu
9C<rlL
9S(wEu
$9S(u
9C8rxu
9C<rnL
;S(r u
&9S(r
L$@E3
@SUVWH
@ 9B r
u3E9X
u.D9Y
ugL;P
WAVAWH
 A_A^_
A(A9@(A
x AVAWH
|$0A_A^
UVWATAUAVAWH
@A_A^A]A\_^]
D$ E3
UVWATAUAVAWH
D;@ r
D;H$v
D;@ r
A_A^A]A\_^]
UVWATAUAVAWH
l$P;n
`A_A^A]A\_^]
UVWATAUAVAWH
D$@E2
D$XH9D$H
A_A^A]A\_^]
UVWATAUAVAWH
 A_A^A]A\_^]
UVWATAUAVAWH
D$PE3
L9l$X
A_A^A]A\_^]
@SUVWAVH
L$@E3
A^_^][
9L$0t
` AVL
d$(A^
x AVH
UWAVI
\$ WH
t$ D+D$ H
|$`Lc
+l$0L
d$xLc
D9C0vg
D;C0r
t!H;C s
|$HE3
HcK(} 
C(A;B
H9{0@
{09{,t
|$ AVH
@VWAVAWH
(A_A^_^
(A_A^_^
(A_A^_^
@SUWATAUH
L$@E3
L$@E3
D$HH;D$`sHL;
A]A\_][
UVWATAUAVAWH
@A_A^A]A\_^]
|$ AVH
WAVAWH
D$(I;
A_A^_
|$ AVH
|$ AVH
t$ WAVAWH
T$(H;T$@
A_A^_
|$ AVAW
|$0A_A^
@SAUAWH
t$@I;
l$pfA
PA_A][
PA_A][
@SAVAWH
l$`fD
pA_A^[
pA_A^[
@SUWH
@SUVWH
(_^][
(_^][
@SAVH
|$ L;
@SWAVH
 A^_[
vfunctab
0123456789ABCDEFTestString
lengthBlock
lengthLocals
lengthParams
maxStack
lengthProlog
lengthSavedRegisters
program
systemExceptionHandling
cplusplusExceptionHandling
functionStart
allocatesBasePointer
Frame data for enclosing function.
Base of the stack frame
size of frame in bytes
return address of the frame
base of locals
cbLocals
cbParams
cbProlog
cbSavedRegs
fHasSEH
fHasEH
funcStart
fUsesBP
compiland
addressSection
addressOffset
length
notPaged
initializedData
uninitializedData
remove
comdat
discardable
notCached
share
execute
write
dataCRC
relocCRC
compilandID
16 bit code
Frame.
Offset in physical section.
Length in bytes of segment.
Read allowed.
Write allowed.
Execute allowed.
CRC of source bytes.
Length of source in bytes.
Source filename.
Object filename.
Virtual filename.
Source compression algorithm.
`Rs%a
\%9~-
vfunctab
Qkkbal
wn>Jj
* CIL *
* Linker *
__imp_
Microsoft (R) Optimizing Compiler
vfunctab
OMAPTO
OMAPFROM
TOKENRIDMAP
XDATA
PDATA
NEWFPO
SECTIONHEADERS
SymIndex
SymTag
LexicalParent
ClassParent
DataKind
LocationType
AddressSection
AddressOffset
RelativeVirtualAddress
VirtualAddress
RegisterId
Offset
Length
VolatileType
ConstType
UnalignedType
Access
LibraryName
Platform
Language
EditAndContinueEnabled
FrontEndMajor
FrontEndMinor
FrontEndBuild
BackEndMajor
BackEndMinor
BackEndBuild
SourceFileName
ObjectFileName
ThunkOrdinal
ThisAdjust
VirtualBaseOffset
Virtual
Intro
CallingConvention
Value
BaseType
Token
TimeStamp
SymbolsFileName
L-value Reference
Count
BitPosition
ArrayIndexType
Packed
UDT has constructor or destructor, or func is a constructor
OverloadedOperator
Nested
HasNestedTypes
HasAssignmentOperator
HasCastOperator
Scoped
VirtualBaseClass
IndirectVirtualBaseClass
VirtualBasePointerOffset
VirtualTableShape
LexicalParentId
ClassParentId
TypeId
ArrayIndexTypeId
VirtualTableShapeId
Function
Managed
VirtualBaseDispIndex
UndecoratedName
Signature
CompilerGenerated
AddressTaken
LowerBound
UpperBound
LowerBoundId
UpperBoundId
TargetSection
TargetOffset
TargetRelativeVirtualAddress
TargetVirtualAddress
MachineType
OEMId
OEMSymbolId
ObjectPointerType
UDTKind
NoReturn
uses custom calling convention
NoInline
debug info for optimized code
Unreachable
return from interrupt
far return
static function
hasDebugInfo
Compiled With LTCG
Is it compiled with -Bzalign
hasSecurityChecks
compiler name
hasAlloca
hasSetJump
hasLongJump
hasInlineAssembly
hasC++EH
hasStructuredEH
hasAsynchronousEH
IsNaked
isAggregated
isSplitted
container
WasSpecifiedAsInline
BufferChecksWithoutOrdering
Type of Virtual Base Offset Table
hasManagedCode
isHotpatchable
isCVTCIL
isMSILNetmodule
isCTypes
isStripped
FrontEndQFE
BackEndQFE
WasInlined
StrictGSCheck
return C++ style UDT
instance constructor of a class with virtual base
R-value Reference
unmodified type
frame pointer present
isSafeBuffers
class is intrinsic type
can't be base class, or method can't be overridden
HFA float
HFA double
LiveRangeStartAddressSection
LiveRangeStartAddressOffset
LiveRangeStartRelativeVirtualAddress
number of live ranges
length of live range
offset into UDT
ID of the register holding base pointer to parameters
ID of the register holding base pointer to locals
location is dependent on control flow
stride
number of rows in a matrix
number of columns in a matrix
matrix is row major
this variable holds return value
this variable is optimized away
built in type kind
register type kind
base data slot
base data offset start
texture slot start
sampler slot start
UAV slot start
size in UDT
memory space kind
unmodified type ID
sub type ID
sub type
number of modifiers
number of HLSL register indices
is HLSL data
is pointer to data member
is pointer to member function
is single inheritance
is multiple inheritance
is virtual inheritance
pointer based on value of a symbol
base symbol for base pointer
ID of base symbol for base pointer
object file name
is Accelerator group shared local
is live range of Accelerator pointer tag
is Accelerator stub function
number of Accelerator pointer tags
is compiled with /sdl
is WinRT pointer
is ref class/struct
is value class/struct
is interface class/struct
is compiled with /ltcg:pgo
has valid PGO counts
is the function optimized for speed
total invocation count in PGO training
edge count between a caller/callee and it's parent
dynamic instruction count calculated by training
static instruction count
final static size of live function, after inlining
phase this function is a member of for PGO multiphased builds
is compiled with /guard:cf
export is CONSTANT
export is DATA
export is PRIVATE
export is NONAME
export has explicitly assigned ordinal
export is forwarder
export ordinal
frame size
section number of exception handler
offset of exception handler
is objective-c class interface/implementation
is objective-c category
is objective-c protocol
SECTIONHEADERSORIG
Unique id for the source file (in this data store).
fileName
checksumType
compilands
Symbols
SourceFiles
LineNumbers
sourceFile
lineNumber
lineNumberEnd
columnNumber
columnNumberEnd
sourceFileID
statement
Sections
SegmentMap
Unique id for input assembly file (in this data store)
index of input assembly file
time stamp
PDB is available at IL merge time
input assembly file name
InjectedSource
FrameData
InputAssemblyFiles
FIXUP
@Module %d
***DIA***
***globals***
ulRvaStart
cbBlock
cbStkMax
frameFunc
raSearchStart
raSearch
$T0 .raSearch = $eip $T0 ^ = $esp $T0 4 + =
$T0 $ebp = $eip $T0 4 + ^ = $ebp $T0 ^ = $esp $T0 8 + =
$T0 .raSearch 4 - = $ebp $T0 ^ = $eip $T0 4 + ^ = $esp $T0 8 + =
$T0 .raSearch = $eip $T0 ^ = $esp $T0 4 + =
$T2 $esp = $T0 .raSearchStart = $eip $T0 ^ = $esp $T0 4 + = $ebp $ebp = $ebx $ebx =
$T0 $esp = $eip $T0 ^ = $esp $T0 4 + = $ebp $ebp = $ebx $ebx = $eax $eax = $ecx $ecx = $edx $edx = $esi $esi = $edi $edi =
__EH_prolog
_EH_prolog
__EH_prolog2
_EH_prolog2
$T2 $esp = $T0 .raSearchStart =
__SEH_prolog
_SEH_prolog
__SEH_prolog4
_SEH_prolog4
__SEH_prolog4_GS
_SEH_prolog4_GS
__EH_prolog3
_EH_prolog3
__EH_prolog3_catch
_EH_prolog3_catch
__EH_prolog3_GS
_EH_prolog3_GS
__EH_prolog3_catch_GS
_EH_prolog3_catch_GS
__EH_prolog3_align
_EH_prolog3_align
__EH_prolog3_catch_align
_EH_prolog3_catch_align
__EH_prolog3_GS_align
_EH_prolog3_GS_align
__EH_prolog3_catch_GS_align
_EH_prolog3_catch_GS_align
_KiUserExceptionDispatcher@8
_KiUserCallbackDispatcher@12
Import:
.debug$P
.debug$T
.debug$S
@%s<E&C%03.3d>
@ILT+%d(%s)EnC
vfunctab
___ImageBase
vfunctab
QOMthis
vfunctab
(none)
 0x%x
 "%s"
<NoType>
wchar_t
signed char
unsigned char
unsigned int
float
<BCD>
short
unsigned short
unsigned long
__int8
__int16
__int32
__int64
__int128
unsigned __int8
unsigned __int16
unsigned __int32
unsigned __int64
unsigned __int128
<currency>
<date>
VARIANT
<complex>
<bit>
HRESULT
char16_t
char32_t
unsigned 
double
[%llu]
 const
 volatile
 unaligned
struct
class
union
const 
__unaligned 
static 
vfunctab
vfunctab
Microsoft
 Program Database
14.20.27412.1
vfunctab
bcrypt.dll
BCryptOpenAlgorithmProvider
BCryptCloseAlgorithmProvider
BCryptGetProperty
BCryptCreateHash
BCryptHashData
BCryptFinishHash
BCryptDestroyHash
SHA256
HashDigestLength
ObjectLength
kernel32.dll
api-ms-win-core-file-l2-1-1.dll
CopyFileExW
3333333333333333UUUUUUUUUUUUUUUU
vfunctab
vfunctab
LF_MODIFIER
LF_POINTER
LF_ARRAY
LF_CLASS
LF_STRUCTURE
LF_UNION
LF_ENUM
LF_ALIAS
LF_MANAGED
LF_PROCEDURE
LF_MFUNCTION
LF_VTSHAPE
LF_VFTABLE
LF_COBOL0
LF_COBOL1
LF_BARRAY
LF_LABEL
LF_NULL
LF_DIMARRAY
LF_VFTPATH
LF_PRECOMP
LF_ENDPRECOMP
LF_OEM
LF_OEM2
LF_TYPESERVER
LF_TYPESERVER2
LF_SKIP
LF_ARGLIST
LF_DERIVED
LF_DEFARG
LF_LIST
LF_FIELDLIST
LF_METHODLIST
LF_BITFIELD
LF_DIMCONU
LF_DIMCONLU
LF_DIMVARU
LF_DIMVARLU
LF_REFSYM
LF_INDEX
LF_BCLASS
LF_VBCLASS
LF_IVBCLASS
LF_FRIENDCLS
LF_FRIENDFCN
LF_MEMBER
LF_STMEMBER
LF_VFUNCTAB
LF_VFUNCOFF
LF_METHOD
LF_ONEMETHOD
LF_ENUMERATE
LF_NESTTYPE
LF_TYPESERVER_ST
LF_ENUMERATE_ST
LF_ARRAY_ST
LF_CLASS_ST
LF_STRUCTURE_ST
LF_UNION_ST
LF_ENUM_ST
LF_ALIAS_ST
LF_MANAGED_ST
LF_DIMARRAY_ST
LF_PRECOMP_ST
LF_DEFARG_ST
LF_FRIENDFCN_ST
LF_MEMBER_ST
LF_STMEMBER_ST
LF_METHOD_ST
LF_NESTTYPE_ST
LF_ONEMETHOD_ST
LF_NESTTYPEEX_ST
LF_MEMBERMODIFY_ST
LF_MODIFIER_16t
LF_POINTER_16t
LF_ARRAY_16t
LF_CLASS_16t
LF_STRUCTURE_16t
LF_UNION_16t
LF_ENUM_16t
LF_PROCEDURE_16t
LF_MFUNCTION_16t
LF_COBOL0_16t
LF_BARRAY_16t
LF_DIMARRAY_16t
LF_VFTPATH_16t
LF_PRECOMP_16t
LF_OEM_16t
LF_SKIP_16t
LF_ARGLIST_16t
LF_DERIVED_16t
LF_DEFARG_16t
LF_FIELDLIST_16t
LF_METHODLIST_16t
LF_BITFIELD_16t
LF_DIMCONU_16t
LF_DIMCONLU_16t
LF_DIMVARU_16t
LF_DIMVARLU_16t
LF_INDEX_16t
LF_BCLASS_16t
LF_VBCLASS_16t
LF_IVBCLASS_16t
LF_FRIENDCLS_16t
LF_FRIENDFCN_16t
LF_MEMBER_16t
LF_STMEMBER_16t
LF_VFUNCTAB_16t
LF_VFUNCOFF_16t
LF_METHOD_16t
LF_ONEMETHOD_16t
LF_NESTTYPE_16t
LF_NESTTYPEEX
LF_MEMBERMODIFY
LF_FUNC_ID
LF_MFUNC_ID
LF_BUILDINFO
LF_STRING_ID
LF_SUBSTR_LIST
LF_UDT_SRC_LINE
LF_STRIDED_ARRAY
LF_VECTOR
LF_MATRIX
LF_MODIFIER_EX
LF_HLSL
LF_INTERFACE
LF_BINTERFACE
LF_CLASS2
LF_STRUCTURE2
LF_UNION2
LF_INTERFACE2
S_COMPILE
S_REGISTER_16t
S_CONSTANT_16t
S_UDT_16t
S_SSEARCH
S_END
S_SKIP
S_CVRESERVE
S_OBJNAME_ST
S_ENDARG
S_COBOLUDT_16t
S_MANYREG_16t
S_RETURN
S_ENTRYTHIS
S_BPREL16
S_LDATA16
S_GDATA16
S_PUB16
S_LPROC16
S_GPROC16
S_THUNK16
S_BLOCK16
S_WITH16
S_LABEL16
S_CEXMODEL16
S_VFTABLE16
S_REGREL16
S_BPREL32_16t
S_LDATA32_16t
S_GDATA32_16t
S_PUB32_16t
S_LPROC32_16t
S_GPROC32_16t
S_THUNK32_ST
S_BLOCK32_ST
S_WITH32_ST
S_LABEL32_ST
S_CEXMODEL32
S_VFTABLE32_16t
S_REGREL32_16t
S_LTHREAD32_16t
S_GTHREAD32_16t
S_SLINK32
S_LPROCMIPS_16t
S_GPROCMIPS_16t
S_PROCREF_ST
S_DATAREF_ST
S_ALIGN
S_LPROCREF_ST
S_OEM
S_REGISTER_ST
S_CONSTANT_ST
S_UDT_ST
S_COBOLUDT_ST
S_MANYREG_ST
S_BPREL32_ST
S_LDATA32_ST
S_GDATA32_ST
S_PUB32_ST
S_LPROC32_ST
S_GPROC32_ST
S_VFTABLE32
S_REGREL32_ST
S_LTHREAD32_ST
S_GTHREAD32_ST
S_LPROCMIPS_ST
S_GPROCMIPS_ST
S_FRAMEREG
S_FRAMEPROC
S_COMPILE2_ST
S_MANYREG2_ST
S_LPROCIA64_ST
S_GPROCIA64_ST
S_LOCALSLOT_ST
S_PARAMSLOT_ST
S_ANNOTATION
S_GMANPROC_ST
S_LMANPROC_ST
S_RESERVED1
S_RESERVED2
S_RESERVED3
S_RESERVED4
S_LMANDATA_ST
S_GMANDATA_ST
S_MANFRAMEREL_ST
S_MANREGISTER_ST
S_MANSLOT_ST
S_MANMANYREG_ST
S_MANREGREL_ST
S_MANMANYREG2_ST
S_MANTYPREF
S_UNAMESPACE_ST
S_OBJNAME
S_THUNK32
S_BLOCK32
S_WITH32
S_LABEL32
S_REGISTER
S_CONSTANT
S_UDT
S_COBOLUDT
S_MANYREG
S_BPREL32
S_BPREL32_INDIR
S_LDATA32
S_GDATA32
S_STATICLOCAL
S_PUB32
S_LPROC32
S_GPROC32
S_LPROC32EX
S_GPROC32EX
S_REGREL32
S_REGREL32_INDIR
S_LTHREAD32
S_GTHREAD32
S_LPROCMIPS
S_GPROCMIPS
S_COMPILE2
S_MANYREG2
S_LPROCIA64
S_GPROCIA64
S_LOCALSLOT
S_PARAMSLOT
S_LMANDATA
S_GMANDATA
S_MANFRAMEREL
S_MANREGISTER
S_MANSLOT
S_MANMANYREG
S_MANREGREL
S_MANMANYREG2
S_UNAMESPACE
S_PROCREF
S_DATAREF
S_LPROCREF
S_ANNOTATIONREF
S_TOKENREF
S_GMANPROC
S_LMANPROC
S_TRAMPOLINE
S_MANCONSTANT
S_ATTR_FRAMEREL
S_ATTR_REGISTER
S_ATTR_REGREL
S_ATTR_MANYREG
S_SEPCODE
S_LOCAL
S_FILESTATIC
S_DEFRANGE
S_DEFRANGE_SUBFIELD
S_DEFRANGE_SUBFIELD_REGISTER
S_DEFRANGE_REGISTER
S_DEFRANGE_FRAMEPOINTER_REL
S_DEFRANGE_FRAMEPOINTER_REL_FULL_SCOPE
S_DEFRANGE_REGISTER_REL
S_DEFRANGE_REGISTER_REL_INDIR
S_SECTION
S_COFFGROUP
S_EXPORT
S_CALLSITEINFO
S_HEAPALLOCSITE
S_FRAMECOOKIE
S_DISCARDED
S_COMPILE3
S_ENVBLOCK
S_BUILDINFO
S_INLINESITE
S_INLINESITE2
S_INLINESITE_END
S_PROC_ID_END
S_GPROC32_ID
S_LPROC32_ID
S_GPROC32EX_ID
S_LPROC32EX_ID
S_GPROCMIPS_ID
S_LPROCMIPS_ID
S_GPROCIA64_ID
S_LPROCIA64_ID
S_DEFRANGE_HLSL
S_GDATA_HLSL
S_LDATA_HLSL
S_GDATA_HLSL32
S_LDATA_HLSL32
S_GDATA_HLSL32_EX
S_LDATA_HLSL32_EX
S_LPROC32_DPC
S_LPROC32_DPC_ID
S_LOCAL_DPC_GROUPSHARED
S_DEFRANGE_DPC_PTR_TAG
S_DPC_SYM_TAG_MAP
S_ARMSWITCHTABLE
S_CALLEES
S_CALLERS
S_INLINEES
S_POGODATA
S_REF_MINIPDB
S_REF_MINIPDB2
S_PDBMAP
S_HOTPATCHFUNC
0123456789abcdef
vfunctab
Microsoft C/C++ program database 2.00
Microsoft C/C++ MSF 7.00
Fcb = %d
vfunctab
/names
vfunctab
vfunctab
* Portable PDB *
#GUID
#Blob
Method.#%X
COM+_Entry_Point
/LinkInfo
vfunctab
__enc$textbss$begin
__enc$textbss$end
' line %d)
vfunctab
@%d%s (ordinal)
'%s'!'%s'
Microsoft (R) LINK
vfunctab
@Cannot access 32-bit type pool with 16-bit APIs
_NT_ALT_SYMBOL_PATH
_NT_SYMBOL_PATH
SystemRoot
symbols\
SYMSRV*
CACHE*
Software\Microsoft\VisualStudio\MSPDB
SymbolSearchPath
SYMSRV.DLL
SymbolServerW
SymbolServerSetOptions
SymbolServerStoreFileW
SYMSRV.DLL*
Qkkbal
wn>Jj
/src/headerblock
/src/files/
vfunctab
vfunctab
@%08x
.Base
@ILT+%d(
vfunctab
@::<unnamed-tag>
::__unnamed
vfunctab
}yXZ,
Double-precision floating point
Early depth-stencil
UAVs at every shader stage
64 UAV slots
Minimum-precision data types
Double-precision extensions for 11.1
Shader extensions for 11.1
Comparison filtering for feature level 9
Tiled resources
PS Output Stencil Ref
PS Inner Coverage
Typed UAV Load Additional Formats
Raster Ordered UAVs
SV_RenderTargetArrayIndex or SV_ViewportArrayIndex from any shader feeding rasterizer
// <internal error> could not get live range length for variable from PDB
// <internal error> could not get variable index ID from PDB
float
string
Buffer
Texture
Texture1D
Texture1DArray
Texture2D
Texture2DMS
Texture2DArray
Texture2DMSArray
Texture3D
TextureCube
TextureCubeArray
sampler
SamplerState
sampler1D
sampler2D
sampler3D
samplerCUBE
PixelShader
VertexShader
GeometryShader
HullShader
DomainShader
RasterizerState
DepthStencilState
BlendState
RenderTargetView
DepthStencilView
pixelfragment
vertexfragment
interface
ComputeShader
double
min8float
min10float
min16float
min12int
min16int
min16uint
UNKNOWN
//   
row_major %s%ux%u
%s%ux%u
struct %s
struct
// Offset: %4u
%s %s
mixed
unorm
snorm
<continued>
<unknown resource return type>
<unused>
// Buffer Definitions: 
cbuffer
tbuffer
interfaces
Resource bind info for
<unknown buffer type>
// %s %s
// Offset:  N/A Size:   N/A [unused]
 [unused]
// Offset: %4u Size: %5u%s
0x%08x 
Textures:  t%u-t%u
Texture:   t%u
Samplers: s%u-s%u
Sampler: s%u
// Resource Bindings:
// Name                                 Type  Format         Dim      HLSL Bind  Count
// ------------------------------ ---------- ------- ----------- -------------- ------
// Name                                 Type  Format         Dim      ID      HLSL Bind  Count
// ------------------------------ ---------- ------- ----------- ------- -------------- ------
texture
sampler_c
cubearray
1darray
2darray
%sMS%d
struct
r/w+cnt
append
consume
%s%u,space%u
unbounded
// %-30s %10s %6s%d %11s %14s %6s %s
// %-30s %10s %7s %11s %14s %6s %s
// %-30s %10s %6s%d %11s %7s %14s %6s %s
// %-30s %10s %7s %11s %7s %14s %6s %s
// Constant buffer to DX9 shader constant mappings:
// Target Reg Buffer  Source Reg Component
// ---------- ------- ---------- ---------
// b%-9d cb%-5d %10d %9d
// i%-9d cb%-5d %10d %9d
// Target Reg Buffer  Start Reg # of Regs        Data Conversion
// ---------- ------- --------- --------- ----------------------
// clip%-6d cb%-5d %9d %9d  (
// c%-9d cb%-5d %9d %9d  (
// Runtime generated constant mappings:
// Target Reg                               Constant Description
// ---------- --------------------------------------------------
Vertex Shader position offset
Instance ID
Unknown Value
// c%-10d %49s
// Sampler/Resource to DX9 shader sampler mappings:
// Target Sampler Source Sampler  Source Resource
// -------------- --------------- ----------------
// s%-13d s%-14d t%-16d
// Approximately %i instruction slots used
<internal error>
Undefined
Isoline
Triangle
Quadrilateral
// Tessellation Domain   # of control points
// -------------------- --------------------
// %-20s %20u
Point
Clockwise Triangles
Counter-Clockwise Triangles
Integer
Integer Power of 2
Odd Fractional
Even Fractional
// Tessellation Output Primitive  Partitioning Type 
// ------------------------------ ------------------
// %-30s %-18s
// %s signature:
// Name                 Index   Mask Register SysValue  Format   Used
// -------------------- ----- ------ -------- -------- ------- ------
// no %s
%-17s
%-20s
SV_Depth
    N/A
   oDepth
SV_DepthGreaterEqual
 oDepthGE
SV_DepthLessEqual
 oDepthLE
SV_Coverage
    oMask
SV_StencilRef
    oStencilRef
   primID
  special
   %c%c%c%c
CLIPDST
CULLDST
RTINDEX
VPINDEX
VERTID
PRIMID
INSTID
FFACE
SAMPLE
TARGET
DEPTH
DEPTHGE
DEPTHLE
COVERAGE
INNERCOV
STENCILREF
QUADEDGE
QUADINT
TRIEDGE
TRIINT
LINEDET
LINEDEN
unknown
min2_8f
min16f
min16i
min16u
    YES
     NO
// Function parameter signature (return: %s, parameters: %u):
// Name                 SemanticName         In 1st,Num,Mask Out 1st,Num,Mask Type                           
// -------------------- -------------------- --------------- ---------------- ------------------------------ 
 %-20s
  v%-4u %-3u 
   o%-4u %-3u 
 inout
 row_major
 void
 bool
 float
 min16float
 min10float
 min16int
 min12int
 uint
 min16uint
 min8uint
%ux%u
%s%d%s
[%s%d[%s].%c]
[%s%d.%c]
 (%.9g
, %.9g
 expr
 vPos
 vPSize
0x%08x
+#INF
-#INF
%.14fl
0x%016I64xUI64
%4u%c 
0x%08X: 
// approximately %u instruction%s used
Error: Texture shader assembly not found!
Error: Error getting texture shader literal block.
    tx_%u_%u
def32
 { nonuniform }
oDepth
vFace
<invalid member offset>
// Generated by 
Microsoft (R) D3DX9 Shader Disassembler
<invalid constant table>
// Parameters:
<invalid type offset>
// Registers:
//   Name
 Reg   Size
 ----- ----
 %c%-4u
// Default values:
//   %s
//     %c%-4u= 
<invalid default value offset>
{ %g, %g, %g, %g }
{ %d, %d, %d, %d }
false
label
vPrim
oDepthGE
oDepthLE
rasterizer
oMask
oStencilRef
vOutputControlPointID
vForkInstanceID
vJoinInstanceID
vDomain
vThreadID
vThreadGroupID
vThreadIDInGroup
vThreadIDInGroupFlattened
vCoverage
vInnerCoverage
vGSInstanceID
vCycleCounter
<unknown register type>
<unknown register type %u>
%d[%d].
_%d_%d.
 + %d]
(%fl, %fl)
(%f, %f, %f, %f)
(0x%08x)
undefined
clip_distance
cull_distance
position
rendertarget_array_index
viewport_array_index
vertex_id
sampleIndex
primitive_id
instance_id
is_front_face
finalQuadUeq0EdgeTessFactor
finalQuadVeq0EdgeTessFactor
finalQuadUeq1EdgeTessFactor
finalQuadVeq1EdgeTessFactor
finalQuadUInsideTessFactor
finalQuadVInsideTessFactor
finalTriUeq0EdgeTessFactor
finalTriVeq0EdgeTessFactor
finalTriWeq0EdgeTessFactor
finalTriInsideTessFactor
finalLineDetailTessFactor
finalLineDensityTessFactor
    preshader
    vs_2_x
    lib_4_0_vs_2_x
    vs_2_sw
    vs_3_sw
    ps_2_x
    lib_4_0_ps_2_x
    ps_2_sw
    ps_3_sw
    vs_%u_%u
    lib_4_0_vs_%u_%u
    ps_%u_%u
    lib_4_0_ps_%u_%u
// disassembly only available for VS and PS targets
Error: unexpected end of buffer
    // %s
#line 
%u "%s"
      
sincos
trunc
callnz
endloop
endrep
endif
break
texkill
texbem
texbeml
texreg2ar
texreg2gb
texreg2rgb
texldl
texldd
texm3x2pad
texm3x2tex
texm3x3pad
texm3x3tex
texm3x3spec
texm3x3vspec
texm3x2depth
texm3x3
texdp3tex
texdp3
texdepth
dp2add
reserved0
phase
texldp
texldb
texld
texcrd
texcoord
_cube
_volume
_unknown
_position
_blendweight
_blendindices
_normal
_psize
_texcoord
_tangent
_binormal
_tessfactor
_positiont
_color
_depth
_sample
_centroid
_bias
  // 
%s<%d
// approximately %u instruction slot%s used
 (%u texture, %u arithmetic)
// <internal error> unable to iterate instruction in PDB
// <internal error> incorrect instruction offset in debug info
// <internal error> incorrect token offset in debug info
// <internal error> incorrect file offset in debug info
// <internal error> file name too long in debug info
// <internal error> unable to find instruction in PDB
// <internal error> unable to get statement flag from PDB
// <internal error> unable to instruction offset from PDB
// <internal error> unable to get file id from PDB
// <internal error> unable to get line number from PDB
// <internal error> unable to get column number from PDB
// <internal error> unable to get source file info from PDB
// <internal error> unable to get file name from PDB
// <internal error> line mismatch in debug info
// <internal error> column mismatch in debug info
// <internal error> filename length mismatch in debug info
// <internal error> filename mismatch in debug info
// <internal error> incorrect instruction offset in debug info
// <internal error> too many instruction outputs in debug info
// <internal error> incorrect scalar offset in debug info
// <internal error> incorrect variable offset in debug info
// <internal error> incorrect token offset in debug info
%s[r%u.%c]<
%s[r%u.%c/%u]<
// <internal error> unable to get typedef type from PDB
// <internal error> unable to get type length from PDB
// <internal error> offset overruns length for type in PDB
// <internal error> unable to get sub-variable type from PDB
// <internal error> could not get UDT children in PDB
// <internal error> could not get find UDT child with correct offset in PDB
// <internal error> could not get UDT child offset in PDB
// <internal error> could not get UDT child type in PDB
// <internal error> could not get UDT child length in PDB
// <internal error> unable to get array element type from PDB
// <internal error> could not get array element stride from PDB
// <internal error> unable to get vector element type from PDB
// <internal error> could not get vector element length from PDB
// <internal error> could not get vector length from PDB
// <internal error> invalid vector member
// <internal error> unable to get matrix element type from PDB
// <internal error> could not get matrix element length from PDB
// <internal error> could not get matrix columns from PDB
// <internal error> could not get matrix rows from PDB
// <internal error> could not get matrix row-major flag from PDB
// <internal error> could not get matrix major stride from PDB
// <internal error> invalid matrix member
._m%u%u
// <internal error> unable to get HLSL type kind from PDB
<unknown HLSL built-in %u offset %u>
// <internal error> unexpected data kind in PDB
%s[%u][%u].%c
%s%u.%c
%s[%u].%c
// <internal error> unexpected register type in PDB
// <internal error> could not get location type from PDB
// <internal error> could not get register type from PDB
// <internal error> could not get register index count from PDB
// <internal error> could not get register index values from PDB
//   
// <internal error> unexpected location type in PDB
<internal error> unable to get variable name from PDB
<internal error> unable to get variable subfield offset from PDB
<internal error> unable to get variable type from PDB
// <internal error> could not find inner most frame in PDB
// Initial variable locations:
Prior locations: 
Post-call locations: 
buffer
texture1d
texture2d
texture2dms
texture3d
texturecube
texture1darray
texture2darray
texture2dmsarray
texturecubearray
raw_buffer
structured_buffer
<unknown dimension>
%s%u[%u:
refactoringAllowed
enableDoublePrecisionFloatOps
enableRawAndStructuredBuffers
forceEarlyDepthStencil
skipOptimization
enableMinimumPrecision
enable11_1DoubleExtensions
enable11_1ShaderExtensions
allResourcesBound
<!-- id=%d -->
[%8I64u] 
           
_aoffimmi
_indexable
precise
(%i,%i,%i)
, stride=%u
_rcpfloat 
_uint 
_uglobal
_ugroup
 x%i[%i], %d
 pointlist 
 linestrip 
 trianglestrip 
 undefined 
 ??? 
 point 
 line 
 triangle 
 lineadj 
 triangleadj 
 patch1 
 patch2 
 patch3 
 patch4 
 patch5 
 patch6 
 patch7 
 patch8 
 patch9 
 patch10 
 patch11 
 patch12 
 patch13 
 patch14 
 patch15 
 patch16 
 patch17 
 patch18 
 patch19 
 patch20 
 patch21 
 patch22 
 patch23 
 patch24 
 patch25 
 patch26 
 patch27 
 patch28 
 patch29 
 patch30 
 patch31 
 patch32 
 constant 
 linear 
 linear centroid 
 linear noperspective 
 linear noperspective centroid 
 linear sample 
 linear noperspective sample 
CB%d[%d:
, dynamicIndexed
, immediateIndexed
, space=%d
 domain_quad
 domain_tri
 domain_isoline
 partitioning_integer
 partitioning_pow2
 partitioning_fractional_odd
 partitioning_fractional_even
 output_point
 output_line
 output_triangle_cw
 output_triangle_ccw
 l(%f)
dcl_immediateConstantBuffer
                              
printf 
errorf 
<unknown> 
// COMMENT: %s
undecipherable custom data
_dynamicindexed
 fp%u[%u][%u] = {
, ft%u
 ft%u = {
, fb%u
, %u, %u
 %u, %u, %u
, mode_default
, mode_comparison
, mode_mono
, space=%u
ps_%d_%d
vs_%d_%d
hs_%d_%d
ds_%d_%d
gs_%d_%d
cs_%d_%d
lib_%d_%d
// Available Class Types:
// Name                             ID CB Stride Texture Sampler
// ------------------------------ ---- --------- ------- -------
// %-30s %4u %9u %7u %7u
// Available Class Instances:
// Name                        Type CB CB Offset Texture Sampler
// --------------------------- ---- -- --------- ------- -------
%s[%u]
// %-27s %4u 
%2u %9u 
 -         - 
      - 
      -
// Interface slots, %u total:
//             Slots
// +----------+---------+---------------------------------------
// | Type ID  |%4u-%-4u|
// | Type ID  |%4u     |
// | Type ID  |         |
// | Table ID |         |
// %s shader bytecode:
Microsoft (R) D3D Shader Disassembler
// Note: SHADER WILL ONLY WORK WITH THE DEBUG SDK LAYER ENABLED.
// Note: shader requires additional functionality:
//       %s
Patch Constant
Input
Output
// Debug name: %s
// Pixel Shader runs at sample frequency
Level9
XNA Prepass
D3DCOMPILER_DISASSEMBLY_FORCE_HEX_LITERALS
<pre>
<body bgcolor="#000000">
</pre>
// Library:  flags %x, %u functions:
// %3u  %s
// Created by:  %s
// Trace has %u steps (some may be inactive)
%4u: Illegal instruction index
%s %s = 
%s %s[%d] = 
    asm {
    },
asm {
    NULL,
technique10 
    pass 
    {
        // No embedded %s
        %s = %s[%d];
        %s = %s;
        %s = asm {
        %s = NULL;
    }
=FALSE
WIREFRAME
SOLID
MIN_MAG_MIP_POINT
MIN_MAG_POINT_MIP_LINEAR
MIN_POINT_MAG_LINEAR_MIP_POINT
MIN_POINT_MAG_MIP_LINEAR
MIN_LINEAR_MAG_MIP_POINT
MIN_LINEAR_MAG_POINT_MIP_LINEAR
MIN_MAG_LINEAR_MIP_POINT
MIN_MAG_MIP_LINEAR
ANISOTROPIC
COMPARISON_MIN_MAG_MIP_POINT
COMPARISON_MIN_MAG_POINT_MIP_LINEAR
COMPARISON_MIN_POINT_MAG_LINEAR_MIP_POINT
COMPARISON_MIN_POINT_MAG_MIP_LINEAR
COMPARISON_MIN_LINEAR_MAG_MIP_POINT
COMPARISON_MIN_LINEAR_MAG_POINT_MIP_LINEAR
COMPARISON_MIN_MAG_LINEAR_MIP_POINT
COMPARISON_MIN_MAG_MIP_LINEAR
COMPARISON_ANISOTROPIC
TEXT_1BIT
SRC_COLOR
INV_SRC_COLOR
SRC_ALPHA
INV_SRC_ALPHA
DEST_ALPHA
INV_DEST_ALPHA
DEST_COLOR
INV_DEST_COLOR
SRC_ALPHA_SAT
BLEND_FACTOR
INV_BLEND_FACTOR
SRC1_COLOR
INV_SRC1_COLOR
SRC1_ALPHA
INV_SRC1_ALPHA
CLAMP
MIRROR
BORDER
MIRROR_ONCE
FRONT
NEVER
EQUAL
LESS_EQUAL
GREATER
NOT_EQUAL
GREATER_EQUAL
ALWAYS
REPLACE
INCR_SAT
DECR_SAT
INVERT
SUBTRACT
REV_SUBTRACT
GenerateMips
DS_StencilRef
AB_BlendFactor
AB_SampleMask
FillMode
CullMode
FrontCounterClockwise
DepthBias
DepthBiasClamp
SlopeScaledDepthBias
DepthClipEnable
ScissorEnable
MultisampleEnable
AntialiasedLineEnable
DepthEnable
DepthWriteMask
DepthFunc
StencilEnable
StencilReadMask
StencilWriteMask
FrontFaceStencilFail
FrontFaceStencilDepthFail
FrontFaceStencilPass
FrontFaceStencilFunc
BackFaceStencilFail
BackFaceStencilDepthFail
BackFaceStencilPass
BackFaceStencilFunc
AlphaToCoverageEnable
BlendEnable
SrcBlend
DestBlend
BlendOp
SrcBlendAlpha
DestBlendAlpha
BlendOpAlpha
RenderTargetWriteMask
Filter
AddressU
AddressV
AddressW
MipLODBias
MaxAnisotropy
ComparisonFunc
BorderColor
MinLOD
MaxLOD
[%s[%u + %s].%c]
[%s[%s].%c]
[%s[%u].%c]
[%s.%c]
%s[%u +
Error: Effects expression assembly in invalid format!
Error: Effects expression assembly not found!
Error: Error getting Effects expression constant table.
Error: Error getting Effects expression literal block.
##Internal error##
0x%02x
 = { 
 : %s
 : packoffset(c%u.%c)
 : register(%c%u)
 = { "%s"
, "%s"
 = "%s"
// Offset: %4u, size: %4u
// %u %s buffer(s)
single 
asm {
/* Stream %u out decl: "%s" */
/* Stream %u to rasterizer */
/* Interface parameter %u bound to: %s
%s[%s]
%s[eval(
eval(
/* Stream out decl: "%s" */
// %u %s object(s)
// %u %s interface(s)
// %u technique(s)
technique11
technique10
// %u groups(s)
fxgroup
// FX Version: %s
// Child effect (requires effect pool): %s
local
shared
fx_4_0
fx_4_1
fx_5_0
ID3D11FunctionLinkingGraph::CreateModuleInstance: FLG module instance has already been created
ID3D11FunctionLinkingGraph::CreateModuleInstance: NULL parameter
ID3D11FunctionLinkingGraph::CreateModuleInstance: FLG has no nodes
ID3D11FunctionLinkingGraph::CreateModuleInstance: uninitialized shader output signature parameter #%u, component '%c'
ID3D11FunctionLinkingGraph::CreateModuleInstance: uninitialized parameter #%u component '%c' passed to function '%s::%s' at call site #%u
ID3D11FunctionLinkingGraph::SetSignature: illegal name for parameter %u
__%s_n%u_%u
ID3D11FunctionLinkingGraph::SetSignature: illegal semantic name for parameter %u
ID3D11FunctionLinkingGraph::SetSignature: unknown class for parameter %u
ID3D11FunctionLinkingGraph::SetSignature: NumRows must be between 1 and 4 for parameter %u
ID3D11FunctionLinkingGraph::SetSignature: NumColums must be between 1 and 4 for parameter %u
ID3D11FunctionLinkingGraph::SetSignature: illegal type for parameter %u
ID3D11FunctionLinkingGraph::SetSignature: unknown interpolation mode for parameter %u
ID3D11FunctionLinkingGraph::SetInputSignature: NULL parameter
ID3D11FunctionLinkingGraph::SetInputSignature: too many parameters (%u) in the input signature (max=%u)
ID3D11FunctionLinkingGraph::SetInputSignature: input signature has already been set
ID3D11FunctionLinkingGraph::SetInputSignature: input signature must be the first FLG node
ID3D11FunctionLinkingGraph::SetInputSignature: input signature has duplicate parameter names/semantics
ID3D11FunctionLinkingGraph::SetOutputSignature: NULL parameter
ID3D11FunctionLinkingGraph::SetOutputSignature: too many parameters (%u) in the output signature (max=%u)
ID3D11FunctionLinkingGraph::SetOutputSignature: output signature must be the last FLG node
ID3D11FunctionLinkingGraph::SetOutputSignature: output signature has already been specified
ID3D11FunctionLinkingGraph::SetOutputSignature: output signature has duplicate parameter names/semantics
ID3D11FunctionLinkingGraph::SetOutputSignature: input and output signatures have duplicate parameter names
ID3D11FunctionLinkingGraph::CallFunction: NULL parameter
ID3D11FunctionLinkingGraph::CallFunction: a function cannot be called after the output signature has been set
ID3D11FunctionLinkingGraph::CallFunction: function name cannot be empty
ID3D11FunctionLinkingGraph::CallFunction: function '%s' prototype is not found in the module
ID3D11FunctionLinkingGraph::CallFunction: function '%s' input parameter %u has unsupported register mapping
ID3D11FunctionLinkingGraph::CallFunction: function '%s' output parameter %u has unsupported register mapping
ID3D11FunctionLinkingGraph::CallFunction: %s::%s function has non-matching prototypes (different parameter counts)
ID3D11FunctionLinkingGraph::CallFunction: %s::%s function has non-matching prototypes (parameter %u)
ID3D11FunctionLinkingGraph::PassValueWithSwizzle: illegal character in the swizzle string '%s'
source
destination
ID3D11FunctionLinkingGraph::PassValueWithSwizzle: %s parameter component '%c' is not defined
ID3D11FunctionLinkingGraph::PassValueWithSwizzle: destination swizzle '%s' cannot have replicated components
ID3D11FunctionLinkingGraph::PassValueWithSwizzle: swizzle string cannot be empty
ID3D11FunctionLinkingGraph::PassValueWithSwizzle: NULL parameter
ID3D11FunctionLinkingGraph::PassValueWithSwizzle: source node must preceed destination node in FLG
ID3D11FunctionLinkingGraph::PassValueWithSwizzle: bad source swizzle '%s'
ID3D11FunctionLinkingGraph::PassValueWithSwizzle: bad destination swizzle '%s'
ID3D11FunctionLinkingGraph::PassValueWithSwizzle: illegal source parameter index
ID3D11FunctionLinkingGraph::PassValueWithSwizzle: illegal destination parameter index
ID3D11FunctionLinkingGraph::PassValueWithSwizzle: source parameter must be an INOUT or OUT parameter
ID3D11FunctionLinkingGraph::PassValueWithSwizzle: destination parameter must be an INOUT or IN parameter
ID3D11FunctionLinkingGraph::PassValueWithSwizzle: value must be produced by an output parameter
ID3D11FunctionLinkingGraph::PassValueWithSwizzle: value must be consumed by an input parameter
ID3D11FunctionLinkingGraph::PassValueWithSwizzle: cannot pass values for parameters of type void
ID3D11FunctionLinkingGraph::PassValueWithSwizzle: incompatible element types
ID3D11FunctionLinkingGraph::PassValueWithSwizzle: possible loss of precision when passing value from <%u, %d> to <%u, %d> (<NodeId, ParamId>)
ID3D11FunctionLinkingGraph::PassValueWithSwizzle: incompatible row dimensions
ID3D11FunctionLinkingGraph::PassValueWithSwizzle: incompatible type classes
ID3D11FunctionLinkingGraph::PassValueWithSwizzle: incompatible column dimensions
ID3D11FunctionLinkingGraph::PassValueWithSwizzle: swizzle is not supported for matrices
ID3D11FunctionLinkingGraph::PassValueWithSwizzle: source value has too few components
ID3D11FunctionLinkingGraph::PassValueWithSwizzle: destination parameter component '%c' has already been initialized
row_major 
min8uint
<unknown type>
<unknown class>
inout 
nointerpolation 
centroid 
noperspective 
noperspective centroid 
sample 
noperspective sample 
<unknown interpolation> 
%s_%s_n%u_%u
%s_n%u_%u
void main()
namespace %s
{    
void main(
4SV_VertexID
SV_InstanceID
SV_Position
SV_PrimitiveID
SV_SampleIndex
SV_IsFrontFace
SV_RenderTargetArrayIndex
SV_ClipDistance
SV_CullDistance
SV_Target
ID3D11Linker::SetEntry: entry cannot be NULL
ID3D11Linker::SetEntry: shader target name cannot be NULL
ID3D11Linker::Link: NULL parameter
ID3D11Linker::SetEntry: entry has already been set
ID3D11Linker::SetEntry: unsupported shader target '%s'
ID3D11Linker::SetEntry: only FLG and cs_5_0 entries are supported currently
ID3D11Linker::Link: failed to generate byte code
ID3D11Linker::Link: function '%s::%s' is not found in registered module instances
ID3D11Linker::Link: function '%s::%s' prototype does not match function signature
ID3D11Linker::Link: function '%s::%s' prototype and signature semantics do not match for parameter %u
ID3D11Linker::Link: function '%s::%s' prototype and signature flags do not match for parameter %u
ID3D11Linker::Link: function '%s::%s' prototype and signature types do not match for parameter %u
ID3D11Linker::Link: function '%s::%s' is missing a legacy shader blob necessary to link '%s' target
ID3D11Linker::Link: function '%s::%s' legacy byte code (version '%u.%u') cannot be used to link shader target '%s'
ID3D11Linker::Link: remapping has not been specified for cbuffer slot %u in function '%s::%s'
ID3D11Linker::Link: cbuffer slot %u in function '%s::%s' maps to real slot %u that is too big (max=%u)
ID3D11Linker::Link: illegal remapping specified for sampler slot range [%u, %u] in function '%s::%s'
ID3D11Linker::Link: illegal remapping specified for resource slot range [%u, %u] in function '%s::%s'
ID3D11Linker::Link: illegal remapping specified for UAV slot range [%u, %u] in function '%s::%s'
ID3D11Linker::Link: a duplicate resource names (%s) are not allowed (use namespaces to disambiguate)
ID3D11Linker::Link: function '%s::%s' byte code (version '%u.%u') cannot be used for the requested shader target '%s'
ID3D11Linker::Link: several virtual samplers with incompatible sampler modes map to slot %u
ID3D11Linker::Link: remapping of resource (slot %u) to UAV (slot %u) in function '%s::%s' is allowed only for buffers
resource
ID3D11Linker::Link: several virtual resources with incompatible properties map to real %s slot %u
ID3D11Linker::Link: several UAVs/SRVs with incompatible properties map to slot %u
ID3D11Linker::Link: cbuffer (size=%u) remapping <vslot %u>-><slot %u, offset %u> in function '%s::%s' exceeds the maximum cbuffer size (%u)
ID3D11Linker::Link: immediate cbuffer (%u entries) exceeds the limit of %u entries
ID3D11Linker::Link: not enough temporary registers (max=%u).
ID3D11Linker::Link: total number of registers %u exceeds %u.
input
output
ID3D11Linker::Link: bad %s semantic name '%s'
ID3D11Linker::Link: %s sematic %s number must be in range [%u, %u] for shader target '%s'
ID3D11Linker::Link: invalid %s SV_ semantic '%s' for shader target '%s'
ID3D11Linker::Link: invalid type specified for %s semantic '%s'
ID3D11Linker::Link: %s semantic '%s' can only have one row and number of components between [%u,%u]
ID3D11Linker::Link: invalid interpolation mode specified for %s semantic '%s'
ID3D11Linker::Link: integer types must have constant interpolation mode for %s semantic '%s'
ID3D11Linker::Link: invalid class specified for %s semantic '%s'
ID3D11Linker::Link: only one Depth sematic can be spesified for shader target '%s'
ID3D11Linker::Link: pixel shaders cannot declare arbitrary output semantics ('%s')
ID3D11Linker::Link: SV_ClipDistance semantics cannot be used when using the clipplanes attribute
ID3D11Linker::Link: overlapping %s sematics %s are not supported
ID3D11Linker::Link: Cannot use clipplanes attribute without specifying a 4-component SV_Position output
ID3D11Linker::Link: clipplanes can only specified for Vertex shaders
ID3D11Linker::Link: SV_ClipDistance and SV_CullDistance occupy %u %s registers, only two are allowed
ID3D11Linker::Link: failed to pack %s signature
ID3D11Linker::Link: all components of %s semantic '%s' must be initialized by '%s' shaders
ID3D11Linker::Link: SV_Target outputs must be contiguous from SV_Target0 to SV_TargetN for shader target '%s'
ID3D11Linker::Link: the number of sample entries exceeded the limit of %u
ID3D11Linker::Link: input semantic '%s' cannot be read by '%s' shaders
ID3D11Linker::Link: output semantic '%s' cannot be written by '%s' shaders
ID3D11Linker::Link: the shader requires %u defc constants, which exceeds the allowed limit of %u
ID3D11Linker::Link: the shader requires %u defb constants, which exceeds the allowed limit of %u
ID3D11Linker::Link: the shader requires %u defi constants, which exceeds the allowed limit of %u
ID3D11Linker::UseLibraryWithNamespace: NULL parameter
ID3D11Linker::AddClipPlaneFromCBuffer: cbuffer slot index is too large (max=%u)
ID3D11Linker::AddClipPlaneFromCBuffer: cbuffer entry index is too large (max=%u)
ID3D11Linker::AddClipPlaneFromCBuffer: clipplane for cbuffer %u entry %u has already been specified
ID3D11Linker::AddClipPlaneFromCBuffer: the maximum allowed number of clipplane fron a cbuffer is %u
Microsoft (R) Shader Linker
$CBufferForClipPlane_%u
ID3D11Linker::Link: failed to remap SRV to UAV (slot=%u)
ID3D11Linker::Link: remapping has not been specified for resource slot %u
ID3D11Linker::Link: remapping of resource (slot %u) to UAV (slot %u) is allowed only for buffers
ID3D11Linker::Link: resource slot %u maps to real resource slot %u that is too big (max=%u)
ID3D11Linker::Link: resource slot %u maps to real UAV slot %u that is too big (max=%u)
ID3D11Linker::Link: remapping has not been specified for UAV slot %u
ID3D11Linker::Link: UAV slot %u maps to real slot %u that is too big (max=%u)
vs_4_0
vs_4_0_level_9_1
vs_4_0_level_9_3
vs_4_1
vs_5_0
ps_4_0
ps_4_0_level_9_1
ps_4_0_level_9_3
ps_4_1
ps_5_0
cs_5_0
ID3D11Linker::Link: validation error:  %s
 !@"@
@"@"@
@#@$@%@
@,@&@+@
@'@.@
2@3@1@0@
@)@8@
@:@9@/@
 ;@5@
 $@#@
@ @&@%@
 (@*@
@potentially uninitialized data accessed at this location <| I%u (B%u)
<| dependent on I%u (B%u), A%u (B%u)
uninitialized
this variable depends on potentially %s data on loop exit: %s <| I%u (B%u), A%u (B%u)
. The compiler cannot always detect that an array is fully assigned to. Fully initializing the array in its declaration may help avoid this error
this variable dependent on potentially %s data: %s%s <| I%u (B%u), A%u (B%u)
this loop dependent on potentially %s data <| I%u (B%u), A%u (B%u)
this memory access dependent on potentially %s data <| I%u (B%u), A%u (B%u)
Derivative being used before it was defined. consider moving the derivative assignment earlier in the program.
Derivative is not defined in a different branch of flow-control. Consider moving the derivative assignment before any flow control statements.
this operation
"%s" with respect to "%s"
this operation with respect to %s
Unable to calculate derivative of %s. %s
Redefinition of derivative, derivatives may only be assigned once.
Derivatives of known values are unimplemented.
Consider using the [unroll] attribute on the loop statement or using the assignment syntax to calculate it yourself (e.g.: x`(y) = z)
Consider using the [flatten] attribute on the switch statement or using the assignment syntax to calculate it yourself (e.g.: x`(y) = z)
Consider using the [flatten] attribute on the if statement or using the assignment syntax to calculate it yourself (e.g.: x`(y) = z)
Consider using the assignment syntax to calculate it yourself (e.g.: x`(y) = z)
%s semantic '%s'
IEEE-safe mode clamps float literals to 32-bit values, %g is losing precision (this warning will only be shown once per compile)
32-bit floating-point operations flush denorm float literals to zero, %g is losing precision (this warning will only be shown once per compile)
(unknown)
internal error: not all rules initialized
internal error: Rule class id invalid
$Globals
$Params
$ThisPointer
[internal error]
VerifyAfterFrontEnd
TaylorToShaderModel
ProcessLoadStore64
MoveInputsToTemps
Original - Dead Code Removed
Optimize
Vectorize
Semantic length is limited to %d characters
Zero character semantics aren't allowed
VFace
SV_PrimitiveId
SV_OutputControlPointID
SV_DomainLocation
SV_TessFactor
SV_InsideTessFactor
SV_DispatchThreadID
SV_GroupThreadID
SV_GroupID
SV_GroupIndex
SV_InnerCoverage
SV_GSInstanceID
SV_InstanceId
Position
cannot bind the same variable to multiple constants in the same constant bank
<unknown shader model>
the size of constant buffer %s is %d 16-byte entries, which exceeds maximum allowed size of %d entries
reduce literal lit instruction <| Explicit
symmetric cmp <| Explicit
reduce mov instruction <| Explicit
min of known positive identity <| Explicit
max of known positive identity <| Explicit
lt of known range reduction <| Explicit
ge of known range reduction <| Explicit
atan of known 0 or 1 identity <| Explicit
mul of a half times add of same value identity <| Explicit
negative bool less then another bool identity <| Explicit
bool multiply chain reduction <| Explicit
dot of partial nullity reduction <| Explicit
eval mul <| Explicit
min(x,y) where range of one is <= the other (ieee safe version) <| Explicit
max(x,y) where range of one is >= the other (ieee safe version) <| Explicit
cmp of negated bool identity <| Explicit
cmp diff to basic logic identity <| Explicit
Negative values for cmp and clip can be rordered <| Explicit
Negative value compared with zero <| Explicit
Sequence of compares <| Explicit
FRC of add with integer can bypass add <| Explicit
Mulitply by 1 reduces to no-op move <| Explicit
Multiply by -1 reduces to NEG operation <| Explicit
integer add sequence simplification <| Explicit
integer multiply by one identity <| Explicit
integer multiply by zero identity <| Explicit
integer multiply by negative one identity <| Explicit
integer multiply by literal identity <| Explicit
shift of commutative literals <| Explicit
combine of commutative literals <| Explicit
shift of commutative inputs <| Explicit
imin(x,y) where one is <= the other <| Explicit
imax(x,y) where one is >= the other <| Explicit
umin(x,y) where one is <= the other <| Explicit
umax(x,y) where one is >= the other <| Explicit
umod(x,y) where x < y <| Explicit
Eval range add inf flag if range not bound <| Explicit
Eval range add NaN flag if integer mask says it's possible <| Explicit
propagate range info through mov <| Explicit
propagate special floating point values through div <| Explicit
propagate special floating point values through log <| Explicit
propagate special floating point values through add <| Explicit
propagate special floating point values through mul <| Explicit
propagate special floating point values through rsq <| Explicit
propagate special floating point values through rcp <| Explicit
propagate special floating point values through sqrt <| Explicit
propagate special floating point values through asin <| Explicit
propagate special floating point values through atan2 <| Explicit
(A + L2) - (A + L1) = L2 - L1 if A non-NaN/Inf <| Explicit
Don't truncate double values to floats <| Explicit
Don't flush denorm values to zero <| Explicit
Literal in Log * Mul * Exp pattern <| Explicit
Addition of same argument is same as multiply by 2 <| Explicit
Multiply by 2, 4, or 8 <| Explicit
Multiply by 0 reduces to literal 0 <| Explicit
A * (1/A) = 1 <| Explicit
range sequence reduction <| Explicit
Known literals reduced to mov <| Explicit
rsq result can be assumed positive <| Explicit
min(x,y) where range of one is <= the other <| Explicit
max(x,y) where range of one is >= the other <| Explicit
Simplify conditions on instructions which only care about sign on possibly NaN/Inf values <| Explicit
Simplify cmp sequences on possibly NaN/Inf values <| Explicit
Simplify pow on possibly NaN/Inf values <| Explicit
Simplify integer fraction on possibly NaN/Inf values <| Explicit
CombineInstructions can create dots <| Explicit
vectorize tunnel through mul <| Explicit
vectorize tunnel through neg <| Explicit
vectorize tunnel through add <| Explicit
Change swizzle of parameters to dot <| Explicit
negate modifier match <| Explicit
sat instruction to sat modifier match <| Explicit
abs instruction to abs modifier match <| Explicit
integer negate modifier match <| Explicit
max of neg idenity to abs instruction match <| Explicit
Don't use marker values for clamped literal conversions <| Explicit
propogate swizzles <| Explicit
attempt to group scalar values read by similar instructions <| Explicit
Emit return instructions <| Explicit
Emit output arrays <| Explicit
Tunnel through temp arrays on load <| Explicit
Initialize arrays to void <| Explicit
Conservative correctness checking <| Explicit
Basic correctness checking <| Explicit
emit write masks on sample instructions <| Explicit
reorder instructions to minimize register load <| Explicit
Use replicate swizzles to squish literal arrays <| Explicit
Try swizzling literal arrays to fit them together <| Explicit
Try to match temp array loads to their original store <| Explicit
Remove temp array stores that are immediately overwritten <| Explicit
Do not reduce literals in no-opt compiles <| Explicit
Try to reduce known values to movs <| Explicit
Try to combine like instructions <| Explicit
Remove args for CBuffers that are never read <| Explicit
Hoist predicated code into outermost predicate <| Explicit
search for instancing opportunities in hull shaders <| Explicit
enable instancing searches for programs with multiple outputs <| Explicit
simplify flow control that writes the same value in each flow control path <| Explicit
Do not remove unaliasable array loads in no-opt compiles <| Explicit
Do not reduce switches in no-opt compiles <| Explicit
combine simple instructions to reduce instruction count <| Explicit
Compact Registers - Paint  <| Explicit
Compact Registers - Press Moves <| Explicit
Compact Registers - Press Loop Ins <| Explicit
Compact Registers - Compress <| Explicit
mov of sampler register reduction <| Explicit
detect errors induced by race conditions <| Explicit
if(x){} else {...} -> if(!x) {...} <| Explicit
if(x){...} else {} -> if(x) {...} <| Explicit
if(x){...} if(x){...} -> if(x) {... ...} <| Explicit
use flow control and logical conditions to tighten ranges <| Explicit
if(A){B = A ? C : D} -> if(A){B = C} <| Explicit
A = B ? B : C -> A = B ? TRUE : C} <| Explicit
A = B || !B -> A = B || TRUE <| Explicit
movc(c,ignore,a) -> mov(a) <| MR.GenSimplifyInstructionsAlways_Both
movc(c,a,ignore) -> mov(a) <| MR.GenSimplifyInstructionsAlways_Both
movc(c,ignore,ignore) -> ignore(0) <| MR.GenSimplifyInstructionsAlways_Both
dmovc(c,ignore,a) -> dmov(a) <| MR.GenSimplifyInstructionsAlways_Both
dmovc(c,a,ignore) -> dmov(a) <| MR.GenSimplifyInstructionsAlways_Both
dmovc(c,ignore,ignore) -> ignore(0) <| MR.GenSimplifyInstructionsAlways_Both
break never match (to NOP) <| MR.GenSimplifyInstructionsAlways_Both
continue never match (to NOP) <| MR.GenSimplifyInstructionsAlways_Both
return never match (to NOP) <| MR.GenSimplifyInstructionsAlways_Both
NOT BLT => BGE <| MR.GenSimplifyInstructionsOpt1_Excl
NOT BGE => BLT <| MR.GenSimplifyInstructionsOpt1_Excl
NOT BLT => BGE (safe) <| MR.GenSimplifyInstructionsOpt1_Excl
NOT BGE => BLT (safe) <| MR.GenSimplifyInstructionsOpt1_Excl
NOT BEQ => BNE <| MR.GenSimplifyInstructionsOpt1_Excl
NOT BNE => BEQ <| MR.GenSimplifyInstructionsOpt1_Excl
NOT BILT => BIGE <| MR.GenSimplifyInstructionsOpt1_Excl
NOT BIGE => BILT <| MR.GenSimplifyInstructionsOpt1_Excl
NOT BIEQ => BINE <| MR.GenSimplifyInstructionsOpt1_Excl
NOT BINE => BIEQ <| MR.GenSimplifyInstructionsOpt1_Excl
NOT BULT => BUGE <| MR.GenSimplifyInstructionsOpt1_Excl
NOT BUGE => BULT <| MR.GenSimplifyInstructionsOpt1_Excl
a*(1/(b*a)) -> 1 / b <| MR.GenSimplifyInstructionsOpt1_Excl
rsq(x) * rsq(x) -> rcp(x) <| MR.GenSimplifyInstructionsOpt1_Excl
rsq(x) * rsq(x) -> rcp(x) for positive x <| MR.GenSimplifyInstructionsOpt1_Excl
combine AND of two equal unknown left shifts <| MR.GenSimplifyInstructionsOpt1_Excl
combine AND of two equal unknown right shifts <| MR.GenSimplifyInstructionsOpt1_Excl
combine AND of two equal unknown unsigned right shifts <| MR.GenSimplifyInstructionsOpt1_Excl
back-propagate negate through iadd <| MR.GenSimplifyInstructionsOpt1_Excl
back-propagate negate through imul <| MR.GenSimplifyInstructionsOpt1_Excl
ishl(ishl(a, b), c) : if( nooverflow_mod_32(b, c) ) -> ishl(a, iadd(b, c)) <| MR.GenSimplifyInstructionsOpt1_Excl
ushr(ishl(a, bv), cv) : if( ge_mod_32(cv, bv) ) -> and(ushr(a, cv - bv), (1 << (32-cv))-1) <| MR.GenSimplifyInstructionsOpt1_Excl
ishr(ishr(a, b), c) : if( nooverflow_mod_32(b, c) ) -> ishr(a, iadd(b, c)) <| MR.GenSimplifyInstructionsOpt1_Excl
(a & b) | (a & c) -> and(a, b | c) <| MR.GenSimplifyInstructionsOpt1_Excl
b | (a & c) | (a & d) -> or(b, and(a, or(c,d)) <| MR.GenSimplifyInstructionsOpt1_Excl
and(or(a, iv1), iv2) -> or(and(a, iv2), and(iv1, iv2)) <| MR.GenSimplifyInstructionsOpt1_Excl
or(and(a, iv1), iv2) if(and_ne_zero(iv1, iv2) -> or(and(a, iv1 & ~iv2), iv2) <| MR.GenSimplifyInstructionsOpt1_Excl
u/ishr/l(or(a, iv1), iv2) -> or(u/ishr/l(a, iv2), u/ishr/l(iv1, iv2)) <| MR.GenSimplifyInstructionsOpt1_Excl
u/ishr/l(and(a, iv1), iv2) -> and(u/ishr/l(a, iv2), u/ishr/l(iv1, iv2)) <| MR.GenSimplifyInstructionsOpt1_Excl
u/ishr/l(xor(a, iv1), iv2) -> xor(u/ishr/l(a, iv2), u/ishr/l(iv1, iv2)) <| MR.GenSimplifyInstructionsOpt1_Excl
ishl(imul(a, iv1), iv2) : if(low_bit_clear(iv2)) -> imul(ishl(a, iv2/2), ishl(iv1, iv2/2)) <| MR.GenSimplifyInstructionsOpt1_Excl
ishl(ineg(a), iv1) -> ineg(ishl(a, iv1)) <| MR.GenSimplifyInstructionsOpt1_Excl
ishl(iadd(a, iv1), iv2) -> iadd(ishl(a, iv2), ishl(iv1, iv2)) <| MR.GenSimplifyInstructionsOpt1_Excl
imul(iadd(a, iv1), iv2) -> iadd(imul(a, iv2), imul(iv1, iv2)) <| MR.GenSimplifyInstructionsOpt1_Excl
ushr(ushr(a, b), c) : if( nooverflow_mod_32(b, c) ) -> ushr(a, iadd(b, c)) <| MR.GenSimplifyInstructionsOpt1_Excl
split literal sum ishl to allow literalization <| MR.GenSimplifyInstructionsOpt1_Excl
split literal sum ishr to allow literalization <| MR.GenSimplifyInstructionsOpt1_Excl
split literal sum ushr to allow literalization <| MR.GenSimplifyInstructionsOpt1_Excl
a = bfi(w, o, v, 0i) | r : if( mask_is_zero(w,o,r) ) -> bfi(w, o, v, r) <| MR.GenSimplifyInstructionsOpt1_Excl
r | (a = bfi(w, o, v, 0i)) : if( mask_is_zero(w,o,r) ) -> bfi(w, o, v, r) <| MR.GenSimplifyInstructionsOpt1_Excl
bfi(w, o, v, n) << s -> bfi(w, o+s, v, n) <| MR.GenSimplifyInstructionsOpt1_Excl
ubfe(w, o, a) >> s -> ubfe(w, o + s, a) <| MR.GenSimplifyInstructionsOpt1_Excl
ubfe(w, o, (a >> s) & m) : if( o + s < 32 ) -> ubfe(w, o + s, a & (m << s)) <| MR.GenSimplifyInstructionsOpt1_Excl
ibfe(w, o, (a >> s) & m) : if( o + s < 32 ) -> ibfe(w, o + s, a & (m << s)) <| MR.GenSimplifyInstructionsOpt1_Excl
ibfe(w, o, ((uint)a >> s) & m) : if( w + o + s < 32 ) -> ibfe(w, o + s, a & (m << s)) <| MR.GenSimplifyInstructionsOpt1_Excl
-sin(x) -> sin(-x) <| MR.GenSimplifyInstructionsOpt1_Excl
-dtof(x) -> dtof(-x) <| MR.GenSimplifyInstructionsOpt1_Excl
-ftod(x) -> ftod(-x) <| MR.GenSimplifyInstructionsOpt1_Excl
bfi(w, 0i, n, n) -> mov(n) <| MR.GenSimplifyInstructionsOpt1_NoExcl
bfi(w, o, v, bfi(w, o, 0, n)) -> bfi(w, o, v, n) <| MR.GenSimplifyInstructionsOpt1_NoExcl
bfi(w, o, v, n) << s -> bfi(w, o+s, v, n) <| MR.GenSimplifyInstructionsOpt1_NoExcl
bfi(w, 0, v, n << w) : if( w != 0 ) -> bfi(32-w, w, n, v) <| MR.GenSimplifyInstructionsOpt1_NoExcl
(bfi(w, o, 0, n) | bfi(w, o, v, 0)) -> bfi(w, o, v, n) <| MR.GenSimplifyInstructionsOpt1_NoExcl
(bfi(w, 0i, 0, n) | ubfe(w, 0i, v)) -> bfi(w, 0i, v, n) <| MR.GenSimplifyInstructionsOpt1_NoExcl
ubfe(w, 0i, a) << o -> bfi(w, o, a, 0i) <| MR.GenSimplifyInstructionsOpt1_NoExcl
bfi(w, 0i, a, 0i) -> ubfe(w, 0i, a) <| MR.GenSimplifyInstructionsOpt1_NoExcl
ubfe(w, 0i, a >> s) -> ubfe(w, s, a) <| MR.GenSimplifyInstructionsOpt1_NoExcl
ubfe(w, o, a >> s) : if( o + s < 32 ) -> ubfe(w, o + s, a) <| MR.GenSimplifyInstructionsOpt1_NoExcl
ibfe(w, o, a >> s) : if( o + s < 32 ) -> ibfe(w, o + s, a) <| MR.GenSimplifyInstructionsOpt1_NoExcl
ibfe(w, o, (uint)a >> s) : if( o + s + w < 32 ) -> ibfe(w, o + s, a) <| MR.GenSimplifyInstructionsOpt1_NoExcl
ubfe(w, o, a) >> s : if( o + s < 32 && w >= s ) -> ubfe(w - s, o + s, a) <| MR.GenSimplifyInstructionsOpt1_NoExcl
ibfe(w, o, a) >> s : if( o + s < 32 && w >= s ) -> ibfe(w - s, o + s, a) <| MR.GenSimplifyInstructionsOpt1_NoExcl
b = ubfe(w, o, a); movc(b & (1 << (w - 1 + o)), b | ~((1 << w + o)-1), b) -> ibfe(w, o, a) <| MR.GenSimplifyInstructionsOpt1_NoExcl
a = bfi(w, o, v, 0i) | r : if( mask_is_zero(w,o,r) ) -> bfi(w, o, v, r) <| MR.GenSimplifyInstructionsOpt1_NoExcl
a = bfi(w, o, v, and(m, r)) : if( unmasked_is_one_or_val_is_zero(w,o,v,m) ) -> bfi(w, o, v, r) <| MR.GenSimplifyInstructionsOpt1_NoExcl
a = bfi(w, o, v, and(r, m)) : if( unmasked_is_one_or_val_is_zero(w,o,v,m) ) -> bfi(w, o, v, r) <| MR.GenSimplifyInstructionsOpt1_NoExcl
a = bfi(w, o, and(v, m), r) : if( masked_is_one(w,o,m) ) -> bfi(w, o, v, r) <| MR.GenSimplifyInstructionsOpt1_NoExcl
a = bfi(w, o, and(m, v), r) : if( masked_is_one(w,o,m) ) -> bfi(w, o, v, r) <| MR.GenSimplifyInstructionsOpt1_NoExcl
bfi(and(w,31), o, v, r) : if( lower_5_bits_are_set(31) ) -> bfi(w, o, v, r) <| MR.GenSimplifyInstructionsOpt1_NoExcl
bfi(and(31,w), o, v, r) : if( lower_5_bits_are_set(31) ) -> bfi(w, o, v, r) <| MR.GenSimplifyInstructionsOpt1_NoExcl
bfi(w, and(o,31), v, r) : if( lower_5_bits_are_set(31) ) -> bfi(w, o, v, r) <| MR.GenSimplifyInstructionsOpt1_NoExcl
bfi(w, and(31,o), v, r) : if( lower_5_bits_are_set(31) ) -> bfi(w, o, v, r) <| MR.GenSimplifyInstructionsOpt1_NoExcl
abs(a), a positive -> a <| MR.GenSimplifyInstructionsOpt1_NoExcl
abs(a), a negative -> neg(a) <| MR.GenSimplifyInstructionsOpt1_NoExcl
bine for isfinite on finite -> true <| MR.GenSimplifyInstructionsOpt1_NoExcl
frc(a + int) = frc(a) <| MR.GenSimplifyInstructionsOpt1_NoExcl
$IsRound(fp int) = mov(fp int) <| MR.GenSimplifyInstructionsOpt1_NoExcl
add of zero identity <| MR.GenSimplifyInstructionsOpt1_NoExcl
double add of zero identity <| MR.GenSimplifyInstructionsOpt1_NoExcl
add of negative of itself identity <| MR.GenSimplifyInstructionsOpt1_NoExcl
Legacy (!A + A) => 1 + B <| MR.GenSimplifyInstructionsOpt1_NoExcl
Legacy !A + (A + B) => 1 + B <| MR.GenSimplifyInstructionsOpt1_NoExcl
Legacy C + (A * B) + (A * !B) => C + A <| MR.GenSimplifyInstructionsOpt1_NoExcl
LERP(!A,B,C) -> LERP(A, C, B) <| MR.GenSimplifyInstructionsOpt1_NoExcl
eval eq <| MR.GenSimplifyInstructionsOpt1_NoExcl
eval bne on non-nan value <| MR.GenSimplifyInstructionsOpt1_NoExcl
eval ge <| MR.GenSimplifyInstructionsOpt1_NoExcl
binary expression with negative symmetry reduction <| MR.GenSimplifyInstructionsOpt1_NoExcl
bge(mul(x,x),neg(mul(x,x))) -> true <| MR.GenSimplifyInstructionsOpt1_NoExcl
IGE a,a -> true <| MR.GenSimplifyInstructionsOpt1_NoExcl
ILT a,a -> false <| MR.GenSimplifyInstructionsOpt1_NoExcl
bine(ishl(a, n),0) : if(upper_n_bits_are_zero(a, n)) -> bine (a, 0) <| MR.GenSimplifyInstructionsOpt1_NoExcl
bine(i/ushr(a, n),0) : if(lower_n_bits_are_zero(a, n)) -> bine (a, 0) <| MR.GenSimplifyInstructionsOpt1_NoExcl
dtoi(itod(x)) -> mov(x) <| MR.GenSimplifyInstructionsOpt1_NoExcl
dtou(utod(x)) -> mov(x) <| MR.GenSimplifyInstructionsOpt1_NoExcl
trunc(utod(x)) -> utod(x) <| MR.GenSimplifyInstructionsOpt1_NoExcl
dtof(ftod(x)) -> mov(x) <| MR.GenSimplifyInstructionsOpt1_NoExcl
(a != b) ? a : b -> a <| MR.GenSimplifyInstructionsOpt1_NoExcl
(a != b) ? b : a -> b <| MR.GenSimplifyInstructionsOpt1_NoExcl
(a == b) ? a : b -> b <| MR.GenSimplifyInstructionsOpt1_NoExcl
(a == b) ? b : a -> a <| MR.GenSimplifyInstructionsOpt1_NoExcl
(a == (b ? c : a)) : if (c != a) -> b == 0 <| MR.GenSimplifyInstructionsOpt1_NoExcl
(a == (b ? a : c)) : if (c != a) -> b != 0 <| MR.GenSimplifyInstructionsOpt1_NoExcl
firstbit*(x) != -1 -> x != 0 <| MR.GenSimplifyInstructionsOpt1_NoExcl
firstbit*(x) == -1 -> x == 0 <| MR.GenSimplifyInstructionsOpt1_NoExcl
x ? firstbit*(x) : -1 -> firstbit*(x) <| MR.GenSimplifyInstructionsOpt1_NoExcl
$IsAnyShift(x, and(y, 31)) <| MR.GenSimplifyInstructionsOpt1_NoExcl
$IsAnyShift(x, and(31, y)) <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc(ishl(a, n),v1, v2) : if(upper_n_bits_are_zero(a, n)) -> movc (a, v1, v2) <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc(i/ushr(a, n),v1, v2) : if(lower_n_bits_are_zero(a, n)) -> movc (a, v1, v2) <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc(a, i/ushr/l(a, n), 0) -> i/ushr/l(a, n) <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc(a, b, i/ushr/l(a, n)) -> movc(a, b, 0) <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc(u/ishr/l(a, n), movc(a, b, c), d) -> movc(u/ishr/l(a, n), b, d) <| MR.GenSimplifyInstructionsOpt1_NoExcl
A+A REL L <| MR.GenSimplifyInstructionsOpt1_NoExcl
L REL A+A <| MR.GenSimplifyInstructionsOpt1_NoExcl
A*(L2>0) REL L <| MR.GenSimplifyInstructionsOpt1_NoExcl
L REL A*(L2>0) <| MR.GenSimplifyInstructionsOpt1_NoExcl
A*(L2<0) REL L <| MR.GenSimplifyInstructionsOpt1_NoExcl
L REL A*(L2<0) <| MR.GenSimplifyInstructionsOpt1_NoExcl
A+A REL L (double) <| MR.GenSimplifyInstructionsOpt1_NoExcl
L REL A+A (double) <| MR.GenSimplifyInstructionsOpt1_NoExcl
A*(L2>0) REL L (double) <| MR.GenSimplifyInstructionsOpt1_NoExcl
L REL A*(L2>0) (double) <| MR.GenSimplifyInstructionsOpt1_NoExcl
A*(L2<0) REL L (double) <| MR.GenSimplifyInstructionsOpt1_NoExcl
L REL A*(L2<0) (double) <| MR.GenSimplifyInstructionsOpt1_NoExcl
A*L2 REL L where L2 divides L as a UINT <| MR.GenSimplifyInstructionsOpt1_NoExcl
L REL A*L2 where L2 divides L as a UINT <| MR.GenSimplifyInstructionsOpt1_NoExcl
A*L2 REL L where L2 > 0 divides L as an INT <| MR.GenSimplifyInstructionsOpt1_NoExcl
L REL A*L2 where L2 > 0 divides L as an INT <| MR.GenSimplifyInstructionsOpt1_NoExcl
A*L2 REL L where L2 < 0 divides L as an INT <| MR.GenSimplifyInstructionsOpt1_NoExcl
L REL A*L2 where L2 < 0 divides L as an INT <| MR.GenSimplifyInstructionsOpt1_NoExcl
eval lt <| MR.GenSimplifyInstructionsOpt1_NoExcl
btof -> movc <| MR.GenSimplifyInstructionsOpt1_NoExcl
btoi -> movc <| MR.GenSimplifyInstructionsOpt1_NoExcl
UGE a,a -> true <| MR.GenSimplifyInstructionsOpt1_NoExcl
ULT a,a -> false <| MR.GenSimplifyInstructionsOpt1_NoExcl
simplify chain merges that bring in chain input <| MR.GenSimplifyInstructionsOpt1_NoExcl
simplify chain merges that bring in chain input via mov right <| MR.GenSimplifyInstructionsOpt1_NoExcl
simplify chain merges that bring in chain input via mov left <| MR.GenSimplifyInstructionsOpt1_NoExcl
simplify chain merges that repeatedly chain in the same value <| MR.GenSimplifyInstructionsOpt1_NoExcl
simplify array merges that repeatedly chain in the same value <| MR.GenSimplifyInstructionsOpt1_NoExcl
clip(a+a,b) -> clip(a,b) <| MR.GenSimplifyInstructionsOpt1_NoExcl
clip(+d * a,b) -> clip(a,b) <| MR.GenSimplifyInstructionsOpt1_NoExcl
nullify clip ops on known positive values <| MR.GenSimplifyInstructionsOpt1_NoExcl
remove clips that are merged with known-success clips <| MR.GenSimplifyInstructionsOpt1_NoExcl
remove clip chains that are merged with known-success clips <| MR.GenSimplifyInstructionsOpt1_NoExcl
cmp(+d * a,b,c) -> cmp(a,b,c) <| MR.GenSimplifyInstructionsOpt1_NoExcl
cmp(-d * a,b,c) -> cmp(-a,b,c) <| MR.GenSimplifyInstructionsOpt1_NoExcl
cmp(-b,0,b) -> cmp(b,b,0) <| MR.GenSimplifyInstructionsOpt1_NoExcl
cmp of known positive identity <| MR.GenSimplifyInstructionsOpt1_NoExcl
cmp of known negative identity <| MR.GenSimplifyInstructionsOpt1_NoExcl
cmp(a+a,b,c) -> cmp(a,b,c) <| MR.GenSimplifyInstructionsOpt1_NoExcl
symmetric cmp <| MR.GenSimplifyInstructionsOpt1_NoExcl
cmp(cmp(a, >=0, <0), b, c) -> cmp(a,b,c) <| MR.GenSimplifyInstructionsOpt1_NoExcl
cmp(cmp(a, <0, >=0), b, c) -> cmp(a,c,b) <| MR.GenSimplifyInstructionsOpt1_NoExcl
cmp(-cmp(a, <=0, >0), b, c) -> cmp(a,b,c) <| MR.GenSimplifyInstructionsOpt1_NoExcl
cmp(-cmp(a, >0, <=0), b, c) -> cmp(a,c,b) <| MR.GenSimplifyInstructionsOpt1_NoExcl
Legacy NOT (A || A) => NOT A <| MR.GenSimplifyInstructionsOpt1_NoExcl
CMP(c,d=1+CMP(c,a,b),f) -> CMP(c,1+a,f) <| MR.GenSimplifyInstructionsOpt1_NoExcl
nullify discard ops on known false values <| MR.GenSimplifyInstructionsOpt1_NoExcl
remove discards that are merged with known-success discards <| MR.GenSimplifyInstructionsOpt1_NoExcl
remove discard chains that are merged with known-success discards <| MR.GenSimplifyInstructionsOpt1_NoExcl
merge discard_nz test with an earlier bine comparison <| MR.GenSimplifyInstructionsOpt1_NoExcl
merge discard_z test with an earlier bine comparison <| MR.GenSimplifyInstructionsOpt1_NoExcl
merge and flip discard_nz test with an earlier bieq comparison <| MR.GenSimplifyInstructionsOpt1_NoExcl
merge and flip discard_z test with an earlier bieq comparison <| MR.GenSimplifyInstructionsOpt1_NoExcl
division by a literal becomes multiplication by reciprocal <| MR.GenSimplifyInstructionsOpt1_NoExcl
1 / x -> rcp(x) <| MR.GenSimplifyInstructionsOpt1_NoExcl
x / x -> 1 <| MR.GenSimplifyInstructionsOpt1_NoExcl
dot(normalized_v, normalized_v) == 1.0 when v has length <| MR.GenSimplifyInstructionsOpt1_NoExcl
exp(log(x)) identity <| MR.GenSimplifyInstructionsOpt1_NoExcl
ftob(trunc(btof(x))) -> mov(x) <| MR.GenSimplifyInstructionsOpt1_NoExcl
ftoi(itof(x)) -> mov(x) <| MR.GenSimplifyInstructionsOpt1_NoExcl
trunc(itof(x)) -> itof(x) <| MR.GenSimplifyInstructionsOpt1_NoExcl
ftou(utof(x)) -> mov(x) <| MR.GenSimplifyInstructionsOpt1_NoExcl
trunc(utof(x)) -> utof(x) <| MR.GenSimplifyInstructionsOpt1_NoExcl
Legacy NOT GE => LT <| MR.GenSimplifyInstructionsOpt1_NoExcl
Legacy NOT LT => GE <| MR.GenSimplifyInstructionsOpt1_NoExcl
iadd zero reduces to no-op mov <| MR.GenSimplifyInstructionsOpt1_NoExcl
Integer addition negative identities <| MR.GenSimplifyInstructionsOpt1_NoExcl
iadd(a, b) : if( and_is_zero(a, b) ) -> or(a, b) <| MR.GenSimplifyInstructionsOpt1_NoExcl
if(bine(x,0)) -> if(x) <| MR.GenSimplifyInstructionsOpt1_NoExcl
imul one reduces to no-op mov <| MR.GenSimplifyInstructionsOpt1_NoExcl
ineg(and(ne(x,0),1)) -> ne(x,0) <| MR.GenSimplifyInstructionsOpt1_NoExcl
ineg(ineg(x)) -> mov(x) <| MR.GenSimplifyInstructionsOpt1_NoExcl
u/ishl/r(a, 0) -> mov(a) <| MR.GenSimplifyInstructionsOpt1_NoExcl
((a >> ov1) << o2) : if( ov1 == o2 ) -> and(a, ~((1 << ov1)-1)) <| MR.GenSimplifyInstructionsOpt1_NoExcl
u/ishr(or(a, m), n) : if( or_is_identity_ignore_lower_n_bits(a, m, n) -> u/ishr(a, n) <| MR.GenSimplifyInstructionsOpt1_NoExcl
u/ishr(or(m, a), n) : if( or_is_identity_ignore_lower_n_bits(a, m, n) -> u/ishr(a, n) <| MR.GenSimplifyInstructionsOpt1_NoExcl
u/ishr(and(a, m), n) : if( and_is_identity_ignore_lower_n_bits(a, m, n) -> u/ishr(a, n) <| MR.GenSimplifyInstructionsOpt1_NoExcl
u/ishr(and(m, a), n) : if( and_is_identity_ignore_lower_n_bits(a, m, n) -> u/ishr(a, n) <| MR.GenSimplifyInstructionsOpt1_NoExcl
ishl(or(a, m), n) : if( or_is_identity_ignore_upper_n_bits(a, m, n) -> ishl(a, n) <| MR.GenSimplifyInstructionsOpt1_NoExcl
ishl(or(m, a), n) : if( or_is_identity_ignore_upper_n_bits(a, m, n) -> ishl(a, n) <| MR.GenSimplifyInstructionsOpt1_NoExcl
ishl(and(a, m), n) : if( and_is_identity_ignore_upper_n_bits(a, m, n) -> ishl(a, n) <| MR.GenSimplifyInstructionsOpt1_NoExcl
ishl(and(m, a), n) : if( and_is_identity_ignore_upper_n_bits(a, m, n) -> ishl(a, n) <| MR.GenSimplifyInstructionsOpt1_NoExcl
imul(ishl(iv1, a), iv2) -> ishl(imul(iv1, iv2), a) <| MR.GenSimplifyInstructionsOpt1_NoExcl
A + B for boolean A & B -> OR A, B <| MR.GenSimplifyInstructionsOpt1_NoExcl
A * B for boolean A & B -> AND A, B <| MR.GenSimplifyInstructionsOpt1_NoExcl
itob(x) -> bine(x,0) <| MR.GenSimplifyInstructionsOpt1_NoExcl
itof(ftoi(x)) -> trunc(x) <| MR.GenSimplifyInstructionsOpt1_NoExcl
log(exp(x)) identity <| MR.GenSimplifyInstructionsOpt1_NoExcl
exp(a*log(0)) = 0 identity <| MR.GenSimplifyInstructionsOpt1_NoExcl
Legacy -BOOL < BOOL => BOOL <| MR.GenSimplifyInstructionsOpt1_NoExcl
Legacy (A || A) => A <| MR.GenSimplifyInstructionsOpt1_NoExcl
max(i0, i1): if (i0 >= i1) -> mov(i0) <| MR.GenSimplifyInstructionsOpt1_NoExcl
max(i0, i1): if (i1 >= i0) -> mov(i1) <| MR.GenSimplifyInstructionsOpt1_NoExcl
max(max(i0, l1), l2) -> max(i0, max(l1, l2)) <| MR.GenSimplifyInstructionsOpt1_NoExcl
dmax(i0, i1): if (i0 >= i1) -> mov(i0) <| MR.GenSimplifyInstructionsOpt1_NoExcl
dmax(i0, i1): if (i1 >= i0) -> mov(i1) <| MR.GenSimplifyInstructionsOpt1_NoExcl
dmax(dmax(i0, l1), l2) -> dmax(i0, dmax(l1, l2)) <| MR.GenSimplifyInstructionsOpt1_NoExcl
imax(i0, i1): if (i0 >= i1) -> mov(i0) <| MR.GenSimplifyInstructionsOpt1_NoExcl
imax(i0, i1): if (i1 >= i0) -> mov(i1) <| MR.GenSimplifyInstructionsOpt1_NoExcl
imax(imax(i0, l1), l2) -> imax(i0, imax(l1, l2)) <| MR.GenSimplifyInstructionsOpt1_NoExcl
umax(i0, i1): if (i0 >= i1) -> mov(i0) <| MR.GenSimplifyInstructionsOpt1_NoExcl
umax(i0, i1): if (i1 >= i0) -> mov(i1) <| MR.GenSimplifyInstructionsOpt1_NoExcl
umax(umax(i0, l1), l2) -> umax(i0, umax(l1, l2)) <| MR.GenSimplifyInstructionsOpt1_NoExcl
min(i0, i1): if (i0 >= i1) -> mov(i1) <| MR.GenSimplifyInstructionsOpt1_NoExcl
min(i0, i1): if (i1 >= i0) -> mov(i0) <| MR.GenSimplifyInstructionsOpt1_NoExcl
min(min(i0, l1), l2) -> min(i0, min(l1, l2)) <| MR.GenSimplifyInstructionsOpt1_NoExcl
dmin(i0, i1): if (i0 >= i1) -> mov(i1) <| MR.GenSimplifyInstructionsOpt1_NoExcl
dmin(i0, i1): if (i1 >= i0) -> mov(i0) <| MR.GenSimplifyInstructionsOpt1_NoExcl
dmin(dmin(i0, l1), l2) -> dmin(i0, dmin(l1, l2)) <| MR.GenSimplifyInstructionsOpt1_NoExcl
imin(i0, i1): if (i0 >= i1) -> mov(i1) <| MR.GenSimplifyInstructionsOpt1_NoExcl
imin(i0, i1): if (i1 >= i0) -> mov(i0) <| MR.GenSimplifyInstructionsOpt1_NoExcl
imin(imin(i0, l1), l2) -> imin(i0, imin(l1, l2)) <| MR.GenSimplifyInstructionsOpt1_NoExcl
umin(i0, i1): if (i0 >= i1) -> mov(i1) <| MR.GenSimplifyInstructionsOpt1_NoExcl
umin(i0, i1): if (i1 >= i0) -> mov(i0) <| MR.GenSimplifyInstructionsOpt1_NoExcl
umin(umin(i0, l1), l2) -> umin(i0, umin(l1, l2)) <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc(a,true,false) -> bine(a, 0) <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc(a,false,true) -> bieq(a, 0) <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc(true,b,c) -> mov(b) <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc(false,b,c) -> mov(c) <| MR.GenSimplifyInstructionsOpt1_NoExcl
dmovc(true,b,c) -> dmov(b) <| MR.GenSimplifyInstructionsOpt1_NoExcl
dmovc(false,b,c) -> dmov(c) <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc(a, true, b) -> or(a, b) <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc and comparison sequence reductions <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc(a, b, movc(c, b, d)) -> movc(or(a, c), b, d) <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc(a, b, and(c, b)) -> and(or(a, c), b) <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc(a, and(b, c), 0) -> and(and(a, b), c) <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc(!a,b,c) -> movc(a,c,b) <| MR.GenSimplifyInstructionsOpt1_NoExcl
dmovc(!a,b,c) -> dmovc(a,c,b) <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc(movc(a,TRUE,FALSE),b,c) -> movc(a,b,c) <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc(movc(a,FALSE,TRUE),b,c) -> movc(a,c,b) <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc(bool b, TRUE, FALSE) -> mov b <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc(bool b, FALSE, TRUE) -> not b <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc(bool b, TRUE, bool c) -> or(b,c) <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc(bool b, bool b, false) -> mov b <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc(b, a, b) -> movc (b, a, 0) <| MR.GenSimplifyInstructionsOpt1_NoExcl
(n > i) ? X : umin(n, i) -> (i > n) ? X: i <| MR.GenSimplifyInstructionsOpt1_NoExcl
bool ? a + 1 : a -> a - bool <| MR.GenSimplifyInstructionsOpt1_NoExcl
bool ? a - 1 : a -> a + bool <| MR.GenSimplifyInstructionsOpt1_NoExcl
(n > i) ? X : imin(n, i) -> (i > n) ? X: i <| MR.GenSimplifyInstructionsOpt1_NoExcl
(n > i) ? X : min(n, i) -> (i > n) ? X: i <| MR.GenSimplifyInstructionsOpt1_NoExcl
(n > i) ? X : dmin(n, i) -> (i > n) ? X: i <| MR.GenSimplifyInstructionsOpt1_NoExcl
(V < n) ? V : n -> min(V, n) <| MR.GenSimplifyInstructionsOpt1_NoExcl
(V < n) ? (V+1) : n -> min(V+1, n) <| MR.GenSimplifyInstructionsOpt1_NoExcl
(n >= V) ? V : n -> min(V, n) <| MR.GenSimplifyInstructionsOpt1_NoExcl
(V < n) ? V : n -> dmin(V, n) <| MR.GenSimplifyInstructionsOpt1_NoExcl
(V < n) ? (V+1) : n -> dmin(V+1, n) <| MR.GenSimplifyInstructionsOpt1_NoExcl
(n >= V) ? V : n -> dmin(V, n) <| MR.GenSimplifyInstructionsOpt1_NoExcl
(0 < n) ? 1 : 0 -> umin(1, n) <| MR.GenSimplifyInstructionsOpt1_NoExcl
(V < n) ? V : n -> umin(V, n) <| MR.GenSimplifyInstructionsOpt1_NoExcl
(V < n) ? (V+1) : n -> umin(V+1, n) <| MR.GenSimplifyInstructionsOpt1_NoExcl
(n >= V) ? V : n -> umin(V, n) <| MR.GenSimplifyInstructionsOpt1_NoExcl
(V < n) ? V : n -> imin(V, n) <| MR.GenSimplifyInstructionsOpt1_NoExcl
(V < n) ? (V+1) : n -> imin(V+1, n) <| MR.GenSimplifyInstructionsOpt1_NoExcl
(n >= V) ? V : n -> imin(V, n) <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc(a,b,b) -> mov(b) <| MR.GenSimplifyInstructionsOpt1_NoExcl
dmovc(a,b,b) -> dmov(b) <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc((a<b),b,a) -> max(a,b) <| MR.GenSimplifyInstructionsOpt1_NoExcl
integer movc((a<b),b,a) -> max(a,b) <| MR.GenSimplifyInstructionsOpt1_NoExcl
unsigned integer movc((a<b),b,a) -> max(a,b) <| MR.GenSimplifyInstructionsOpt1_NoExcl
dmovc((a<b),b,a) -> dmax(a,b) <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc((a>=b),a,b) -> max(a,b) <| MR.GenSimplifyInstructionsOpt1_NoExcl
integer movc((a>=b),a,b) -> max(a,b) <| MR.GenSimplifyInstructionsOpt1_NoExcl
unsigned integer movc((a>=b),a,b) -> max(a,b) <| MR.GenSimplifyInstructionsOpt1_NoExcl
dmovc((a>=b),a,b) -> dmax(a,b) <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc(c,d=movc(c,a,b),f) -> movc(c,a,f) <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc(c,f,d=movc(c,a,b)) -> movc(c,f,b) <| MR.GenSimplifyInstructionsOpt1_NoExcl
cmp(c,d=cmp(c,a,b),f) -> cmp(c,a,f) <| MR.GenSimplifyInstructionsOpt1_NoExcl
cmp(c,f,d=cmp(c,a,b)) -> cmp(c,f,b) <| MR.GenSimplifyInstructionsOpt1_NoExcl
mul of one identity <| MR.GenSimplifyInstructionsOpt1_NoExcl
mul of double one identity <| MR.GenSimplifyInstructionsOpt1_NoExcl
(A + A) * 0.5 -> no-op mov of A <| MR.GenSimplifyInstructionsOpt1_NoExcl
mul of a number times its inverse identity <| MR.GenSimplifyInstructionsOpt1_NoExcl
A * B/A with negative variations on A <| MR.GenSimplifyInstructionsOpt1_NoExcl
normalize(normalize(v)) -> normalize(v) <| MR.GenSimplifyInstructionsOpt1_NoExcl
Legacy !A * (A + B) => !A * B <| MR.GenSimplifyInstructionsOpt1_NoExcl
Legacy A * !(A * B) => A * !B <| MR.GenSimplifyInstructionsOpt1_NoExcl
Legacy (!A * A) => 0 <| MR.GenSimplifyInstructionsOpt1_NoExcl
B*!(A * -B + B) -> A * B <| MR.GenSimplifyInstructionsOpt1_NoExcl
double negative to original <| MR.GenSimplifyInstructionsOpt1_NoExcl
or(ine(x,0),ine(y,0)) -> ine(or(x,y),0) <| MR.GenSimplifyInstructionsOpt1_NoExcl
combine OR of two equal shifts <| MR.GenSimplifyInstructionsOpt1_NoExcl
combine XOR of two equal shifts <| MR.GenSimplifyInstructionsOpt1_NoExcl
X AND ~X => 0 <| MR.GenSimplifyInstructionsOpt1_NoExcl
X AND Y : if( and_is_identity(x,y) => X <| MR.GenSimplifyInstructionsOpt1_NoExcl
X AND Y : if( and_is_identity(y,x) => Y <| MR.GenSimplifyInstructionsOpt1_NoExcl
and(and(a, b), c) : if( and_is_identity(c, b) ) -> and(a, c) <| MR.GenSimplifyInstructionsOpt1_NoExcl
and(and(b, a), c) : if( and_is_identity(c, b) ) -> and(a, c) <| MR.GenSimplifyInstructionsOpt1_NoExcl
and(a, iv2) : if( can_reduce_and(a, iv2) ) -> and(a, get_reduced_and(a, iv2)) <| MR.GenSimplifyInstructionsOpt1_NoExcl
X OR ~X => btrue <| MR.GenSimplifyInstructionsOpt1_NoExcl
X OR Y : if( or_is_identity(x,y) => X <| MR.GenSimplifyInstructionsOpt1_NoExcl
X OR Y : if( or_is_identity(y,x) => Y <| MR.GenSimplifyInstructionsOpt1_NoExcl
or(a, iv2) : if( can_reduce_or(a, iv2) ) -> or(a, get_reduced_or(a, iv2)) <| MR.GenSimplifyInstructionsOpt1_NoExcl
or(or(a, b), c) : if( or_is_identity(c, b) ) -> or(a, c) <| MR.GenSimplifyInstructionsOpt1_NoExcl
or(or(b, a), c) : if( or_is_identity(c, b) ) -> or(a, c) <| MR.GenSimplifyInstructionsOpt1_NoExcl
(A & B) | (A & C) => (A & (B | C)) <| MR.GenSimplifyInstructionsOpt1_NoExcl
(B & A) | (A & C) => (A & (B | C)) <| MR.GenSimplifyInstructionsOpt1_NoExcl
double rcp identity <| MR.GenSimplifyInstructionsOpt1_NoExcl
double drcp identity <| MR.GenSimplifyInstructionsOpt1_NoExcl
rcp(mul(x, rsq(x)) = rsq(x) identity <| MR.GenSimplifyInstructionsOpt1_NoExcl
1 / sqrt(x) -> rsq(x) <| MR.GenSimplifyInstructionsOpt1_NoExcl
sqrt times sqrt of positive value equals the original value identity <| MR.GenSimplifyInstructionsOpt1_NoExcl
positive sqrt(x*x) identity <| MR.GenSimplifyInstructionsOpt1_NoExcl
convert mod by power-of-2 to bitwise AND <| MR.GenSimplifyInstructionsOpt1_NoExcl
utof(sampleinfo_uint(x)) -> sampleinfo(x) <| MR.GenSimplifyInstructionsOpt1_NoExcl
xor(xor(a, iv1), iv2) -> xor(a, xor(iv1, iv2)) <| MR.GenSimplifyInstructionsOpt1_NoExcl
replace bitwise double-complement with move <| MR.GenSimplifyInstructionsOpt1_NoExcl
bine(b,0) -> b <| MR.GenSimplifyInstructionsOpt2_NoExcl
movc(bool,x,0) -> and(bool,x) <| MR.GenSimplifyInstructionsOpt2_NoExcl
utof(sampleinfo_uint_rt(x)) -> sampleinfo_rt(x) <| MR.GenSimplifyInstructionsSampleMask_Both
movc, unary_compute on values lhs -> unary_compute, movc <| MR.GenShuffleCompute_Excl
movc, unary_compute on values rhs -> unary_compute, movc <| MR.GenShuffleCompute_Excl
cmp, unary_compute on values lhs -> unary_compute, cmp <| MR.GenShuffleCompute_Excl
cmp, unary_compute on values rhs -> unary_compute, cmp <| MR.GenShuffleCompute_Excl
movc, binary_compute on values lhs -> binary_compute, movc <| MR.GenShuffleCompute_Excl
movc, binary_compute on values rhs -> binary_compute, movc <| MR.GenShuffleCompute_Excl
cmp, binary_compute on values lhs -> binary_compute, cmp <| MR.GenShuffleCompute_Excl
cmp, binary_compute on values rhs -> binary_compute, cmp <| MR.GenShuffleCompute_Excl
movc, ternary arg1 on values lhs -> ternary, movc <| MR.GenShuffleCompute_Excl
movc, ternary arg1 on values rhs -> ternary, movc <| MR.GenShuffleCompute_Excl
movc, ternary arg2 on values lhs -> ternary, movc <| MR.GenShuffleCompute_Excl
movc, ternary arg2 on values rhs -> ternary, movc <| MR.GenShuffleCompute_Excl
movc, ternary arg3 on values lhs -> ternary, movc <| MR.GenShuffleCompute_Excl
movc, ternary arg3 on values rhs -> ternary, movc <| MR.GenShuffleCompute_Excl
movc, quat arg1 on values lhs -> quat, movc <| MR.GenShuffleCompute_Excl
movc, quat arg1 on values rhs -> quat, movc <| MR.GenShuffleCompute_Excl
movc, quat arg2 on values lhs -> quat, movc <| MR.GenShuffleCompute_Excl
movc, quat arg2 on values rhs -> quat, movc <| MR.GenShuffleCompute_Excl
movc, quat arg3 on values lhs -> quat, movc <| MR.GenShuffleCompute_Excl
movc, quat arg3 on values rhs -> quat, movc <| MR.GenShuffleCompute_Excl
movc, quat arg4 on values lhs -> quat, movc <| MR.GenShuffleCompute_Excl
movc, quat arg4 on values rhs -> quat, movc <| MR.GenShuffleCompute_Excl
movc, unary_compute on values -> unary_compute, movc <| MR.GenShuffleCompute_NoExcl
cmp, unary_compute on values -> unary_compute, cmp <| MR.GenShuffleCompute_NoExcl
and, unary_compute on values -> unary_compute, and <| MR.GenShuffleCompute_NoExcl
movc, binary_compute on values -> binary_compute, movc <| MR.GenShuffleCompute_NoExcl
movc, binary_compute on same value -> binary_compute, movc <| MR.GenShuffleCompute_NoExcl
cmp, binary_compute on values -> binary_compute, cmp <| MR.GenShuffleCompute_NoExcl
cmp, binary_compute on same value -> binary_compute, cmp <| MR.GenShuffleCompute_NoExcl
and, binary_compute on values -> binary_compute, and <| MR.GenShuffleCompute_NoExcl
movc, ternary arg1 on values -> ternary, movc <| MR.GenShuffleCompute_NoExcl
movc, ternary arg2 on values -> ternary, movc <| MR.GenShuffleCompute_NoExcl
movc, ternary arg3 on values -> ternary, movc <| MR.GenShuffleCompute_NoExcl
and, ternary arg1 on values -> ternary, movc <| MR.GenShuffleCompute_NoExcl
and, ternary arg2 on values -> ternary, movc <| MR.GenShuffleCompute_NoExcl
and, ternary arg3 on values -> ternary, movc <| MR.GenShuffleCompute_NoExcl
movc, quat arg1 on values -> quat, movc <| MR.GenShuffleCompute_NoExcl
movc, quat arg2 on values -> quat, movc <| MR.GenShuffleCompute_NoExcl
movc, quat arg3 on values -> quat, movc <| MR.GenShuffleCompute_NoExcl
movc, quat arg4 on values -> quat, movc <| MR.GenShuffleCompute_NoExcl
and, quat arg1 on values -> quat, movc <| MR.GenShuffleCompute_NoExcl
and, quat arg2 on values -> quat, movc <| MR.GenShuffleCompute_NoExcl
and, quat arg3 on values -> quat, movc <| MR.GenShuffleCompute_NoExcl
and, quat arg4 on values -> quat, movc <| MR.GenShuffleCompute_NoExcl
mad match 1 (a + b*c) <| MR.GenMad
mad match 2 (a - b*c) <| MR.GenMad
mad match 3 (a + b+b) <| MR.GenMad
mad match 4 (a - b+b) <| MR.GenMad
imad match 1 (a + b*c) <| MR.GenMad
imad match 2 (a + b+b) <| MR.GenMad
a << L | b (bfi(w=32-L, o=L, a, b) if( mask_is_zero(w, o, b) && allbutwidth_is_zero(w, a) -> imad (a, 1 << L, B) <| MR.GenMad
if+lt -> if_lt <| MR.Gen_PreModTarget_Both
if+ge -> if_ge <| MR.Gen_PreModTarget_Both
if+cmp_lt -> if_lt <| MR.Gen_PreModTarget_Both
if+cmp_ge -> if_ge <| MR.Gen_PreModTarget_Both
if+cmp_lt0 -> if_lt0 <| MR.Gen_PreModTarget_Both
if+cmp_ge0 -> if_ge0 <| MR.Gen_PreModTarget_Both
if_lt(neg(abs(x)), 0) -> if_ne0 <| MR.Gen_PreModTarget_Both
if_ge(neg(abs(x)), 0) -> if_eq0 <| MR.Gen_PreModTarget_Both
if_lt(-a^2,a^2) -> if_ne(a,0) <| MR.Gen_PreModTarget_Both
if_ge(-a^2,a^2) -> if_eq(a,0) <| MR.Gen_PreModTarget_Both
if_ne(x, 0) -> if_ne(x, -x) <| MR.Gen_PreModTarget_Both
if_ge(x + y, 0) -> if_ge(x, -y) <| MR.Gen_PreModTarget_Both
if_lt(x + y, 0) -> if_lt(x, -y) <| MR.Gen_PreModTarget_Both
if_ne(x + y, 0) -> if_ne(x, -y) <| MR.Gen_PreModTarget_Both
if_eq(x + y, 0) -> if_eq(x, -y) <| MR.Gen_PreModTarget_Both
break(a,not(x)) -> breakn(a,x) <| MR.Gen_PreModTarget_Both
continue(a,not(x)) -> continuen(a,x) <| MR.Gen_PreModTarget_Both
return(a,not(x)) -> returnn(a,x) <| MR.Gen_PreModTarget_Both
break(a,bieq(x,0)) -> breakn(a,x) <| MR.Gen_PreModTarget_Both
continue(a,bieq(x,0)) -> continuen(a,x) <| MR.Gen_PreModTarget_Both
return(a,bieq(x,0)) -> returnn(a,x) <| MR.Gen_PreModTarget_Both
break(a,bine(x)) -> break(a,x) <| MR.Gen_PreModTarget_Both
continue(a,bine(x)) -> continue(a,x) <| MR.Gen_PreModTarget_Both
return(a,bine(x)) -> return(a,x) <| MR.Gen_PreModTarget_Both
break(ge(neg(fbool), fbool)) -> break_eq(fbool, 0) <| MR.Gen_PreModTarget_Both
BREAK_GE i2,i1 short form <| MR.Gen_PreModTarget_Both
BREAK_GE i2,i1 for targets that use CMP <| MR.Gen_PreModTarget_Both
BREAK_GE i2,-iv1 where iv1 is literal and needs to be negated before using <| MR.Gen_PreModTarget_Both
BREAK_LT i2,i1 short form <| MR.Gen_PreModTarget_Both
BREAK_LT i2,i1 for targets that use CMP <| MR.Gen_PreModTarget_Both
BREAK_LT i2,-iv1 where iv1 is literal and needs to be negated before using <| MR.Gen_PreModTarget_Both
BREAK_EQ i2,i1 <| MR.Gen_PreModTarget_Both
BREAK_EQ i2,i1 matches when CMP is used <| MR.Gen_PreModTarget_Both
BREAK_EQ i2,-iv1 where iv1 is literal and has to be negated <| MR.Gen_PreModTarget_Both
BREAK_EQ i2,-iv1 where iv1 is literal and has to be negated, CMP form <| MR.Gen_PreModTarget_Both
BREAK_NE i2,i1 <| MR.Gen_PreModTarget_Both
BREAK_NE i2,i1 with CMP <| MR.Gen_PreModTarget_Both
BREAK_NE i2,-iv1 where iv1 is literal and has to be negated <| MR.Gen_PreModTarget_Both
BREAK_NE i2,-iv1 where iv1 is literal and has to be negated, CMP form <| MR.Gen_PreModTarget_Both
movc(blt(a, 0), |a|, a) -> abs(a) <| MR.GenD3D10PreMod_NoExcl
dmovc(bdlt(a, 0), |a|, a) -> dabs(a) <| MR.GenD3D10PreMod_NoExcl
breaka match <| MR.GenD3D10PostMod_Both
continuea match <| MR.GenD3D10PostMod_Both
returna match <| MR.GenD3D10PostMod_Both
if(bult(0,x)) -> if(x) <| MR.GenD3D10PostMod_Both
if(bilt(0,x)) -> if(x) <| MR.GenD3D10PostMod_Both
if(bieq(x,0)) -> ifn(x) <| MR.GenD3D10PostMod_Both
if(bine(x,0)) -> if(x) <| MR.GenD3D10PostMod_Both
if(!a) -> ifn(a) <| MR.GenD3D10PostMod_Both
bfi(w, 0i, v, r) : if( width_is_zero(w,r) && allbutwidth_is_zero(w, v) -> iadd(v, r) <| MR.GenD3D10PostMod_Both
or(a, b) : if( and_is_zero(a, b) ) -> iadd(a, b) <| MR.GenD3D10PostMod_Both
div(a,b)->mul(a, rcp(b)) <| MR.Gen_RequiredTranslate
lt(a, b) -> cmp(a - b, 0f, 1f) <| MR.Gen_RequiredTranslate
ge(a, b) -> cmp(a - b, 1f, 0f) <| MR.Gen_RequiredTranslate
max(a, -a) -> abs <| MR.Gen_RequiredTranslate
max(a, b) -> cmp(a - b, a, b) <| MR.Gen_RequiredTranslate
min(a, b) -> cmp(a - b, b, a) <| MR.Gen_RequiredTranslate
dmad -> dmul, dadd <| MR.Gen_RequiredTranslate
countbits(i) -> and/shift/add sequence <| MR.Gen_RequiredTranslate
firstbitlow(i) -> shift/bine/add sequence <| MR.Gen_RequiredTranslate
firstbit_shi(i) -> shift/bine/add sequence <| MR.Gen_RequiredTranslate
firstbit_hi(i) -> shift/bine/add sequence <| MR.Gen_RequiredTranslate
reversebits(i) -> and/shift/or sequence <| MR.Gen_RequiredTranslate
f32tof16(i) -> conversion sequence <| MR.Gen_RequiredTranslate
f16tof32(i) -> conversion sequence <| MR.Gen_RequiredTranslate
ubfe(i) -> extraction sequence <| MR.Gen_RequiredTranslate
ibfe(i) -> extraction sequence <| MR.Gen_RequiredTranslate
bfi(i) -> insertion sequence <| MR.Gen_RequiredTranslate
preshader abs -> max(i, neg(i)) <| MR.Gen_RequiredTranslate_Preshader
preshader sat -> min(max(i, 0), 1) <| MR.Gen_RequiredTranslate_Preshader
cmp sequence 1 -> sat <| MR.Gen_OptimizeEarlyTranslate_SAT_NoExcl
cmp sequence 2 -> sat <| MR.Gen_OptimizeEarlyTranslate_SAT_NoExcl
pos cmp sequence -> sat <| MR.Gen_OptimizeEarlyTranslate_SAT_NoExcl
max(i, neg(i)) -> abs <| MR.Gen_OptimizeEarlyTranslate_SAT_NoExcl
dmax(i, dneg(i)) -> dabs <| MR.Gen_OptimizeEarlyTranslate_SAT_NoExcl
cmp (a, a, -a) -> abs <| MR.Gen_OptimizeEarlyTranslate_SAT_NoExcl
min 1/max 0 -> sat <| MR.Gen_OptimizeEarlyTranslate_SAT_Excl
max 0/min 1 -> sat <| MR.Gen_OptimizeEarlyTranslate_SAT_Excl
dmin 1/dmax 0 -> dsat <| MR.Gen_OptimizeEarlyTranslate_SAT_Excl
dmax 0/dmin 1 -> dsat <| MR.Gen_OptimizeEarlyTranslate_SAT_Excl
(n & a) | r : if( known_bfi_bitmask_noshift(n,a,r) && and_is_zero(n,r) ) -> bfi(bfi_bitwidth_noshift(n,a,r), 0i, a, r) <| MR.GenD3D10_OptimizeEarlyTranslate_Excl
(a & n) | r : if( known_bfi_bitmask_noshift(n,a,r) && and_is_zero(n,r) ) -> bfi(bfi_bitwidth_noshift(n,a,r), 0i, a, r) <| MR.GenD3D10_OptimizeEarlyTranslate_Excl
r | (n & a) : if( known_bfi_bitmask_noshift(n,a,r) && and_is_zero(n,r) ) -> bfi(bfi_bitwidth_noshift(n,a,r), 0i, a, r) <| MR.GenD3D10_OptimizeEarlyTranslate_Excl
r | (a & n) : if( known_bfi_bitmask_noshift(n,a,r) && and_is_zero(n,r) ) -> bfi(bfi_bitwidth_noshift(n,a,r), 0i, a, r) <| MR.GenD3D10_OptimizeEarlyTranslate_Excl
a | r : if( known_bfi_bitmask_noshift_impmask(a,r) && and_is_zero(a,r) ) -> bfi(bfi_bitwidth_noshift_impmask(a,r), 0i, a, r) <| MR.GenD3D10_OptimizeEarlyTranslate_Excl
r | a : if( known_bfi_bitmask_noshift_impmask(a,r) && and_is_zero(a,r) ) -> bfi(bfi_bitwidth_noshift_impmask(a,r), 0i, a, r) <| MR.GenD3D10_OptimizeEarlyTranslate_Excl
((a << m) & n) | i : if( known_bfi_bitmask_postshift_ignore(n,a,m,i) ) -> bfi(bfi_bitwidth_postshift_ignore(n,a,m,i), m, a, 0i) <| MR.GenD3D10_OptimizeEarlyTranslate_Excl
imul(a, iv_pow2) -> ishl(a, get_lowest_bit(iv_pow2)) <| MR.GenD3D10_OptimizeEarlyTranslate
udiv(a, iv_pow2) -> ushr(a, get_lowest_bit(iv_pow2)) <| MR.GenD3D10_OptimizeEarlyTranslate
(a << n) >> (m) -> ibfe(32-m, m-n, a) <| MR.GenD3D10_OptimizeEarlyTranslate
b = ubfe/ushr(a,o), movc((b >> o) & iv_pow2, bfi(w, 0, b, -iv_pow2)) -> ibfe(get_first_bit(iv_pow2), 0, a) <| MR.GenD3D10_OptimizeEarlyTranslate
b = ubfe/ushr(a,o), movc((a >> o) & iv_pow2, b | -iv_pow2) -> ibfe(get_first_bit(iv_pow2), 0, a) <| MR.GenD3D10_OptimizeEarlyTranslate
movc(b & iv_pow2, bfi(w, 0, b, -iv_pow2), b) -> ibfe(get_first_bit(iv_pow2), 0, b) <| MR.GenD3D10_OptimizeEarlyTranslate
movc(b & iv_pow2, bfi(w, 0, (b & m), -iv_pow2)) -> ibfe(get_first_bit(iv_pow2), 0, (b&m)) <| MR.GenD3D10_OptimizeEarlyTranslate
movc(b & iv_pow2, b | -iv_pow2, b) -> ibfe(get_first_bit(iv_pow2), 0, b) <| MR.GenD3D10_OptimizeEarlyTranslate
movc(b & iv_pow2, (b & m) | -iv_pow2, b) -> ibfe(get_first_bit(iv_pow2), 0, (b&m)) <| MR.GenD3D10_OptimizeEarlyTranslate
(a << n) >> (m) -> ubfe(32-m, m-n, a) <| MR.GenD3D10_OptimizeEarlyTranslate
(a & ((iv_pow2 << n) - 1)) -> bfi(iv_pow2 + n, 0, a, 0i) <| MR.GenD3D10_OptimizeEarlyTranslate
(a & ~((iv_pow2 << n) - 1)) -> bfi(iv_pow2 + n, 0, 0, a) <| MR.GenD3D10_OptimizeEarlyTranslate
(a & ~(((iv_pow2 << n) - 1) << o) -> bfi(iv_pow2 + n, o, 0, a) <| MR.GenD3D10_OptimizeEarlyTranslate
(a & ~(((iv_pow2 << n) << ov) + (-1 << ov))) -> bfi(iv_pow2 + n, ov, 0, a) <| MR.GenD3D10_OptimizeEarlyTranslate
((a >> o1) << o2) : if( o1 == o2 ) -> bfi(o, 0, 0, a) <| MR.GenD3D10_OptimizeEarlyTranslate
(a | ((iv_pow2 << n) - 1)) -> bfi(iv_pow2 + n, 0, -1, a) <| MR.GenD3D10_OptimizeEarlyTranslate
(a | (((iv_pow2 << n) - 1) << o)) -> bfi(iv_pow2 + n, o, -1, a) <| MR.GenD3D10_OptimizeEarlyTranslate
(a | (((iv_pow2 << n) << ov) + (-1 << ov))) -> bfi(iv_pow2 + n, ov, -1, a) <| MR.GenD3D10_OptimizeEarlyTranslate
(a | (b << n)) : if(known_bfi_bitwidth_impmask(a, b, n)) -> bfi(get_bfi_bitwidth_impmask(a, b, n), n, b, a) <| MR.GenD3D10_OptimizeEarlyTranslate
(a & n) << m : if( known_bfi_bitmask(a,n,m) ) -> bfi(bfi_bitwidth(a,n,m), m, n, 0i) <| MR.GenD3D10_OptimizeEarlyTranslate
(a & n) | i << m : if( known_bfi_bitmask_ignore(a,n,i,m) ) -> bfi(bfi_bitwidth_ignore(a,n,i,m), m, n | i, 0i) <| MR.GenD3D10_OptimizeEarlyTranslate
(a & n) << m : if( known_bfi_bitmask(n,a,m) ) -> bfi(bfi_bitwidth(n,a,m), m, a, 0i) <| MR.GenD3D10_OptimizeEarlyTranslate
(a << m) & n : if( known_bfi_bitmask_postshift(n,a,m) ) -> bfi(bfi_bitwidth_postshift(n,a,m), m, a, 0i) <| MR.GenD3D10_OptimizeEarlyTranslate
(a & n) >> m : if( known_ubfe_bitmask(a,n,m) ) -> ubfe(ubfe_bitwidth(a,n,m), m, n) <| MR.GenD3D10_OptimizeEarlyTranslate
(a & n) >> m : if( known_ubfe_bitmask(n,a,m) ) -> ubfe(bitwidth(n,a,m), m, a) <| MR.GenD3D10_OptimizeEarlyTranslate
(int)(a & n) >> m : if( high_bit_clear(a & n) && known_ubfe_bitmask(a,n,m) ) -> ubfe(bitwidth(a,n,m), m, n) <| MR.GenD3D10_OptimizeEarlyTranslate
(int)(a & n) >> m : if( high_bit_clear(a & n) && known_ubfe_bitmask(n,a,m) ) -> ubfe(ubfe_bitwidth(n,a,m), m, a) <| MR.GenD3D10_OptimizeEarlyTranslate
(a >> m) & n : if( known_ubfe_bitmask_nomaskshift(a,n,m) ) -> ubfe(ubfe_bitwidth_nomaskshift(a,n,m), m, n) <| MR.GenD3D10_OptimizeEarlyTranslate
(a >> m) & n : if( high_bit_clear(a & n) && known_ubfe_bitmask_nomaskshift(a,n,m) ) -> ubfe(ubfe_bitwidth_nomaskshift(a,n,m), m, n) <| MR.GenD3D10_OptimizeEarlyTranslate
dcl_func_output(a) -> o->append_dataflow() <| SMR.DataflowAnalysis
loop_in(completed a) -> o->append_inloop() <| SMR.RangeDataAnalysis
$IsStandardLoad(a, chain) -> append_addressed(o, chain) (range/flag prop) <| SMR.RangeDataAnalysis
$IsResLoad(uav, a, addr, offs, mask) -> append_arg(sources(o, a)) <| SMR.RangeDataAnalysis
movc(true,b,c) -> append_arg(b) <| SMR.RangeDataAnalysis
movc(false,b,c) -> append_arg(b) <| SMR.RangeDataAnalysis
movc(a,b,c) -> append_arg(b, c) <| SMR.RangeDataAnalysis
cmp(a,b,c) -> append_arg(b, c) <| SMR.RangeDataAnalysis
ignore move(a) -> append_arg(a) <| SMR.RangeDataAnalysis
ignore double move(a) -> append_arg(a) <| SMR.RangeDataAnalysis
pred move(a) -> append_arg(a) <| SMR.RangeDataAnalysis
tunnelable move(a) -> append_arg(a) <| SMR.RangeDataAnalysis
and(btrue,a) -> append_arg(a) <| SMR.RangeDataAnalysis
and(false,a) -> append_arg(0,a) <| SMR.RangeDataAnalysis
or(bfalse,a) -> append_arg(a) <| SMR.RangeDataAnalysis
or(true,a) -> append_arg(true,a) <| SMR.RangeDataAnalysis
mul(1f,a) -> append_arg(a) <| SMR.RangeDataAnalysis
add(0f,a) -> append_arg(a) <| SMR.RangeDataAnalysis
mul(fbool,a) -> append_arg(0f,a) <| SMR.RangeDataAnalysis
mul(fbool,finite a) -> append_arg(0f,a) <| SMR.RangeDataAnalysis
lerp(fbool, a, b) -> append_arg(a,b) <| SMR.RangeDataAnalysis
lerp(fbool, finite a, finite b) -> append_arg(a,b) <| SMR.RangeDataAnalysis
lerp(fbool, a, 0) -> append_arg(a,0) <| SMR.RangeDataAnalysis
lerp(fbool, finite a, 0) -> append_arg(a,0) <| SMR.RangeDataAnalysis
a + -a -> append_arg(0) <| SMR.RangeDataAnalysis
(a + F) - a -> append_arg(F) <| SMR.RangeDataAnalysis
a + (F - a) -> append_arg(F) <| SMR.RangeDataAnalysis
(a + F1) - (a + F2) -> append_arg(F1-F2) <| SMR.RangeDataAnalysis
finite a + -a -> append_arg(0) <| SMR.RangeDataAnalysis
i + -i -> append_arg(0) <| SMR.RangeDataAnalysis
(i + I) - i -> append_arg(I) <| SMR.RangeDataAnalysis
i + (I - i) -> append_arg(I) <| SMR.RangeDataAnalysis
(i + I1) - (i + I2) -> append_arg(I1-I2) <| SMR.RangeDataAnalysis
endif(a,b) -> append_arg(a,b) <| SMR.RangeDataAnalysis
$IsMultiWriteOut(a, chain) -> append_sources(a) <| SMR.RangeDataAnalysis
bind_load(chain, value) -> o->append_sources(chain) <| SMR.DataFlagAnalysis
o = dfuse(ab) -> o->append_dfuse() <| SMR.DataFlagAnalysis
loop_in(completed a) -> o->append_inloop() <| SMR.DataFlagAnalysis
loop_endif(a) -> append_arg(a, pred_a) <| SMR.DataFlagAnalysis
function_endif(a) -> append_arg(a, pred_a) <| SMR.DataFlagAnalysis
cl = $IsBreak(a, ci) -> append_arg(a, ci) <| SMR.DataFlagAnalysis
cl = $IsContinue(a, ci) -> append_arg(a, ci) <| SMR.DataFlagAnalysis
cf = $IsReturn(a, ci) -> append_arg(a, ci) <| SMR.DataFlagAnalysis
cl = $IsConsume(a, b, ci) -> append_arg(ci) <| SMR.DataFlagAnalysis
endif(a,b) -> append_arg(a,b,p_a) <| SMR.DataFlagAnalysis
loop_endif(a,b) -> append_arg(a,b,p_a) <| SMR.DataFlagAnalysis
function_endif(a,b) -> append_arg(a,b,p_a) <| SMR.DataFlagAnalysis
chain_merge($IsSync() || chain) -> append_arg(sync) <| SMR.DataFlagAnalysis_ConstInterp
$IsStandardLoad(a, chain) -> append_addressed(o, chain), append_arg(a, chain) <| SMR.DataFlagAnalysis_PlaceHolder
$IsAtomicAllocConsume(a, res) -> append_arg(all_sources(o, a)) <| SMR.DataFlagAnalysis_PlaceHolder
$IsTwoValueAtomic(chain, res, addr, op1, op2) -> append_arg(all_sources(o, chain), chain, addr, op1, op2) <| SMR.DataFlagAnalysis_PlaceHolder
$IsBasicOrImmAtomic(a, res, addr, op) -> append_arg(all_sources(o, a), a, addr, op) <| SMR.DataFlagAnalysis_PlaceHolder
$IsResLoad(uav, a, addr, offs, mask) -> append_arg(all_sources(o, a), uav, a, addr, offs, mask) <| SMR.DataFlagAnalysis_PlaceHolder
$IsStandardStore(addr, val, chain) -> append_param(chain) <| SMR.DataFlagAnalysis_PlaceHolder
$IsResStore(uav, a, addr, offs, mask, val) -> append_param(a) <| SMR.DataFlagAnalysis_PlaceHolder
cl = endcase(ci, ch) -> append_arg(ci, ci_p, ch) <| SMR.DataFlagAnalysis_PlaceHolder
cl = fcbody_end(ci, ch) -> append_arg(ci, ci_p, ch) <| SMR.DataFlagAnalysis_PlaceHolder
discard_endif(a,b) -> append_arg(a,b,p_a) <| SMR.DataFlagAnalysis_PlaceHolder
$IsLoop(a) -> append_sources() (loop predicate linkage) <| SMR.DataFlagAnalysis_PlaceHolder
$IsMultiWriteOut(a, chain) -> append_sources(a) <| SMR.DataFlagAnalysis_PlaceHolder
$IsSync() -> append_all_visible+inputs(UAV chain args) <| SMR.DataFlagAnalysis_PlaceHolder
$IsStandardStore(addr, val, chain) -> append_param(chain) <| SMR.DataFlagAnalysis_NoPlaceHolder
chain_merge($IsSync() || chain) -> append_arg(chain) <| SMR.DataFlagAnalysis_NoPlaceHolder
chain_merge(chain_merge() || chain) -> append_arg(chain) <| SMR.DataFlagAnalysis_NoPlaceHolder
array_merge(chain_merge() || chain) -> append_arg(chain) <| SMR.DataFlagAnalysis_NoPlaceHolder
cl = emitarg(a, b, ci) -> append_arg(ci) <| SMR.DataFlagAnalysis_NoPlaceHolder
cl = emit(ci, stream) -> append_arg(ci) <| SMR.DataFlagAnalysis_NoPlaceHolder
cl = casecond(ci, c) -> append_arg(ci) <| SMR.DataFlagAnalysis_NoPlaceHolder
cl = endcase(ci, ch) -> append_arg(ci) <| SMR.DataFlagAnalysis_NoPlaceHolder
cl = fcbody(ci, c) -> append_arg(ci, c) <| SMR.DataFlagAnalysis_NoPlaceHolder
cl = fcbody_end(ci, ch) -> append_arg(ci, ci_p, ch) <| SMR.DataFlagAnalysis_NoPlaceHolder
loop(a) -> append_sources() (loop predicate linkage) <| SMR.DataFlagAnalysis_NoPlaceHolder
o = $IsStandardLoad(a, chain) -> append_addressed(o, chain) (all sources) <| SMR.DataFlagAnalysis_NoPlaceHolder
$IsMultiWriteOut(a, chain) -> append_sources(a) <| SMR.DataFlagAnalysis_NoPlaceHolder
$IsAtomicAllocConsume(a, res) -> append_arg(all_sources(o, a)) <| SMR.DataFlagAnalysis_NoPlaceHolder
$IsTwoValueAtomic(chain, res, addr, op1, op2) -> append_arg(chain, addr, op1, op2) <| SMR.DataFlagAnalysis_NoPlaceHolder
$IsBasicOrImmAtomic(a, res, addr, op) -> append_arg(all_sources(o, a), addr, op) <| SMR.DataFlagAnalysis_NoPlaceHolder
$IsResLoad(uav, a, addr, offs, mask) -> append_arg(all_sources(o, a), addr, offs) <| SMR.DataFlagAnalysis_NoPlaceHolder
$IsResStore(uav, a, addr, offs, mask, val) -> append_param(a) (chain) <| SMR.DataFlagAnalysis_NoPlaceHolder
d(x)/dz -> dx/dz <| SR.GenDerivatives_Unary
d((double)x)/dz -> (double)dx/dz <| SR.GenDerivatives_Unary
d(-x)/dz -> -dx/dz <| SR.GenDerivatives_Unary
d((double)-x)/dz -> -(double)dx/dz <| SR.GenDerivatives_Unary
d(x+eps)/dz -> dx/dz <| SR.GenDerivatives_Unary
d(x^-0.5)/dz -> -0.5*x^-1.5 * dx/dz <| SR.GenDerivatives_Unary
d(frac(x))/dz -> dx/dz <| SR.GenDerivatives_Unary
d(2^x)/dz -> ln(2) * 2^x * dx/dz <| SR.GenDerivatives_Unary
d(log_2(x))/dz -> 1/(x * ln(2)) * dx/dz <| SR.GenDerivatives_Unary
sqrt(x)/dz -> 0.5 / sqrt(x) * (dx/dz) <| SR.GenDerivatives_Unary
float d(1/x)/dz -> -dx/dz/x^2 <| SR.GenDerivatives_Unary
double d(1/x)/dz -> -dx/dz/x^2 <| SR.GenDerivatives_Unary
d(IsRound(x))/dz -> 0 <| SR.GenDerivatives_Unary
d(sin(x))/dz -> cos(x) * dx/dz <| SR.GenDerivatives_Unary
d(cos(x))/dz -> -sin(x) * dx/dz <| SR.GenDerivatives_Unary
d(asin(x))/dz -> 1/sqrt(1-x^2) * dx/dz <| SR.GenDerivatives_Unary
d(acos(x))/dz -> -1/sqrt(1-x^2) * dx/dz <| SR.GenDerivatives_Unary
d(atan(x))/dz -> 1/(1+x^2) * dx/dz <| SR.GenDerivatives_Unary
$IsAnyDeriv(x)/dz -> $IsAnyDeriv(dx/dz) <| SR.GenDerivatives_Unary
dsy(x)/dz -> dsy(dx/dz) <| SR.GenDerivatives_Unary
dtof(x)/dz -> dtof(dx/dz) <| SR.GenDerivatives_Unary
ftod(x)/dz -> ftod(dx/dz) <| SR.GenDerivatives_Unary
d(IsIntToFloat(x))/dz -> 0f <| SR.GenDerivatives_Unary
d(IsIntToDouble(x))/dz -> 0lf <| SR.GenDerivatives_Unary
d(min(x,y))/dz -> (x < y) ? dx/dz : ((y < x) ? dy/dz : min(dx/dz, dy/dz) <| SR.GenDerivatives_Binary
d(max(x,y))/dz -> (x > y) ? dx/dz : ((y > x) ? dy/dz : max(dx/dz, dy/dz) <| SR.GenDerivatives_Binary
d(dmin(x,y))/dz -> (x < y) ? dx/dz : ((y < x) ? dy/dz : dmin(dx/dz, dy/dz) <| SR.GenDerivatives_Binary
d(dmax(x,y))/dz -> (x > y) ? dx/dz : ((y > x) ? dy/dz : dmax(dx/dz, dy/dz) <| SR.GenDerivatives_Binary
d(x + y)/dz -> dx/dz + dy/dz <| SR.GenDerivatives_Binary
d((double)x + (double)y)/dz -> dx/dz + dy/dz <| SR.GenDerivatives_Binary
d(x * x)/dz -> 2*dx/dz * x <| SR.GenDerivatives_Binary
d((double)x * x)/dz -> 2*dx/dz * x <| SR.GenDerivatives_Binary
d(x * y)/dz -> dx/dz * y + x * dy/dz <| SR.GenDerivatives_Binary
d((double)x * y)/dz -> dx/dz * y + x * dy/dz <| SR.GenDerivatives_Binary
d(atan2(x,y))/dz -> 1 / (1 + (y/x)^2) * d(y/x)/dz <| SR.GenDerivatives_Binary
d(x / y)/dz -> dx/dz / y + x * -dy/dz / y^2 <| SR.GenDerivatives_Binary
d(a ? b : c)/dz -> a ? db/dz : dc/dz <| SR.GenDerivatives_Ternary
abs fp_flags <| SFPS
abs fp_specials <| SFPS
abs float_literal <| SFPS
abs fp_range <| SFPS
acos fp_flags <| SFPS
acos fp_specials <| SFPS
acos float_literal <| SFPS
acos fp_range <| SFPS
add fp_flags <| SFPS
add float_literal <| SFPS
add fp_range <| SFPS
and fp_flags <| SFPS
and int_flags <| SFPS
and int_literal <| SFPS
and bits_known <| SFPS
asin fp_flags <| SFPS
asin fp_specials <| SFPS
asin float_literal <| SFPS
asin fp_range <| SFPS
atan fp_flags <| SFPS
atan fp_specials <| SFPS
atan float_literal <| SFPS
atan fp_range <| SFPS
atan2 fp_flags <| SFPS
atan2 fp_specials <| SFPS
atan2 float_literal <| SFPS
atan2 fp_range <| SFPS
bdeq fp_flags <| SFPS
bdeq int_literal <| SFPS
bdeq int_range <| SFPS
bdge fp_flags <| SFPS
bdge int_literal <| SFPS
bdge int_range <| SFPS
bdlt fp_flags <| SFPS
bdlt int_literal <| SFPS
bdlt int_range <| SFPS
bdne fp_flags <| SFPS
bdne int_literal <| SFPS
bdne int_range <| SFPS
beq fp_flags <| SFPS
beq int_literal <| SFPS
beq int_range <| SFPS
bfi fp_flags <| SFPS
bfi int_literal <| SFPS
bfi bits_known <| SFPS
bge fp_flags <| SFPS
bge int_literal <| SFPS
bge int_range <| SFPS
blt fp_flags <| SFPS
blt int_literal <| SFPS
blt int_range <| SFPS
bne fp_flags <| SFPS
bne int_literal <| SFPS
bne int_range <| SFPS
bieq fp_flags <| SFPS
bieq int_literal <| SFPS
bieq bits_known <| SFPS
bieq int_range <| SFPS
bige fp_flags <| SFPS
bige int_literal <| SFPS
bige bits_known <| SFPS
bige int_range <| SFPS
bilt fp_flags <| SFPS
bilt int_literal <| SFPS
bilt bits_known <| SFPS
bilt int_range <| SFPS
bine fp_flags <| SFPS
bine int_literal <| SFPS
bine bits_known <| SFPS
bine int_range <| SFPS
bufinfo fp_flags <| SFPS
buge fp_flags <| SFPS
buge int_literal <| SFPS
buge bits_known <| SFPS
buge int_range <| SFPS
bult fp_flags <| SFPS
bult int_literal <| SFPS
bult bits_known <| SFPS
bult int_range <| SFPS
break fp_flags <| SFPS
btof fp_flags <| SFPS
btoi fp_flags <| SFPS
btoi int_literal <| SFPS
btoi bits_known <| SFPS
btoi int_range <| SFPS
calclod1d fp_flags <| SFPS
calclod1d_a fp_flags <| SFPS
calclod1d_u fp_flags <| SFPS
calclod1d_u_a fp_flags <| SFPS
calclod2d fp_flags <| SFPS
calclod2d_a fp_flags <| SFPS
calclod2d_u fp_flags <| SFPS
calclod2d_u_a fp_flags <| SFPS
calclod3d fp_flags <| SFPS
calclod3d_u fp_flags <| SFPS
calclodcube fp_flags <| SFPS
calclodcube_a fp_flags <| SFPS
calclodcube_u fp_flags <| SFPS
calclodcube_u_a fp_flags <| SFPS
case fp_flags <| SFPS
ceil fp_flags <| SFPS
ceil fp_specials <| SFPS
ceil float_literal <| SFPS
ceil fp_range <| SFPS
chain_end fp_flags <| SFPS
cmp fp_flags <| SFPS
cmp fp_specials <| SFPS
cmp float_literal <| SFPS
cmp fp_range <| SFPS
continue fp_flags <| SFPS
cos fp_flags <| SFPS
cos fp_specials <| SFPS
cos float_literal <| SFPS
cos fp_range <| SFPS
countbits fp_flags <| SFPS
countbits int_literal <| SFPS
countbits bits_known <| SFPS
dabs fp_flags <| SFPS
dabs fp_specials <| SFPS
dabs float_literal <| SFPS
dabs fp_range <| SFPS
dadd fp_flags <| SFPS
dadd float_literal <| SFPS
dadd fp_range <| SFPS
dfma fp_flags <| SFPS
dfma fp_specials <| SFPS
dfuse fp_flags <| SFPS
dfuse float_literal <| SFPS
dfuse fp_specials <| SFPS
dmad fp_flags <| SFPS
dmad fp_specials <| SFPS
dmad float_literal <| SFPS
dmad fp_range <| SFPS
dmax fp_flags <| SFPS
dmax fp_specials <| SFPS
dmax float_literal <| SFPS
dmax fp_range <| SFPS
dmin fp_flags <| SFPS
dmin fp_specials <| SFPS
dmin float_literal <| SFPS
dmin fp_range <| SFPS
dmov fp_flags <| SFPS
dmov mov <| SFPS
dmovc fp_flags <| SFPS
dmovc fp_specials <| SFPS
dmovc float_literal <| SFPS
dmul fp_flags <| SFPS
dmul float_literal <| SFPS
dmul fp_range <| SFPS
dneg fp_flags <| SFPS
dneg fp_specials <| SFPS
dneg float_literal <| SFPS
dneg fp_range <| SFPS
dot fp_flags <| SFPS
dot float_literal <| SFPS
dot fp_range <| SFPS
dsat fp_flags <| SFPS
dsat float_literal <| SFPS
dsat fp_range <| SFPS
ddiv fp_flags <| SFPS
ddiv fp_specials <| SFPS
ddiv float_literal <| SFPS
ddiv fp_range <| SFPS
drcp_approx fp_flags <| SFPS
drcp_approx fp_specials <| SFPS
drcp_approx float_literal <| SFPS
drcp_approx fp_range <| SFPS
dsplit fp_flags <| SFPS
dsplit int_literal <| SFPS
dsplit fp_specials <| SFPS
dtof fp_flags <| SFPS
dtof float_literal <| SFPS
dtof fp_range <| SFPS
dtof fp_specials <| SFPS
dtoi fp_flags <| SFPS
dtoi int_literal <| SFPS
dtoi int_range <| SFPS
dtou fp_flags <| SFPS
dtou int_literal <| SFPS
dtou int_range <| SFPS
discardif fp_flags <| SFPS
div fp_flags <| SFPS
div fp_specials <| SFPS
div float_literal <| SFPS
div fp_range <| SFPS
dsx fp_flags <| SFPS
dsx fp_specials <| SFPS
dsx float_literal <| SFPS
dsx fp_range <| SFPS
dsy fp_flags <| SFPS
dsy fp_specials <| SFPS
dsy float_literal <| SFPS
dsy fp_range <| SFPS
dsx_fine fp_flags <| SFPS
dsx_fine fp_specials <| SFPS
dsx_fine float_literal <| SFPS
dsx_fine fp_range <| SFPS
dsy_fine fp_flags <| SFPS
dsy_fine fp_specials <| SFPS
dsy_fine float_literal <| SFPS
dsy_fine fp_range <| SFPS
dsx_coarse fp_flags <| SFPS
dsx_coarse fp_specials <| SFPS
dsx_coarse float_literal <| SFPS
dsx_coarse fp_range <| SFPS
dsy_coarse fp_flags <| SFPS
dsy_coarse fp_specials <| SFPS
dsy_coarse float_literal <| SFPS
dsy_coarse fp_range <| SFPS
eval_centroid fp_flags <| SFPS
eval_sample fp_flags <| SFPS
eval_snapped fp_flags <| SFPS
exp fp_flags <| SFPS
exp fp_specials <| SFPS
exp float_literal <| SFPS
exp fp_range <| SFPS
f16tof32 fp_flags <| SFPS
f16tof32 float_literal <| SFPS
f16tof32 bits_known <| SFPS
f32tof16 fp_flags <| SFPS
f32tof16 int_literal <| SFPS
f32tof16 int_range <| SFPS
fcall fp_flags <| SFPS
fcbody fp_flags <| SFPS
firstbitlow fp_flags <| SFPS
firstbitlow int_literal <| SFPS
firstbitlow bits_known <| SFPS
firstbit_hi fp_flags <| SFPS
firstbit_hi int_literal <| SFPS
firstbit_hi bits_known <| SFPS
firstbit_shi fp_flags <| SFPS
firstbit_shi int_literal <| SFPS
firstbit_shi bits_known <| SFPS
floor fp_flags <| SFPS
floor fp_specials <| SFPS
floor float_literal <| SFPS
floor fp_range <| SFPS
frc fp_flags <| SFPS
frc fp_specials <| SFPS
frc float_literal <| SFPS
frc fp_range <| SFPS
ftob fp_flags <| SFPS
ftob int_literal <| SFPS
ftob int_range <| SFPS
ftod fp_flags <| SFPS
ftod float_literal <| SFPS
ftod fp_range <| SFPS
ftod fp_specials <| SFPS
ftoi fp_flags <| SFPS
ftoi int_literal <| SFPS
ftoi int_range <| SFPS
ftou fp_flags <| SFPS
ftou int_literal <| SFPS
ftou int_range <| SFPS
functionif fp_flags <| SFPS
gather2d fp_flags <| SFPS
gather2d_a fp_flags <| SFPS
gather2d_a_o fp_flags <| SFPS
gather2d_o fp_flags <| SFPS
gathercube fp_flags <| SFPS
gathercube_a fp_flags <| SFPS
gathercube_c fp_flags <| SFPS
gathercube_c_a fp_flags <| SFPS
ge fp_flags <| SFPS
ge float_literal <| SFPS
ge fp_range <| SFPS
iadd fp_flags <| SFPS
iadd int_literal <| SFPS
iadd bits_known <| SFPS
iadd int_range <| SFPS
ibfe fp_flags <| SFPS
ibfe int_literal <| SFPS
ibfe bits_known <| SFPS
idiv fp_flags <| SFPS
idiv int_literal <| SFPS
idiv bits_known <| SFPS
idiv int_range <| SFPS
imad fp_flags <| SFPS
imad int_literal <| SFPS
imad bits_known <| SFPS
imad int_range <| SFPS
imax fp_flags <| SFPS
imax int_literal <| SFPS
imax bits_known <| SFPS
imax int_range <| SFPS
imin fp_flags <| SFPS
imin int_literal <| SFPS
imin bits_known <| SFPS
imin int_range <| SFPS
imod fp_flags <| SFPS
imod int_literal <| SFPS
imod bits_known <| SFPS
imod int_range <| SFPS
imul fp_flags <| SFPS
imul int_literal <| SFPS
imul bits_known <| SFPS
imul int_range <| SFPS
ineg fp_flags <| SFPS
ineg int_literal <| SFPS
ineg bits_known <| SFPS
ineg int_range <| SFPS
ishl fp_flags <| SFPS
ishl int_literal <| SFPS
ishl bits_known <| SFPS
ishr fp_flags <| SFPS
ishr int_literal <| SFPS
ishr bits_known <| SFPS
itob fp_flags <| SFPS
itob int_literal <| SFPS
itob bits_known <| SFPS
itob int_range <| SFPS
itod fp_flags <| SFPS
itof fp_flags <| SFPS
load fp_flags <| SFPS
load_o fp_flags <| SFPS
load_s fp_flags <| SFPS
load_o_s fp_flags <| SFPS
load_uav_s fp_flags <| SFPS
load_uav fp_flags <| SFPS
tload fp_flags <| SFPS
load2d_msaa fp_flags <| SFPS
load2d_msaa_o fp_flags <| SFPS
load2d_msaa_o_s fp_flags <| SFPS
load2darray_msaa fp_flags <| SFPS
load2darray_msaa_o fp_flags <| SFPS
load2darray_msaa_o_s fp_flags <| SFPS
log fp_flags <| SFPS
log fp_specials <| SFPS
log float_literal <| SFPS
log fp_range <| SFPS
loopif fp_flags <| SFPS
lt fp_flags <| SFPS
lt float_literal <| SFPS
lt fp_range <| SFPS
mad fp_flags <| SFPS
mad fp_specials <| SFPS
mad float_literal <| SFPS
mad fp_range <| SFPS
max fp_flags <| SFPS
max fp_specials <| SFPS
max float_literal <| SFPS
max fp_range <| SFPS
min fp_flags <| SFPS
min fp_specials <| SFPS
min float_literal <| SFPS
min fp_range <| SFPS
mov fp_flags <| SFPS
mov mov <| SFPS
movc fp_flags <| SFPS
movc fp_specials <| SFPS
movc float_literal <| SFPS
msad fp_flags <| SFPS
msad int_literal <| SFPS
msad bits_known <| SFPS
msad int_range <| SFPS
mul fp_flags <| SFPS
mul float_literal <| SFPS
mul fp_range <| SFPS
neg fp_flags <| SFPS
neg fp_specials <| SFPS
neg float_literal <| SFPS
neg fp_range <| SFPS
not fp_flags <| SFPS
not int_literal <| SFPS
not bits_known <| SFPS
or fp_flags <| SFPS
or int_flags <| SFPS
or int_literal <| SFPS
or bits_known <| SFPS
placement_mov fp_flags <| SFPS
placement_mov mov <| SFPS
rcp fp_flags <| SFPS
rcp fp_specials <| SFPS
rcp float_literal <| SFPS
rcp fp_range <| SFPS
rcp_approx fp_flags <| SFPS
rcp_approx fp_specials <| SFPS
rcp_approx float_literal <| SFPS
rcp_approx fp_range <| SFPS
resinfo fp_flags <| SFPS
resinfo_uint fp_flags <| SFPS
return fp_flags <| SFPS
reversebits fp_flags <| SFPS
reversebits int_literal <| SFPS
reversebits bits_known <| SFPS
round fp_flags <| SFPS
round fp_specials <| SFPS
round float_literal <| SFPS
round fp_range <| SFPS
rsq fp_flags <| SFPS
rsq fp_specials <| SFPS
rsq float_literal <| SFPS
rsq fp_range <| SFPS
sample1d fp_flags <| SFPS
sample1d_a fp_flags <| SFPS
sample1d_o fp_flags <| SFPS
sample1d_a_o fp_flags <| SFPS
sample1d_bias fp_flags <| SFPS
sample1d_bias_a fp_flags <| SFPS
sample1d_bias_o fp_flags <| SFPS
sample1d_bias_a_o fp_flags <| SFPS
sample1d_bias_l fp_flags <| SFPS
sample1d_c fp_flags <| SFPS
sample1d_c_a fp_flags <| SFPS
sample1d_c_o fp_flags <| SFPS
sample1d_c_a_o fp_flags <| SFPS
sample1d_c_lz fp_flags <| SFPS
sample1d_c_lz_a fp_flags <| SFPS
sample1d_c_lz_o fp_flags <| SFPS
sample1d_c_lz_a_o fp_flags <| SFPS
sample1d_dd fp_flags <| SFPS
sample1d_dd_a fp_flags <| SFPS
sample1d_dd_o fp_flags <| SFPS
sample1d_dd_a_o fp_flags <| SFPS
sample1d_lod fp_flags <| SFPS
sample1d_lod_a fp_flags <| SFPS
sample1d_lod_o fp_flags <| SFPS
sample1d_lod_a_o fp_flags <| SFPS
sample1d_lod_l fp_flags <| SFPS
sample2d fp_flags <| SFPS
sample2d_a fp_flags <| SFPS
sample2d_o fp_flags <| SFPS
sample2d_a_o fp_flags <| SFPS
sample2d_dd fp_flags <| SFPS
sample2d_dd_a fp_flags <| SFPS
sample2d_dd_o fp_flags <| SFPS
sample2d_dd_a_o fp_flags <| SFPS
sample2d_lod fp_flags <| SFPS
sample2d_lod_a fp_flags <| SFPS
sample2d_lod_o fp_flags <| SFPS
sample2d_lod_a_o fp_flags <| SFPS
sample2d_c fp_flags <| SFPS
sample2d_c_a fp_flags <| SFPS
sample2d_c_o fp_flags <| SFPS
sample2d_c_a_o fp_flags <| SFPS
sample2d_c_lz fp_flags <| SFPS
sample2d_c_lz_a fp_flags <| SFPS
sample2d_c_lz_o fp_flags <| SFPS
sample2d_c_lz_a_o fp_flags <| SFPS
sample2d_bias fp_flags <| SFPS
sample2d_bias_a fp_flags <| SFPS
sample2d_bias_o fp_flags <| SFPS
sample2d_bias_a_o fp_flags <| SFPS
sample2d_lod_l fp_flags <| SFPS
sample2d_bias_l fp_flags <| SFPS
sample3d fp_flags <| SFPS
sample3d_o fp_flags <| SFPS
sample3d_dd fp_flags <| SFPS
sample3d_dd_o fp_flags <| SFPS
sample3d_lod fp_flags <| SFPS
sample3d_lod_o fp_flags <| SFPS
sample3d_bias fp_flags <| SFPS
sample3d_bias_o fp_flags <| SFPS
sample3d_lod_l fp_flags <| SFPS
sample3d_bias_l fp_flags <| SFPS
samplecube fp_flags <| SFPS
samplecube_dd fp_flags <| SFPS
samplecube_lod fp_flags <| SFPS
samplecube_c fp_flags <| SFPS
samplecube_c_a fp_flags <| SFPS
samplecube_c_lz fp_flags <| SFPS
samplecube_c_lz_a fp_flags <| SFPS
samplecube_bias fp_flags <| SFPS
samplecube_a fp_flags <| SFPS
samplecube_dd_a fp_flags <| SFPS
samplecube_lod_a fp_flags <| SFPS
samplecube_bias_a fp_flags <| SFPS
samplecube_lod_l fp_flags <| SFPS
samplecube_bias_l fp_flags <| SFPS
sampleinfo fp_flags <| SFPS
sampleinfo_uint fp_flags <| SFPS
sampleinfo_rt fp_flags <| SFPS
sampleinfo_uint_rt fp_flags <| SFPS
samplepos fp_flags <| SFPS
samplepos_rt fp_flags <| SFPS
gather2d_a_o_s fp_flags <| SFPS
gather2d_o_s fp_flags <| SFPS
gathercube_a_s fp_flags <| SFPS
gathercube_c_a_s fp_flags <| SFPS
gathercube_c_s fp_flags <| SFPS
gathercube_s fp_flags <| SFPS
sample1d_a_o_cl_s fp_flags <| SFPS
sample1d_bias_a_o_cl_s fp_flags <| SFPS
sample1d_bias_o_cl_s fp_flags <| SFPS
sample1d_c_a_o_cl_s fp_flags <| SFPS
sample1d_c_lz_a_o_s fp_flags <| SFPS
sample1d_c_lz_o_s fp_flags <| SFPS
sample1d_c_o_cl_s fp_flags <| SFPS
sample1d_dd_a_o_cl_s fp_flags <| SFPS
sample1d_dd_o_cl_s fp_flags <| SFPS
sample1d_lod_a_o_s fp_flags <| SFPS
sample1d_lod_o_s fp_flags <| SFPS
sample1d_o_cl_s fp_flags <| SFPS
sample2d_a_o_cl_s fp_flags <| SFPS
sample2d_bias_a_o_cl_s fp_flags <| SFPS
sample2d_bias_o_cl_s fp_flags <| SFPS
sample2d_c_a_o_cl_s fp_flags <| SFPS
sample2d_c_lz_a_o_s fp_flags <| SFPS
sample2d_c_lz_o_s fp_flags <| SFPS
sample2d_c_o_cl_s fp_flags <| SFPS
sample2d_dd_a_o_cl_s fp_flags <| SFPS
sample2d_dd_o_cl_s fp_flags <| SFPS
sample3d_dd_o_cl_s fp_flags <| SFPS
sample2d_lod_a_o_s fp_flags <| SFPS
sample2d_lod_o_s fp_flags <| SFPS
sample2d_o_cl_s fp_flags <| SFPS
sample3d_bias_o_cl_s fp_flags <| SFPS
sample3d_lod_o_s fp_flags <| SFPS
sample3d_o_cl_s fp_flags <| SFPS
samplecube_a_cl_s fp_flags <| SFPS
samplecube_bias_a_cl_s fp_flags <| SFPS
samplecube_bias_cl_s fp_flags <| SFPS
samplecube_c_a_cl_s fp_flags <| SFPS
samplecube_c_cl_s fp_flags <| SFPS
samplecube_c_lz_a_s fp_flags <| SFPS
samplecube_c_lz_s fp_flags <| SFPS
samplecube_cl_s fp_flags <| SFPS
samplecube_dd_a_cl_s fp_flags <| SFPS
samplecube_dd_cl_s fp_flags <| SFPS
samplecube_lod_a_s fp_flags <| SFPS
samplecube_lod_s fp_flags <| SFPS
sat fp_flags <| SFPS
sat float_literal <| SFPS
sat fp_range <| SFPS
sin fp_flags <| SFPS
sin fp_specials <| SFPS
sin float_literal <| SFPS
sin fp_range <| SFPS
sincos fp_flags <| SFPS
sincos fp_specials <| SFPS
sincos float_literal <| SFPS
sincos fp_range <| SFPS
sqrt fp_flags <| SFPS
sqrt fp_specials <| SFPS
sqrt float_literal <| SFPS
sqrt fp_range <| SFPS
switch fp_flags <| SFPS
tex1d fp_flags <| SFPS
tex1d_bias fp_flags <| SFPS
tex1d_dd fp_flags <| SFPS
tex1d_lod fp_flags <| SFPS
tex1d_proj fp_flags <| SFPS
tex2d fp_flags <| SFPS
tex2d_bias fp_flags <| SFPS
tex2d_dd fp_flags <| SFPS
tex2d_lod fp_flags <| SFPS
tex2d_proj fp_flags <| SFPS
tex3d fp_flags <| SFPS
tex3d_bias fp_flags <| SFPS
tex3d_dd fp_flags <| SFPS
tex3d_lod fp_flags <| SFPS
tex3d_proj fp_flags <| SFPS
texcube fp_flags <| SFPS
texcube_bias fp_flags <| SFPS
texcube_dd fp_flags <| SFPS
texcube_lod fp_flags <| SFPS
texcube_proj fp_flags <| SFPS
trunc fp_flags <| SFPS
trunc fp_specials <| SFPS
trunc float_literal <| SFPS
trunc fp_range <| SFPS
uaddc fp_flags <| SFPS
uaddc int_literal <| SFPS
uaddc bits_known <| SFPS
uaddc int_range <| SFPS
ubfe fp_flags <| SFPS
ubfe int_literal <| SFPS
ubfe bits_known <| SFPS
usubb fp_flags <| SFPS
usubb int_literal <| SFPS
usubb bits_known <| SFPS
usubb int_range <| SFPS
udiv fp_flags <| SFPS
udiv int_literal <| SFPS
udiv bits_known <| SFPS
udiv int_range <| SFPS
umax fp_flags <| SFPS
umax int_literal <| SFPS
umax bits_known <| SFPS
umax int_range <| SFPS
umin fp_flags <| SFPS
umin int_literal <| SFPS
umin bits_known <| SFPS
umin int_range <| SFPS
umod fp_flags <| SFPS
umod int_literal <| SFPS
umod bits_known <| SFPS
umod int_range <| SFPS
umul fp_flags <| SFPS
umul int_literal <| SFPS
umul bits_known <| SFPS
umul int_range <| SFPS
ushr fp_flags <| SFPS
ushr int_literal <| SFPS
ushr bits_known <| SFPS
utof fp_flags <| SFPS
utod fp_flags <| SFPS
xor fp_flags <| SFPS
xor int_flags <| SFPS
xor int_literal <| SFPS
xor bits_known <| SFPS
check_access_fully_mapped fp_flags <| SFPS
break_consume fp_flags <| SFPS
continue_consume fp_flags <| SFPS
loopif_consume fp_flags <| SFPS
output_consume fp_flags <| SFPS
return_consume fp_flags <| SFPS
sync_g fp_flags <| SFPS
sync_ug fp_flags <| SFPS
sync_up fp_flags <| SFPS
sync_g_ug fp_flags <| SFPS
sync_g_up fp_flags <| SFPS
sync_g_t fp_flags <| SFPS
sync_ug_t fp_flags <| SFPS
sync_up_t fp_flags <| SFPS
sync_g_ug_t fp_flags <| SFPS
sync_g_up_t fp_flags <| SFPS
atomic_and fp_flags <| SFPS
atomic_or fp_flags <| SFPS
atomic_xor fp_flags <| SFPS
atomic_iadd fp_flags <| SFPS
atomic_imax fp_flags <| SFPS
atomic_imin fp_flags <| SFPS
atomic_umax fp_flags <| SFPS
atomic_umin fp_flags <| SFPS
atomic_cmp_store fp_flags <| SFPS
imm_atomic_and fp_flags <| SFPS
imm_atomic_or fp_flags <| SFPS
imm_atomic_xor fp_flags <| SFPS
imm_atomic_iadd fp_flags <| SFPS
imm_atomic_imax fp_flags <| SFPS
imm_atomic_imin fp_flags <| SFPS
imm_atomic_umax fp_flags <| SFPS
imm_atomic_umin fp_flags <| SFPS
imm_atomic_exch fp_flags <| SFPS
imm_atomic_cmp_exch fp_flags <| SFPS
imm_atomic_alloc fp_flags <| SFPS
imm_atomic_consume fp_flags <| SFPS
Needs to be replaced with a real rule
GenerateDerivatives
DetectRaceConditions
ProcessTBuffer
RemoveDeadCode
MarkSideEffects
VectorizeLeft
RequiredTranslate
PropagateFlags
SimplifyInstructions
SimplifyPredicates
ConvertIgnores
SimplifyTiledResourceInstructions
CompactOutputs
Hull Shader pass-through analysis
RemovePreciseRestrictions
DelayOutputs
ReduceLiterals
SimplifyInstructionsLegacy
Hull Shader Patch Constant Separation
SimplifyInstructionsComplex
SimplifyRangeExpressions
GroupStores
UnaliasArrayLoads
SimplifyFlowStores
CompactArrays
CombineInstructions
OptimizeSyncs
SquishInstructions
RemoveDuplicateInstructions
MergeInstructions
SimplifyLoads
SimplifyAddresses
SimplifyAddressesIPA
PropagatePredicates
OptimizeEarlyTranslate
BackEndOptimize
ReorderBinary
ReorderBinaryI
ShuffleCompute
internal warning: optimization did not converge
Split
Hull Shader codegen
multiple variables found with the same user-specified location
gradient-based operations must be moved out of flow control to prevent divergence. Performance may improve by using a non-gradient operation
cannot have gradient operations inside loops with divergent flow control
internal error: argument pulled into unrelated predicate
cannot have divergent gradient operations inside flow control
internal error: invalid register
array index out of bounds <| A%u (B%u), I%u (B%u)
variable '%s' used without having been completely initialized <| A%u (B%u), I%u (B%u)
thread sync operation must be in non-varying flow control, due to a potential race condition this sync is illegal, consider adding a sync after reading any values controlling shader execution at this point
thread sync operation found in varying flow control, consider reformulating your algorithm so all threads will hit the sync simultaneously
varying
gradient operation uses a value that may not be defined for all pixels (in %s UAV loads can not participate in gradient operations)
UAV-related
%s FAILED!
floating point division by zero
imaginary square root
indefinite logarithm
indefinite arcsine
indefinite arccosine
double-precision floating point division by zero
Literal floating-point value out of integer range for conversion: %f
Literal floating-point value out of unsigned range for conversion: %f
sum of %g and %g cannot be represented accurately in double precision
Integer divide by zero
Unsigned integer divide by zero
floating-point value out of integer range for conversion: %f
floating-point value out of unsigned range for conversion: %f
indefinite derivative calculation
Possible integer divide by zero
VectorizeRight
PropagateSwizzles
SplitRegisters
Translate
VectorizeLiterals
ReorderInstructions
SeparatePhases
PropagateMovs
Constrain
CompactRegisters
CombineInstsVectorized
Reading from texture buffers is unsupported on %s
Shader uses texture addressing operations in a dependency chain that is too complex for the target shader model (%s) to handle.
internal error: instruction list too long
internal error: instruction list and count mismatch
note that in IEEE strict mode, all values are implicitly marked precise
variable '%s' has a minimum precision type and cannot be marked precise <| A%u (B%u)
expression has a minimum precision type and cannot be marked precise <| A%u (B%u), I%u (B%u)
internal error: compiler-generated value has a minimum precision type and is marked precise <| A%u (B%u)
internal error: argument used without having been initialized <| A%u (B%u), I%u (B%u)
internal error: output argument was never initialized <| (A%u (B%u))
internal error: cannot write to argument pool <| (A%u (B%u), I%u (B%u))
internal error: cannot read from argument pool <| (A%u (B%u))
internal error: 64-bit arg component %u not aligned <| A%u (B%u)
internal error: reading from value known not to be read <| (A%u (B%u))
internal error: argument was never used <| (A%u (B%u), I%u (B%u))
internal error: argument was never used <| (A%u (B%u))
use of potentially uninitialized variable (%s)
infinite loop detected - loop never exits
array index out of bounds
Internal error: unpredicated endif input
Internal error: invalid read of more specific predicate
internal error: unpredicated incomplete
internal error: unpredicated loop_in
Internal error: unread predicate
preshader
overlapping register semantics not yet implemented 'c%u'
internal error: component out of range
SV_TARGET
SV_DEPTH
SV_DEPTHGREATEREQUAL
SV_DEPTHLESSEQUAL
SV_COVERAGE
SV_INNERCOVERAGE
SV_STENCILREF
Unknown creator
Unknown library function
Microsoft (R) HLSL Shader Compiler 10.1
$Invalid
rootsig_1_0
rootsig_1_1
D3DCompile: Entry point must specify the RootSignature define name
[RootSignature(%s)]void ___DummyMainForRS(){}
ps_5_1
___DummyMainForRS
D3DCompile: Invalid flags specified
D3DCompile: cannot specify source and binary debug names
D3DCompile: pEntrypoint pointer is invalid
__fx_2_0__
Shader@0x%p
D3DCompile: Entry point cannot be specified for a library (mark library entry points with the export keyword)
D3DCOMPILER_SAVE_REPLAY
D3DCOMPILER_USE_REPLAY
#pragma pack_matrix(row_major)
#pragma pack_matrix(column_major)
#pragma pack_matrix()
#pragma ruledisable "%s"
#line %u %.*s
#line %u
#pragma def (%s, %s, %g, %g, %g, %g)
#pragma warning (once:%d)
#pragma warning (disable:%d)
#pragma warning (error:%d)
D3DCompressedData
(%u,%u-%u): 
(%u,%u): 
%s X%u: 
error
Error creating error string
warning treated as error
warning
Unable to create warning string
version token
token '%s'
integer '%u'
integer '%dl'
integer '%uul'
integer '%I64d'
integer '%I64uu64'
float '%g'
float '%gh'
float '%gf'
float '%gl'
string constant
end of line
end of file
token
syntax error : unexpected %s
--- Compilation status for library function '%s' ---
comment continues past end of file
1.#IND
1.#INF
1.#QNAN
1.#SNAN
hex value truncated to 64 bits
octal value truncated to 64 bits
decimal value truncated to 64 bits
string continues past end of file
string continues past end of line
character continues past end of file
<error - out of memory>
<float16>
sbyte
short
ushort
ulong
<count>
<none>
<unknown>
<nocast>
<pointer>
Texture2DArrayMS
SamplerComparisonState
StateBlock
Rasterizer
DepthStencil
Blend
PointStream
LineStream
TriangleStream
InputPatch
OutputPatch
RWTexture1D
RWTexture1DArray
RWTexture2D
RWTexture2DArray
RWTexture3D
RWBuffer
ByteAddressBuffer
RWByteAddressBuffer
StructuredBuffer
RWStructuredBuffer
RWStructuredBuffer(Incrementable)
RWStructuredBuffer(Decrementable)
AppendStructuredBuffer
ConsumeStructuredBuffer
ConstantBuffer
TextureBuffer
RasterizerOrderedBuffer
RasterizerOrderedByteAddressBuffer
RasterizerOrderedStructuredBuffer
RasterizerOrderedTexture1D
RasterizerOrderedTexture1DArray
RasterizerOrderedTexture2D
RasterizerOrderedTexture2DArray
RasterizerOrderedTexture3D
<basic>
class
<compound>
<anonymous>
.$super
$super
<error>*
typedef 
precise 
column_major 
const 
unorm 
snorm 
array_index 
<unknown qual> 
#hlsl_full_path
hlsl_full_path
malformed #hlsl_full_path
No include handler specified, can't perform a #include. Use D3DX APIs or provide your own include handler.
failed to open source file: '%s'
<memory>
unexpected tokens following preprocessor directive
unexpected end of file
__FILE__
__LINE__
DIRECT3D
D3D10_COMPILER
HLSL_VERSION
D3DX_VERSION
define
ifdef
ifndef
include
pragma
undef
defined
invalid or unsupported integer constant expression
internal error: stack underflow
division by zero in preprocessor expression
Stack
internal error: out of memory
syntax error
invalid preprocessor command '%s'
duplicate macro parameter '%s'
#hlsl_full_path must be the first content in a source file
too many nested #includes
error: %s
unexpected #elif
unexpected #elif following #else
unexpected #else
unexpected #else following #else
unexpected #endif
pack_matrix
ruledisable
message
feature
'%s' : unknown pragma ignored
row_major
column_major
disable
default
#pragma feature(%s) must appear before any local declaration
unrecognized feature '%s' requested in '#pragma feature(...)'
'%s' : macro redefinition
functional defines in preprocessor expressions not yet implemented
unexpected end of file in macro expansion
not enough actual parameters for macro '%s'
internal error: production failed
LegacyLocalResourceArrays
invalid
scope
variable
function
technique
global variables
local variables
annotation members
passes
members
loop variables
struct/class members
methods
function parameters
<container>
initial value
value
initializer
<method>
default value
<symobj>
(unknown scope entry kind)
(unknown scope value kind)
namespace
memory exhausted
 !;<=> !
4560*+;<E
D=>3[FG
NOPQ9:?@H
LMIRSZWT
 !"#$%&'().
!&)+-/135
$%"#'(*,.02
+,,,,,,,,,,,,,,,,-----....///000111112223344556677889:;<
Value
internal error: this-relative %s '%s' found outsideof function scope
static method %s cannot refer to instance members
undeclared identifier '%s'
data member
'%s': initializer does not match type
object literals are not allowed inside functions
all global variables are implicitly constant when compiling a library.
global variables are implicitly constant, enable compatibility mode to allow modification
global variables are implicitly constant, variables of classes with interface inheritance can never be modified
l-value specifies const object
int or unsigned int type required
scalar, vector, or matrix expected
operator cannot be used with a bool lvalue
couldn't cast expression to integer
unary negate of unsigned value is still unsigned
couldn't cast expression to boolean for logical not operator
type mismatch
signed/unsigned mismatch, unsigned assumed
couldn't cast expression to boolean for logical operator
comma expression used where an initializer list may have been intended
comma expression used where a vector constructor may have been intended
constructors only defined for numeric base types
cannot convert from 'object type' to 'numeric type'
incorrect number of arguments to numeric-type constructor
conditional must be numeric
type mismatch between conditional values
dimension of conditional does not match value
array, matrix, vector, or indexable object type expected in index expression
invalid type for index - index must be a scalar, or a vector with the correct number of dimensions
Sub index list
sample
Length
Swizzle
invalid subscript '%s'
Partials
Inputs
Outputs
out parameters require l-value arguments (given argument is implicitly const, such as a global)
out parameters require l-value arguments
'%s': %ss are limited to no more than %u parameters (%u given)
'%s': no matching %u parameter %s
Possible %ss are:
    %s
Parameters
Method and Parameters
intrinsic function
method
<out of memory>
%s does not have method '%s'
'%s': static methods cannot be called on objects
%s object does not have methods
%s object does not have method '%s'
intrinsic method
vector dimension must be a literal scalar expression
vector dimension must be between 1 and %u
vector element type must be a scalar type
matrix dimensions must be literal scalar expressions
matrix dimensions must be between 1 and %u
matrix element type must be a scalar type
untyped textures are deprecated in strict mode
the 'sampler1D' keyword is deprecated in strict mode; use 'SamplerState' instead
the 'sampler2D' keyword is deprecated in strict mode; use 'SamplerState' instead
the 'sampler3D' keyword is deprecated in strict mode; use 'SamplerState' instead
the 'samplerCUBE' keyword is deprecated in strict mode; use 'SamplerState' instead
the 'stateblock' keyword is deprecated in strict mode
non-numeric sample count
sample count must be non-zero
non-numeric vertex count
vertex count must be non-zero
matrix types cannot be both column_major and row_major
non-matrix types cannot be declared 'row_major' or 'column_major'
%cnorm can not be used with type
unsigned can not be used with type
object element type cannot be an object type
object's templated type must have at least one element
elements of typed buffers and textures cannot be arrays
elements of typed buffers and textures must fit in four 32-bit quantities
classes and interfaces are not supported in libraries
interfaces cannot inherit from other types
base type is not a struct, class or interface
multiple concrete base types specified
'%s': class does not implement method %s
array dimensions of type must be explicit
array dimensions must be literal scalar expressions
array dimension must be between 1 and 65536
secondary array dimensions must be explicit
interface arrays cannot be multi-dimensional
redefinition of type with struct/class
redefinition of type with interface
AddUint64
AllMemoryBarrier
AllMemoryBarrierWithGroupSync
CheckAccessFullyMapped
status
D3DCOLORtoUBYTE4
DeviceMemoryBarrier
DeviceMemoryBarrierWithGroupSync
EvaluateAttributeAtSample
index
EvaluateAttributeCentroid
EvaluateAttributeSnapped
offset
GetRenderTargetSampleCount
GetRenderTargetSamplePosition
GroupMemoryBarrier
GroupMemoryBarrierWithGroupSync
InterlockedAdd
result
original
InterlockedAnd
InterlockedCompareExchange
compare
InterlockedCompareStore
InterlockedExchange
InterlockedMax
InterlockedMin
InterlockedOr
InterlockedXor
NonUniformResourceIndex
Process2DQuadTessFactorsAvg
RawEdgeFactors
InsideScale
RoundedEdgeFactors
RoundedInsideFactors
UnroundedInsideFactors
Process2DQuadTessFactorsMax
Process2DQuadTessFactorsMin
ProcessIsolineTessFactors
RawDetailFactor
RawDensityFactor
RoundedDetailFactorr
RoundedDensityFactor
ProcessQuadTessFactorsAvg
ProcessQuadTessFactorsMax
ProcessQuadTessFactorsMin
ProcessTriTessFactorsAvg
RoundedInsideFactor
UnroundedInsideFactor
ProcessTriTessFactorsMax
ProcessTriTessFactorsMin
__test_intrin1
__test_intrin2
__test_intrin3
__test_intrin4
abort
asdouble
asfloat
asint
asuint
atan2
clamp
countbits
cross
ddx_coarse
ddx_fine
ddy_coarse
ddy_fine
degrees
determinant
distance
errorf
Format
f16tof32
f32tof16
faceforward
firstbithigh
firstbitlow
floor
frexp
fwidth
isfinite
isinf
isnan
ldexp
length
log10
msad4
reference
accum
noise
normalize
printf
radians
reflect
refract
reversebits
round
rsqrt
saturate
smoothstep
source_mark
tex1D
tex1Dbias
tex1Dgrad
tex1Dlod
tex1Dproj
tex2D
tex2Dbias
tex2Dgrad
tex2Dlod
tex2Dproj
tex3D
tex3Dbias
tex3Dgrad
tex3Dlod
tex3Dproj
texCUBE
texCUBEbias
texCUBEgrad
texCUBElod
texCUBEproj
transpose
Append
RestartStrip
CalculateLevelOfDetail
CalculateLevelOfDetailUnclamped
GetDimensions
width
levels
Sample
SampleBias
SampleCmp
SampleCmpLevelZero
SampleGrad
SampleLevel
elements
Gather
GatherAlpha
GatherBlue
GatherCmp
GatherCmpAlpha
GatherCmpBlue
GatherCmpGreen
GatherCmpRed
GatherGreen
GatherRed
height
samples
GetSamplePosition
depth
byteOffset
Load2
Load3
Load4
Store
Store2
Store3
Store4
count
stride
DecrementCounter
IncrementCounter
Consume
dword
float4
float4x4
<unnamed>
matrix
pixelshader
vector
vertexshader
'%s': identifier represents a %s, not a variable
internal error: unable to process intrinsic
'%s': identifier represents a %s, not a function
'%s': ambiguous function call
center
globallycoherent
single
unrecognized identifier '%s'
'%s': too many target specifiers given
duplicate usages specified
constinterp usage cannot be used with linear, noperspective, or centroid usage
conflicting geometry types
AttrParams
$clip_outputs
Attributes
clipplanes
'clipplanes' attribute is ignored in library functions
location semantics do not apply to %ss
location semantics cannot be specified on members
packoffset cannot have a target qualifier
sampler requires an 's' or 't' register
buffer requires a 't' register
texture requires a 't' or 's' register
UAV requires a 'u' register
cbuffer requires a 'b' register
tbuffer requires a 't' register
usage semantics do not apply to %ss
bind semantics cannot be specified for this object
incorrect bind semantic
duplicate usage semantic ignored
redefinition of '%s'
'%s': variable is declared as tbuffer, which is not supported for libraries yet
'%s': invalid shader target/usage
'%s': %s cannot be target specific
'%s': %s cannot be declared 'inline'
'%s': %s cannot be declared 'single'
'%s': interfaces cannot contain data
'%s': interfaces cannot be declared in buffers
'%s': extern %s cannot be declared 'static'
'%s': uniform %s cannot be declared 'static'
'%s': extern %s cannot be declared 'groupshared'
'%s': uniform %s cannot be declared 'groupshared'
'%s': groupshared variables cannot hold resources
'%s': types cannot contain members of their own type
'%s': interfaces cannot be members
'%s': %s cannot be declared 'const'
'%s': output parameters cannot be declared 'const'
'%s': %s cannot be void
'%s': %s cannot be declared 'static'
'%s': %s cannot be declared 'uniform'
'%s': %s cannot be declared 'uniform out'
'%s': %s cannot be declared 'extern'
'%s': %s cannot be declared 'groupshared'
'%s': %s cannot be declared 'shared'
'%s': %s cannot be declared 'volatile'
'%s': only first dimension can be implicit
'%s': array dimensions of %s must be explicit
'%s': implicit array missing %s
'%s': implicit array type does not match %s
'%s': array dimension must be between 1 and 65536
redefinition of formal parameter '%s'
'%s': static members can only be defined in global scopes
'%s': static member not found in class
'%s': member not a static variable
D3D12 constant/texture buffer template element can only be a struct
'%s': declaration type differs from definition type
Conflicting register semantics: '%s' and '%s'
'%s': interfaces cannot have semantics
'%s': %s cannot have semantics
'%s': %s cannot have annotations
stream parameters can only be single-element types
'%s': out parameters cannot have default values
potentially unintended use of a comma expression in a variable initializer
'%s': variables of type '%s' cannot be declared 'static'
'%s': variables containing textures, samplers and UAVs can only be declared 'static' if the variable only contains resources
'%s': %s cannot have %ss
'%s': non-numeric uniform %s cannot have %ss
'%s': output only %s cannot have %ss
'%s': %s must be a literal expression
static interfaces cannot have initializers
Initializer used on a global 'const' variable. This requires setting an external constant. If a literal is desired, use 'static const' instead.
'%s': missing %s
'%s': incorrect array size
'%s' used but not defined
'%s': functions cannot be declared 'uniform'
'%s': functions cannot be declared 'extern'
'%s': interface methods cannot be static
'%s': function return value cannot contain Effects objects
'%s': method not found in class
'%s': interface methods cannot be declared outside of an interface
'%s': library functions cannot have a target
'%s': functions cannot have a target
'%s': library functions are supported only for PS and VS shaders
'%s': void function cannot have a semantic
'%s': missing default value for parameter '%s'
'%s': unsupported type qualifier for a library function parameter '%s'
'%s': library function parameters cannot have duplicate semantic '%s'
'%s': library function parameter and return cannot have duplicate semantic '%s'
'%s': doubles cannot be used as library function inputs or outputs. If you need to pass a double to a library function, you must pass it as two uints and use asuint and asdouble to convert between forms.
'%s': unsupported type for a library function parameter '%s'
'%s': return type does not match overridden method
%s cannot be redeclared
'%s' already defined as a %s
%s did not match any prototype in the class
'%s': function return value differs from prototype
'%s': 'static' mismatch between declaration and definition
'%s': default parameters can only be provided in the first prototype
'%s': interface methods cannot have bodies
invalid usage modifier applied to %cbuffer
cbuffers cannot have the same name ('%s') in a library
space
out of memory while parsing
Illegal character in shader file
asm_fragment
catch
centroid
compile
compile_fragment
const
const_cast
continue
CompileShader
delete
discard
dynamic_cast
explicit
extern
export
friend
groupshared
inline
inout
lineadj
linear
mutable
nointerpolation
noperspective
operator
packoffset
private
protected
public
point
the 'pixelshader' keyword is deprecated and reserved in strict mode
register
reinterpret_cast
return
sampler_state
signed
sizeof
stateblock_state
static
static_cast
switch
stateblock
String
template
triangle
triangleadj
throw
typedef
typename
texture1D
texture2D
texture3D
textureCUBE
alternate cases for 'Texture1D' are deprecated in strict mode
alternate cases for 'Texture2D' are deprecated in strict mode
alternate cases for 'Texture3D' are deprecated in strict mode
alternate cases for 'TextureCube' are deprecated in strict mode
uniform
union
unsigned
using
virtual
volatile
the 'vertexshader' keyword is deprecated and reserved in strict mode
while
alternate cases for 'asm' are deprecated in strict mode
alternate cases for 'decl' are deprecated in strict mode
alternate cases for 'pass' are deprecated in strict mode
alternate cases for 'technique' are deprecated in strict mode
integer constant
float constant
syntax error: unexpected %s
error count exceeds %u, aborting
implicitly 
output parameter 
cannot %sconvert %sfrom '%s' to '%s'
'%s': cannot %sconvert %sfrom '%s' to '%s'
'%s': conversion from larger type to smaller, possible loss of data
conversion from larger type to smaller, possible loss of data
'%s': implicit truncation of vector type
implicit truncation of vector type
<parse error>
packoffset is only allowed in a constant buffer
register offset must be a literal scalar expression
'%s' matches a variable in the template shader but the type layout does not match
'%s': place-holder template resources can only be simple resources, structs and arrays are not supported
unsigned integer literal %I64u too large, truncated
SetComputeShader
SetDomainShader
SetHullShader
SetGeometryShader
SetPixelShader
SetVertexShader
SetRasterizerState
SetBlendState
SetDepthStencilState
OMSetRenderTargets
ConstructGSWithSO
BindInterfaces
D3D10_SHADER_DEBUG
D3D10_SHADER_SKIP_OPTIMIZATION
D3D10_SHADER_PARTIAL_PRECISION
D3D10_SHADER_NO_PRESHADER
D3D10_SHADER_AVOID_FLOW_CONTROL
D3D10_SHADER_PREFER_FLOW_CONTROL
D3D10_SHADER_ENABLE_BACKWARDS_COMPATIBILITY
D3D10_SHADER_IEEE_STRICTNESS
invalid compiler flag %s
parameter count mismatch (%s)
this FX API is not available in this part your program (%s)
Unrecognized FX function call (%s)
States
DX9-style 'LHS = <RHS>' syntax is deprecated in strict mode
Values
unsupported compiler target '%s'
the debug info flag can only be set globally
%s shader fragments are not supported
DX9-style 'compile' syntax is deprecated in strict mode
DX9-style '= sampler_state' syntax is deprecated in strict mode
'%s': void functions cannot return a value
'%s': function must return a value
potentially unintended use of a comma expression in a return statement
if statement conditional expressions must evaluate to a scalar
could not cast condition to boolean
scalar value expected
could not cast condition to uint
non-scalar case expression
non-numeric case expression
CaseStmts
'%s': loop control variable conflicts with a previous declaration in the outer scope; most recent declaration will be used
internal error: unable to add non-conflicting symbol
Stmts
space is only supported for shader targets 5.1 and higher
FkF3PQL
xyzhi
lmnop
stuvw
defghijklmnopqrstuvw
;<=>?@ABCDEFGHIJKL
VWXYZ[\]^_`a
xyz{|}~
;<=>?@ABCDEFGHIJKL
VWXYZ[\]^_`a
xyz{|}~
;<=>?@ABCDEFGHIJKL
VWXYZ[\]^_`a
xyz{|}~
;<=>?@ABCDEFGHIJKL
VWXYZ[\]^_`a
xyz{|}~
=>?@ABCD
Z[\]^_`
xyz{|}~
>?@ABCD
xyz{|}~
>?@ABCD
xyz{|}~
>?@ABCD
xyz{|}~
=>?@ABCDEFGHIJK
YZ[\]^_`
xyz{|}~
>?@ABCD
xyz{|}~
>?@ABCD
xyz{|}~
>?@ABCD
xyz{|}~
>?@ABCD
xyz{|}~
>?@ABCD
xyz{|}~
>?@ABCD
xyz{|}~
>?@ABCD
xyz{|}~
>?@ABCD
xyz{|}~
>?@ABCD
xyz{|}~
>?@ABCD
xyz{|}~
>?@ABCD
xyz{|}~
>?@ABCD
xyz{|}~
>?@ABCD
xyz{|}~
&'()*+,-
56789
=>?@ABC
QRSTUV
YZ[\]^_`
+,-./
=>?@ABC
NOPQRS
XYZ[\]^_`
+,-./
=>?@ABC
MNOPQRS
XYZ[\]^_`
+,-./
=>?@ABC
NOPQRS
XYZ[\]^_`
=>?@ABC
YZ[\]^_`
=>?@ABC
YZ[\]^_`
&'()*+,-
56789
=>?@ABC
QRSTUV
YZ[\]^_`
=>?@ABC
YZ[\]^_`
=>?@ABC
YZ[\]^_`
=>?@ABC
Z[\]^_`
>?@ABC
Z[\]^_
>?@ABC
Z[\]^_
vjt}e
 !"#$%
3456789:;
=>?@A
 !"#$%
3456789:;
=>?@A
 !"#$%
3456789:;
=>?@A
 !"#$%
3456789:;
=>?@A
 !"#$%
56789:;
=>?@A
 !"#$%
=>?@A
 !"#$%
=>?@A
 !"#$%
=>?@A
 !"#$%
456789:;
=>?@A
 !"#$%
=>?@A
 !"#$%
=>?@A
 !"#$%
=>?@A
 !"#$%
=>?@A
 !"#$%
=>?@A
 !"#$%
=>?@A
 !"#$%
=>?@A
 !"#$%
=>?@A
 !"#$%
=>?@A
 !"#$%
=>?@A
 !"#$%
=>?@A
 !"#$%
=>?@A
 !"#$%
=>?@A
 !"#$%
56789
=>?@A
 !"#$%
,-./01
3456789:;
=>?@A
 !"#$%
,-./01
3456789:;
=>?@A
 !"#$%
,-./01
3456789:;
=>?@A
 !"#$%
456789:;
=>?@A
 !"#$%
456789:;
=>?@A
 !"#$%
56789:;
=>?@A
 !"#$%
456789:;
=>?@A
 !"#$%
456789:;
=>?@A
 !"#$%
56789:;
=>?@A
 !"#$%
56789:
 !"#$%
56789:
DEFGH
VWXY{Z
2d/%mwe)
nx1^_`abc"
TkiP0
4BDQRSC6
 !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
vOutputControlPointId
vGroupIndex
vHSInstanceID
rcp_approx
firstbit_shi
firstbit_hi
uaddc
usubb
fcall
dmovc
eval_centroid
eval_snapped
resinfo
bufinfo
sampleinfo
samplepos
d3ds_dotswiz
d3ds_noiseswiz
atomic_and
atomic_or
atomic_xor
atomic_iadd
atomic_imax
atomic_imin
atomic_umax
atomic_umin
atomic_cmp_store
imm_atomic_and
imm_atomic_or
imm_atomic_xor
imm_atomic_iadd
imm_atomic_imax
imm_atomic_imin
imm_atomic_umax
imm_atomic_umin
imm_atomic_exch
imm_atomic_cmp_exch
imm_atomic_alloc
imm_atomic_consume
check_access_fully_mapped
COMPILER_GENERATE_OLD_DEBUG_INFO
<font color = "#
</font>
a0a0a0
ffff40
e0e0e0
00ffff
<font color = "#%s">
D3DX: (WARN) Overloaded ::new and ::delete operators do not conform to C++ standards:
D3DX: (WARN) An allocation of zero bytes should return a unique non-null pointer to at
D3DX: (WARN) least zero bytes. Deletion of a null pointer should quietly do nothing.
D3DX: (WARN) D3DX11 relies upon this behavior.
O8T>[
7xicuU
cabinet.dll
FCICreate
FCIAddFile
FCIFlushCabinet
FCIDestroy
FDICreate
FDICopy
FDIDestroy
D0x%I64x
breakc
callc
continuec
emit_then_cut
endswitch
deriv_rtx
deriv_rty
round_ne
round_ni
round_pi
round_z
sample_b
sample_l
sample_d
sample_c
sample_c_lz
dcl_input
dcl_output
dcl_input_sgv
dcl_input_ps_sgv
dcl_inputprimitive
dcl_outputtopology
dcl_maxout
dcl_input_ps
dcl_constantbuffer
dcl_sampler
dcl_resource
dcl_input_siv
dcl_input_ps_siv
dcl_output_siv
dcl_output_sgv
dcl_temps
dcl_indexableTemp
dcl_indexrange
dcl_globalFlags
gather4
emit_stream
cut_stream
emit_then_cut_stream
dcl_stream
dcl_function_body
dcl_function_table
dcl_interface
deriv_rtx_coarse
deriv_rtx_fine
deriv_rty_coarse
deriv_rty_fine
gather4_c
gather4_po
gather4_po_c
firstbit_lo
bfrev
swapc
hs_decls
hs_control_point_phase
hs_fork_phase
hs_join_phase
dcl_input_control_point_count
dcl_output_control_point_count
dcl_tessellator_domain
dcl_tessellator_partitioning
dcl_tessellator_output_primitive
dcl_hs_max_tessfactor
dcl_hs_fork_phase_instance_count
dcl_hs_join_phase_instance_count
dcl_thread_group
dcl_uav_typed
dcl_uav_raw
dcl_uav_structured
dcl_tgsm_raw
dcl_tgsm_structured
dcl_resource_raw
dcl_resource_structured
ld_uav_typed
store_uav_typed
ld_raw
store_raw
ld_structured
store_structured
eval_sample_index
dcl_gsinstances
debug_break
gather4_s
gather4_c_s
gather4_po_s
gather4_po_c_s
ldms_s
ld_uav_typed_s
ld_raw_s
ld_structured_s
sample_l_s
sample_c_lz_s
sample_cl_s
sample_b_cl_s
sample_d_cl_s
sample_c_cl_s
cs_4_0
cs_4_1
cs_5_1
ds_5_0
ds_5_1
fx_2_0
gs_4_0
gs_4_1
gs_5_0
gs_5_1
hs_5_0
hs_5_1
lib_4_0
lib_4_1
lib_4_0_level_9_1
lib_4_0_level_9_1_vs_only
lib_4_0_level_9_1_ps_only
lib_4_0_level_9_3
lib_4_0_level_9_3_vs_only
lib_4_0_level_9_3_ps_only
lib_5_0
ps.1.0
ps.1.1
ps.1.2
ps.1.3
ps.1.4
ps.2.0
ps.2.a
ps.2.b
ps.2.sw
ps.2.x
ps.3.0
ps.3.sw
ps_1_0
ps_1_1
ps_1_2
ps_1_3
ps_1_4
ps_2_0
ps_2_a
ps_2_b
ps_2_sw
ps_2_x
ps_3_0
ps_3_sw
ps_4_0_level_9_0
tx_1_0
vs.1.0
vs.1.1
vs.2.0
vs.2.a
vs.2.sw
vs.2.x
vs.3.0
vs.3.sw
vs_1_0
vs_1_1
vs_2_0
vs_2_a
vs_2_sw
vs_2_x
vs_3_0
vs_3_sw
vs_4_0_level_9_0
vs_5_1
breakp
break_c
boolean constant register '%s' must be defined as a variable of type bool only
integer constant register '%s' must be defined as a variable of type int3 or int4 only
Constant variable '%s' bound to register greater than 8191 (%d requested)
Sampler variable '%s' does not specify the sampler type.  Explicit sampler types required for asm fragments.
POSITION
BLENDWEIGHT
BLENDINDICES
NORMAL
PSIZE
TEXCOORD
TANGENT
BINORMAL
TESSFACTOR
POSITIONT
COLOR
VFACE
DIFFUSE
SPECULAR
invalid register, input, or constant name '%s'
Invalid input register '%s' specified
addressing operations are not allowed on input registers '%s'
Invalid pixel shader input register '%s' specified
addressing operations not allowed on temporary registers '%s'
constant register '%s' must be defined as a variable '%s'
constant register address out of bounds on constant '%s', size %d, offset %d
Invalid output register '%s' specified
addressing operations are not allowed on output registers '%s'
'%s' is not a valid register name.  Registers must start with v_, r_, c_, b_, or i_ depending on the register type. (o_ for vs_3_0 only)
shader version expected
vs_1_0 is no longer supported; using vs_1_1
ps_1_0 is no longer supported; using ps_1_1
unrecognized shader version
only vs_1_1, vs_2_0, vs_2_x, vs_2_sw, ps_2_0, ps_2_x, and ps_2_sw are supported for assembly fragments
entrypoint
instruction coissue is not supported in this shader version
instruction predication is not supported in this shader version
scalar registers cannot be masked
not cannot be used with other modifiers
negate and divide modifiers cannot be combined
invalid complement expression
complement is not supported in this shader version
complement cannot be used with other modifiers
scalar registers cannot be swizzled
only one address register reference allowed in a relative address expression
'%s' is not a valid instruction in this shader version
invalid instruction modifiers '%s'
volume
blendweight
blendindices
normal
psize
tangent
binormal
tessfactor
positiont
color
temporary, constant, and output registers are not allowed in vs_3_0 assembly fragments
temporary and constant registers are not allowed in assembly fragments
invalid register '%s[%u]'
invalid register '%s[...]'
invalid register '%s'
invalid mask '%s'
invalid swizzle '%s'
call, callnz, label, and ret instructions are not allowed in assembly fragments
Matrices cannot be specified in temp registers with the fragment linker
source modifiers are not allowed on destination parameters
relative addressing of destination parameters is not supported in this shader version
only one address register reference is allowed in a relative address expression
predicates are not supported in this shader version
source modifiers are not allowed on predicates
relative addressing of predicates is not supported in this shader version
source modifiers incompatible with SUB instruction
only a0.x is allowed as a relative address register in vs_1_1
internal error: instruction size mismatch
Microsoft (R) D3DX9 Shader Assembler 10.1
fragment info exceeds maximum comment size
debug info exceeds maximum comment size; no debug info emitted
 !1234zw
GHWXYZ
TU"opqr\]!
89CDEF
%JK%[:;"%a#"\<STUb
"%&'%[
=Q00000000_dopqrefmn>
tv?@{Bsu
MGxyNVHIWXYQ1234567
Zh_ijdk
+*++++056++
UWX++++
YZ_ab
+++de
/()*OPgc^
 !+,`
:;<=>?@ABCD
$%%&&'''())**++++,,,,-----------..////0011223344555666666789:;<=>?@ABCD
MAXMIPLEVEL
MAXLOD
SRGBTEXTURE
ELEMENTINDEX
DMAPOFFSET
MAGFILTER
FILTER
MINFILTER
MIPFILTER
MIPMAPLODBIAS
MIPLODBIAS
D3DEffectCompiler
Effects deprecated for D3DCompiler_47
register or offset bind %s.%s not valid
register or offset bind %s not valid
Internal Error - there was a problem getting a type size
There was an unexpected error in the parse tree
float1
float2
float3
uint1
uint2
uint3
uint4
bool1
bool2
bool3
bool4
float1x1
float1x2
float1x3
float1x4
float2x1
float2x2
float2x3
float2x4
float3x1
float3x2
float3x3
float3x4
float4x1
float4x2
float4x3
int1x1
int1x2
int1x3
int1x4
int2x1
int2x2
int2x3
int2x4
int3x1
int3x2
int3x3
int3x4
int4x1
int4x2
int4x3
int4x4
uint1x1
uint1x2
uint1x3
uint1x4
uint2x1
uint2x2
uint2x3
uint2x4
uint3x1
uint3x2
uint3x3
uint3x4
uint4x1
uint4x2
uint4x3
uint4x4
bool1x1
bool1x2
bool1x3
bool1x4
bool2x1
bool2x2
bool2x3
bool2x4
bool3x1
bool3x2
bool3x3
bool3x4
bool4x1
bool4x2
bool4x3
bool4x4
Variable has an invalid type; is the structure definition empty?
%s does not support structs without members
interfaces cannot be embedded in other types
Incorrect number of rows or columns
Objects not allowed in structures
Only single-dimensional object arrays are allowed
Unexpected template type
Unexpected component type
Unexpected node encountered when trying to determine type
There was a problem getting annotations
Only numeric types and strings are allowed as annotations
This object can only be bound to one slot in this version of Effects
Numeric variables ('%s') can't be shared; share the containing cbuffer instead
Only numeric variables ('%s') can be added to a cbuffer
Error: constant buffer %s has both user-defined offset and compiler-assigned offsets
Buffers can only be bound to one slot in this version of Effects
Constant buffers, functions, and techniques cannot be nested inside of constant buffers
Unnamed objects are not allowed
Redefinition of pass "%s"
Sampler
DX9-style assignment syntax is deprecated in technique10 pass blocks in favor of new function call syntax
Deprecated DX9 state '%s' is being ignored for %s
Deprecated DX9 state '%s' is being ignored for %s; use state '%s' instead
DX9 state '%s' is not supported in %s; use compatibility mode to ignore
DX9 state '%s' is not supported in %s; convert to '%s' or use compatibility mode to ignore
Unrecognized state '%s'
State '%s' belongs in %s blocks, not %s blocks
GenerateMips is not supported in %s
State '%s' is not indexed
Max index for effect state '%s' is %d
Index is required for state '%s'
Internal error: unrecognized SB API Call
%s is not supported on %s
Internal error: unrecognized assignment type
(unnamed)
ERROR: Semantic %s is not supported in fx_4_1.
Stage linkage warning: Semantic %s has been placed in different registers in the two stages.
Stage linkage warning: Semantic %s has been inconsistently defined in the two stages.
Stage linkage warning: Semantic %s is read from, but it's never written to.
%s: ERROR: If either a HullShader or DomainShader is set then both must be set. Technique %s, Pass %s.
%s: ERROR: No valid %s-%s combination could be found in Technique %s, Pass %s.
%s: WARNING: There exist invalid %s-%s combinations in Technique %s, Pass %s, depending on which elements of the specified shader array(s) are chosen.
'%s': samplers can only be used with declared textures or texture assignments
Assignment %s: Reference to shader variable '%s' not valid for %s techniques because it uses an uninitialized shader
Assignment %s: Reference to shader variable '%s' not valid for %s techniques because it uses an unsupported shader model
Assignment %s: Reference to shader variable '%s' not valid for %s techniques because it is missing interface parameter bindings
Unrecognized RHS value in assignment: '%s'
There was an error compiling HLSL shader variable
Undefined shader variable '%s'
%s can't operate on array references
Stream output geometry shaders can only be created from valid 4.0+ vertex and geometry shaders
%s can only be used with non-NULL shaders
Invalid shader type used with %s
Identifier invalid or not found (were you attempting a forward reference?)
%s does not support multi-output stream out
StreamOut declarations must be a literal string
Invalid StreamOut decl: %s
Invalid StreamOut decl
StreamOut rasterization stream index must be a literal
%s does not support interface bindings
invalid interface binding parameter
cannot bind interfaces to classes in tbuffers
BindInterfaces used with a shader that does not have interface parameters
Incorrect number of parameters for BindInterfaces
interface variables can only be initialized with concrete classes
Illegal initializer for a numeric variable
Can't create/set an invalid shader. Make sure your shader is valid, and make sure you're not using asm shaders in SM4.0
Illegal initializer
Unrecognized token %s
Internal error in compiler
Shader model %s is not allowed in D3D10 techniques
There was an error compiling expression
Assignment %s: Non-array right-hand type expected
Assignment %s: Only literal right-hand side values are allowed in state blocks in Effects performance mode
Assignment %s: Left-hand side type does not match right-hand side type
Assignment %s: Attempting to assign an incompatible inline shader
Assignment %s: Inline shader missing interface parameter bindings
Assignment %s: Only 0 and NULL are valid constants for an object assignment
Assignment %s: Dimensionality mismatch (LHS expects %d, RHS has %d)
Invalid assignment index (%u). Maximum allowed is %u.
TEXTURE assignments inside of samplers cannot be variable indexed
TEXTURE assignments inside of samplers cannot be expression indexed
Assignment %s: Expressions cannot be evaluated to produce objects, though they may be used to index into arrays of objects
Assignment %s: Objects left-hand sides cannot be assigned to expressions
Effect file is too large, try reducing the number of techniques or compiling without debug info
ID3D10Effect::ParseSODecl - Invalid output slot
ID3D10Effect::ParseSODecl - Non-digit '%c' in output slot
ID3D10Effect::ParseSODecl - invalid mask declaration '%s'
$SKIP
GOURAUD
PHONG
POINT
SRCCOLOR
INVSRCCOLOR
SRCALPHA
INVSRCALPHA
DESTALPHA
INVDESTALPHA
DESTCOLOR
INVDESTCOLOR
SRCALPHASAT
BOTHSRCALPHA
BOTHINVSRCALPHA
BLENDFACTOR
INVBLENDFACTOR
MIRRORONCE
LESSEQUAL
NOTEQUAL
GREATEREQUAL
INCRSAT
DECRSAT
LINEAR
MATERIAL
COLOR1
COLOR2
COORD0
COORD1
COORD2
COORD3
GREEN
ALPHA
QUADRATIC
CUBIC
QUINTIC
DISCRETE
CONTINUOUS
DISABLE
0WEIGHTS
1WEIGHTS
2WEIGHTS
3WEIGHTS
TWEENING
CLIPPLANE0
CLIPPLANE1
CLIPPLANE2
CLIPPLANE3
CLIPPLANE4
CLIPPLANE5
REVSUBTRACT
PASSTHRU
CAMERASPACENORMAL
CAMERASPACEPOSITION
CAMERASPACEREFLECTIONVECTOR
SPHEREMAP
SELECTARG1
SELECTARG2
MODULATE
MODULATE2X
MODULATE4X
ADDSIGNED
ADDSIGNED2X
ADDSMOOTH
BLENDDIFFUSEALPHA
BLENDTEXTUREALPHA
BLENDFACTORALPHA
BLENDTEXTUREALPHAPM
BLENDCURRENTALPHA
PREMODULATE
MODULATEALPHA_ADDCOLOR
MODULATECOLOR_ADDALPHA
MODULATEINVALPHA_ADDCOLOR
MODULATEINVCOLOR_ADDALPHA
BUMPENVMAP
BUMPENVMAPLUMINANCE
DOTPRODUCT3
MULTIPLYADD
SELECTMASK
CURRENT
TEXTURE
TFACTOR
CONSTANT
COMPLEMENT
ALPHAREPLICATE
PYRAMIDALQUAD
GAUSSIANQUAD
COUNT1
COUNT2
COUNT3
COUNT4
PROJECTED
DIRECTIONAL
XYZRHW
XYZB1
XYZB2
XYZB3
XYZB4
XYZB5
LASTBETA_UBYTE4
LASTBETA_D3DCOLOR
TEXCOORDSIZE1_0
TEXCOORDSIZE1_1
TEXCOORDSIZE1_2
TEXCOORDSIZE1_3
TEXCOORDSIZE1_4
TEXCOORDSIZE1_5
TEXCOORDSIZE1_6
TEXCOORDSIZE1_7
TEXCOORDSIZE2_0
TEXCOORDSIZE2_1
TEXCOORDSIZE2_2
TEXCOORDSIZE2_3
TEXCOORDSIZE2_4
TEXCOORDSIZE2_5
TEXCOORDSIZE2_6
TEXCOORDSIZE2_7
TEXCOORDSIZE3_0
TEXCOORDSIZE3_1
TEXCOORDSIZE3_2
TEXCOORDSIZE3_3
TEXCOORDSIZE3_4
TEXCOORDSIZE3_5
TEXCOORDSIZE3_6
TEXCOORDSIZE3_7
TEXCOORDSIZE4_0
TEXCOORDSIZE4_1
TEXCOORDSIZE4_2
TEXCOORDSIZE4_3
TEXCOORDSIZE4_4
TEXCOORDSIZE4_5
TEXCOORDSIZE4_6
TEXCOORDSIZE4_7
ZENABLE
FILLMODE
SHADEMODE
ZWRITEENABLE
ALPHATESTENABLE
LASTPIXEL
SRCBLEND
DESTBLEND
CULLMODE
ZFUNC
ALPHAREF
ALPHAFUNC
DITHERENABLE
ALPHABLENDENABLE
FOGENABLE
SPECULARENABLE
FOGCOLOR
FOGTABLEMODE
FOGSTART
FOGEND
FOGDENSITY
RANGEFOGENABLE
STENCILENABLE
STENCILFAIL
STENCILZFAIL
STENCILPASS
STENCILFUNC
STENCILMASK
STENCILWRITEMASK
TEXTUREFACTOR
WRAP0
WRAP1
WRAP2
WRAP3
WRAP4
WRAP5
WRAP6
WRAP7
WRAP8
WRAP9
WRAP10
WRAP11
WRAP12
WRAP13
WRAP14
WRAP15
CLIPPING
LIGHTING
AMBIENT
FOGVERTEXMODE
COLORVERTEX
LOCALVIEWER
NORMALIZENORMALS
DIFFUSEMATERIALSOURCE
SPECULARMATERIALSOURCE
AMBIENTMATERIALSOURCE
EMISSIVEMATERIALSOURCE
VERTEXBLEND
CLIPPLANEENABLE
POINTSIZE
POINTSIZE_MIN
POINTSIZE_MAX
POINTSPRITEENABLE
POINTSCALEENABLE
POINTSCALE_A
POINTSCALE_B
POINTSCALE_C
MULTISAMPLEANTIALIAS
MULTISAMPLEMASK
PATCHEDGESTYLE
DEBUGMONITORTOKEN
INDEXEDVERTEXBLENDENABLE
COLORWRITEENABLE
TWEENFACTOR
BLENDOP
POSITIONDEGREE
NORMALDEGREE
SCISSORTESTENABLE
SLOPESCALEDEPTHBIAS
ANTIALIASEDLINEENABLE
MINTESSELLATIONLEVEL
MAXTESSELLATIONLEVEL
ADAPTIVETESS_X
ADAPTIVETESS_Y
ADAPTIVETESS_Z
ADAPTIVETESS_W
ENABLEADAPTIVETESSELLATION
TWOSIDEDSTENCILMODE
CCW_STENCILFAIL
CCW_STENCILZFAIL
CCW_STENCILPASS
CCW_STENCILFUNC
COLORWRITEENABLE1
COLORWRITEENABLE2
COLORWRITEENABLE3
SRGBWRITEENABLE
DEPTHBIAS
SEPARATEALPHABLENDENABLE
SRCBLENDALPHA
DESTBLENDALPHA
BLENDOPALPHA
COLOROP
COLORARG0
COLORARG1
COLORARG2
ALPHAOP
ALPHAARG0
ALPHAARG1
ALPHAARG2
RESULTARG
BUMPENVMAT00
BUMPENVMAT01
BUMPENVMAT10
BUMPENVMAT11
TEXCOORDINDEX
BUMPENVLSCALE
BUMPENVLOFFSET
TEXTURETRANSFORMFLAGS
PATCHSEGMENTS
PROJECTIONTRANSFORM
VIEWTRANSFORM
WORLDTRANSFORM
TEXTURETRANSFORM
MATERIALDIFFUSE
MATERIALAMBIENT
MATERIALSPECULAR
MATERIALEMISSIVE
MATERIALPOWER
LIGHTTYPE
LIGHTDIFFUSE
LIGHTSPECULAR
LIGHTAMBIENT
LIGHTPOSITION
LIGHTDIRECTION
LIGHTRANGE
LIGHTFALLOFF
LIGHTATTENUATION0
LIGHTATTENUATION1
LIGHTATTENUATION2
LIGHTTHETA
LIGHTPHI
LIGHTENABLE
VERTEXSHADER
PIXELSHADER
VERTEXSHADERCONSTANTF
VERTEXSHADERCONSTANTB
VERTEXSHADERCONSTANTI
VERTEXSHADERCONSTANT
VERTEXSHADERCONSTANT1
VERTEXSHADERCONSTANT2
VERTEXSHADERCONSTANT3
VERTEXSHADERCONSTANT4
PIXELSHADERCONSTANTF
PIXELSHADERCONSTANTB
PIXELSHADERCONSTANTI
PIXELSHADERCONSTANT
PIXELSHADERCONSTANT1
PIXELSHADERCONSTANT2
PIXELSHADERCONSTANT3
PIXELSHADERCONSTANT4
ADDRESSU
ADDRESSV
ADDRESSW
BORDERCOLOR
MAXANISOTROPY
SAMPLER
STATEBLOCK
$PRESHADER_VS
$PRESHADER_PS
ID3DXEffectCompiler: Unexpected template type
ID3DXEffectCompiler: Unexpected component type
ID3DXEffectCompiler: Unexpected node encountered when trying to determine type
ID3DXEffectCompiler: There was an error initializing parameter handles
ID3DXEffectCompiler: There was an error initializing parameter annotation handles
ID3DXEffectCompiler: There was an error initializing technique annotation handles
ID3DXEffectCompiler: There was an error initializing pass annotation handles
ID3DXEffectCompiler: There was an error initializing the compiler
ID3DXEffectCompiler: There was a problem getting variable type
ID3DXEffectCompiler: Error initializing variable type
ID3DXEffectCompiler: There was a problem in the parse tree
ID3DXEffectCompiler: There was a problem getting annotations
ID3DXEffectCompiler: Only numeric types and strings are allowed as annotations
ID3DXEffectCompiler: Error initializing annotation type
ID3DXEffectCompiler: Only numeric types are allowed inside structures
ID3DXEffectCompiler: Arrays must be either numeric, structure, string or shader
ID3DXEffectCompiler: Only pass allowed within a technique
ID3DXEffectCompiler: Unrecognized state '%s'
ID3DXEffectCompiler: State '%s' is not indexed
ID3DXEffectCompiler: Max index for effect state '%s' is %d
ID3DXEffectCompiler: Index is required for state '%s'
ID3DXEffectCompiler: DMAPOFFSET sampler state can only be used with D3DDMAPSAMPLER (i.e. sampler index 256)
ID3DXEffectCompiler: Invalid sampler index %d
ID3DXEffectCompiler: Invalid integer expression assignment
ID3DXEffectCompiler: Unsupported sampler or stateblock expression (static usage not supported).
ID3DXEffectCompiler: Can't set shader'
ID3DXEffectCompiler: Geometry shader can only be set in fx_4_0 or higher.'
ID3DXEffectCompiler: Internal Error: Unexpected state.
ID3DXEffectCompiler: Initializer list elements cannot be complex expressions or variables
ID3DXEffectCompiler: Unexpected error
ID3DXEffectCompiler: Error in type checking
ID3DXEffectCompiler: State '%s' does not accept '%s' as a value
ID3DXEffectCompiler: State '%s' accepts only dwords and ids
ID3DXEffectCompiler: FVFs must not evaluate to NULL
ID3DXEffectCompiler: Dword expressions for state '%s' must evaluate to NULL
ID3DXEffectCompiler: State '%s' was assigned an unsupported value
ID3DXEffectCompiler: Error initializing assignment type
ID3DXEffectCompiler: Internal error initializing assignment - missing type case
ID3DXEffectCompiler: Assignment cannot be a structure
ID3DXEffectCompiler: Initializers must be numeric scalars
ID3DXEffectCompiler: State '%s' cannot be assigned an array or structure
ID3DXEffectCompiler: State '%s' was not assigned a stateblock type
ID3DXEffectCompiler: State '%s' was not assigned a sampler type
ID3DXEffectCompiler: State '%s' was not assigned a texture type
ID3DXEffectCompiler: State '%s' was assigned an incompatible type
ID3DXEffectCompiler: State '%s' must be assigned a numeric scalar or a 4-float vector
ID3DXEffectCompiler: State '%s' must be assigned a scalar
ID3DXEffectCompiler: State '%s' must be assigned a 3-vector or a 4-vector or a uint scalar
ID3DXEffectCompiler: State '%s' must be assigned a numeric value
ID3DXEffectCompiler: Unexpected value type of state '%s' (internal error)
ID3DXEffectCompiler::CompileEffect: There was an error compiling HLL shader parameter
ID3DXEffectCompiler::CompileEffect: Unrecognized value type
ID3DXEffectCompiler::CompileEffect: Only 1-d shader arrays allowed
ID3DXEffectCompiler::CompileEffect: Shader arrays must be a previously defined parameter
ID3DXEffectCompiler::CompileEffect: Shader arrays index was not float or int
ID3DXEffectCompiler::CompileEffect: Shader arrays index %d out of bounds [0, %d]
ID3DXEffectCompiler::CompileEffect: There was an error compiling expression
ID3DXEffectCompiler::CompileEffect: Could not compile expression containing shader array
ID3DXEffectCompiler: There were no techniques
ID3DXEffectCompiler: This sampler is used with a DX10-style texture intrinsic. This is not implemented in this version of the compiler.
ID3DXEffectCompiler: Compilation failed
Output variable 
%s%s contains a system-interpreted value (%s) which must be written in every execution path of the shader.  Unconditional initialization may help. <| A%u (B%u)
%s%s contains a system-interpreted value (%s) which should be written in every execution path of the shader <| A%u (B%u)
emitting a system-interpreted value which is not written in every execution path of the shader. Unconditional initialization may help. <| A%u (B%u)
emitting a system-interpreted value which may not be written in every execution path of the shader <| A%u (B%u)
Inconsistent semantic definition: %s and %s
Duplicate system value semantic definition: %s and %s
Duplicate non-system value semantic definition: %s and %s
Reading uninitialized value
maximum number of samplers exceeded. %s target can have a maximum of %u samplers
%s target does not support texture lookups
The maximum number of constant buffer slots is exceeded for a library (slot index=%u, max slots=%u)
cbuffer register (b%u) used more than once
The maximum number of sampler slots is exceeded for a library (slot index=%u, max slots=%u)
sampler register (s%u) used more than once
The maximum number of texture slots is exceeded for a library (slot index=%u, max slots=%u)
texture register (t%u) used more than once
internal error: output register missing semantic
internal error: input register missing semantic
internal error: emitting a denorm
NaN and infinity literals not allowed by shader model
maximum number of inputs exceeded
overlapping output semantics
internal error: statistics append failed, byte count (%d) too large?
internal error: non ordinal input/output found
maximum cbuffer exceeded. target has %u slots, manual bind to slot %u failed
cbuffer bank %u used more than once
maximum cbuffer exceeded. target has %u slots
boolean
constant
iterator
 - Try reducing number of constant branches, take bools out of structs/arrays or move them to the start of the struct
 - Try reducing number of constants referenced
 - Try reducing number of loops, take loop counters out of structs/arrays or move them to the start of the struct
 - note that the target doesn't support texture sampling intrinsics
 - note that the target doesn't support textures
 - note that the target doesn't support UAVs
maximum %s %s register index (%u) exceeded - note that the minimum index is %u%s
maximum %s %s register index (%u) exceeded%s
invalid register semantic '%s', or variable must be bound to multiple register banks (%c register binding required)
%s registers live in the same name space as outputs, so they must be bound to at least %c%u, manual bind to slot %s failed
maximum %s register index exceeded, target has %d slots, manual bind to slot %s failed
overlapping register semantics not yet implemented '%c%u'
Using sampler arrays with texture objects on DX9 targets is not yet implemented.
Cannot use texture arrays on DX9 targets with multiple samplers.
Invalid %s semantics - POSITIONT0
invalid %s %s
, or '%s'
one of '%s'
, '%s'
Sample interpolation usage unsupported on %s
nointerpolation usage unsupported on %s
noperspective usage unsupported on %s
SV_SampleIndex isn't supported on %s
Maximum semantic index (%d) exceeded: %d
%s semantic '%s' cannot be centroid
%s semantic '%s' has been deprecated; use '%s%d' instead
invalid %s semantic '%s': Legal indices are in [%d,%d]
invalid type used for '%s' %s semantics
integral
invalid type used for '%s' %s semantics, must be %s
internal error: result violated port constraints
internal error: non-vectorized pool violated port constraints
relative address references too deep
internal error: multiple write to same output
ApplyPreModTargetReplacements
Replace MAD 10+
Replace MAD Excl 9
Replace MAD Int 9
cannot match lerp because lerp factor is not _sat'd
internal error: instruction missing outputs
internal error: IF with size greater then 1 found
cannot clip from a swizzled vector
clip must be performed from a float3 vector for ps_1_x models
clip must be performed from a float4 vector for ps_2_0 models
internal error: unexpected input register type
clip cannot be performed from a constant or literal
constant table info exceeds maximum comment size
%s+%s
maximum temp register index exceeded
maximum address register index exceeded
maximum predicate register index exceeded
internal error: unexpected output register type
internal error: overlapping output writes
maximum input register index exceeded
maximum constant register index exceeded - Try reducing number of constants referenced
maximum bool register index exceeded
maximum sampler register index exceeded
maximum loop register index exceeded
target does not support relative addressing
tessfactor semantic out of order
conflicting quad/tri/isoline tessfactor semantic
tessfactor semantics must be in the same component
SV_Coverage and SV_InnerCoverage are mutually exclusive
%s output limit (%d) exceeded, shader uses %d outputs.
%s input limit (%d) exceeded, shader uses %d inputs.
internal error: no semantic found on i/o argument
internal error: output found with no semantic
semantic '%s' unsupported on %s
output %s%u used more than once
integer inputs unsupported on %s
Not all elements of SV_Position were written
%s tessfactor %ss missing
Indexable function parameters are unsupported (parameter: %u, "%s".
Unsupported function parameter ("%s") type.
Unsupported function parameter "%s" type.
Clip planes cannot be addressed in %s
Clip planes must be non-literal constants with identity swizzles in %s
Unsized MSAA textures aren't supported on this target
TextureCubeArray textures aren't supported on this target
texture2DMS cannot be more than %u samples
Texture1D types are unsupported on %s
resource '%s' binding conflicts with template shader
resource '%s' binding not present in template shader
texture mismatch: texture used inconsistently, can only use one DX9-style texture intrinsic on individual samplers or sampler arrays
$Element
RWStructuredBuffers may increment or decrement their counters, but not both.
The array element count of GetDimensions on TextureCubeArray objects is unavailable on %s
cannot sample from non-floating point texture formats.
sampler mismatch: sampler used inconsistently
`UUe?
`OTHER
`TEMP
`PACKED
<%s return value>
hlslFlags
hlslTarget
hlslEntry
hlslDefines
internal error: failed to write debug data to pdb stream
internal error: failed to add section contribution
internal warning: PDB Error string is "%S"
internal error: failed to close debug info
internal error: failed to close PDB
internal error: failed to open PDB for writing in stream
internal error: failed to create debug info in PDB
internal error: failed to add code section to debug info
internal error: failed to add module to debug info
internal error: failed to create type info in PDB
internal error: failed to create inline type info in PDB
internal error: failed to create source file store in PDB
internal error: failed to close source file store in PDB
internal error: failed to close module in debug info
internal error: failed to commit type info in PDB
internal error: failed to commit inline type info in PDB
internal error: failed to add section header to debug info
internal error: failed to append section header to pdb
internal error: failed to close section header in debug info
internal error: failed to close debug info in PDB
internal error: failed to commit PDB
internal error: PDB data too large
internal error: PDB stream truncated
internal error: failed to close source file store
internal error: failed to close type info
internal error: pdb append failed
fxl_4_0
too many arguments to target TX
too many outputs to target TX
clip not supported in texture shaders
invalid reference to input semantic '%s%d'
invalid reference to output semantic '%s%d'
0123456789abcdef
SV_ViewportArrayIndex
Color
Failed to log error, redirecting to debug output:
hs_5_0 patch constant
hs_5_0 control point
Shader uses too many (%u) indexable literal values, the maximum allowed is %u, consider using less constant arrays
By default, unbounded size descriptor tables are disabled to support frame captures in graphics tools. Use of unbounded (or large) size descriptor tables can produce unusually large and potentially unusable frame captures in graphics tools.  Please specify a reasonably small upper bound on table size.  If that isn?t an option, unbounded size descriptor tables can be enabled using the compiler using switch: /enable_unbounded_descriptor_tables
Overflow of resource binding range
%s binding ranges overlap for range %s[%d:%d]
Sum of temp registers and indexable temp registers exceeds limit of %u
sum of temp registers and indexable temp registers times %u threads exceeds the recommended total %u.  Performance may be reduced
The total amount of group shared memory (%u bytes) exceeds the %s limit of %d bytes
The maximum number of UAV slots is exceeded for a library (slot index=%u, max slots=%u)
UAV register (u%u) used more than once
Debug instructions are unsupported in shader libraries
internal error gathering debug file information
Maximum %s control point count (%u) exceeded (%u).
internal error: debug info append failed, byte count (%d) too large?
internal error: RootSignature append failed, byte count (%d) too large?
unknown error
RootSignature verification failed: %s
RootSignature creation failed: %s
internal error: scalar instruction with too many inputs
internal error: expected binary instruction for scalar RHS
maximum number of interface pointers exceeded (%s max is %u)
interface calls cannot be indexed with varying values
%s can only emit to streams 0-%u
%s can only emit to 1 stream
%s does not support stream out
when multiple GS output streams are used they must be pointlists
Shaders compiled for %s can only have a single group shared data item
Group shared data for %s must have a count of elements (%u) equal to the number of threads in the thread group (%u)
Group shared data for %s must have an element size (%u) of at most %u bytes when compiling for %u theads
Group shared data for %s must be an array of elements
internal error: modifier used on address
internal error: constant buffer used as address
internal error: binary instruction expected
internal error: vectorized instruction too large
internal error: expected scalar RHS for instruction
%s does not support structured buffers
structured buffer element size must be a multiple of %u bytes in %s (actual size %u bytes)
structured buffer elements cannot be larger than %u bytes in %s (actual size %u bytes)
offset texture instructions must take offset which can resolve to integer literal in the range -8 to 7
MSAA Sample Index must be in the range 0 to %u
MSAA Sample Index must be a literal
Sample Bias value is limited to the range [-16.00, 15.99], using %f instead of %f
reading uninitialized value
%s does not support UAVs
%s does not support Append/Consume buffers
RasterizerOrdered objects are only allowed in 5.0+ pixel shaders
%s does not support typed UAVs
idiv currently not supported (instruction deprecated). For now, try using unsigned int types for div instead
typed UAV stores must write all declared components.
stores to group shared memory for %s targets must be indexed by an SV_GroupIndex only
%s snap offset must be in the range -8 to 7
cannot map expression to %s instruction set
internal error: failed to emit instruction
SV_Position cannot be constinterp
SV_Coverage input not supported on %s
SV_Coverage not supported on %s
SV_InnerCoverage input not supported on %s
invalid semantic '%s' on pixel shader output
BlendWeight
BlendIndices
Normal
PSize
Texcoord
Tangent
Binormal
PositionT
Depth
Diffuse
Specular
Tessfactor
Psize
internal error: no profile exists for this shader version
PSIZE must be a scalar
vertex shader must minimally write all four components of POSITION
DEPTH must be a scalar
pixel shader must minimally write all four components of COLOR0
COLOR%d must be a four-component vector
COLOR outputs must be contiguous from COLOR0 to COLORn
cannot map expression to vertex shader instruction set
cannot map expression to pixel shader instruction set
Unsupported texture type for %s
internal error: unexpected Alias on texture declaration
relative addressing not supported in vs_1_0 instruction set
fxl_2_0
internal error: gradient instruction sent to preshader
internal error: no profile exists for this pixel shader version
SV_Target0
COLOR0
pixel shader must minimally write all four components of %s
%s%d must be a four-component vector
SV_Target outputs must be contiguous from SV_Target0 to SV_TargetN
relative addressing not allowed for pixel shaders
texlod not supported on this target
Shader model %s doesn't allow reading from position semantics.
Invalid %s input semantic '%s'.
sample interpolation usage unsupported on %s
Exceeded maximum number or index of output registers. Max allowed for this target is %d.
internal error: invalid swizzle found
SV_Color
internal error: no profile exists for this vertex shader version
FOG must be a scalar
vertex shader must minimally write all four components of SV_Position
internal error: DST test failure
internal error: no storage type for block output
expressions returning objects in an array or struct not yet implemented
internal error: expression expected
compile expression must specify a valid shader model
compile expression does not refer to a compilable function.  API calls such as ConstructGSWithSO and BindInterfaces can not be used in arguments to CompileShader
non-trivial object expressions not yet implemented
asm blocks have not yet been implemented
'%s': entrypoint not found
Library entry points cannot be overloaded ('%s')
overloaded function not found
a library must have at least one exported function
internal error: blob size mismatch between level9 and d3d10 shader
internal error: blob mismatch between level9 and d3d10 shader
internal error: blob content mismatch between level9 and d3d10 shader
Software\Microsoft\Direct3D\Direct3D12
ForceDebuggable
ForceShaderSkipOptimization
Flags parameter is invalid
D3DCOMPILER_FORCE_PREFER_FLOW
Flag specified was exclusively a parse flag and not a compile flag
Flags specified both compatibility and strict mode. These are mutually exclusive
unrecognized compiler target '%s'
ppShader pointer is invalid
Only 4_x targets supported on this compiler.
Only 3_x and earlier targets are supported on this compiler.
ps_1_x is no longer supported; use /Gec in fxc to automatically upgrade to ps_2_0
ps_1_x is no longer supported; using ps_2_0
partial precision is not supported for target %s. Min-precision types may offer similar functionality.
Alternately, fxc's /LD option allows use of the old compiler DLL
D3DCompile: backwards compatibility mode (/Gec) option is not supported for SM5_1+ targets
D3DCompile: resources_may_alias option is only valid for cs_5_0+ targets
Failed compiling 10_level_9 VS version of the library function '%s'.
D3DCompile: Gfa option cannot be used in SM_5_1+ unless all_resources_bound flag is specified
out of memory during compilation
Failed compiling 10_level_9 PS version of the library function '%s'.
internal error: compilation aborted unexpectedly
cinstanceid
%s does not support groupshared, groupshared ignored
'%s': variable declared but not defined
'%s': %s does not support doubles as a storage type
'%s': global variables cannot use the 'half' type in %s. To treat this variable as a float, use the backwards compatibility flag.
'%s': %s does not support 64-bit integers
'%s': %s does not support 8-bit or 16-bit integers
'%s': %s does not support minimum-precision data
%s does not support 16-bit uint minimum-precision data
groupshared variables cannot contain resources such as textures, samplers or UAVs
invalid packoffset location '%s'
stream object '%s' cannot be declared in the global scope
cannot mix packoffset elements with nonpackoffset elements in a cbuffer
branch
forcecase
flatten
unroll
fastopt
allow_uav_condition
a uint specifying the number of iterations to unroll
Texture sample will be considered dependent since texcoord was not declared as at least float%d
internal error: unrecognized statement
expressions with side effects are illegal as attribute parameters
DX9-style intrinsics are disabled when not in dx9 compatibility mode.
cannot match attribute %s, non-uint parameters found
non-literal parameter(s) found for attribute %s
'%s(%s)' attribute expected, where '%s' is %s
attribute %s expects the %s parameter to be a %s
expected %s parameter to be %s, got '%s'
'%s(%s)' attribute expected, where '%s' are %s
can't match attribute %s, %d or 0 parameters expected, found %d
cannot match attribute %s, parameter %i is expected to be of type %s%c
can't match attribute %s, %d parameter(s) expected, found %d
unknown attribute %s, or attribute invalid for this statement
RootSignature
duplicate attribute %s
unknown attribute %s, or attribute invalid for this statement, valid attributes are: %s
doubles cannot be used as shader inputs or outputs. If you need to pass a double between shader stages you must pass it as two uints and use asuint and asdouble to convert between forms
Cannot use %s attribute without specifying a 4-component SV_Position output
structure being emitted has elements with no semantic defined
stream parameter must come from a literal expression
%s does not support thread synchronization operations
%s does not support synchronization operations
%s does not support interlocked operations
signed/unsigned mismatch between destination and value, unsigned assumed
%s only supports interlocked operations on scalar int or uint data
interlocked targets must be groupshared or UAV elements
attribute evaluation can only be done on values taken directly from inputs
%s does not support pull-model attribute evaluation
'%s': undefined variable
%s does not support pull-model evaluation of position
internal error: invalid access of unbound variable
invalid variable reference in static variable initializer.  Locals cannot be used to initialize static variables
out of memory
internal error: unrecognized value
unexpected error in GetTypeArgFlags
all template type components must have the same type
invalid register specification, expected 'b' or 'c' binding
invalid register specification, expected 'b' binding
User defined %s buffer slots cannot be target specific
invalid register specification, expected 't' binding
Buffers may only be bound to one constant offset.
Buffers may only be bound to one slot.
SV_PrimitiveId is an invalid input semantic for geometry shader primitives, it must be its own parameter.
Cannot declare streams as an input for geometry shader primitives, it must be its own parameter.
for better compilation results, consider re-enabling rule "%s"
SV_GSInstanceID is an invalid input semantic for geometry shader primitives, it must be its own parameter.
'#pragma def' is no longer supported on DX10+ and 10level9 targets.  Use compatibility mode to allow compilation for now.
for better compilation results, consider re-enabling rule 0x%08x
warning location reached from this location
error location reached from this location
, forcing loop to unroll
ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT
addressU
ALLOW_STREAM_OUTPUT
addressW
addressV
borderColor
COMPARISON_NEVER
comparisonFunc
COMPARISON_EQUAL
COMPARISON_LESS
COMPARISON_GREATER
COMPARISON_LESS_EQUAL
COMPARISON_GREATER_EQUAL
COMPARISON_NOT_EQUAL
DescriptorTable
COMPARISON_ALWAYS
DENY_VERTEX_SHADER_ROOT_ACCESS
DESCRIPTOR_RANGE_OFFSET_APPEND
DENY_DOMAIN_SHADER_ROOT_ACCESS
DENY_HULL_SHADER_ROOT_ACCESS
DENY_PIXEL_SHADER_ROOT_ACCESS
DENY_GEOMETRY_SHADER_ROOT_ACCESS
DESCRIPTORS_STATIC_KEEPING_BUFFER_BOUNDS_CHECKS
DESCRIPTORS_VOLATILE
DATA_STATIC
DATA_VOLATILE
flags
DATA_STATIC_WHILE_SET_AT_EXECUTE
FILTER_MIN_MAG_MIP_POINT
filter
FILTER_MIN_POINT_MAG_LINEAR_MIP_POINT
FILTER_MIN_MAG_POINT_MIP_LINEAR
FILTER_MIN_LINEAR_MAG_MIP_POINT
FILTER_MIN_POINT_MAG_MIP_LINEAR
FILTER_MIN_MAG_LINEAR_MIP_POINT
FILTER_MIN_LINEAR_MAG_POINT_MIP_LINEAR
FILTER_ANISOTROPIC
FILTER_MIN_MAG_MIP_LINEAR
FILTER_COMPARISON_MIN_MAG_POINT_MIP_LINEAR
FILTER_COMPARISON_MIN_MAG_MIP_POINT
FILTER_COMPARISON_MIN_POINT_MAG_MIP_LINEAR
FILTER_COMPARISON_MIN_POINT_MAG_LINEAR_MIP_POINT
FILTER_COMPARISON_MIN_LINEAR_MAG_POINT_MIP_LINEAR
FILTER_COMPARISON_MIN_LINEAR_MAG_MIP_POINT
FILTER_COMPARISON_MIN_MAG_MIP_LINEAR
FILTER_COMPARISON_MIN_MAG_LINEAR_MIP_POINT
FILTER_MINIMUM_MIN_MAG_MIP_POINT
FILTER_COMPARISON_ANISOTROPIC
FILTER_MINIMUM_MIN_POINT_MAG_LINEAR_MIP_POINT
FILTER_MINIMUM_MIN_MAG_POINT_MIP_LINEAR
FILTER_MINIMUM_MIN_LINEAR_MAG_MIP_POINT
FILTER_MINIMUM_MIN_POINT_MAG_MIP_LINEAR
FILTER_MINIMUM_MIN_MAG_LINEAR_MIP_POINT
FILTER_MINIMUM_MIN_LINEAR_MAG_POINT_MIP_LINEAR
FILTER_MINIMUM_ANISOTROPIC
FILTER_MINIMUM_MIN_MAG_MIP_LINEAR
FILTER_MAXIMUM_MIN_MAG_POINT_MIP_LINEAR
FILTER_MAXIMUM_MIN_MAG_MIP_POINT
FILTER_MAXIMUM_MIN_POINT_MAG_MIP_LINEAR
FILTER_MAXIMUM_MIN_POINT_MAG_LINEAR_MIP_POINT
FILTER_MAXIMUM_MIN_LINEAR_MAG_POINT_MIP_LINEAR
FILTER_MAXIMUM_MIN_LINEAR_MAG_MIP_POINT
FILTER_MAXIMUM_MIN_MAG_MIP_LINEAR
FILTER_MAXIMUM_MIN_MAG_LINEAR_MIP_POINT
maxAnisotropy
FILTER_MAXIMUM_ANISOTROPIC
minLOD
mipLODBias
numDescriptors
maxLOD
RootFlags
num32BitConstants
StaticSampler
RootConstants
SHADER_VISIBILITY_VERTEX
SHADER_VISIBILITY_ALL
SHADER_VISIBILITY_DOMAIN
SHADER_VISIBILITY_HULL
SHADER_VISIBILITY_PIXEL
SHADER_VISIBILITY_GEOMETRY
STATIC_BORDER_COLOR_OPAQUE_BLACK
STATIC_BORDER_COLOR_TRANSPARENT_BLACK
TEXTURE_ADDRESS_WRAP
STATIC_BORDER_COLOR_OPAQUE_WHITE
TEXTURE_ADDRESS_CLAMP
TEXTURE_ADDRESS_MIRROR
TEXTURE_ADDRESS_MIRROR_ONCE
TEXTURE_ADDRESS_BORDER
Unexpected token '%s'
visibility
Unexpected token '%s' when parsing root signature
RootFlags cannot be specified more than once
Root signature flag values can only be 0 or flag enum values, found: '%s'
Expected ',', found: '%s'
cbuffer register b#
Expected a root signature flag value, found: '%s'
Constant buffer register b# must be defined for each RootConstants
num32BitConstants must be defined for each RootConstants
shader register must be defined for each CBV/SRV/UAV
shader register
Incorrect register type '%s' in CBV (expected b#)
Expected a register token (CBV, SRV, UAV, Sampler), found: '%s'
Incorrect register type '%s' in UAV (expected u#)
Incorrect register type '%s' in SRV (expected t#)
Root descriptor flags cannot be specified for root_sig_1_0
Incorrect register type '%s' in Sampler/StaticSampler (expected s#)
Expected a root descriptor flag value, found: '%s'
Root descriptor flag values can only be 0 or flag enum values, found: '%s'
Descriptor range flag values can only be 0 or flag enum values, found: '%s'
Descriptor range flags cannot be specified for root_sig_1_0
Unexpected visibility value: '%s'.
Expected a descriptor range flag value, found: '%s'
Sampler register s# must be defined for each static sampler
sampler register s#
Unexpected texture address mode value: '%s'.
Unexpected filter value: '%s'.
Parameter '%s' can be specified only once
maxvertexcount
MaxVertexCount
the maximum number of vertices emitted by this shader
the number of instances of this shader to execute simultaneously
instance
X,Y,Z
numthreads
patchconstantfunc
the dimensions of the thread group
the name of the patch constant value evaluation function
function name
domain type
domain
partitioning
one of "tri", "quad", or "isoline"
one of "integer", "pow2", "fractional_even", or "fractional_odd"
partitioning mode
topology type
outputtopology
outputcontrolpoints
one of "point", "line", "triangle_cw", or "triangle_ccw"
maxtessfactor
the number of control points to emit
the maximum tessellation factor to allow
limit
c1, c2, c3, c4, c5, c6
earlydepthstencil
root signature
the clip planes (up to 6) to use
isoline
fractional_even
integer
fractional_odd
triangle_ccw
'%s': input parameter '%s' missing semantics, expected %s
triangle_cw
'%s': stream input parameter '%s' can only be used in geometry shaders
'%s': stream input parameter '%s' must be an inout parameter
'%s': interface input parameters not yet implemented for hull shaders, use a global interface instead
'%s': input parameter '%s' cannot have a geometry specifier
'%s': input parameter '%s' conflicts with geometry specifier of previous input parameters
'%s': Patch constant function must use the same input control point type declared in the control point phase.
'%s': may only have one InputPatch parameter
'%s': Patch constant function must use the same output control point type returned from the control point phase.
'%s': may only have one OutputPatch parameter
'%s': stream input parameter '%s' must be an inout parameter 
'%s': Patch constant function's output patch input should have %d elements, but has %d.
'%s': OutputPatch inputs can only be used in the domain shaders and a hull shader's patch constant function
'%s': InputPatch inputs can only be used in hull and geometry (5_0+) shaders
'%s': input parameter '%s' missing semantics
'%s': input parameter '%s' must have a geometry specifier
'%s': no input primitive specified, if your shader doesn't require inputs, then define an empty struct and give it the proper primitive type.
'%s': input parameter '%s' patch size must be in the range [1,32]
'%s': interfaces can only be inputs
internal error: unrecognized geometry shader input primitive type
'%s': function return value missing semantics
'%s': %s only allows one depth output
'%s': output parameters not yet implemented for control point shaders
'%s': output parameter '%s' missing semantics
'%s': stream output parameter '%s' must be an inout parameter 
'%s': Compute shaders can't return values, outputs must be written in writable resources (UAVs).
'%s': Geometry shaders can't return values, outputs must be written to streams.
'%s': stream output parameter '%s' can only be used in geometry shaders
'%s': output parameter '%s' not completely initialized
'%s': Top-level return value is not completely initialized
'%s': top-level interface arguments cannot be 'out'
'%s': Top-level output parameter '%s' not completely initialized
'%s' must have a max vertex count
'%s': %s semantic has no special meaning on 10level9 targets
%s does not allow instancing
'%s' must have a max vertex count greater then 0
%s only allows up to %u instances
GS instance count must be at least 1
the product of the arguments of %s(%u,%u,%u) must be less than or equal to %u
the product of the arguments of %s(%u,%u,%u) must be at least %u
'%s': line output topologies are only available with isoline domains
the final dimension specified (%u) for %s must be less than or equal to %u
'%s' max tesselation factor must be in the range [1,64]
'%s': triangle output topologies are not available with isoline domains
Indexed expressions are illegal as attribute parameters
Clip plane attribute parameters must be non-literal constants
RootSignature is not allowed in HS patch constant function
RootSignature is allowed only for 5.0+ targets
'%s': recursive functions not allowed in %s
RootSignature attribute parameter must be a string
'%s': When defining a pass-through control-point shader, the number of output control points must be zero or must match the input patch size.
'%s': When defining a pass-through control-point shader,you must declare an InputPatch object.
internal error: unassociated return
'%s': Not all control paths return a value
abstract interfaces not supported on %s
'%s': global structs and classes cannot be changed
%s does not support doubles
internal error: result register invalid
%s does not support minimum-precision data
%s does not support 8-bit or 16-bit integers
cannot cast the LHS of an assignment to an indexable object, consider using asuint, asfloat, or asdouble on the RHS
cannot use casts on l-values
internal error: l-value expected
in %s uints can only be used with known-positive values, use int if possible
internal error: addressing inconsistent pool
internal error: inconsistent addressing
internal error: invalid sequence/cast expression
internal error: inconsistent derivative writer
both sides of the && operator are always evaluated, side effect on '%s' will not be conditional
Bitwise operations not supported on target %s.
both sides of the || operator are always evaluated, side effect on '%s' will not be conditional
internal error: AND operator inputs not bool
%s emulates A / B with A * reciprocal(B). If the reciprocal of B is not representable in your min-precision type the result may not be mathematically correct.
internal error: OR operater inputs not bool
.sample can only be used in a two-element indexing expression such as .sample[sample][element]
.mips can only be used in a two-element indexing expression such as .mips[mip][element]
internal error: unrecognized expression
both sides of the ?: operator are always evaluated, side effect on '%s' will not be conditional
Output value '%s' is not completely initialized
Derivatives of indexed variables are not yet implemented.
multiply
negate
modulo
divide
internal error: chain register invalid
signed integer division is not supported on minimum-precision types. Cast to int to use 32-bit division.
%s does not support double-precision floating-point
signed integer remainder is not supported on minimum-precision types. Cast to int to use 32-bit division.
integer divides may be much slower, try using uints if possible.
this operation cannot be used directly on resources containing doubles.
integer modulus may be much slower, try using uints if possible.
internal error: operand type mismatch
internal error: argument missing context <| A%u (B%u)
%s not supported on the given type
%s cannot be used with doubles, cast to float first
proto
pdr_t
pdr_ts
pdr_tb
pdr_sc
pdr_s
pdr_?
pdr_m
pdr_ut
pdr_robj
pdr_us
pdr_ub
array dimension for %s must be %i
input types for geometry shader must be arrays
Patch semantics must live in the enclosed type, outer semantic ignored.
GS Input
register %s not valid
textures
%s does not allow writable textures, samplers or UAVs to be members of compound types with interface inheritance
%s does not allow textures or samplers to be members of compound types
resources such as textures, samplers or UAVs cannot contain other resources
semantics in type overridden by variable/function or enclosing type
SV_ClipDistance semantics cannot be used when using the clipplanes attribute
internal error: unknown node
Duplicated input semantics can't change type, size, or layout ('%s').
SV_InstanceID semantic cannot be used with 10Level9 targets
globallycoherent cannot be used with append/consume buffers
globallycoherent can only be used with Unordered Access View buffers
typed UAV loads are only allowed for single-component 32-bit element types
%s does not support indexing resources
race condition writing to shared resource detected, note that threads will be writing the same value, but performance may be diminished due to contention.
Interface-reachable members containing UAVs or group shared variables are not yet implemented
race condition writing to shared resource detected, consider making this write conditional.
race condition writing to shared memory detected, note that threads will be writing the same value, but performance may be diminished due to contention.
inner array index within group shared element must be a literal expression for %s
race condition writing to shared memory detected, consider making this write conditional.
index for an array of complex types containing doubles must be a literal expression
array reference cannot be used as an l-value; not natively addressable
Resource being indexed is uninitialized.
%s array index must be a literal expression
element type of texture too large. Cannot exceed 4 components
Resources being indexed cannot come from conditional expressions, they must come from literal expressions.
Append/Consume not compatible with buffer type
IncrementCounter/DecrementCounter are only valid on RWStructuredBuffer objects
can't flatten with flow control when variable is bound to b register
case ordinal too large for floating point representation
can't emit if statement with both gradients and program flow control
can't use flow control on this profile
if statement was flattened due to nesting limits but it contains side effects and can't be flattened
can't flatten if statements that contain side effects
can't flatten if statements that contain out of bounds array accesses
internal error: flattened side effect
can't use branch and flatten attributes together
can't force branch with gradients on non-inputs
non-empty case statements must have break or return
error, duplicate case %u
error, duplicate default in switch statement
Too many nested flow control constructs
can't use branch, flatten, call  or case attributes together
can't use call or forcecase attributes on switches in %s programs
Fall-throughs in switch statements are not allowed.
flow control depth too deep to honor call or forcecase attribute
can't use fastopt and unroll attributes together
can't use loop and unroll attributes together
literal loop terminated early due to out of bounds array access
can't unroll loops marked with loop attribute
loop only executes for %d iteration(s), forcing loop to unroll
loop only executes for %d iteration(s), consider removing [loop]
can't use gradient instructions in loops with break
cannot map loop to shader target, target does not support breaks
loop doesn't seem to do anything, consider removing [loop]
loop executes for more than %d iterations (maximum for this shader target), forcing loop to unroll
infinite loop detected - loop writes no values
loop doesn't seem to do anything, forcing loop to unroll
gradient instruction used in a loop with varying iteration, attempting to unroll the loop
loop will not exit early, try to make sure the loop condition as tight as possible
texture access must have literal offset and multisample index
gradient instruction used in a loop with varying iteration; partial derivatives may have undefined value
cannot unroll loop with an out-of-bounds array reference in the condition
loop simulation finished early, use /O1 or above for potentially better codegen
unable to unroll loop, loop does not appear to terminate in a timely manner (%d iterations)
forced to unroll loop, but unrolling failed.
break must be inside loop
unable to unroll loop, loop does not appear to terminate in a timely manner (%d iterations) or unrolled loop is too large, use the [unroll(n)] attribute to force an exact higher number
continue cannot be used in a switch
continue must be inside loop
%s does not support aborts
abs on unsigned values is not meaningful, ignoring
%s does not support messages
value cannot be infinity, isfinite() may not be necessary.  /Gis may force isfinite() to be performed
fma can only be used with double arguments
value cannot be NaN, isnan() may not be necessary.  /Gis may force isnan() to be performed
value cannot be infinity, isinf() may not be necessary.  /Gis may force isinf() to be performed
asfloat can only be used on floating point values on %s
%s is only valid in hull shaders
asint cannot be used on %s
asfloat cannot be used on min precision values
asuint cannot be used on %s
asint cannot be used on min precision values
asdouble can only be used on uint values on %s
asuint cannot be used on min precision values
source_mark is most useful in /Od builds.  Without /Od source_mark can be moved around in the final shader by optimizations.
asuint can only be used on double values on %s
tex1D will be considered dependent since texcoord was not declared as at least float2
Sampler parameter must come from a literal expression.
AddUint64 requires shader model 5 or higher
CheckAccessFullyMapped requires shader model 5 or higher
'NonUniformResourceIndex' requires shader model 5 or higher
AddUint64 can only be applied to uint2 and uint4 operands
return type of texture too large. Cannot exceed 4 components
intrinsic function '%s' is not yet implemented
pow(f, e) will not work for negative f, use abs(f) or conditionally handle negative values if you expect them
clip can only be used with 1 to 4 components in %s
Texture1D Load method for tiled resources requires shader model 5 or higher
%s does not support 16-bit float conversions
Texture1D SampleCmp method for tiled resources requires shader model 5 or higher
Texture1D Sample method for tiled resources requires shader model 5 or higher
Texture1D SampleLevel method for tiled resources requires shader model 5 or higher
Texture1D SampleCmpLevelZero method for tiled resources requires shader model 5 or higher
Texture2D Load method for tiled resources requires shader model 5 or higher
Texture1D SampleBias method for tiled resources requires shader model 5 or higher
Texture2D SampleCmp method for tiled resources requires shader model 5 or higher
Texture2D Sample method for tiled resources requires shader model 5 or higher
Texture2D SampleLevel method for tiled resources requires shader model 5 or higher
Texture2D SampleCmpLevelZero method for tiled resources requires shader model 5 or higher
Texture2D GatherRed method for tiled resources requires shader model 5 or higher
Texture2D SampleBias method for tiled resources requires shader model 5 or higher
Texture2D GatherBlue method for tiled resources requires shader model 5 or higher
Texture2D GatherGreen method for tiled resources requires shader model 5 or higher
Texture2D GatherCmpRed method for tiled resources requires shader model 5 or higher
Texture2D GatherAlpha method for tiled resources requires shader model 5 or higher
Texture2D GatherCmpBlue method for tiled resources requires shader model 5 or higher
Texture2D GatherCmpGreen method for tiled resources requires shader model 5 or higher
Texture3D Sampler method for tiled resources requires shader model 5 or higher
Texture2D GatherCmpAlpha method for tiled resources requires shader model 5 or higher
Texture3D SamplerLevel method for tiled resources requires shader model 5 or higher
Texture3D SamplerBias method for tiled resources requires shader model 5 or higher
TextureCube SampleCmp method for tiled resources requires shader model 5 or higher
TextureCube Sample method for tiled resources requires shader model 5 or higher
TextureCube SampleLevel method for tiled resources requires shader model 5 or higher
TextureCube SampleCmpLevelZero method for tiled resources requires shader model 5 or higher
TextureCube GatherRed method for tiled resources requires shader model 5 or higher
TextureCube SampleBias method for tiled resources requires shader model 5 or higher
TextureCube GatherBlue method for tiled resources requires shader model 5 or higher
TextureCube GatherGreen method for tiled resources requires shader model 5 or higher
TextureCube GatherCmpRed method for tiled resources requires shader model 5 or higher
TextureCube GatherAlpha method for tiled resources requires shader model 5 or higher
TextureCube GatherCmpBlue method for tiled resources requires shader model 5 or higher
TextureCube GatherCmpGreen method for tiled resources requires shader model 5 or higher
Texture1DArray Load method for tiled resources requires shader model 5 or higher
TextureCube GatherCmpAlpha method for tiled resources requires shader model 5 or higher
Texture1DArray SampleCmp method for tiled resources requires shader model 5 or higher
Texture1DArray Sample method for tiled resources requires shader model 5 or higher
Texture1DArray SampleLevel method for tiled resources requires shader model 5 or higher
Texture1DArray SampleCmpLevelZero method for tiled resources requires shader model 5 or higher
Texture2DArray Load method for tiled resources requires shader model 5 or higher
Texture1DArray SampleBias method for tiled resources requires shader model 5 or higher
Texture2DArray SampleCmp method for tiled resources requires shader model 5 or higher
Texture2DArray Sample method for tiled resources requires shader model 5 or higher
Texture2DArray SampleLevel method for tiled resources requires shader model 5 or higher
Texture2DArray SampleCmpLevelZero method for tiled resources requires shader model 5 or higher
Texture2DArray Gather method for tiled resources requires shader model 5 or higher
Texture2DArray SampleBias method for tiled resources requires shader model 5 or higher
Texture2DArray GatherBlue method for tiled resources requires shader model 5 or higher
Texture2DArray GatherGreen method for tiled resources requires shader model 5 or higher
Texture2DArray GatherCmpRed method for tiled resources requires shader model 5 or higher
Texture2DArray GatherAlpha method for tiled resources requires shader model 5 or higher
Texture2DArray GatherCmpBlue method for tiled resources requires shader model 5 or higher
Texture2DArray GatherCmpGreen method for tiled resources requires shader model 5 or higher
TextureCubeArray Sample method for tiled resources requires shader model 5 or higher
Texture2DArray GatherCmpAlpha method for tiled resources requires shader model 5 or higher
TextureCubeArray SampleCmpLevelZero method for tiled resources requires shader model 5 or higher
TextureCubeArray SampleCmp method for tiled resources requires shader model 5 or higher
TextureCubeArray SampleBias method for tiled resources requires shader model 5 or higher
TextureCubeArray SampleLevel method for tiled resources requires shader model 5 or higher
TextureCubeArray GatherGreen method for tiled resources requires shader model 5 or higher
TextureCubeArray GatherRed method for tiled resources requires shader model 5 or higher
TextureCubeArray GatherAlpha method for tiled resources requires shader model 5 or higher
TextureCubeArray GatherBlue method for tiled resources requires shader model 5 or higher
TextureCubeArray GatherCmpGreen method for tiled resources requires shader model 5 or higher
TextureCubeArray GatherCmpRed method for tiled resources requires shader model 5 or higher
TextureCubeArray GatherCmpAlpha method for tiled resources requires shader model 5 or higher
TextureCubeArray GatherCmpBlue method for tiled resources requires shader model 5 or higher
GatherBlue requires shader model 5 or higher
GatherGreen requires shader model 5 or higher
Tessellation factor scale will be clamped to the range [0, 1]
GatherAlpha requires shader model 5 or higher
%s does not support msad4
Tess factor processing functions only available on shader model 4+
function '%s' missing implementation
late-resolve interface calls nested too deeply
flow control depth too deep to emit function call
abstract interfaces not supported on %s, interface references must resolve to specific instances
interface references must resolve to non-varying objects
no classes implement '%s'
internal error: failed to devirtualize a contained interface call
D3D11 Internal Compiler Error: Invalid Bytecode: %s
D3D11 Assembler Error: Invalid Bytecode: %s
Bytecode appears corrupt - integrity check failed.
Validation Error: %s
Failed to extract input signature.
Failed to extract driver shader code.
Input signature cannot be defined for a library function.
Failed to extract output signature.
ShaderFeatureInfo blob must not specify 4x raw and structured buffers for Compute Shaders, or for any shader 5_0+.
Output signature cannot be defined for a library function.
Unrecognized shader type.
Failed to extract patch constant signature.
Invalid interface metadata: too many instances.
Failed to parse shader using reference shader parser: 0x%x
Invalid interface metadata: too many interface slots.
Invalid interface metadata: too many types.
Invalid interface metadata: instance buffer overrun.
Invalid interface metadata: no types defined.
Invalid interface metadata: interface buffer overrun.
Invalid interface metadata: type buffer overrun.
Invalid interface metadata: duplicated type in interface %d's type list.
Invalid interface metadata: interface %u unimplemented.
Invalid interface metadata: type %d violates type stride limits.
Invalid interface metadata: interface count mismatch.
Invalid interface metadata: unterminated type name.
Invalid interface metadata: type name buffer overrun.
Invalid interface metadata: variable %d violates limits on member offsets.
Invalid interface metadata: instance type buffer overrun.
Invalid interface metadata: unterminated instance name.
Invalid interface metadata: instance name buffer overrun.
label (%d) already defined. Opcode #%d (count 1-based). 
Can't continue validation - aborting.
function body (%d) referenced without being defined. Opcode #%d (count 1-based). 
function body (%d) defined without being declared. Opcode #%d (count 1-based). 
function body (%d) already declared. Opcode #%d (count 1-based). 
%s instruction requires shader model 5 or higher.
Declaration statements must appear before other instructions.
Saturate modifier not permitted for opcode #%d (counts are 1-based). 
Incorrect number of operands for opcode #%d (count is 1-based).  Expecting %d, encountered %d.
Resource dimension and return type extended opcodes not expected on opcode #%d (counts are 1-based). 
Precise mask not permitted for opcode #%d (counts are 1-based). 
Expected component count of 0 for operand #%d of opcode #%d (counts are 1-based). 
Invalid operand type for operand #%d of opcode #%d (counts are 1-based). 
Expected component count of 4 (or 1 component immediate32, or in certain cases NULL or scalar operand allowed) for operand #%d of opcode #%d (counts are 1-based). 
Expected component count of 1 (or 4 component with select-1 mode) for operand #%d of opcode #%d (counts are 1-based). 
Expected single component mask (or in certain cases also NULL or single component output operand allowed) for operand #%d of opcode #%d (counts are 1-based). 
Expected nonzero component mask (or in certain cases also NULL or single component output operand allowed) for operand #%d of opcode #%d (counts are 1-based). 
Expected a component mask which picks any one or 2 components for operand #%d of opcode #%d (counts are 1-based). 
Expected contiguous component mask starting at x (.x, .xy, .xyz, or .xyzw) for operand #%d of opcode #%d (counts are 1-based). 
Expected double-compatible swizzle for operand #%d of opcode #%d (counts are 1-based). 
Expected double-compatible component mask (xy, zw, or xyzw) for operand #%d of opcode #%d (counts are 1-based). 
Abs modifier not allowed for operand #%d of opcode #%d (counts are 1-based). 
Negate modifier not allowed for operand #%d of opcode #%d (counts are 1-based). 
Incompatible min precision type for operand #%d of opcode #%d (counts are 1-based). Expected float.
.rrrr swizzle expected for operand #%d of opcode #%d (counts are 1-based). 
Incompatible min precision type for operand #%d of opcode #%d (counts are 1-based). Expected int or uint.
Unrecognized min precision type for operand #%d of opcode #%d (counts are 1-based).
Only immediate32 indexing permitted for operand #%d of opcode #%d (counts are 1-based). Aborting.
Min precision types not allowed for operand #%d of opcode #%d (counts are 1-based). 
4 component with no swizzle expected for operand #%d of opcode #%d (counts are 1-based). 
Indexing of t# resources with current instruction requires opcode to specify resource dimension and return type. Operand #%d of opcode #%d (counts are 1-based). Aborting.
Unexpected indexing dimension for operand #%d of opcode #%d (counts are 1-based). Aborting.
Constant buffer size (%d 16-byte entries) exceeds allowed limit of %d entries. Aborting.
Invalid index dimension %d for relative address temp register within dimension 1 of operand.  Opcode #%d, operand #%d (counts are 1-based). 
Invalid indexing mode for first dimension.  Opcode #%d, operand #%d (counts are 1-based). 
Invalid index dimension for relative address indexable temp register within dimension %d of operand.  Opcode #%d, operand #%d (counts are 1-based). 
Index Dimension %d's relative address temp is out of range (%d specified, max allowed is %d) for operand #%d of opcode #%d (counts are 1-based). Aborting.
Index Dimension %d's relative address indexable temp's dimension %d index is out of range (%d specified, max allowed is %d) for operand #%d of opcode #%d (counts are 1-based). Aborting.
Index Dimension %d's relative address indexable temp is out of range (%d specified, max allowed is %d) for operand #%d of opcode #%d (counts are 1-based). Aborting.
Index Dimension %d out of range (%d specified, max allowed is %d) for operand #%d of opcode #%d (counts are 1-based). Aborting.
Invalid relative indexing register type for dimension %d.  Operand #%d of opcode #%d (counts are 1-based). Aborting.
function body (%d) was never referenced.
Invalid representation for index dimension %d.  Opcode #%d, operand #%d (counts are 1-based). 
function table (%d) was declared, but never referenced.
function body (%d) was never defined.
Interface metadata instance %d refers to undeclared constant buffer offset [%d,%d].
Interface metadata instance %d refers to undeclared constant buffer %d.
Interface metadata instance %d refers to undeclared sampler %d.
Interface metadata instance %d refers to undeclared texture %d.
Interface metadata expects interface %d to be of size %d, but it was declared as size %d.
Interface metadata expects interface %d to be declared, but it was not.
GS input primitive not declared. 
interface pointer (%d) was declared, but never referenced.
All GS input v[][] registers must have vertex count (first dimension) declared with size equal to the number of vertices in the declared input primitive (%d vertices in this case). Input %d has %d vertices declared. 
GS has no input primitive, so no input regisers may be declared.  Input v[][%d] was declared.
Interpolation mode for PS input position must be linear_noperspective_centroid or linear_noperspective_sample when outputting oDepthGE or oDepthLE and not running at sample frequency (which is forced by inputting SV_SampleIndex or declaring an input linear_sample or linear_noperspective_sample). 
GS output topology not declared for stream m%d. 
Thread local temp register storage in Compute Shader (per thread) %d. The shader declares too much temp storage (%d registers). 
Compute Shader must declare a thread group size (X,Y,Z).
For Compute Shader versions < 5_0, with %d threads in a group, at most %d bytes per thread of Thread Group Shared Memory 
can be declared (the amount is a function of how many threads there are).  This shader exceeds the limit at %d bytes per thread. 
For Compute Shader versions < 5_0, the element count for all Structured Thread Group Shared Memory declarations 
must be equal to the number of threads in the group (%d in this case).  %d elements were specified for g%d. 
Domain Shader must declare a tessellator domain.
Domain Shader must declare an input control point count.
Domain Shader input vDomain must be declared with at most a .xy mask when the domain is QUAD.
Domain Shader input vDomain must be declared with at most a .xyz mask when the domain is TRI.
All DS input control point vcp[][] registers must have control point count (first dimension) declared with size equal to the number of input control points declared in the hs decls phase (%d control points in this case). Input %d has %d control points declared. 
Domain Shader input vDomain must be declared with at most a .xy mask when the domain is ISOLINE.
Input index range defined from %d to %d does not include any declared input registers. 
Total number of scalars across all DS input control points must not exceed %d. Current input control point declaration specifies %d scalars of output per control point with %d output control points, resulting in %d total scalars of input control point data. 
Registers in an input index range cannot have system names associated with them (TessFactors are an exception).  Input register %s[%d] has a name and is in an index range from %d to %d. 
Named register components cannot appear to the left (xyzw order) of components that are not named in a given register. TessFactors are an exception. Affected register is input %d. 
Masks (and if pixel shader, also interpolation mode) on all input registers in an index range must be identical. Input register %s[%d] does not match with others in the index range from %d to %d. 
Named register components cannot appear to the left (xyzw order) of components that are not named in a given register. TessFactors are an exception. Affected register is output %d. 
Named register components cannot appear to the left (xyzw order) of components that are not named in a given register. TessFactors are an exception. Affected register is output %d in stream m%d. 
Mismatch between shader declaration of raw and structured buffers for shader 4_x and accompanying Shader Feature Info blob (or lack thereof). Both the shader must declare raw and structured buffer use and a Shader Feature Info blob must specify the same thing as well, or neither should request it. 
Mismatch between shader declaration of double precision floats and accompanying Shader Feature Info blob (or lack thereof). Both the shader must declare double precision float use and a Shader Feature Info blob must specify the same thing as well, or neither should request it. 
Minimum precision types used in a shader that does not have minimum precision support enabled. 
Mismatch between shader declaration of minimum precision and accompanying Shader Feature Info blob (or lack thereof). Both the shader must declare minimum precision use and a Shader Feature Info blob must specify the same thing as well, or neither should request it. 
Mismatch between shader declaration of 11.1 double extensions and shader declaration of double precision floats. If a shader declares 11.1 double extensions use it must also declare double precision float use. 
Mismatch between shader declaration of 11.1 double extensions and accompanying Shader Feature Info blob (or lack thereof). Both the shader must declare 11.1 double extensions use and a Shader Feature Info blob must specify the same thing as well, or neither should request it. 
Raw or Structured buffers can't be declared in shader model 4_* VS/GS/PS without enabling them via a global flags declaration.. 
Mismatch between shader declaration of 11.1 shader extensions and accompanying Shader Feature Info blob (or lack thereof). Both the shader must declare 11.1 shader extensions use and a Shader Feature Info blob must specify the same thing as well, or neither should request it. 
Immediate constant buffer already declared, repeated declaration on opcode #%d (count is 1-based). 
CB[%d] already declared, repeated declaration on opcode #%d (count is 1-based). 
Temp decl already encountered.  Repeated declaration on opcode #%d (count is 1-based). 
Immediate constant buffer size must be a multiple (not incl. 0) of 32bit*4-tuples in size, but no larger than %d 32bit*4-tuples (%d bytes declared).  Opcode #%d (count is 1-based). 
Sum of temp registers and indexable temp registers exceeds limit of %d..  Opcode #%d (count is 1-based). 
Too many temp registers declared (%d).  Max allowed is %d.  Opcode #%d (count is 1-based). 
Indexable temp x%d already declared.  Opcode #%d (count is 1-based). 
Indexable temp register index, [%d], too high.  Opcode #%d (count is 1-based). Aborting.
Invalid component mask in indexable temp decl: 0x%x.  Opcode #%d (count is 1-based). Aborting. 
Sum of temp registers and indexable temp registers exceeds limit of %d..  Opcode #%d (count is 1-based). Aborting. 
Expected sample count of 0 but encountered %d for resource t%d.  Opcode #%d (count is 1-based). 
Resource t%d already declared.  Opcode #%d (count is 1-based). 
Expected sample count > 0 but encountered %d for resource t%d.  Opcode #%d (count is 1-based). 
Texture2DMS resources are only available for input to Pixel Shaders. Opcode #%d (count is 1-based). 
Invalid resource return type on component %d of resource t%d.  Opcode #%d (count is 1-based). 
Invalid resource dimension on resource t%d.  Opcode #%d (count is 1-based). 
Invalid sampler mode on sampler s%d.  Opcode #%d (count is 1-based). 
Sampler s%d already declared.  Opcode #%d (count is 1-based). 
Invalid stream index s%d.  Index must be between 0 and %d Opcode #%d (count is 1-based). 
The first stream declaration cannot appear after any output or output topology declarations.  Opcode #%d (count is 1-based). 
Input index range declaration out of range.  Opcode #%d (count is 1-based). 
Stream s%d already declared.  Opcode #%d (count is 1-based). 
Output index range declaration out of range.  Opcode #%d (count is 1-based). 
Overlapping input index range decl encountered.  Opcode #%d (count is 1-based). 
GS output topology in stream m%d already declared.  Opcode #%d (count is 1-based). 
Overlapping output index range decl encountered.  Opcode #%d (count is 1-based). 
GS output primitive topology unrecognized.  Opcode #%d (count is 1-based). 
GS output topology already declared.  Opcode #%d (count is 1-based). 
GS instance count already declared.  Opcode #%d (count is 1-based). 
GS output vertex count declaration can't be more than %d vertices (%d specified).  Opcode #%d (count is 1-based). 
GS instance count must be at least 1 (%d specified).  Opcode #%d (count is 1-based). 
GS instance count declaration cannot be greater than %d (%d specified).  Opcode #%d (count is 1-based). 
GS input primitive can be a patch only if the GS version is gs_5_0 and greater.  Opcode #%d (count is 1-based). 
GS input primitive already declared.  Opcode #%d (count is 1-based). 
vCycleCounter is only supported on 5_0+ shaders.  Opcode #%d (count is 1-based). 
GS input primitive unrecognized.  Opcode #%d (count is 1-based). 
Cycle Counter declaration must have mask of .x or .xy.  Opcode #%d (count is 1-based). 
Cycle Counter already declared.  Opcode #%d (count is 1-based). 
Compute Shader input Thread ID declaration must have a non-empty mask and allows only components x, y, and z in mask.  Opcode #%d (count is 1-based). 
Compute Shader input Thread ID already declared.  Opcode #%d (count is 1-based). 
Compute Shader input Thread Group ID declaration must have a non-empty mask and allows only components x, y, and z in mask.  Opcode #%d (count is 1-based). 
Compute Shader input Thread Group ID already declared.  Opcode #%d (count is 1-based). 
Compute Shader input Thread ID In Group declaration must have a non-empty mask and allows only components x, y, and z in mask.  Opcode #%d (count is 1-based). 
Compute Shader input Thread ID In Group already declared.  Opcode #%d (count is 1-based). 
Compute Shader input Thread ID In Group Flattened declaration must have an empty writemask.  Opcode #%d (count is 1-based). 
Compute Shader input Thread ID In Group Flattened already declared.  Opcode #%d (count is 1-based). 
Hull Shader output control point ID already declared.  Opcode #%d (count is 1-based). 
Input primitive ID already declared in this HS phase.  Opcode #%d (count is 1-based). 
Hull Shader join phase instance ID already declared.  Opcode #%d (count is 1-based). 
Hull Shader fork phase instance ID already declared.  Opcode #%d (count is 1-based). 
Input primitive ID already declared.  Opcode #%d (count is 1-based). 
When there is no Control Point phase in the HS, the control points are pass-through to the DS, but the Fork/Join phases in the HS cannot use 'output control points' (vocp[][] registers).  Instead just use vcp[][] input control points (which are the same anyway in the passthrough case). Opcode #%d (count is 1-based).
Input domain point declaration can't have an empty mask.  Opcode #%d (count is 1-based). 
Input domain point already declared.  Opcode #%d (count is 1-based). 
GS instance ID already declared.  Opcode #%d (count is 1-based). 
GS input primID already declared.  Opcode #%d (count is 1-based). 
PS input vInnerCoverage declared, cannot also declare vCoverage (features are mutually exclusive).  Opcode #%d (count is 1-based). 
PS input vCoverage already declared.  Opcode #%d (count is 1-based). 
PS input vInnerCoverage already declared.  Opcode #%d (count is 1-based). 
PS input vInnerCoverage requires feature flag enableInnerCoverage.  Opcode #%d (count is 1-based). 
Components of input declaration for register %d overlap with previous declaration for same register.  Opcode #%d (count is 1-based). 
PS input vCoverage declared, cannot also declare vInnerCoverage (features are mutually exclusive).  Opcode #%d (count is 1-based). 
SGV must have scalar mask in declaration.  Opcode #%d (count is 1-based). 
Invalid name or shader for SGV dcl.  Opcode #%d (count is 1-based). 
instanceID already declared for input.  Opcode #%d (count is 1-based). 
vertexID already declared for input.  Opcode #%d (count is 1-based). 
TessFactors must each be declared with a single component.  Opcode #%d (count is 1-based). 
Invalid name or shader for SIV dcl.  Opcode #%d (count is 1-based). 
finalTri*TessFactor requires TRI tessellator domain.  Opcode #%d (count is 1-based). 
finalQuad*TessFactor requires QUAD tessellator domain.  Opcode #%d (count is 1-based). 
finalQuadUeq0EdgeTessFactor already declared for input.  Opcode #%d (count is 1-based). 
finalLine*TessFactor requires ISOLINE tessellator domain.  Opcode #%d (count is 1-based). 
finalQuadUeq1EdgeTessFactor already declared for input.  Opcode #%d (count is 1-based). 
finalQuadVeq0EdgeTessFactor already declared for input.  Opcode #%d (count is 1-based). 
finalQuadUInsideTessFactor already declared for input.  Opcode #%d (count is 1-based). 
finalQuadVeq1EdgeTessFactor already declared for input.  Opcode #%d (count is 1-based). 
finalTriUeq0EdgeTessFactor already declared for input.  Opcode #%d (count is 1-based). 
finalQuadVInsideTessFactor already declared for input.  Opcode #%d (count is 1-based). 
finalTriWeq0EdgeTessFactor already declared for input.  Opcode #%d (count is 1-based). 
finalTriVeq0EdgeTessFactor already declared for input.  Opcode #%d (count is 1-based). 
finalLineDetailTessFactor already declared for input.  Opcode #%d (count is 1-based). 
finalTriInsideTessFactor already declared for input.  Opcode #%d (count is 1-based). 
position already declared for input.  Opcode #%d (count is 1-based). 
finalLineDensityTessFactor already declared for input.  Opcode #%d (count is 1-based). 
Too many total clip/cull distance values.  At most %d allowed (clip+cull total).  Opcode #%d (count is 1-based). 
Too many unique registers contain clip/cull distance values.  At most %d unique registers can have clip/cull distance in components.  Opcode #%d (count is 1-based). 
Invalid interpolation mode for register v%d.  Opcode #%d (count is 1-based). 
Components of input declaration for register v%d overlap with previous declaration for same register.  Opcode #%d (count is 1-based). 
primitiveID already declared for input.  Opcode #%d (count is 1-based). 
Interpolation mode cannot vary for different components of a single input register (v%d).  Opcode #%d (count is 1-based). 
sampleIndex already declared for input.  Opcode #%d (count is 1-based). 
isFrontFace already declared for input.  Opcode #%d (count is 1-based). 
Interpolation mode for PS input position must be linear_noperspective or linear_noperspective_centroid (shader model 4.1+ allows linear_noperspective_sample as well). 
Interpolation mode for PS SGV must be constant (register v%d).  Opcode #%d (count is 1-based). 
renderTargetArrayIndex or viewportArrayIndex must have scalar mask in declaration.  Opcode #%d (count is 1-based). 
Interpolation mode for PS clip or cull distance must be linear or linear centroid, or in 4.1, linear_sample  (register v%d).  Opcode #%d (count is 1-based). 
viewportArrayIndex already declared for input.  Opcode #%d (count is 1-based). 
renderTargetArrayIndex already declared for input.  Opcode #%d (count is 1-based). 
PS output depth already declared.  Opcode #%d (count is 1-based). 
Interpolation mode for PS renderTargetArrayIndex or viewportArrayIndex must be constant (register v%d).  Opcode #%d (count is 1-based). 
PS output coverage mask already declared.  Opcode #%d (count is 1-based). 
PS output depth already declared.  The previous declaration was of a different type.  Opcode #%d (count is 1-based). 
PS output stencil ref already declared.  Opcode #%d (count is 1-based). 
PS output stencil ref requires feature flag enableStencilRef.  Opcode #%d (count is 1-based). 
Components of output declaration for register o%d overlap with previous declaration for same register.  Opcode #%d (count is 1-based). 
PS ouputs must be declared in slots less than UAVs.  Output declared in slot %d while UAV declared in slot %d.  Opcode #%d (count is 1-based). 
primitiveID already declared for output.  Opcode #%d (count is 1-based). 
Components of output declaration for register %d overlap with previous declaration for same register.  Opcode #%d (count is 1-based). 
finalQuadUeq0EdgeTessFactor already declared for output.  Opcode #%d (count is 1-based). 
isFrontFace already declared for output.  Opcode #%d (count is 1-based). 
finalQuadUeq1EdgeTessFactor already declared for output.  Opcode #%d (count is 1-based). 
finalQuadVeq0EdgeTessFactor already declared for output.  Opcode #%d (count is 1-based). 
finalQuadUInsideTessFactor already declared for output.  Opcode #%d (count is 1-based). 
finalQuadVeq1EdgeTessFactor already declared for output.  Opcode #%d (count is 1-based). 
finalTriUeq0EdgeTessFactor already declared for output.  Opcode #%d (count is 1-based). 
finalQuadVInsideTessFactor already declared for output.  Opcode #%d (count is 1-based). 
finalTriWeq0EdgeTessFactor already declared for output.  Opcode #%d (count is 1-based). 
finalTriVeq0EdgeTessFactor already declared for output.  Opcode #%d (count is 1-based). 
finalLineDetailTessFactor already declared for output.  Opcode #%d (count is 1-based). 
finalTriInsideTessFactor already declared for output.  Opcode #%d (count is 1-based). 
position declaration must have xyzw mask.  Opcode #%d (count is 1-based). 
finalLineDensityTessFactor already declared for output.  Opcode #%d (count is 1-based). 
renderTargetArrayIndex already declared for output.  Opcode #%d (count is 1-based). 
position already declared for output.  Opcode #%d (count is 1-based). 
Global flags already declared once.  Opcode #%d (count is 1-based). 
viewportArrayIndex already declared for output.  Opcode #%d (count is 1-based). 
enableRawAndStructuredBuffers global flag can't be used (not needed) with Compute Shaders.  Opcode #%d (count is 1-based). 
Unrecognized global flags.  Opcode #%d (count is 1-based). 
Input control point count must be [%d..%d].  %d specified.  Opcode #%d (count is 1-based). 
When streams are declared, you must use emit_stream, cut_stream, and emitthencut_stream instead of emit, cut, and emitthencut.  Opcode #%d (count is 1-based). 
Input control point count must be [0..%d].  %d specified.  Opcode #%d (count is 1-based). 
Hull Shader input control point count already declared. Aborting.  Opcode #%d (count is 1-based). 
Hull Shader output control point count already declared. Aborting.  Opcode #%d (count is 1-based). 
Domain Shader input control point count already declared. Aborting.  Opcode #%d (count is 1-based). 
Invalid Tessellator Domain specified. Must be isoline, tri or quad. Aborting. Opcode #%d (count is 1-based). 
Output control point count must be [0..%d].  %d specified.  Opcode #%d (count is 1-based). 
Invalid Tessellator Partitioning specified. Must be integer, pow2, fractional_odd or fractional_even. Aborting. Opcode #%d (count is 1-based). 
Tessellator domain already declared. Aborting. Opcode #%d (count is 1-based). 
Invalid Tessellator Output Primitive specified. Must be point, line, triangleCW or triangleCCW. Aborting. Opcode #%d (count is 1-based). 
Tessellator Partitioning already declared. Aborting. Opcode #%d (count is 1-based). 
Hull Shader output max tessfactor already declared. Aborting.  Opcode #%d (count is 1-based). 
Tessellator Output Primitive already declared. Aborting. Opcode #%d (count is 1-based). 
Hull Shader Fork Phase Instance Count already declared in this phase. Aborting.  Opcode #%d (count is 1-based). 
Hull Shader MaxTessFactor must be [%f..%f].  %f specified.  Opcode #%d (count is 1-based). 
Hull Shader Join Phase Instance Count already declared in this phase. Aborting.  Opcode #%d (count is 1-based). 
Hull Shader Fork Phase Instance Count must be [%d..%d].  %d specified.  Opcode #%d (count is 1-based). 
Declared Thread Group X size %d outside valid range [%d..%d].  Opcode #%d (count is 1-based). 
Hull Shader Join Phase Instance Count must be [%d..%d].  %d specified.  Opcode #%d (count is 1-based). 
Declared Thread Group Z size %d outside valid range [%d..%d].  Opcode #%d (count is 1-based). 
Declared Thread Group Y size %d outside valid range [%d..%d].  Opcode #%d (count is 1-based). 
Declared Thread Group X size %d outside valid range [%d..%d] for Compute Shader version < 5_0.  Opcode #%d (count is 1-based). 
Declared Thread Group Count %d (X*Y*Z) is beyond the valid maximum of %d.  Opcode #%d (count is 1-based). 
Declared Thread Group Count %d (X*Y*Z) is beyond the valid maximum of %d for Compute Shader version < 5_0.  Opcode #%d (count is 1-based). 
Declared Thread Group Y size %d outside valid range [%d..%d] for Compute Shader version < 5_0.  Opcode #%d (count is 1-based). 
Texture2DMS[Array] or TextureCube[Array] resources are not supported with UAVs (Unordered Access Views). Opcode #%d (count is 1-based). 
SRV reference t%d must have a structure byte stride that is a multiple of 4 that is greater than 0 but no greater than %d when declared as structured (%d specified).  Opcode #%d (count is 1-based). 
UAV u%d already declared.  Opcode #%d (count is 1-based). 
Invalid resource dimension on resource u%d.  Opcode #%d (count is 1-based). 
Invalid resource return type on component %d of resource u%d.  Opcode #%d (count is 1-based). 
UAVs must be declared in slots greater than PS outputs.  UAV declared in slot %d while output declared in slot %d.  Opcode #%d (count is 1-based). 
UAV reference u%d: order preserving counter flag valid only on structured buffers.  Opcode #%d (count is 1-based). 
UAV reference u%d specified with invalid flag.  Opcode #%d (count is 1-based). 
UAV reference u%d must have a structure byte stride that is a multiple of 4 that is greater than 0 but no greater than %d when declared as structured (%d specified).  Opcode #%d (count is 1-based). 
UAV reference u%d: ROV requires Rasterizer Ordered feature flag.  Opcode #%d (count is 1-based). 
Thread Group Shared Memory reference g%d already declared.  Opcode #%d (count is 1-based). 
UAV reference u%d has invalid flag.  Opcode #%d (count is 1-based). 
Total Thread Group Shared Memory storage exceeded by g# declarations so far up to g%d.  Opcode #%d (count is 1-based). 
Thread Group Shared Memory reference g%d byteCount (%d specified) must be a nonzero multiple of 4.  Opcode #%d (count is 1-based). 
Output index range defined from %d to %d includes output register %d that was not declared. 
Thread Group Shared Memory reference g%d must have a structure byte stride that is a nonzero multiple of 4 when declared as structured (%d specified).  Opcode #%d (count is 1-based). 
The intersection of all masks on output registers in an index range cannot be empty. Index range from o%d to o%d has empty mask intersecion. 
Registers in an output index range cannot have system names associated with them (TessFactors are an exception).  Output register o%d has a name and is in an index range from o%d to o%d. 
Reference out of range on vertex axis for input v[%d][].  Input primitive type has %d vertices.  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared temp r%d.  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared input or undeclared components of input v%s[%d].  Opcode #%d, operand #%d (counts are 1-based). 
Reference out of range on vertex axis for input v[%d][].  Input control point has %d vertices.  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared input or undeclared components of index range input starting at base v%s[%d].  Opcode #%d, operand #%d (counts are 1-based). 
Relative indexing input register from base %s[0] not allowed when register 0 has not been declared in an index range.  Opcode #%d, operand #%d (counts are 1-based). 
Reference out of range on vertex axis for input vcp[%d][].  Input control point has %d vertices.  Opcode #%d, operand #%d (counts are 1-based). 
Relative indexing input register from base %s[%d] not allowed when register %d has not been declared in an index range.  Opcode #%d, operand #%d (counts are 1-based). 
Relative indexing input register from base vcp[0] not allowed when register 0 has not been declared in an index range.  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared input or undeclared components of input vcp[][%d].  Opcode #%d, operand #%d (counts are 1-based). 
Relative indexing input register from base vcp[][%d] not allowed when register %d has not been declared in an index range.  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared input or undeclared components of index range input starting at base vcp[][%d].  Opcode #%d, operand #%d (counts are 1-based). 
Relative indexing input register from base vpc[0] not allowed when register 0 has not been declared in an index range.  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared input or undeclared components of input vpc[%d].  Opcode #%d, operand #%d (counts are 1-based). 
Relative indexing input register from base vpc[%d] not allowed when register %d has not been declared in an index range.  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared input or undeclared components of index range input starting at base vpc[%d].  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared input or undeclared components of input vocp[][%d].  Opcode #%d, operand #%d (counts are 1-based). 
Reference out of range on vertex axis for input vocp[%d][].  Output control points has %d vertices.  Opcode #%d, operand #%d (counts are 1-based). 
Relative indexing input register from base vocp[][%d] not allowed when register %d has not been declared in an index range.  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared input or undeclared components of index range input starting at base vocp[][%d].  Opcode #%d, operand #%d (counts are 1-based). 
Relative indexing output register from base o[0] not allowed when register 0 has not been declared in an index range.  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared output or undeclared components of output o%d.  Opcode #%d, operand #%d (counts are 1-based). 
Relative indexing output register from base o[%d] not allowed when register %d has not been declared in an index range.  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared output or undeclared components of index range output starting at base o[%d].  Opcode #%d, operand #%d (counts are 1-based). 
Reference out of bounds, [%d], on x%d[size==%d].  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared indexable temp x%d[].  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared sampler s%d.  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared components of indexable temp x%d[].  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared resource t%d.  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared stream m%d.  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared constant buffer cb%d[].  Opcode #%d, operand #%d (counts are 1-based). 
Reference out of bounds, cb%d.  Opcode #%d, operand #%d (counts are 1-based). 
Relative indexing not allowed for cb%d since it was not declared for dynamic indexing..  Opcode #%d, operand #%d (counts are 1-based). 
Reference out of bounds, [%d], on cb%d[size==%d] (if size is listed as 0, it means default size is used, which is %d.  Opcode #%d, operand #%d (counts are 1-based). 
Reference out of bounds, [%d], on immediate constant buffer [size==%d].  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared immediate constant buffer.  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared register vGSInstanceID.  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared register vPrimitiveID.  Opcode #%d, operand #%d (counts are 1-based). 
Reference of register oDepth does mot match declaration (dcl_oDepthGE or dcl_oDepthLE).  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared register oDepth.  Opcode #%d, operand #%d (counts are 1-based). 
Reference of register oDepthGE does mot match declaration (dcl_oDepth or dcl_oDepthLE).  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared register oDepthGE.  Opcode #%d, operand #%d (counts are 1-based). 
Reference of register oDepthLE does mot match declaration (dcl_oDepth or dcl_oDepthGE).  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared register oDepthLE.  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared register vInnerCoverage.  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared register vCoverage.  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared register oStencilRef.  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared register oMask.  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared components of input vCycleCounter.  Opcode #%d, operand #%d (counts are 1-based). 
Invalid component selection mode for vCycleCounter.  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared register vForkPhaseInstanceID.  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared register vOutputControlPointID.  Opcode #%d, operand #%d (counts are 1-based). 
Invalid component selection mode for vInputThreadID.  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared register vJoinPhaseInstanceID.  Opcode #%d, operand #%d (counts are 1-based). 
Invalid component selection mode for vInputThreadGroupID.  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared components of input vInputThreadID.  Opcode #%d, operand #%d (counts are 1-based). 
Invalid component selection mode for vInputThreadIDInGroup.  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared components of input vInputThreadGroupID.  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared input vInputThreadIDInGroupFlattened.  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared components of input vInputThreadIDInGroup.  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared thread group shared memory g%d[].  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared UAV u%d.  Opcode #%d, operand #%d (counts are 1-based). 
Index Dimension %d's relative address temp is out of range (%d specified, max allowed based on temp declaration is %d) for operand #%d of opcode #%d (counts are 1-based). Aborting.
Reference out of bounds, [%d], on g%d[size==%d].  Opcode #%d, operand #%d (counts are 1-based). 
Reference out of range of indexable temp x%d[] within relative index of an operand.  Index [%d] specified, but based on the indexable temp declaration, the max index allowed is [%d].  Operand #%d of opcode #%d (counts are 1-based). Aborting.
Reference of undeclared components of indexable temp x%d[] within relative index of an operand.  Opcode #%d, operand #%d (counts are 1-based). 
interface decl references undefined function table (%d).  Opcode #%d (count 1-based).
function table (%d) already declared. Opcode #%d (count 1-based). 
interface decl for interface index %d has different function table data than the interface metadata.  Opcode #%d (count 1-based).
interface decl expects a table of size %d, but table %d has %d elements.  Opcode #%d (count 1-based).
interface decl declares an interface index %d that is not the interface metadata.  Opcode #%d (count 1-based).
interface decl declares an interface index %d that is not a base register in the interface metadata.  Opcode #%d (count 1-based).
interface decl declares an interface index (%d) that has already been declared.  Opcode #%d (count 1-based).
interface decl declares an invalid interface index %d.  Opcode #%d (count 1-based).
ld does not support raw or structured buffers.  Opcode #%d, operand #%d (counts are 1-based). 
bufinfo requires resource declared as Buffer, Raw Buffer or Structured Buffer.  Opcode #%d, operand #%d (counts are 1-based). 
ld2dms requires resource declared as texture2DMS/texture2DMSArray.  Opcode #%d, operand #%d (counts are 1-based). 
ld requires resource declared as texture1D/2D/3D/1DArray/2DArray.  Opcode #%d, operand #%d (counts are 1-based). 
lod requires resource declared as texture1D/2D/3D/Cube/CubeArray/1DArray/2DArray.  Opcode #%d, operand #%d (counts are 1-based). 
lod instruction requires sampler declared in default mode.  Opcode #%d, operand #%d (counts are 1-based). 
%s instruction requires sampler declared in %s mode.  Opcode #%d, operand #%d (counts are 1-based). 
comparison
%s requires resource declared as texture2D/2DArray%s.  Opcode #%d, operand #%d (counts are 1-based). 
/Cube/CubeArray
sample/_l/_d/_cl_s instructions require sampler declared in default mode.  Opcode #%d, operand #%d (counts are 1-based). 
resinfo requires resource declared as texture1D/2D/3D/Cube/1DArray/2DArray/2DMS/2DMSArray.  Opcode #%d, operand #%d (counts are 1-based). 
sample_c_* instructions require sampler declared in comparison mode.  Opcode #%d, operand #%d (counts are 1-based). 
sample/_l/_d requires resource declared as texture1D/2D/3D/Cube/1DArray/2DArray.  Opcode #%d, operand #%d (counts are 1-based). 
sample_c_* instructions require resource declared as texture1D/2D/Cube, but arrays not allowed.  Opcode #%d, operand #%d (counts are 1-based). 
sample_c_* instructions require resource declared as texture1D/2D/Cube/1DArray/2DArray/CubeArray.  Opcode #%d, operand #%d (counts are 1-based). 
bias amount for sample_b must be in the range [%f,%f], but %f was specified as an immediate. Opcode #%d, operand #%d (counts are 1-based). 
sample_b requires sampler declared in default mode.  Opcode #%d, operand #%d (counts are 1-based). 
swapc requires destination registers to be different.  Opcode #%d, operand #1 and operand #2 (counts are 1-based).
sample_b requires resource declared as texture1D/2D/3D/Cube/1DArray/2DArray.  Opcode #%d, operand #%d (counts are 1-based). 
sync must include some form of memory barrier - _u (UAV) and/or _g (Thread Group Shared Memory).  Only _t (thread group sync) is optional. Opcode #%d (counts are 1-based).
sync in a non-Compute Shader must only sync UAV (sync_uglobal).Opcode #%d (counts are 1-based).
ld_uav_typed cannot be used on a UAV that is not declared as typed (u%d). Opcode #%d (counts are 1-based).
sync can't specify both _ugroup and _uglobal. If both are needed, just specify _uglobal. Opcode #%d (counts are 1-based).
store_uav_typed must write to all four components of the UAV. Opcode #%d (counts are 1-based).
store_uav_typed cannot be used on a UAV that is not declared as typed (u%d). Opcode #%d (counts are 1-based).
ld_raw cannot be used on a resource that is not declared as raw (resource index [%d]). Opcode #%d (counts are 1-based).
ld_raw requires resource declared as Raw Buffer.  Opcode #%d, operand #%d (counts are 1-based). 
ld_structured requires resource declared as Structured Buffer.  Opcode #%d, operand #%d (counts are 1-based). 
store_raw cannot be used on a resource that is not declared as raw (resource index [%d]). Opcode #%d (counts are 1-based).
store_structured cannot be used on a resource that is not declared as structured (resource index [%d]). Opcode #%d (counts are 1-based).
ld_structured cannot be used on a resource that is not declared as structured (resource index [%d]). Opcode #%d (counts are 1-based).
imm_atomic_alloc and imm_atomic_consume require as Structured Buffer UAV (slot %d). Opcode #%d (counts are 1-based).
store_structured writing to Thread Group Shared Memory for shader models less than 5_0 must use 
vThreadIDInGroupFlattened as the structure index (second) parameter. Opcode #%d (counts are 1-based).
imm_atomic_alloc and imm_atomic_consume can't be combined with other atomic operations on an Append UAV (%d). Opcode #%d (counts are 1-based).
imm_atomic_alloc and imm_atomic_consume on a given UAV (%d) cannot both be in the same shader. Opcode #%d (counts are 1-based).
vCycleCounter can only be used with the mov instruction.  Opcode #%d, operand #%d (counts are 1-based). 
sample_* instructions require resource to be declared to return UNORM, SNORM or FLOAT.  Opcode #%d, operand #%d (counts are 1-based). 
else statement seen already.  Opcode #%d (count 1-based). Aborting validation.
else statement doesn't match to an if statement. Opcode #%d (count 1-based). Aborting validation.
endloop statement doesn't match to a loop statement. Opcode #%d (count 1-based). Aborting validation.
endif statement doesn't match to an if statement. Opcode #%d (count 1-based). Aborting validation.
case statement doesn't match to the scope of a switch statement. Opcode #%d (count 1-based). Aborting validation.
endswitch statement doesn't match to a switch statement. Opcode #%d (count 1-based). Aborting validation.
default statement doesn't match to the scope of a switch statement. Opcode #%d (count 1-based). Aborting validation.
case %d (or if bits to be interpreted as float: %f) already seen. Opcode #%d (count 1-based).
continue/continuec statement not inside loop.  Opcode #%d (count 1-based).
default statement seen already.  Opcode #%d (count 1-based).
call/callc statement not referencing a label.  Opcode #%d (count 1-based).
break/breakc statement not inside loop or switch.  Opcode #%d (count 1-based).
Multiple Hull Shader phases cannot call the same subroutine. If this is an important feature, support could be considered in the future. Opcode #%d (count is 1-based)
Shader Model 5+ requires that subroutine definitions appear after any call(s) to the subroutine. This also implies recursion is not allowed, although that may or may not be the case here.  Aborting. Opcode #%d (count 1-based).
fcall statement referencing an undeclared interface (%d).  Opcode #%d (count 1-based).
fcall statement not referencing an interface.  Opcode #%d (count 1-based).
shader exceeds maximum supported number of interface call sites (%d).  Opcode #%d (count 1-based).
fcall statement referencing an out of bounds function index (%d).  Opcode #%d (count 1-based).
label (%d) being defined without any callers. Shader Model 5+ requires all callers to a subroutine to appear before the subroutine definition. Aborting.Opcode #%d (count 1-based). 
Multiple Hull Shader phases cannot call the same interface body. If this is an important feature, support could be considered in the future. Opcode #%d (count is 1-based)
label (%d) must be preceded by a ret. Opcode #%d (count 1-based). Aborting validation.
label (%d) was never used in the shader
Interpolation mode on input v# register used with eval_* instruction must be linear, linear_centroid, linear_noperspective, linear_noperspective_centroid, linear_sample or linear_noperspective_sample. Opcode #%d (count is 1-based). 
label (%d) must not be nested inside flow control. Opcode #%d (count 1-based). Aborting validation.
Can't fall through case/default unless case/default has no code. Opcode #%d (count 1-based). Aborting validation.
It is invalid to use eval_* on position input due to hardware limitation.  Opcode #%d (count is 1-based). 
ret can only be followed by case/default/endswitch/endloop/else/endif/label. Opcode #%d (count 1-based). Aborting validation.
switch must be followed by case or default. Opcode #%d (count 1-based). Aborting validation.
label (%d) called but not defined.
break/continue can only be followed by case/default/endswitch/endloop/else/endif. Opcode #%d (count 1-based). Aborting validation.
End of program reached with incomplete flow control structure.
label (%d) defined but never called.
%s signature parameter %s (1-based Entry %d) specifies invalid interpolation mode for integer component type. 
When code ends in subroutine definition, it must end with ret.
%s array signature parameter %s cannot be indexed dynamically.
%s signature parameter %s (1-based Entry %d) specifies unrecognized or invalid component type. 
%s signature parameter %s (1-based Entry %d) type must be float32. 
Non system-generated input signature parameter (%s) cannot appear after a system generated value.
%s signature parameter %s (1-based Entry %d) type must be float32 and mask must be xyzw. 
%s signature parameter %s (1-based Entry %d) type must be uint32. 
%s signature parameter %s (1-based Entry %d) type must be a scalar uint. 
Too many %s signature parameters of type SV_ClipDistance or SV_CullDistance.  Maximum number of registers usable is %i.
%s signature parameter %s (1-based Entry %d) has an unrecognized system name. 
%s signature parameter %s (1-based Entry %d) type must be a scalar float. 
Patch constant signature parameter #%d (1-based) specifies out of range register %d. 
Stream index (%u) must between 0 and %u.
Patch constant signature name mismatch with declaration in shader code for component %d in register %d. 
Patch constant signature parameter #%d (1-based) specifies register %d (or components in the register) that have already been defined. 
Input signature parameter #%d (1-based) specifies out of range register %d. 
Patch constant signature signature does not specify component %d of register %d which is declared in the shader code. 
Input signature name mismatch with declaration in shader code for component %d in register %d. 
Input signature parameter #%d (1-based) specifies register %d (or components in the register) that have already been defined. 
Output signature parameter #%d (1-based) specifies out of range register %d. 
Input signature does not specify component %d of register %d which is declared in the shader code. 
Output signature name mismatch with declaration in shader code for component %d in register %d. 
Output signature parameter #%d (1-based) specifies register %d (or components in the register) that have already been defined. 
Pixel Shader allows output semantics to be SV_Target, SV_Depth, SV_DepthGreaterEqual, SV_DepthLessEqual, SV_Coverage only, or SV_StencilRef.  Output signature parameter #%d (1-based) specifies semantic %s. 
Output signature does not specify component %d of register %d which is declared in the shader code. 
Extended 11.1 double operations not supported unless globalFlags includes enable11_1DoubleExtensions.
Double operations not supported unless globalFlags includes enableDoublePrecisionFloatOps.
Unrecognized instruction or instruction not valid in vertex shader.
Extended 11.1 shader operations not supported unless globalFlags includes enable11_1ShaderExtensions.
Hull Shader declsphase must declare an output control point count.
Hull Shader declsphase must declare an input control point count.
Hull Shader declsphase must declare a tessellator partitioning.
Hull Shader declsphase must declare a tessellator domain.
Hull Shader declared with IsoLine Domain must specify output primitive point or line. triangle_cw or triangle_ccw output are not compatible with the IsoLine Domain.
Hull Shader declsphase must declare a tessellator output primitive.
Hull Shader declared with Quad Domain must specify output primitive point, triangle_cw or triangle_ccw. line output is not compatible with the Quad domain.
Hull Shader declared with Tri Domain must specify output primitive point, triangle_cw or triangle_ccw. line output is not compatible with the Tri domain.
Total number of scalars across all HS output control points must not exceed %d. Current output control point declaration specifies %d scalars of output per control point with %d output control points, resulting in %d total scalars of output control point data. 
All HS control point phase input v[][] registers must have control point count (first dimension) declared with size less than or equal to the number of input control points declared in the hs decls phase (%d control points in this case). Input %d has %d control points declared. 
All HS fork phase input vocp[][] registers must have control point count (first dimension) declared with size less than or equal to the number of output control points declared in the hs decls phase (%d control points in this case). Input %d has %d control points declared. 
All HS fork phase input vcp[][] registers must have control point count (first dimension) declared with size less than or equal to the number of input control points declared in the hs decls phase (%d control points in this case). Input %d has %d control points declared. 
Multiple fork phase programs declared the same component(s) of output patch constant register o[#d].
Hull Shader Fork Phase reads component(s) of output control point [%d] which were not output by the Control Point Phase.
All HS join phase input vcp[][] registers must have control point count (first dimension) declared with size equal to the number of input control points declared in the hs decls phase (%d control points in this case). Input %d has %d control points declared. 
Multiple fork phase programs cannot declare partially overlapping index ranges for output Patch Constant Data. One index range is from register [%d] to [%d], while the another is from [%d] to [%d].
Hull Shader Join Phase reads component(s) of output control point [%d] which were not output by the Control Point Phase.
All HS join phase input vocp[][] registers must have control point count (first dimension) declared with size equal to the number of output control points declared in the hs decls phase (%d control points in this case). Input %d has %d control points declared. 
Join phase declared the same component(s) of output patch constant register o[#d] as already declared for output by a previous fork phase or other joint phase.
Join phase declaring component(s) of input patch constant register vpc[%d] which have not been output by previous fork phase(s) or other join phase(s).
When the Hull Shader doesn't have a Control Point Phase, the declared Input Control Point Count (%d) must match the declared Output Control Point Count (%d), indicating the control points will pass through, or the Output Control Point Count can be set 0. 
Multiple fork/join phase programs cannot declare partially overlapping index ranges for output Patch Constant Data. One index range is from register [%d] to [%d], while the another is from [%d] to [%d].
finalTriVEdgeTessFactor
finalTriUEdgeTessFactor
Related TessFactor names (such as edges) must be declared in the same component of consecutive Patch Constant registers, in the correct order. %s is in %s[%d].%s, which would put %s past the end of the available registers, since it is %d name after %s in the order.
finalTriWEdgeTessFactor
Related TessFactor names (such as edges) must be declared in the same component of consecutive Patch Constant registers, in the correct order. %s expected in %s[%d].%s since %s is in %s[%d].%s.
ISOLINE
Index ranges declared on Patch Constant Data cannot cross over related blocks of hardware TessFactors. An index range is declared from register [%d] to [%d], which crosses over a block of TessFactors that starts with %s in register [%d] and ends in %s in register [%d].
Required TessFactor name %s for %s domain not found declared anywhere in Patch Constant data. 
Hull Shader must start with HSDecls phase.
Unrecognized instruction or instruction not valid in Hull Shader.
Declaration statements in HS Control Point phase must appear before other instructions.
Invalid instruction for Hull Shader Decls phase.
Declaration statements in HS Fork phase must appear before other instructions.
Invalid instruction for Hull Shader Control Point phase.
Declaration statements in HS Join phase must appear before other instructions.
Invalid instruction for Hull Shader Fork phase.
Invalid instruction for Hull Shader postamble section (subroutines and function bodies).
Invalid instruction for Hull Shader Join phase.
Unrecognized instruction or instruction not valid in geometry shader.
Unrecognized instruction or instruction not valid in Domain Shader.
Unrecognized instruction or instruction not valid in pixel shader.
Declared output vertex count (%d) multiplied by the total number of declared scalar components of output data (%d) equals %d.  This value cannot be greater than %d.
Dest register relative index indexable-temp register component %d in x[%d][%d] uninitialized. Opcode #%d (count is 1-based)
Dest register relative index temp register component %d in r%d uninitialized. Opcode #%d (count is 1-based)
source register relative index indexable-temp register component %d in x[%d][%d] uninitialized. Opcode #%d (count is 1-based)
source register relative index temp register component %d in r%d uninitialized. Opcode #%d (count is 1-based)
source indexable temp register component %d in x%d[*] never initialized anywhere.Opcode #%d (count is 1-based)
source component %d in temp r%d not initialized. Opcode #%d (count is 1-based)
Unrecognized instruction or instruction not valid in a library function.
Unrecognized instruction or instruction not valid in Compute Shader.
lib_4_0_level_9_1_vs
%cs_%d_%d
lib_4_0_level_9_1_ps
lib_4_0_level_9_3_vs
(Statement %d) 
%s(%d) : 
Out of memory.
IDirect3DShaderValidator9::Begin called out of order. ::End must be called first.
IDirect3DShaderValidator9::Instruction called out of order. After end token there should be no more instructions.  Call ::End next.
IDirect3DShaderValidator9::Instruction called out of order. ::Begin must be called first.
Bad version token.  DWORD count > 1 given. Expected DWORD count to be 1 for version token.
IDirect3DShaderValidator9::Instruction called with NULL == pdwInst or 0 == cdw.
Bad end token.  DWORD count > 1 given. Expected DWORD count to be 1 for end token.
Bad version token.  It indicates neither a pixel shader nor a vertex shader.
Shader missing end token.
IDirect3DShaderValidator9::End called out of order. Call to ::Begin, followed by calls to ::Instruction must occur first.
Out of memory
Version token 0x%x does not represent a pixel library function.
Version token 0x%x does not represent a vertex library function.
Version token 0x%x does not represent a vertex shader.
Direct3D9: Shader Validator: 
Version Token: 0x%x is invalid. Pixel shader version token must be of the form 0xffff****. Aborting pixel shader validation.
Version Token: 0x%x indicates a vertex shader.  Pixel shader version token must be of the form 0xffff****.
ps_1_0 is no longer supported.  It turned out that pixel shader capable hardware will always support at least ps_1_1 (which is not as limited a model as ps_1_0 was). To convert a ps_1_0 shader up to ps_1_1, the only change needed is to make the version number 1_1. 
Version Token: Shader version %s is not supported by hardware. 
Instruction not supported by %s shader.
Version Token: Shader version %s is not supported. Aborting pixel shader validation.
first
Invalid parameter count.
third
second
Second source parameter for texm3x3spec must be c#.
(%s source param) Modifiers are not allowed on constants for ps_1_x.
Invalid reg type (%s source param).
Src reg for tex* instruction must be t# register (%s source param).
_bx2 is a valid src mod for texM* instructions only (%s source param).
Invalid reg num %d (%s source param).  Max allowed for this type is %d.
_bx2 cannot be used on src register for texbem or texbeml instructions.
_bx2 cannot be used on src register for texreg2ar or texreg2gb instructions.
Source swizzle not allowed for tex* instruction (%s source param).
Invalid src mod for tex* instruction (%s source param).
Invalid reg num: %d for %s source param. Max allowed for this type is %d.
Invalid reg type for %s source param.
Invalid src mod for %s source param.
For ps_1_2 or ps_1_3, the cmp or dp4 instructions cannot have a source register the same as the destination register.
Invalid src swizzle for %s source param.
Src selector .b (%s source param) is only valid for instructions that occur in the alpha pipe.
When using the bias source modifier on a register, the previous writer should apply the saturate modifier. This would ensure consistent behaviour across different hardware. Affected components(*) of %s source param: %s
Cannot apply a negation source modifier on data that was last written with the saturate destination modifier. Affected components(*) of %s source param: %s
, texm3x2depth
When using the complement source modifier on a register, the previous writer should apply the saturate destination modifier. This would ensure consistent behaviour across different hardware. Affected components(*) of %s source param: %s
Texture register result of texbem or texbeml instruction must not be read by tex* instruction. Affected components(*) of %s source param: %s
Texture register result of texkill%s or texm*pad instructions must not be read. Affected components(*) of %s source param: %s
Multiple dependent texture reads are disallowed (%s source param).  Texture read results can be used as an address for subsequent read, but the results from that read cannot be used as an address in yet another subsequent read.
Register data that has been read by a texbem or texbeml instruction cannot be read later, except by another texbem/l.
Invalid reg type for dest param.
Read of uninitialized component%s(*) in %s%d: %s
Destination of texm3x2depth instruction (t%d) is not available elsewhere in shader.
Invalid dest reg num: %d. Max allowed for this reg type is %d.
tex* instructions must write all components.
Must use texture register a dest param for tex* instructions.
Dest shift not allowed for tex* instructions.
Instruction modifiers are not allowed for tex* instructions.
Invalid dst shift.
Invalid dst modifier.
%d different temp registers (r#) read by instruction.  Max. different temp registers readable per instruction is %d.
Dest write mask must be .rgb, .a, or .rgba (all).
%d different constant registers (c#) read by instruction.  Max. different constant registers readable per instruction is %d.
%d different input registers (v#) read by instruction.  Max. different input registers readable per instruction is %d.
%d different temp registers (r#) read over 2 co-issued instructions. Max. different register numbers from any one register type readable across co-issued instructions is %d.
%d different texture registers (t#) read by instruction.  Max. different texture registers readable per instruction is %d.
%d different constant registers (c#) read over 2 co-issued instructions. Max. different register numbers from any one register type readable across co-issued instructions is %d.
%d different input registers (v#) read over 2 co-issued instructions. Max. different register numbers from any one register type readable across co-issued instructions is %d.
Tex register t%d already declared.
%d different texture registers (t#) read over 2 co-issued instructions. Max. different register numbers from any one register type readable across co-issued instructions is %d.
Cannot use tex* instruction after non-tex* instruction.
t# registers must appear in sequence (i.e. t0 before t2 OK, but t1 before t0 not valid).
Invalid texm* sequence.
Incomplete texm* sequence.
First source for cnd instruction must be 'r0.a'.
Invalid texm* register.
The only valid modifiers for the first source parameter of lrp are: reg (no mod) or 1-reg (complement).
Maximum of 3 cmp instructions allowed.
Const declaration (def) must appear before other instructions.
Previous writer to the first source register of lrp instruction should apply the saturate destination modifier.  This ensures consistent behaviour across different hardware. Affected components(*) of first source register: %s
Invalid const register num: %d. Max allowed is %d.
Destination for def instruction must be of the form c# (where # = reg number). In addition there may be no mask (equivalent to full .xyzw, which is fine).
Dest write mask must be .rgb, or .rgba (all) for dp3.
c%d already def'd in the shader. 
First arithmetic instruction cannot have co-issue ('+') set; there is no previous arithmetic instruction to pair with.
Maximum of 4 dp4 instructions allowed.
Cannot set co-issue ('+') on consecutive instructions.
Cannot set co-issue ('+') on a texture instruction.  Co-issue only applies to arithmetic instructions.
nop instruction cannot be co-issued.
(previous instruction) nop instruction cannot be co-issued.
dp4 instruction cannot be co-issued.
(previous instruction) dp4 instruction cannot be co-issued.
(previous instruction) Dot-product needs color/vector pipeline to execute, so instruction co-issued with it cannot write to color components.
Co-issued instructions cannot both be dot-product, since each require use of the color/vector pipeline to execute.
Dot-product needs color/vector pipeline to execute, so instruction co-issued with it cannot write to color components.
Dot-product which writes alpha cannot co-issue, because both alpha and color/vector pipelines used.
(previous instruction) Co-issued instruction cannot write all components - must write either alpha or color.
(previous instruction) Dot-product which writes alpha cannot co-issue, because both alpha and color/vector pipelines used by the dot product.
Co-issued instructions cannot both write to the same components of a register.  Affected components: %s
Co-issued instruction cannot write all components - must write either alpha or color.
Co-issued instructions cannot both write to alpha component.
Co-issued instructions cannot both write to color components.
Too many arithmetic instruction slots used: %d. Max. allowed (counting any co-issued pairs as 1) is %d.
Too many texture addressing instruction slots used: %d. Max. allowed is %d. (Note that some texture addressing instructions may use up more than one instruction slot)
r0 must be written by shader. Uninitialized component%s(*): %s
Total number of instruction slots used too high: %d. Max. allowed (counting any co-issued pairs as 1) is %d.
Instruction not supported by version %s shader.
Version Token: Shader version %s is not supported by device. 
(First source param) 
(Source param) 
(Third source param) 
(Second source param) 
%sSource register type must be texture coordinate input (t#) for texcrd instruction.
%sModifiers are not allowed on constants for ps_1_4.
%sInvalid register number: %d.  Max allowed for this type is %d.
%sSource register type must be temp (r#) or texture coordinate input (t#) for tex* instruction.
_dz(=_db) modifier on source param for texld must be paired with source selector .xyz(=.rgb). Note: Using no selector is treated same as .xyz here.
_dz(=_db) modifier on source param for texld only allowed if source is a temp register (r#).
_dw(=_da) modifier on source param for texld only allowed if source is a texture coordinate register (t#).
_dz(=_db) modifier cannot be used on source parameter for texcrd. It is only available to texld instruction, when source parameter is temp register (r#).
%sInvalid source modifier for tex* instruction.
_dw(=_da) modifier on source param must be paired with source selector .xyw(=.rga).
Using a texture coordinate register (t#) as source for texld requires component selector .xyw(=.rga), or .xyz(=.rgb). Note: Using no selector is treated same as .xyz here.
Source for texcrd requires component selector .xyw(==.rga), or .xyz(==.rgb). Note: Using no selector is treated same as .xyz here.
%sInvalid source selector for tex* instruction.
Using a temp register (r#) as source for texld requires component selector .xyz(==.rgb). Note: Using no selector is treated same as .xyz here.
%sTexture coordinate registers (t#) are not available to arithmetic instructions.
Texture coordinate register t%d read more than once in shader with different source selector (swizzle). Multiple reads of identical texture coordinate register throughout shader must all use identical source selector. Note this does not restrict mixing use and non-use of a source modifier (i.e. _dw/_da or _dz/_db, depending what the swizzle allows) on these coordinate register reads.
%sInvalid register number: %d. Max allowed for this type is %d.
%sInvalid register type.
%sInvalid source selector.
%sInvalid source modifier.
Read of uninitialized component%s(*) in %s%d: %s. Note that when texcrd is used with a .xy(==.rg) writemask, as it is in this shader, a side effect is that anything previously written to the z(==b) component of the destination r# register is lost and this component becomes uninitialized. In order to read blue again, write to it first. Also: Note that an unfortunate effect of the phase marker earlier in the shader is that the moment it is encountered in certain hardware, values previously written to alpha in any r# register, including the one noted here, are lost. In order to read alpha from an r# register after the phase marker, write to it first.
_dz(=_db) modifier may only be used at most 2 times in a shader.
Read of uninitialized component%s(*) in %s%d: %s. Note that when texcrd is used with a .xy(==.rg) writemask, as it is in this shader, a side effect is that anything previously written to the z(==b) component of the destination r# register is lost and this component becomes uninitialized. In order to read blue again, write to it first.
Read of uninitialized component%s(*) in %s%d: %s. Note that an unfortunate effect of the phase marker earlier in the shader is that the moment it is encountered in certain hardware, values previously written to alpha in any r# register, including the one noted here, are lost. In order to read alpha from an r# register after the phase marker, write to it first.
Invalid register type for destination param.
The current tex* instruction reads from %c%d, which was written earlier by another tex* instruction in the same block of tex* instructions.  Dependent reads are not permitted within a single block of tex* instructions.  To perform a dependent read, separate texture coordinate derivation from the tex* instruction using the coordinates with a 'phase' marker.
texcrd with _dw(=_da) source modifier must use .xy(=.rg) destination writemask.
Invalid destination register number: %d. Max allowed for this register type is %d.
texld/texkill/texdepth instructions must write all components.
texcrd must use .xyz(=.rgb) destination writemask.
Destination shift not allowed for tex* instructions.
Instruction modifiers not allowed for tex* instructions.
Invalid destination shift.
Invalid instruction modifier.
Register r%d (and thus texture stage %d) already used as a destination for a tex* instruction in this block of the shader. Reuse of a texture stage in ps_1_4 may only be accmplished by splitting the tex* ops across a phase marker.
%d different texture coordinate registers (t#) read by instruction.  Max. different texture registers readable per instruction is %d.
Multiple phase markers not permitted.  Aborting shader validation.
tex* instructions cannot be after arithmetic instructions within one phase of a ps_1_4 shader.  Each phase can have a block of tex* instructions followed by a block of arithmetic instructions. 
v# register read by instruction(s) before phase marker.  This is not permitted. When a phase marker is present, v# register reads are only permitted after the phase marker.
Earlier texld instruction used _dz(=_db) modifier on source param. When a phase marker is present, the _dz modifier is only permitted after the phase marker.
bem may only be used once in a shader.
When a phase marker is present in a shader, texkill is only permitted after the phase marker.
Writemask for bem must be '.rg'
bem can only be used before a phase marker (required) later in the shader.
Second source parameter for bem must be temp (r#) register.
First source parameter for bem must be temp (r#) or constant (c#) register.
Destination for texdepth must be r5.
Only one use of texdepth is permitted.
When a phase marker is present in a shader, texdepth is only permitted after the phase marker.
After texdepth instruction, r5 is no longer available in shader.
Phase marker cannot be co-issued.
Cannot set co-issue ('+') on a tex* instruction.  Co-issue only applies to arithmetic instructions.
Instruction cannot have co-issue ('+') set without a previous arithmetic instruction to pair with.
dp4 cannot be coissued.
%s phase marker cannot be co-issued.
(previous instruction)
%s nop cannot be co-issued.
%s def cannot be co-issued.
%s bem cannot be co-issued.
%s dp4 cannot be co-issued.
(previous instruction) dp3 needs color pipe to execute, so instruction co-issued with it cannot write to color components.
Co-issued instructions cannot both be dp3, since each require use of the color pipe to execute.
(previous instruction) dp3 which writes alpha cannot co-issue since it uses up both the alpha and color pipes.
dp3 which writes alpha cannot co-issue since it uses up both the alpha and color pipes.
Individual instruction in co-issue pair cannot write both alpha and color component(s).
(previous instruction) Individual instruction in co-issue pair cannot write both alpha and color component(s).
One of the instructions in a co-issue pair must write to alpha only (.a writemask).
Co-issued instructions cannot both write to the same component(s).  One instruction must write to alpha and the other may write to any combination of red/green/blue.  Destination registers may differ.
Cannot fit shader into length limits for target shader model (ps_1_4). 
Too many (%d) tex* instruction slots used before phase marker. Max. allowed in a phase is %d.
Too many (%d) tex* instruction slots used after phase marker. Max. allowed in a phase is %d.
Too many (%d) arithmetic instruction slots used before phase marker. Max. allowed in a phase (counting any co-issued pairs as 1) is %d.
Too many (%d) tex* instruction slots used. Max. allowed is %d. Note that adding a phase marker to the shader would double the number of instructions available.
Too many (%d) arithmetic instruction slots used after phase marker. Max. allowed in a phase (counting any co-issued pairs as 1) is %d.
r0 must be written by shader. Uninitialized component%s(*): %s. Note that when texcrd is used with a .xy(==.rg) writemask, as it is in this shader, a side effect is that anything previously written to the z(==b) component of the destination r# register is lost and this component becomes uninitialized. The blue component of r0 must to be written after the texcrd. Also: Note that an unfortunate effect of the phase marker in the shader is that the moment it is encountered in certain hardware, values previously written to alpha in any r# register, including r0, are lost. So after a phase marker, the alpha component of r0 must be written.
Too many (%d) arithmetic instruction slots used. Max. allowed (counting any co-issued pairs as 1) is %d. Note that adding a phase marker to the shader would double the number of instructions available.
r0 must be written by shader. Uninitialized component%s(*): %s. Note that when texcrd is used with a .xy(==.rg) writemask, as it is in this shader, a side effect is that anything previously written to the z(==b) component of the destination r# register is lost and this component becomes uninitialized. The blue component of r0 must to be written after the texcrd.
r0 must be written by shader. Uninitialized component%s(*): %s. Note that an unfortunate effect of the phase marker in the shader is that the moment it is encountered in certain hardware, values previously written to alpha in any r# register, including r0, are lost. So after a phase marker, the alpha component of r0 must be written.
ps_2_x extended instruction not supported by the hardware (static flow control not supported).
Version Token: Pixel shader version ps_2_sw is for software rasterizers only (e.g. the reference device). Aborting shader validation.
ps_2_x extended instruction not supported by the hardware (predication not supported).
ps_2_x extended instruction not supported by the hardware (gradient instructions not supported).
ps_2_x extended instruction not supported by the hardware (neither predication or static flow control supported).
ps_2_x extended instruction not supported by the hardware (dynamic flow control not supported).
Instruction not supported by version %s pixel shader.
(Fourth source param) 
First source parameter for texld can't specify min precision unless shader is from D3D10+ target.
First source parameter for texld must be temp (r#) or texture coordinate input(t#) register.
Second source parameter for texld must be sampler stage (s#).
Unrecognized min precision on source parameter.
Third and fourth parameters to texldd must be temp (r#), texture (t#), input (v#) or constant (c#) register.
Second source parameter for texld can't specify min precision.
Third or fourth parameter for texldd using unrecognized min precision.
Third and fourth parameter for texldd can't specify min precision unless shader is from D3D10+ target.
%sSource modifier not allowed for tex* instruction.
%sUnexpected source parameter.
%s instruction requires parameter to be label (l#). 
%sSource swizzles not allowed on tex* instruction.
breakp requires parameter to be predicate register (p0). 
label parameter doesn't allow min precision.
%s requires the first parameter to be a label (l#). 
predicate parameter doesn't allow min precision.
On current device, %s requires the condition%s parameter to be boolean constant register (b#). 
 (second)
%s requires the condition parameter%s to be boolean constant register (b#), or predicate register (p0). 
On current device, %s requires the condition%s parameter to be predicate register (p0). 
%s condition parameter%s can't specify min precision. 
%s requires the condition parameter%s to be boolean constant register (b#). 
rep doesn't allow min precision on parameter.
rep requires parameter to be integer constant register (i#). 
%sInvalid source register type for instruction.
Source parameter can't specify min precision unless shader is from D3D10+ target.
Cannot negate second source parameter to vector*matrix instructions.
%sRegister number: %d on this parameter for a matrix instruction causes attempt to access out of range register number %d. Max allowed for this type is %d.
%s%s requires replicate swizzle for this parameter in order to select component. i.e. .x | .y | .z | .w (or rgba equivalent)
Cannot use negate on source parameter(s) to %s instruction.
When predicate register is used as the condition for a %s instruction, a replicate swizzle must be specified, to select a component. i.e. .x | .y | .z | .w (or rgba equivalent)
Parameter(s) for %s instruction must specify default swizzle (.xyzw, or none specified.).  The exception is (on shader version > ps_2_0) if the condition is the predicate register, p0, in which case a replicate swizzle must be used in order to select a component. i.e. .x | .y | .z | .w (or rgba equivalent) 
Const bool (b#) parameter to %s instruction must specify default swizzle (.xyzw, or none specified.) 
Parameter(s) for %s instruction must specify default swizzle (.xyzw, or none specified.) 
Cannot swizzle second source parameter to vector*matrix instructions.
Predicate register (p0) parameter to %s instruction must specify replicate swizzle in order to select component. i.e. .x | .y | .z | .w (or rgba equivalent)
ps_2_0 does not support predication.
%sInvalid source selector: %s. The only available source swizzles in this shader version are: .rgba/xyzw (same as not specifying swizzle), .r/x, .g/y, .b/z, .a/w, .gbra/yzxw, .brga/zxyw and .abgr/wzyx. 
%s instruction cannot be predicated.
vs_2_x predication not supported by the hardware.
Source predicate p0 must use one of the following swizzles: .x | .y | .z | .w | .xyzw (same as swizzle not present)
Source predicate must be p0 register.
When writing to oDepth with predication, p0 must use a replicate swizzle to select a single component: .x | .y | .z | .w
The only modifier allowed for source predicate p0 is the not (!) modifier.
Component%s of register %s%d being read, but not declared. v# and t# registers must be declared using a dcl statement (down to the component level) in %s. Undeclared component%s(*) being read: %s
Sampler register s%d has not been declared.
Writemask cannot be empty.
Note that the %s component of %s%d was previously initialized, but then became uninitialized by a previous instruction (e.g. SINCOS clobbers components).
Dest parameter can't specify min precision unless shader is from D3D10+ target.
Min precision not allowed on predicate register.
texkill must write all components.
Unrecognized min precision on dest parameter.
Dest writemask for SINCOS must be .xy, .x or .y.
texld* must not specify a writemask (same as full mask). texld* instructions always write 4 components, including defaults if the source texture being sampled contains fewer than 4 components. 
_sat not permitted with frc instruction.
_sat not permitted on tex* instructions.
_sat not permitted with setp instruction.
_sat not permitted with SINCOS instruction.
Instruction shifts not permitted.
Instruction modifiers other than _sat or _pp not permitted. (_sat is permitted only on arithmetic ops, except frc or SINCOS)
xyzw (same as not specifying mask)
Dest register cannot be the same as first source register for m*x* instructions.
%s instruction must use destination writemask: .%s
Shader uses texture addressing operations in a dependency chain that is too complex for the target shader model (%s) to handle.  
Dest register for m*x* instructions cannot be the same as one of the additional registers implied by the second source register.
%d different input (v#) or texture (t#) registers read by instruction.  Max. different input/texture registers readable per instruction is %d.
Dependent tex-op sequence too long (%dth order). A 1st order dependent tex-op is a tex[ld*|kill] instruction in which either: (1) an r# reg is input (NOT t# reg), or (2) output r# reg was previously written, now being written AGAIN. A 2nd order dependent tex-op occurs if: a tex-op reads OR WRITES to an r# reg whose contents, BEFORE executing the tex-op, depend (perhaps indirectly) on the outcome of a 1st order dependent tex-op. An (n)th order dependent tex-op derives from an (n-1)th order tex-op. A given tex-op may be dependent to at most 3rd order (ps_2_0/x only).
%d constant registers (c#) read by instruction.  Max. constant registers readable per instruction (even if they are the same) is %d.  This is in addition to the read port limit of %d for constants, which restricts how many *different* constants can be read. (There is one exception: none of this applies to the SINCOS macro instruction.)
%d different constant registers (c#) read by instruction.  Max. different constant registers readable per instruction is %d.(There is one exception: this rule does not apply to the SINCOS macro instruction.)
Multiple input/texture registers cannot be read by a matrix op.
Multiple constant registers cannot be read by a matrix op.
dcl instruction is missing a parameter.
def and dcl instructions must appear before other instructions.
Invalid register number: %d. Max allowed for %s# register is %d.
Invalid register type for dcl.  Must be t#, v# or s#.
Register %s%d has already been declared.
Min precision not allowed on dest parameter.
dcl %s# must have one of the following masks: x, xy, xyz or xyzw (alternatively: r, rg, rgb, or rgba).
dcl %s# does not support any modifiers.
dcl %s# must be one of the following types: dcl_2d, dcl_cube or dcl_volume.
dcl %s# only supports the _centroid modifier (optional hint), and/or _pp modifier (partial precision hint). No other modifiers supported.
dcl %s# does not support any modifiers. 
dcl %s# must not specify a writemask (equivalent to a full mask). When samplers are used for texture lookup, 4 components are always returned, including defaults for components that may not be present in the texture format set at the sampler. 
def or dcl instructions must appear before other instructions.
dcl must specify non-empty mask.
Invalid constant integer (i#) register num: %d. Max allowed is %d.
Destination for defi instruction must be i# register (where # = reg number). In addition there may be no mask (equivalent to full .xyzw, which is fine).
i%d.x (which represents rep iteration count) cannot be greater than %d. i%d.x is currently def'd as %d. 
i%d.x (which represents rep iteration count) cannot be negative. i%d.x is currently def'd as %d. 
i%d already def'd in the shader. 
i%d.yzw have no meaning in this shader model; they must simply be 0. 
Invalid constant bool (b#) register num: %d. Max allowed is %d.
Destination for defb instruction must be b# register (where # = reg number). In addition there may be no mask (equivalent to full .xyzw, which is fine).
b%d already def'd in the shader. 
b%d must only be defined as true (0x00000001) or false (0x00000000). 
Dest writemask for NRM must be .xyzw (default) or .xyz (or equivalent rgba notation)
Src and dest registers for NRM cannot be the same.
Swizzle not permitted on source parameters to CRS.
Dest register for CRS cannot be the same as a source register.
Dest register for POW cannot be the same as second source register.
Write mask for CRS must be one of: .x | .y | .z | .xy | .xz | .yz | .xyz (or rgba equivalent)
Dest register for SINCOS cannot be the same as first source register.
Dest register for LRP cannot be the same as first or third source register.
Third source parameter for SINCOS must be a constant register.
Second source parameter for SINCOS must be a constant register.
Source selector for first source parameter for SINCOS must be .x, .y, .z or .w.
Second and third source parameters for SINCOS cannot be the same constant register.
Second and third source parameters for SINCOS must use default swizzle (no swizzle specified, or .xyzw). 
Second and third source parameters for SINCOS cannot have a modifier.
Co-issue ('+') is not supported in this shader version.
Third source parameter for dp2add must use a replicate swizzle (.r, .g, .b, .a) to select a scalar component.
When a %s shader writes to oCn, it must write to all of oC(n-1) down to oC0 (no gaps).
Pixel shader must minimally write to oC0 (with a mov instruction).
Source parameter for instruction writing to oCn cannot use a modifier.
oCn registers may only be written using the mov instruction.
Write to oCn register cannot use _sat instruction modifier.
Source parameter for instruction writing to oCn cannot use swizzles.
oC%d already written. (oCn registers can only be written at most once each)
Write to oCn register must use full writemask (equivalent to not specifying writemask at all).
Source parameter for instruction writing to oDepth cannot use a modifier.
oDepth may only be written using the mov instruction.
Write to oDepth register cannot use _sat instruction modifier.
Source parameter for instruction writing to oDepth must use a replicate source swizzle. i.e.: .x | .y | .z | .w or .r | .g | .b | .a.  This identifies the scalar component of the source to send to oDepth.
oDepth already written.
Write to oDepth register must not specify any writemask. (Note, this is equivalent to using a full writemask) oDepth is a scalar output, however a specific rgba/xyzw channel does not apply; the writemask is meaningless. 
Subroutine label #%d never referenced.
Subroutine with label #%d called, but never defined.
End of shader reached and rep construct was not completed with an endrep. 
End of shader reached without 'ret' to terminate subroutine.
Subroutine label number, %d, is too large. Maximum label number is %d. Aborting shader validation.
End of shader reached and 'if' construct was not completed with 'else'/'endif'. 
Cannot call subroutine label defined earlier in shader (label #%d in this case).  Subroutine call must reference label defined later in shader. Aborting shader validation. 
Subroutine label number: %d already defined earlier. Aborting shader validation.
Label is defined inside a subroutine or main program. Label must follow the ret instruction. Aborting shader validation. 
'label' is only permitted directly after a 'ret' instruction. Aborting shader validation. 
Depth of dynamic 'if' nesting exceeds limit of %d (callnz with predicate counts as a dynamic 'if' nesting level). Aborting shader validation. 
Compiled code results in dynamic flow control nesting depth that exceeds limit of %d for target (%s). 
Depth of subroutine call nesting exceeds limit of %d. Aborting shader validation. 
Compiled code results in subroutine call nesting depth that exceeds limit of %d for target (%s). 
'ret' instruction not permitted from inside any flow control block. Aborting shader validation. 
Out of memory. Aborting shader validation. 
Depth of loop nesting exceeds limit of %d. Aborting shader validation. 
Compiled code results in loop nesting depth that exceeds limit of %d for target (%s). 
Compiled code results in dynamic 'if'/'endif' nesting depth that exceeds limit of %d for target (%s). 
'endrep' instruction does not match up to a 'rep'. Aborting shader validation. 
Compiled code results in static 'if'/'endif' nesting depth that exceeds limit of %d for target (%s). 
Depth of dynamic 'if' nesting exceeds limit of %d. Aborting shader validation. 
'endif' instruction does not match up to an 'if' or 'else'. Aborting shader validation. 
Depth of static 'if' nesting exceeds limit of %d. Aborting shader validation. 
'else' already used for current 'if' construct. Aborting shader validation. 
'else' instruction does not match up to an 'if'. Aborting shader validation. 
Depth of dynamic 'if' nesting exceeds limit of %d, due to break_cmp that counts towards same limit. Aborting shader validation. 
Compiled code results in dynamic 'if'/'endif' nesting depth that exceeds limit of %d for target (%s) (due to conditional break that counts towards the same limit). 
A 'ret' instruction must be followed by either (1) the end of the shader or (2) a 'label' instruction. Aborting shader validation.
'break' instruction not within a local rep/endrep construct. Aborting shader validation. 
Compiled shader code has has many operations that use the texture unit (%d). Max. allowed by the target (%s) is %d.
texld/texldb/texldp/dsx/dsy instructions with r# as source cannot be used inside dynamic conditional 'if' blocks, dynamic conditional subroutine calls, or rep with break*. 
Compiled shader code uses too many arithmetic instruction slots (%d). Max. allowed by the target (%s) is %d. Consider increasing optimization level to reduce instruction count.
Too many (%d) tex* instruction slots used. Max. allowed is %d.
Compiled shader code uses too many instruction slots (%d). Max. allowed by the target (%s) is %d.
Too many (%d) standard (non tex*) instruction slots used. Max. allowed is %d.
Too many (%d) total instruction slots used. Max. allowed is %d.
comment
break_cmp
if_cmp
texcoord/texcrd
texld[b|p]*
Version Token: Pixel shader version ps_3_sw is for use with software rasterizers only (e.g. the reference device). Aborting shader validation.
%s requires %s parameter to be label (l#). 
fourth
loop requires first parameter to be loop counter (aL). 
%s requires second source parameter (the condition) to be boolean constant register (b#), or predicate register (p0). 
%s requires parameter (the branch condition) to be boolean constant register (b#), or predicate register (p0). 
%s requires %s parameter to be integer constant register (i#). 
Source modifier not allowed on sampler (s#) parameter to texld* instruction.
First source parameter for texld* must be temp (r#), input (v#) or constant (c#) register.
Third and fourth parameters to texldd must be temp (r#), input (v#) or constant (c#) register.
Second source parameter for texld* must be sampler stage (s#).
(%s source param) Invalid register number: %d.  Max allowed for this type is %d.
Unexpected source parameter.
Invalid reg num for MISCTYPE.
(%s source param) Negate or abs modifiers not permitted on source parameters to texld*
Relative address register must be aL register (%s source param).
Relative addressing only permitted on input (v#) registers (%s source param).
vFace or vPos registers cannot be used as sources for matrix operations.
Invalid register number, %d, specified for aL register. Max # supported is %d (%s source param).
Cannot use abs on source parameter(s) on to vFace register.
Reg num: %d for %s source param on matrix instruction causes attempt to access out of range register number %d. Max allowed for this type is %d.
Cannot use negate or abs on source parameter(s) to %s instruction.
Cannot use negate or abs on second source parameter to vector*matrix instructions.
vFace register can only be used as one of the sources to if_(cond), break_(cond), setp_(cond), or the condition in a cmp.
vFace register must not specify a swizzle (i.e. default swizzle), as it is an implied scalar.
%s requires replicate swizzle for source parameter(s) in order to select component. i.e. .x | .y | .z | .w (or rgba equivalent)
%s requires replicate swizzle for source parameter(s) in order to select component. For the vPos register, this can either be .x or .y (z,w are not available). 
aL can only be referenced in the following scenarios: (1) inside a loop/endloop block, or (2) in a subroutine for which in all cases some call below in the stack is in a loop/endloop block. 
Parameter(s) for %s instruction must specify default swizzle (.xyzw, or none specified.).  The exception is if the condition is the predicate register, p0, in which case a replicate swizzle must be used in order to select a component. i.e. .x | .y | .z | .w (or rgba equivalent)
Component(s) of register vPos being read, but not declared. vPos must be declared using a dcl statement. Affected components (*): %s
Component%s of register %s%d being read, but not declared. v# registers must be declared using dcl statement(s) (down to the component level). Affected components (*): %s
vFace being read, but not declared. vFace must be declared if it is used:  dcl vFace
vPos does not have .z or .w channels in this shader model. Attempt to read following unavailable component(s) (*): %s
The only instruction allowed to write to the predicate register is setp.
_centroid flag only permitted on dcl v# statements.
Absolute and relative addressing of input registers cannot be combined in one instruction.
The setp instruction must write to the predicate register.
When constant registers are read multiple times in a single instruction, the _abs modifier must either be present on all of the constants, or none of them. 
Different relative addressing of input registers cannot be combined in one instruction.
Multiple input registers cannot be read by a matrix op.
%d different input registers (v*#) read by instruction.  Max. different input registers readable per instruction is %d.
dcl can't specify empty writemask.
Invalid register type for dcl.  Must be input register (v#), sampler (s#), position (vPos) or face (vFace).
dcl %s# only supports the (optional) _pp modifier (partial precision hint), and/or the _centroid modifier (relevant to multisampling). No other modifiers supported.
dcl for %s register does not support any modifiers. 
dcl %s# must not specify a writemask (equivalent to a full mask). 
Sampler %s%d already declared. 
Unrecognized usage type in dcl statement.
Declaration for register %s%d overlaps previous declaration for the following component(s) of the same register (*): %s
When multple usages are declared for various components of a given input v# register, the _centroid hint can only be specified on either (a) all usages declared for the register, or (b) on none of them.  Also note that the usage 'color' (with any index) has special behavior: even if the centroid hint is not specified for color, it is assumed to be set. 
dcl usage index, %d, is too high.  Max allowed is %d.
dcl for input v# register must specify usage+index (semantic). i.e. dcl_texcoord5 v%d. Note that the semantics position0, positiont0, psize0, tessfactor(n) and sample(n) are not permitted.
dcl usage+index psize0 cannot be used in a pixel shader.
dcl usage 'tessfactor' is not avaliable to the pixel shader. 
dcl usage+index positiont0 cannot be used in a pixel shader.
dcl usage+index: %s,%d has already been specified for an input register.
dcl usage 'sample' is not avaliable to the pixel shader. 
z or w components of vPos register are not available in this shader version, and cannot be dcl'd.
%s register already declared.
i%d.x (which represents loop or rep iteration count) cannot be greater than %d. i%d.x is currently def'd as %d. 
i%d.x (which represents loop or rep iteration count) cannot be negative. i%d.x is currently def'd as %d. 
i%d.z (which represents loop step value) must be in the range [-%d, %d]. i%d.z is currently def'd as %d. 
i%d.y (which represents loop initial value) must be in the range [0, %d]. i%d.y is currently def'd as %d. 
Swizzle not permitted on source paramters to CRS.
i%d.w has no meaning; it must simply be 0. 
oDepth may not be written by the %s instruction.
Dest for SINCOS must be a temp (r#) register.
Write to oDepth register must not specify any writemask. (Note, this is equivalent to using a full writemask) oDepth is a scalar output, however a specific rgba/xyzw channel does not apply -> the writemask is meaningless. 
When writing to oDepth, %s instruction must use replicate swizzle on source parameter(s), in order to select single component. i.e. .x | .y | .z | .w (or rgba equivalent)
'endloop' instruction does not match up to an 'loop'. Aborting shader validation. 
End of shader reached and '%s' construct was not completed with a '%s'. 
texld/texldb/texldp/dsx/dsy instructions with r# as source cannot be used inside dynamic conditional 'if' blocks, dynamic conditional subroutine calls, or loop/rep with break*. 
'break' instruction not within a local loop/rep construct. Aborting shader validation. 
Too many instruction slots (%d) used by shader. Max. allowed is %d.
Version token: 0x%x indicates a pixel shader.  Vertex shader version token must be of the form 0xfffe****.
vs_1_0 is no longer supported.  It turned out that vertex shader capable hardware will always support at least vs_1_1 (which is not as limited a model as vs_1_0 was). To convert a vs_1_0 shader up to vs_1_1, the only change needed is to make the version number 1_1. 
Version Token: 0x%x is invalid. Vertex shader version token must be of the form 0xfffe****. Aborting vertex shader validation.
%s requires replicate swizzle for the source parameter in order to select component. i.e. .x | .y | .z | .w (or rgba equivalent)
Version Token: Shader version %s is not supported. Aborting vertex shader validation.
Relative addressing of constant register must reference a0.x only.
Address mode must be absolute (%s source param).
Only the mov instruction is allowed to write to the address register.
Format for address register must be a0.x.
Dest shifts not allowed for vertex shaders.
Dst modifiers not allowed for vertex shaders.
%s instruction cannot write to scalar output registers (oFog, oPts).
Dest write mask cannot be empty.
When writing to scalar output register, %s instruction must use replicate swizzle on source parameter(s), in order to select single component. i.e. .x | .y | .z | .w (or rgba equivalent)
M*x* matrix instructions cannot write to scalar output registers (oFog, oPts).
The only valid write masks for the FRC instruction are .xy and .y.
Scalar output registers (oFog, oPts) must have full write mask.
Different relative addressing of constant registers cannot be combined in one instruction.
Absolute and relative addressing of constant registers cannot be combined in one instruction.
By the end of a vertex shader, any oTn register written must not have gaps in components, starting from x, in order xyzw. To satisfy this, oT%d requires writing of the additional component%s(*): %s 
Number of instruction slots used too high: %d. Max. allowed is %d.
Vertex shader must minimally write all four components (xyzw) of oPos output register.  Missing component%s(*): %s
Vertex shader must write all four components (xyzw) of oPos output register.
Version Token: Vertex shader version vs_2_sw is for software use only. Aborting shader validation.
vs_2_x extended instruction not supported by the hardware (predication not supported).
vs_2_x extended instruction not supported by the hardware (dynamic flow control not supported).
Predicate register read, but uninitialized. Note that the predicate register must be written by setp before it is used, and that flow control instructions invalidate the predicate register's contents. Affected components(*): %s
vs_2_0 does not support predication.
predicate doesn't allow min precision.
When writing to scalar output (oFog, oPts) with predication, p0 must use a replicate swizzle to select a single component: .x | .y | .z | .w
loop doesn't allow min precision on parameters.
%s requires second source parameter (the condition) to be boolean constant register (b#). 
%s requires parameter (the branch condition) to be boolean constant register (b#). 
loop/rep don't allow min precision on parameters.
Relative addressing only permitted on constant registers (%s source param).
%s condition parameter can't specify min precision. 
Invalid register number, %d, specified for a# (address) register. Max # supported is %d (%s source param).
Relative address register must be a# register or aL register (%s source param).
Parameter(s) for %s instruction must specify default swizzle (.xyzw, or none specified.).  The exception is (on shader version > vs_2_0) if the condition is the predicate register, p0, in which case a replicate swizzle must be used in order to select a component. i.e. .x | .y | .z | .w (or rgba equivalent) 
Cannot use negate on second source parameter to vector*matrix instructions.
Only the mova instruction is allowed to write to the address register.
Input register v%d was not declared with a dcl statement.  Attempt to read component%s(*): %s
Relative addressing of destination not permitted on destination in this shader model.
mova instruction can only write to the address register.
Destination for def instruction must be c# register (where # = reg number). In addition there may be no mask (equivalent to full .xyzw, which is fine).
Min precision not allowed on predicate/loop/addr register.
Dest register type for CRS must be temp (r#).
Dest register type for NRM must be temp (r#).
Dest register type for LRP must be temp (r#).
Dest register type for POW must be temp (r#).
First source param for SGN cannot be the same register as the second or third params.
Second and third source params for SGN must both be different temp (r#) registers.
Second source paramter for SINCOS must be a constant register.
Second and third source params for SGN cannot use a source selector, and cannot have a modifier. 
Dest register type for SINCOS must be temp (r#).
Third source paramter for SINCOS must be a constant register.
More than 2 constants (even identical ones) cannot be read by an instruction. (There is one exception: this rule does not apply to the SINCOS instruction.)
Dest mask for SINCOS must be one of: .x | .y | .xy 
%d different constant registers (c#) read by instruction.  Max. different constant registers readable per instruction is %d. (There is one exception: this rule does not apply to the SINCOS instruction.)
%d different input registers (v#) read by instruction.  Max. different input registers readable per instruction is %d. 
Too may static flow control instructions (%d) for this shader model.  Maximum allowed is %d. The shader instructions that count as 1 static flow control instruction each are: (1)call, (2)callnz (with static condition), (3)if (static branch), (4)else (paired with static if), (5)loop, (6)rep. 
Shader has too much flow control complexity for the target (%s). 
Compiled code results in subroutine nesting depth that exceeds limit of %d for target (%s). 
Version Token: Shader version %s is not supported. Aborting vertex shader validation. 
Version Token: Vertex shader version vs_3_sw is for software use only. Aborting shader validation.
Invalid register type for dcl.  Must be input register (v#), output register (o#) or sampler (s#).
Too many output registers declared (%d).  When no output register has been declared with the semantic 'psize0', %d o# registers are available.  When an o# register has been declared with the semantic 'psize0' (same as 'psize'), %d registers are available.
Input cannot be dcl'd with usage+index positiont0, as vertex data containing this semantic has special meaning to the API: skip vertex processing altogether.
dcl usage 'tessfactor' is not permitted for vertex shader input registers.
Vertex shader output dcl with usage 'tessfactor' must have usage index 0, and register must have .x write mask. This semantic is for special purpose use only: creating vertex data that is to be used with tesselation, where a scalar tessfactor is needed.  If you are not doing tesselation, do not bother using this semantic. 
Vertex shader output is not permitted to be dcl'd with the usage+index positiont0.
Output register cannot be dcl'd with usage 'sample'.
Output register dcl'd with usage+index psize0 takes as special meaning as a scalar, so no writemask must be specified (identical to full write mask). In addition, no other semantics may declared for the same output register as one assigned to psize0. 
Instruction not supported by this vertex shader version.
dcl usage+index: %s,%d has already been specified for an output register.
First source parameter for texldl must be temp (r#), input (v#) or const (c#) register.
When writing to scalar output (psize) with predication, p0 must use a replicate swizzle to select a single component: .x | .y | .z | .w
(%s source param) Source modifier not allowed on sampler (s#).
(%s source param) Source modifier not allowed on texcoord for texldl.
Relative addressing of source register only permitted on input (v#) and constant (c#) registers (%s source param).
Second source parameter for texldl must be sampler stage (s#).
Relative address for input (v#) can only be aL register (%s source param).
Relative address register for constant (c#) must be a# register or aL register (%s source param).
%s instruction does not support _sat modifier.
Attempt to read undeclared component%s of input register v%d (*): %s. Components of v# registers to be read must be declared by a dcl statement.
Relative addressing of destination only permitted on output registers (o#).
Invalid dst modifier for vertex shader.
When relative addressing of output o# registers is used, position0 must be declared in o%d only, psize0 (if present) must be declared in o%d only, and indexing from/into o%d, or o%d (psize0 case only) is undefined. Indexing into any other declared o# is fine. If relative addressing of o# is not used in the shader, these restrictions on register numbers do not apply. 
Relative addressing of o# register requires aL register.
M*x* matrix instructions cannot write to scalar output register.
%s instruction cannot write to scalar output register.
Attempt to write undeclared component%s of output register o%d (*): %s. Components of o# registers to be written must be declared by a dcl statement.
Scalar output register must have full write mask.
Compiled shader code uses too many instruction slots (%d). Max. allowed by the target (%s), including cap for instruction limit, is %d.
%d different constant registers (c#) read by instruction.  Max. different constant registers readable per instruction is %d. 
Compiled shader code uses too many instructions (%d). Max. allowed by the target (%s), including cap for instruction limit, is %d.
Reserved bit(s) set in instruction parameter token!  Aborting validation.
Bit 31 not set in dcl info token!  Aborting validation.
dcl instruction should have exactly 2 parameter tokens.  Aborting validation.
Reserved bit(s) set in dcl info token!  Aborting validation.
Reserved bit(s) set in destination parameter token!  Aborting validation.
Expected relative address token.  Aborting validation.
Reserved bit(s) set in source %d parameter token!  Aborting validation.
When aL is used as a relative address, it must not specify any swizzle, as it is a scalar register. Aborting validation.
Reserved bit(s) set in relative address token for source parameter %d!  Aborting validation.
Unexpected DWORD count for instruction.  Aborting validation.
Instruction length specified for instruction (%d) does not match the token count encountered (%d). Aborting validation.
Unrecognized instruction. Aborting pixel shader validation.
Unrecognized instruction. Aborting vertex shader validation.
dcl must specify full writemask in this shader version (same as not specifying mask) for %s# registers.
Invalid register type for dcl.  Must be input register (v#).
dcl usage: %s%d has already been specified.
dcl usage 'tessfactor' is not permitted for vertex input shaders.
Reserved bit(s) set in parameter %d source token!  Aborting validation.
Relative address must specify a single component selector (.x, .y, .z or .w) to indicate relative address component. Aborting validation.
D3DSerializeRootSignature: unsupported root signature version (%u)
Unsupported RangeType value %u (descriptor table slot [%u], root parameter [%u]).
Descriptor range (descriptor table slot [%u], root parameter [%u]) overlaps with another incompatible descriptor range.
NumDescriptors cannot be 0 (descriptor table slot [%u], root parameter [%u]).
Samplers cannot be mixed with other resource types in a descriptor table (root parameter [%u]).
Overflow for shader register range: BaseShaderRegister=%u, NumDescriptor=%u; (descriptor table slot [%u], root parameter [%u]).
Cannot append range with implicit lower bound after an unbounded range (descriptor table slot [%u], root parameter [%u]).
VERTEX
Overflow for descriptor range (descriptor table slot [%u], root parameter [%u])
DOMAIN
PIXEL
GEOMETRY
AMPLIFICATION
Root parameter [%u] specifies RegisterSpace=%#x, which is invalid since RegisterSpace values in the range [%#x,%#x] are reserved for system use.
Root parameter [%u] descriptor table entry [%u] specifies RegisterSpace=%#x, which is invalid since RegisterSpace values in the range [%#x,%#x] are reserved for system use.
(root parameter [%u], visibility %s)
(root parameter [%u], visibility %s, descriptor table slot [%u])
(root parameter[%u], visibility %s, descriptor table slot [%u])
(static sampler [%u], visibility %s)
Unsupported bit-flag set (root signature flags %x).
Shader register range of type %s %s overlaps with another shader register range %s.
D3D12_ROOT_SIGNATURE_FLAG_LOCAL_ROOT_SIGNATURE not supported if device does not support raytracing (root signature flags %x).
D3D12_ROOT_SIGNATURE_FLAG_LOCAL_ROOT_SIGNATURE combined with other flag(s) that don't make sense (root signature flags %x).
Local root signatures only support shader visibility flag D3D12_SHADER_VISIBILITY_ALL.  ShaderVisibility value: %u (root parameter [%u]).
Unsupported ShaderVisibility value %u (root parameter [%u]).
Descriptor range flags cannot specify more than one DESCRIPTOR_* flag at a time (descriptor range flags %x).
Unsupported bit-flag set (descriptor range flags %x).
Sampler descriptor ranges can't specify DESCRIPTORS_STATIC_KEEPING_BUFFER_BOUNDS_CHECKS, since there are no bounds to check (descriptor range flags %x).
Sampler descriptor ranges can't specify DATA_* flags since there is no data pointed to by samplers (descriptor range flags %x).
Descriptor range flags cannot specify DESCRIPTORS_VOLATILE with the DATA_STATIC flag at the same time (descriptor range flags %x). DATA_STATIC_WHILE_SET_AT_EXECUTE is fine to combine with DESCRIPTORS_VOLATILE, since DESCRIPTORS_VOLATILE still requires descriptors don't change during execution. 
Descriptor range flags cannot specify more than one DATA_* flag at a time (descriptor range flags %x).
Root descriptor flags cannot specify more than one DATA_* flag at a time (root descriptor flags %x).
Unsupported bit-flag set (root descriptor flags %x).
Unsupported ShaderVisibility value %u (static sampler [%u]).
Unsupported ParameterType value %u (root parameter %u)
Shader sampler descriptor range (BaseShaderRegister=%u, NumDescriptors=%u, RegisterSpace=%u) is not fully bound in root signature
Local root signatures only support shader visibility flag D3D12_SHADER_VISIBILITY_ALL.  ShaderVisibility value: %u (static sampler [%u]).
Shader SRV descriptor range (BaseShaderRegister=%u, NumDescriptors=%u, RegisterSpace=%u) is not fully bound in root signature
A Shader is declaring a resource object as a texture using a register mapped to a root descriptor SRV (ShaderRegister=%u, RegisterSpace=%u).  SRV or UAV root descriptors can only be Raw or Structured buffers.
A Shader is declaring a structured UAV with counter using a register mapped to a root descriptor UAV (ShaderRegister=%u, RegisterSpace=%u).  SRV or UAV root descriptors can only be Raw or Structured buffers.
A Shader is declaring a typed UAV using a register mapped to a root descriptor UAV (ShaderRegister=%u, RegisterSpace=%u).  SRV or UAV root descriptors can only be Raw or Structured buffers.
Shader CBV descriptor range (BaseShaderRegister=%u, NumDescriptors=%u, RegisterSpace=%u) is not fully bound in root signature
Shader UAV descriptor range (BaseShaderRegister=%u, NumDescriptors=%u, RegisterSpace=%u) is not fully bound in root signature
Shader has root bindings but root signature uses a DENY flag to disallow root binding access to the shader stage.
Static sampler: A NULL pSamplerDesc was specified.
Static sampler: Filter unrecognized.
Static sampler: MINIMUM or MAXIMUM filters not supported by the device. To see if the device supports this call CheckFeatureSupport with D3D12_FEATURE_D3D12_OPTIONS and check for TiledResourcesTier support of Tier 2+.
Static sampler: AddressV unrecognized.
Static sampler: AddressU unrecognized.
Static sampler: MipLODBias must be in the range [%f to %f].  %f specified.
Static sampler: AddressW unrecognized.
Static sampler: ComparisonFunc unrecognized.
Static sampler: MaxAnisotropy must be in the range [%d to %d].  %d specified.
MaxLOD be in the range [-INF to +INF].  %f specified.
Static sampler: MinLOD be in the range [-INF to +INF].  %f specified.
D3DSerializeRootSignature: unknown root parameter type (%u)
%s\%s
MostRecentApplication
RSDSD
D3DCompiler_47.pdb
.text$cthunks
.text$di
.text$mn
.text$mn$00
.text$src
.text$tii
.text$wti
.text$x
.text$yd
.rdata$brc
.idata$5
.00cfg
.CRT$XCA
.CRT$XCL
.CRT$XCU
.CRT$XCZ
.CRT$XIA
.CRT$XIC
.CRT$XIZ
.CRT$XPA
.CRT$XPZ
.CRT$XTA
.CRT$XTZ
.gehcont
.gfids
.giats
.rdata
.rdata$r
.rdata$voltmd
.rdata$zzzdbg
.rtc$IAA
.rtc$IZZ
.rtc$TAA
.rtc$TZZ
.xdata
.xdata$x
.edata
.idata$2
.idata$3
.idata$4
.idata$6
.data$brc
.data$r$brc
.data$rs$brc
.data
.pdata
.rsrc$01
.rsrc$02
D3DCOMPILER_47.dll
D3DAssemble
DebugSetMute
D3DCompile
D3DCompile2
D3DCompileFromFile
D3DCompressShaders
D3DCreateBlob
D3DCreateFunctionLinkingGraph
D3DCreateLinker
D3DDecompressShaders
D3DDisassemble
D3DDisassemble10Effect
D3DDisassemble11Trace
D3DDisassembleRegion
D3DGetBlobPart
D3DGetDebugInfo
D3DGetInputAndOutputSignatureBlob
D3DGetInputSignatureBlob
D3DGetOutputSignatureBlob
D3DGetTraceInstructionOffsets
D3DLoadModule
D3DPreprocess
D3DReadFileToBlob
D3DReflect
D3DReflectLibrary
D3DReturnFailure1
D3DSetBlobPart
D3DStripShader
D3DWriteBlobToFile
strncmp
_finite
strnlen
_controlfp
_clearfp
__isascii
_isnan
_initterm
_initterm_e
api-ms-win-crt-string-l1-1-0.dll
api-ms-win-crt-math-l1-1-0.dll
api-ms-win-crt-runtime-l1-1-0.dll
__CxxFrameHandler3
_o___acrt_iob_func
_o___std_type_info_destroy_list
_o___stdio_common_vfprintf
_o___stdio_common_vsnprintf_s
_o___stdio_common_vsnwprintf_s
_o___stdio_common_vsprintf
_o___stdio_common_vsprintf_s
_o___stdio_common_vsscanf
_o___stdio_common_vswprintf
_o___stdio_common_vswprintf_s
_o__atoi64
_o__callnewh
_o__cexit
_o__close
_o__configure_narrow_argv
_o__crt_atexit
_o__errno
_o__execute_onexit_table
_o__filelengthi64
_o__fpclass
_o__fullpath
_o__initialize_narrow_environment
_o__initialize_onexit_table
_o__invalid_parameter_noinfo
_o__lseeki64
_o__mbscmp
_o__mbstrlen
_o__memicmp
_o__open_osfhandle
_o__purecall
_o__read
_o__register_onexit_function
_o__seh_filter_dll
_o__strdup
_o__stricmp
_o__strnicmp
_o__strtoui64
_o__wcsdup
_o__wcsicmp
_o__wcsnicmp
_o__wdupenv_s
_o__wfsopen
_o__wfullpath
_o__wgetenv
_o__wmakepath_s
_o__wsplitpath_s
_o__wtoi
_o_acos
_o_asin
_o_atan
_o_atan2
_o_atof
_o_atoi
_o_bsearch
_o_calloc
_o_ceil
_o_cos
_o_cosh
_o_exp
_o_fclose
_o_fflush
_o_floor
_o_floorf
_o_fmod
_o_fread
_o_free
_o_fseek
_o_ftell
_o_getenv
_o_isalnum
_o_isalpha
_o_isdigit
_o_isspace
_o_isxdigit
_o_log
_o_malloc
_o_modf
_o_pow
_o_qsort
_o_setlocale
_o_sin
_o_sinh
_o_sqrt
_o_strcat_s
_o_strcpy_s
_o_strncpy_s
_o_strtod
_o_strtoul
_o_tan
_o_tanh
_o_terminate
_o_tolower
_o_toupper
_o_towlower
_o_wcscat_s
_o_wcscpy_s
_o_wcsncat_s
_o_wcsncpy_s
_o_wcstoul
strrchr
strchr
__C_specific_handler
__current_exception
__current_exception_context
memset
api-ms-win-crt-private-l1-1-0.dll
DisableThreadLibraryCalls
MultiByteToWideChar
WideCharToMultiByte
InitializeCriticalSection
DeleteCriticalSection
EnterCriticalSection
LeaveCriticalSection
OutputDebugStringA
HeapAlloc
GetProcessHeap
HeapFree
CreateFile2
GetLastError
GetFileSizeEx
ReadFile
CloseHandle
WriteFile
FreeLibrary
Sleep
TlsAlloc
TlsSetValue
HeapDestroy
TlsGetValue
TlsFree
GetFullPathNameW
GetFullPathNameA
GetEnvironmentVariableA
VirtualFree
VirtualAlloc
GetSystemInfo
GetProcAddress
LoadLibraryExW
RtlCaptureContext
RtlLookupFunctionEntry
RtlVirtualUnwind
UnhandledExceptionFilter
SetUnhandledExceptionFilter
GetCurrentProcess
TerminateProcess
IsProcessorFeaturePresent
IsDebuggerPresent
QueryPerformanceCounter
GetCurrentProcessId
GetCurrentThreadId
GetSystemTimeAsFileTime
InitializeSListHead
LocalAlloc
LocalFree
RegCloseKey
RegOpenKeyExW
UnmapViewOfFile
CreateFileW
GetFileSize
CreateFileMappingW
MapViewOfFile
SetLastError
LCMapStringW
GetFileAttributesW
SetFileAttributesW
DeleteFileW
GetFileType
SetEndOfFile
SetFilePointerEx
DeviceIoControl
InitializeCriticalSectionAndSpinCount
MapViewOfFileEx
UuidCreate
ExpandEnvironmentStringsW
RegQueryValueExW
api-ms-win-core-libraryloader-l1-2-0.dll
api-ms-win-core-string-l1-1-0.dll
api-ms-win-core-synch-l1-1-0.dll
api-ms-win-core-debug-l1-1-0.dll
api-ms-win-core-heap-l1-1-0.dll
api-ms-win-core-file-l1-2-0.dll
api-ms-win-core-errorhandling-l1-1-0.dll
api-ms-win-core-file-l1-1-0.dll
api-ms-win-core-handle-l1-1-0.dll
api-ms-win-core-synch-l1-2-0.dll
api-ms-win-core-processthreads-l1-1-0.dll
api-ms-win-core-processenvironment-l1-1-0.dll
api-ms-win-core-memory-l1-1-0.dll
api-ms-win-core-sysinfo-l1-1-0.dll
api-ms-win-core-rtlsupport-l1-1-0.dll
api-ms-win-core-processthreads-l1-1-1.dll
api-ms-win-core-profile-l1-1-0.dll
api-ms-win-core-interlocked-l1-1-0.dll
api-ms-win-core-heap-l2-1-0.dll
api-ms-win-core-registry-l1-1-0.dll
api-ms-win-core-localization-l1-2-0.dll
api-ms-win-core-io-l1-1-0.dll
RPCRT4.dll
CreateFileMappingA
api-ms-win-core-kernel32-legacy-l1-1-0.dll
wcsncmp
strcmp
__doserrno
_time64
strlen
api-ms-win-crt-time-l1-1-0.dll
memcpy
_CxxThrowException
strstr
__unDNameEx
memcmp
memmove
wcschr
__unDName
wcsrchr
HeapCreate
GetModuleFileNameA
CreateFileA
RegOpenKeyExA
RegEnumKeyExA
RegQueryValueExA
lstrcmpiA
api-ms-win-core-string-obsolete-l1-1-0.dll
CryptAcquireContextW
CryptReleaseContext
CryptGetHashParam
CryptCreateHash
CryptHashData
CryptDestroyHash
CRYPTSP.dll
.?AVtype_info@@
VS_VERSION_INFO
StringFileInfo
040904B0
CompanyName
Microsoft Corporation
FileDescription
Direct3D HLSL Compiler
FileVersion
10.0.22621.436 (WinBuild.160101.0800)
InternalName
d3dcompiler_47.dll
LegalCopyright
 Microsoft Corporation. All rights reserved.
OriginalFilename
d3dcompiler_47.dll
ProductName
Microsoft
 Windows
 Operating System
ProductVersion
10.0.22621.436
VarFileInfo
Translation
