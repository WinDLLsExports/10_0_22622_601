!This program cannot be run in DOS mode.
Rich;
.text
`.rdata
@.data
.pdata
@.didat
.rsrc
@.reloc
L$0H3
WAVAWH
A_A^_
|$ ATAVAWH
A_A^A\
pBSRb
t$ WH
l$ VH
qBSRb
\$ UVWH
pBSRb
UWATAVAWH
A_A^A\_]
UVWATAUAVAWH
pBSRb
pBSRb
A_A^A]A\_^]
pBSRb
VAVAWH
`A_A^^
UVWATAUAVAWH
`A_A^A]A\_^]
pBSRb
pBSRb
@USVWATAVAWH
L9|$h
pBSRb
pBSRb
A_A^A\_^[]
|$0E3
l$hI;
|$hI;
pBSRb
pBSRb
tK99tG
El$0I
t$hD9
p{[r7
pBSRb
d$xE3
H9|$h
p2^^0
D$(H;
M9l$ L
pBSRb
t$ WATAUAVAWH
A8~8u
mHE8~
A8~8u
m@A8F
E9~PweE9~Tv'
A_A^A]A\_
A8~8u
A8~8u
A8~8u
A8~8u
H9\$xt\
s WATAUAVAWH
A_A^A]A\_
D9'u.
pYQPR
WAVAWH
A_A^_
\$ UVWAVAWH
p{[r7
pBSRb
A_A^_^]
UVWATAUAVAWH
|$XE3
A_A^A]A\_^]
pBSRb
pBSRb
\$ VH
|$xH9
@SUATAVAWH
`A_A^A\][
`A_A^A\][
x AVH
s WATAVH
A^A\_
H!\$P
!\$8!\$0!\$(H
pBSRb
ATAUAVH
A^A]A\
UVWATAUAVAWH
pBSRb
pBSRb
A_A^A]A\_^]
pBSRb
pBSRb
pYQPR
@SUVWATAUAVAWH
pBSRb
pBSRb
A_A^A]A\_^][
pYQPR
pBSRb
WATAUAVAWH
phW^(
pBSRb
A_A^A]A\_
pBSRb
L$`H3
L$ E3
pYQPR
\$ UVWATAUAVAWH
A_A^A]A\_^]
L9d$`
WATAVH
A^A\_
@USVWATAUAVAWH
A_A^A]A\_^[]
D$pE3
WATAUAVAWH
pBSRb
A_A^A]A\_
UVWATAUAVAWH
A_A^A]A\_^]
@SUVWH
@SVATAUAWH
pBSRb
`A_A]A\^[
pBSRb
xpH9\$pti
pBSRb
@USWATAUAVAWH
\$ E3
A_A^A]A\_[]
D$0E3
\$(E3
t$ AVH
H9\$p
pBSRb
@UVWATAWH
pBSRb
pA_A\_^]
pA_A\_^]
@SUVWATAUAVAWH
l$`E3
D$PL9
A_A^A]A\_^][
L$pE3
L$ E3
@SVWH
@SUVWAUH
A]_^][
VWAVH
t$ WATAUAVAWH
D9yPtZM
A_A^A]A\_
D9|$0
D9{(H
@SUVAVAWH
`A_A^^][
`A_A^^][
`A_A^^][
pYQPR
pBSRb
pBSRb
pBSRb
pYQPR
pBSRb
@SVWH
@SWATAWH
hA_A\_[
phW^(
pYQPR
phW^(
phW^(
phW^(
WATAUAVAWH
A_A^A]A\_
WATAVH
A^A\_
pYQPR
VWATAUAWH
A_A]A\_^
|$ ATAVAWH
A_A^A\
l$ VWAWH
 A__^
H9\$p
qhW^(
{ AVH
H9t$p
pBSRb
VWAVH
 A^_^
\$ WH
t$xH9
{ ATAVAWH
A_A^A\
SUVWAWH
pBSRb
`A__^][
|$ ATAVAWH
L9c`L
A_A^A\
UVWATAUAVAWH
PA_A^A]A\_^]
p WATAUAVAWH
0A_A^A]A\_
WATAUAVAWH
0A_A^A]A\_
p WATAUAVAWH
fD9(t
 A_A^A]A\_
@USVWATAUAVAWH
xA_A^A]A\_^[]
s WATAVH
A^A\_
VWAVH
L97uXL93uSL
L97u L93u
WATAUAVAWH
A_A^A]A\_
P<3&A
WAVAWH
0A_A^_
s WAVAWH
A_A^_
WATAUAVAWH
A_A^A]A\_
x ATAVAWH
fD9$Zu
 A_A^A\
UVWATAUAVAWH
D$pD;
L$pE3
D$hL;
fD98t
A_A^A]A\_^]
D$0E3
D$ E3
D$ E3
{ AVH
WAVAWH
A_A^_
pBSRb
{ AVH
pBSRb
qSSP>>
{ ATAVAWH
A_A^A\
WATAUAVAWH
A_A^A]A\_
UWATAVAWH
tfL!3L
D!t$ L
A_A^A\_]
UATAUAVAWH
D$0E3
A_A^A]A\]
@USWH
WAVAWH
 A_A^_
x AVH
UVWATAUAVAWH
A_A^A]A\_^]
@SWATAUAVAWH
fD90t
A_A^A]A\_[
D$PE3
D$PH;
USVWATAUAVAWH
D$ E3
f94Au
D9ewtF
fC9D}
fE9|E
A_A^A]A\_^[]
UVWATAUAVAWH
A_A^A]A\_^]
@USVWATAUAVAWH
D$p9w<
A_A^A]A\_^[]
L$hE3
E@Etx
E`ZJU
E|o{!
L$hE3
p WATAUAVAWH
A_A^A]A\_
\$ E3
UATAUAVAWH
A_A^A]A\]
|$ UAVAWH
A_A^]
\$ E3
{ ATAVAWH
A_A^A\
p0URv
qc[^l
t$ WAVAWH
A_A^_
\$ UVWATAUAVAWH
\$ E3
A_A^A]A\_^]
[ UVWATAVH
`A^A\_^]
USVWATAVAWH
`A_A^A\_^[]
x AUAVAWH
A_A^A]
WAVAWH
!D$pI
A_A^_
;RSDS
|$ UATAUAVAWH
A_A^A]A\]
t+HcC<
D$(L+
pBSRb
pBSRb
q0URv
q{[r7
qhW^(
qYQPR
pBSRb
!t$8!t$0!t$(I
WAVAWH
A_A^_
phW^(
phW^(
phW^(
R$fA;Z*s
fA9Z*
p{[r7
WAVAWH
 A_A^_
{ AVH
s WAVAWH
@A_A^_
pBSRb
pYQPR
WAVAWH
fE9<Pu
 A_A^_
t$ WH
WAVAWH
H#L$XH
 A_A^_
\$ UVWATAUAVAWH
H9uou
H9uou
A_A^A]A\_^]
p{[r7
x AVH
SUVWATAUAVH
PA^A]A\_^][
WAVAWH
A_A^_
H9y`H
H9{0t
uRM9@
t1L9A
VWAVH
@A^_^
UATAUAVAWH
A_A^A]A\]
@SUVWATAUAVAWH
hA_A^A]A\_^][
WAVAWH
A_A^_
qiR^E
uv8Y9uq
\$(E3
UVWATAUAVAWH
L$ E3
A_A^A]A\_^]
WAVAWH
A_A^_
ATAVAWH
A_A^A\
pkP4V&
s WAVAWH
0A_A^_
H9A@t
WAVAWH
pBSRb
0A_A^_
pzRp?
x AVH
fD97t'H;
uRM9@
t1L9A
q0R^G'
D$HE3
\$ UH
 H3E H3E
oD$ f
oL$0f
oT$@f
o\$PH
oD$ f
oL$0f
oT$@f
o\$PH
oD$ f
oL$0f
oT$@f
o\$PH
oD$ f
oL$0f
oT$@f
o\$PH
qyV~j
qyV~j
qyV~j
qyV~j
oD$ f
oL$0f
oT$@f
o\$PH
L$PH3
L$`H3
UVWATAUAVAWH
fA9LE
fE9,Du
fE9,Gu
fE9,Fu
fD9lE
fD9,Fu
fD9,Gu
fE9,Pu
A_A^A]A\_^]
x AVH
p1Y\G
VWAVH
0A^_^
L$PH9
Tph6|
ph^PN
@USVWATAUAVAWH
L$XL9(L
|$0L9h
A_A^A]A\_^[]
L$(H9
pS]0<
VWATAVAWH
L!p H
Q^W?}
A_A^A\_^
VWAVH
<^\t*f
UVWAVAWH
Tph6|
Tph6|
pA_A^_^]
fA94Iu
f94Ku
fA94Ku
fA94Ju
f94Gu
fA9<Cu
fC9<Qu
fC9<Bu
fA9<Au
fC9<Bu
fA9<Au
UVWATAUAVAWH
t$0fA9?
A_A^A]A\_^]
q3Tv*
q[XTn?h
vH9k8tp
9k0viH
T$`E3
L$0H3
D$ E3
t$ WH
9{0v#H
@USVWAVAWH
A_A^_^[]
D$ 9\$ w
L$@H3
@SVWH
@SVWH
VWATAVAWH
0A_A^A\_^
UVWATAUAVAWH
pA_A^A]A\_^]
UVWATAUAVAWH
M9<$u
pBSRb
pBSRb
A_A^A]A\_^]
qhV6)'1
{ AVH
G(H;l
SUVWATAUAVAWH
HA_A^A]A\_^][
D$ E3
@USVWATAUAVAWH
A_A^A]A\_^[]
)D$0E
L$@H3
L$pH3
q2_pA
L$PH9
qcRPp
WAVAWH
A_A^_
q3S8j
@SUVWH
qA\Xp
D$ E3
qsP2q
@SUVWAVH
A^_^][
L$ SVWH
pBSRb
@SUVWAWH
L$xH3
A__^][
SUVWAWH
`A__^][
[ UVWATAVH
`A^A\_^]
[ UVWATAVH
`A^A\_^]
H;L$Hs
t$ WH
\$ UVWH
t)H9p
L$PH9
H9APt
D$ E3
ppYzS
L$`H3
D$pE3
L$pH3
D$DDtXH
L$ SVWAVH
8A^_^[
@SUVWH
CWudfIoStackLocation::GetReadParameters
Dereference of destroyed object
CTrackedObject::Release
FinalRelease incremented the refcount
minkernel\wdf\framework\umdf\driverhost\wudfhost\WudfIrp.h
CWudfIrp::~CWudfIrp
CTrackedObject::AddRef
Ref count went from 0 to 1
minkernel\wdf\framework\umdf\DriverHost\common\inc\private\TrackedObject.h
CWudfIoStack::Validate
minkernel\wdf\framework\umdf\driverhost\wudfhost\WudfIoStack.h
CWudfIoStack::GetStackLocation
TODO: Write something interesting here
ppCtx should not be NULL
CWudfIoStackLocationBase::GetCompletionRoutine
ppWudfIoCompletionRoutine should not be NULL
CWudfIrp::CWudfIrp
CWudfIrp::Initialize
Multiple initialization of IoStack object
minkernel\wdf\framework\umdf\driverhost\wudfhost\wudfiostack.cpp
CWudfIoStack::Initialize
CWudfIoIrp::CreateAndInitialize
File object is unexpectedly NULL
CWudfDeviceStack::AllocateIoIrp
ppIoIrp should not be NULL
minkernel\wdf\framework\umdf\driverhost\wudfhost\wudfdevice.cpp
CWudfDevice::_GetDeviceItf
CWudfDeviceStack::Forward
CWudfIoStack::Reinitialize
Trying to reinitialze with more stack locations than allocated
Trying to reuse stack which has not completed unwound
CWudfIoIrp::ReInitialize
Original file object can be NULL only for Create IRP
CWudfFileObj::Initialize
Device stack depth can't be 0
CWudfIoIrp::SetHostFileObject
SetHostFileObject can only be called for Create Irp
CWudfFileObj::PreallocateCleanupCloseIoIrp
LpcPort is NULL for non-driver created file
m_pOwnerIWudfDevice should not be NULL
pCompletionEvent should not be NULL
CWudfDeviceStack::ForwardAndWaitForCompletion
CWudfDriverCreatedFile::SendIrp
CWudfDriverCreatedFile::SendIrp should only be used with cleanup or close IRP
Cleanup IRP cannot be failed
pIrp should not be NULL
CWudfFileObj::AcquirePreallocatedIrp
kernelIrpPointer should not be NULL
ppHostFile should not be NULL
pFileNameBuffer shouldn't be NULL with non-zero length
K{/CWudfDeviceStack::CreateWdfFile
Underlying file hasn't been created
CWudfDriverCreatedFile::Close
Unexpected failure in QueryInterface
loggingCtx should not be NULL
Dequeue attempted when I/O count is already 0
minkernel\wdf\framework\umdf\driverhost\wudfhost\wudfdrivercreatedfile.cpp
CWudfDriverCreatedFile::DequeueIrpFromFileObject
pIWudfDevice should not be NULL
driverName should not be NULL
CWudfIoStack::OnCompletion
driverModuleInfo should not be NULL
CWudfDevice::_GetObjFromItf
CWudfDeviceStack::GetDriverModuleInfo
@CWudfIoStack::HasCompletionRoutines
CWudfPnpIrp::ForwardToRedirector
Cannot install completion callback for Remove IRP
deviceStack should not be NULL
deviceObjectPointer should not be NULL
@CWudfDriverCreatedFile::SetOwnerDevice
minkernel\wdf\framework\umdf\driverhost\wudfhost\wudfdrivercreatedfile.h
CWudfDeviceStack::AddToDeviceFileList
CWudfIoIrp::QueueOnTopmostFile
Closed file object used in setting file for next IRP stack location
CWudfDeviceStack::RemoveFromDeviceFileList
CWudfDeviceStack::DetermineMaxAndMinDriverVersions
m_MinDriverVersion is 0.0, but m_MaxDriverVersion is not.
CWudfDeviceStack::DetachDevice
m_TopDevice should not be NULL
UM Irp already in use
CWudfPnpIrp::AcquireRelease
CWudfDeviceStack::OnDispatchPnp
CLpcNotification::Message
ppAttachedIWudfDevice should not be NULL
CWudfDeviceStack::AttachDevice
marshaller should not be NULL
CWudfIoIrp::Init
CWudfDefaultDispatcher::DoWrite
minkernel\wdf\framework\umdf\driverhost\wudfhost\wudffileobj.cpp
File object not associated with device stack
CWudfFileObj::GetDeviceStack
Multiple initialization
CWudfRefCountedHandle::SetHandle
minkernel\wdf\framework\umdf\driverhost\wudfhost\WudfRefCountedHandle.h
Only Internal Ioctl can be passed to UsbDispatcher
pUmUrb should not be NULL
GetFileObjFromItf
CWudfNativeUsbDispatcher::SubmitUsbIo
IOCTL_INETRNAL_USB_SUBMIT_UMURB == dwIoctl
minkernel\wdf\framework\umdf\driverhost\wudfhost\wudfnativeusbdispatcher.cpp
pUmUrb->UmUrbHeader.Length == sizeof(_UMURB_BULK_OR_INTERRUPT_TRANSFER)
CWudfIoDispatcher::Dispatch
CWudfDefaultDispatcher::DoRead
minkernel\wdf\framework\umdf\driverhost\wudfhost\wudfdefaultdispatcher.cpp
pIoIrp should not be NULL
CWudfDefaultDispatcher::DoIoctl
GetIrpObjFromItf
CDispatcherFile::CDispatcherFile
IRP has NULL file object, but NULL file object support is not enabled for this device.
minkernel\wdf\framework\umdf\driverhost\wudfhost\WudfDefaultDispatcher.h
CWudfIrp::ProcessCompletion
pHostFileObj should not be NULL
CWudfIoIrp::CompleteHandlerPostAlpcReply
UMIrp != stored irp
CWudfFileObj::ReleasePreallocatedIrp
file handle is invalid
CWudfRefCountedHandle::Release
CWudfDefaultDispatcher::DoCreate
pUmUrb->UmUrbHeader.Length == sizeof(_UMURB_CONTROL_TRANSFER)
CWudfDeviceStack::ReadFromHardware
Unexpected failure
CWudfDeviceStack::SetPowerState
CWudfIoIrp::CompleteHandlerPreAlpcReply
Current IRP buffer was never retrieved, but request is returning data ... this is incorrect
Couldn't open kernel device object
minkernel\wdf\framework\umdf\driverhost\wudfhost\wudfdevstack.cpp
CWudfDeviceStack::SendFastIoToControlObject
Current IRP buffer != Original IRP buffer.  Someone did not properly restore the buffers
CWudfDeviceStack::PoFxActivateComponent
pUmUrb->UmUrbHeader.Length == sizeof(_UMURB_INTERFACE_INFORMATION)
CWudfDeviceStack::PoFxIdleComponent
CWudfDeviceStack::SubmitUsbIdleNotification
USB idle callback function/context being overwritten!
USB SS IOCTL completion function/context being overwritten!
.Only Read/Write/IoControl may be forwarded to Self Target
Cannot be at the bottom of the stack while sending to Self IO Target
CWudfDeviceStack::PrepareToForwardToSelf
CWudfIoStack::SetCompletionRoutine
CWudfIrp::SetCompletionRoutine
Cannot change device for a stack location
CWudfIoStackLocationBase::SetDevice
CWudfIoIrp::Dispatch
minkernel\wdf\framework\umdf\driverhost\wudfhost\wudfirp.cpp
FxIrp::GetIrpFromListEntry
CWudfIoDispatcher::MarkUmdfDriverInitiatedRequest
minkernel\wdf\framework\umdf\driverhost\wudfhost\WudfIoDispatcher.h
pTeb->ReservedForWdf should be NULL
pDevStack should be NULL
GetFileObjAndDevStackFromMessage
pDevStack should not be NULL
Reflector unexpectedly sent NULL create context
File Object for the stack location not set. Potentially because driver didn't forward Create to this layer.
CWudfFileObj::GetFrameworkFileObj
minkernel\wdf\framework\umdf\driverhost\wudfhost\wudffileobj.h
CWudfIoStackLocation::GetDeviceIoControlParameters
CWudfIoStackLocation::SetReadParameters
CWudfIoIrp::SetFileForNextIrpStackLocation
Invalid index into m_pDriverAndFxInfo
minkernel\wdf\framework\umdf\driverhost\wudfhost\wudfdevstack.h
CWudfDeviceStack::GetMessageDispatch
CWudfIoDispatcher::SetCancelCallback
minkernel\wdf\framework\umdf\driverhost\wudfhost\wudfiodispatcher.cpp
Caller should remove its cancel callback before forwarding the irp
reply message has to be of non-zero size
minkernel\wdf\framework\umdf\driverhost\wudfhost\um\wudflpcum.cpp
GetIoReplyMessageSize
m_pCurrentIWudfDevice should not be NULL
CWudfIrp::Forward
CWudfIoDispatcher::IoCompleted
CWudfIrp::SetContext
Invalid index for SetContext
CWudfIoStackLocation::SetDeviceIoControlParameters
CWudfDeviceStack::UnregisterTargetDeviceNotification
WUDF_TARGET_CONTEXT_INVALID != RegistrationID
pCallback should not be NULL
pRegistrationID should not be NULL
hTarget is not a valid handle
CWudfDeviceStack::SendMsgToControlObject
foundRegistration
CWudfDeviceStack::RegisterTargetDeviceNotification
CWudfDeviceStack::RequestPowerIrp
Fx is requesting a power IRP with an unexpected minor function
Dx-IRP completion function/context being overwritten!
CWudfDeviceStack::Initialize
HostProcessSharingEnabled
DeviceGroupId
%s\%s
CWudfDeviceStack::AllocateIfrMemory
Buffer should not be NULL
WudfCompatibilitySettings
minkernel\wdf\framework\umdf\driverhost\wudfhost\wudfloader.cpp
ServiceName should not be NULL
CWudfModuleInfo::_BuildDriverRegistryPath
D0-IRP completion function/context being overwritten!
CWudfDevStackTable::UpdateEnvironmentBlock
insufficient space in buffer to hold the device instance string - internal error.
ACTIVE_DEVICES
CWudfDeviceStack::~CWudfDeviceStack
Only driver created IRPs can be deallocated
CWudfIoIrp::Deallocate
CWudfModuleTable::LoadFrameworkAndDriver
WUDFx.dll
WUDFx
unknown
HostProcessDbgBreakOnDriverLoad
MaxThreadpoolThreadCount
SOFTWARE\Microsoft\Windows NT\CurrentVersion\WUDF\Services
non state changing
DriverList
SOFTWARE\Microsoft\Windows NT\CurrentVersion\WUDF\DebugMode
UmdfDispatcher
DllGetClassObject
System\CurrentControlSet\Control\Wdf\Umdf\Diagnostics
DbgPrintOn
WdfMajorVersion
m_FxModInfo should be NULL
FxModInfo should not be NULL
CWudfModuleInfo::SetFxModuleInfo
WUDFDiagnosticInfo
CWudfIoStackLocation::SetOtherParameters
CWudfDevice::~CWudfDevice
m_pAttachedWudfDevice should be NULL
minkernel\wdf\framework\umdf\driverhost\wudfhost\WudfDevice.h
CWudfIrp::GetContext
Invalid index for GetContext
CWudfIoStackLocation::GetOtherParameters
Unknown USB request passed to USB dispatcher
CWudfUsbDispatcher::SubmitUsbIo
minkernel\wdf\framework\umdf\driverhost\wudfhost\wudfusbdispatcher.cpp
pUmUrb->UmUrbHeader.Length == sizeof(_UMURB_PIPE_REQUEST)
pUmUrb->UmUrbHeader.Length == sizeof(_UMURB_INTERFACE_POLICY_REQUEST)
pUmUrb->UmUrbHeader.Length == sizeof(_UMURB_PIPE_POLICY_REQUEST)
pDeviceStack should not be NULL
ppRemoteDispatcher should not be NULL
CWudfRemoteDispatcher::Create
minkernel\wdf\framework\umdf\driverhost\wudfhost\wudfremotedispatcher.cpp
CWudfIoDispatcher::Create
Invalid argument
ppIoDispatcher should not be NULL
CWudfRemoteDispatcher::CreateRemoteDispatcher
ppDefaultDispatcher should not be NULL
CWudfDefaultDispatcher::Create
CWudfDefaultDispatcher::CreateDefaultDispatcher
ppDispatcher should not be NULL
dbghelp.dll
\WppRecorderUM.dll
CWudfFileObj::SetFrameworkFileObj
File Object for the stack location must not already be set
CWudfFileObj::~CWudfFileObj
CreateContext is not cleaned up
CWudfDevice::GetDeviceStackInterface
Device object not associated with device stack
CWudfIoStackLocation::SetCreateParameters
CWudfIoIrp::SetFrameworkFileObjectContext
CWudfIoIrp::GetFrameworkRelatedFileObjectContext
GetFrameworkRelatedFileObjectContext can only be called for Create Irp
CLpcNotification::ProcessCancelMessage
CWudfIrpTable::GetAndSetCancelRoutine
invalid arg ppWudfIrp
ppvObject should not be NULL
CWudfRemoteDispatcher::QueryInterface
CWudfIoDispatcher::QueryInterface
ppv is NULL
_CWudfIrp::RevertImpersonation
minkernel\wdf\framework\umdf\driverhost\wudfhost\wudfhostglobals.h
CWudfHostGlobals::ClearThreadTlsFlag
TlsSetValue failed
HOST_THREAD_IMPERSONATED not previous set
Invalid operation
.MyCWudfIoStackLocation::SetWriteParameters
m_ImpersonationDataValid should not be NULL
CWudfIrp::ImpersonateRequestorProcess
CWudfHostGlobals::SetThreadTlsFlag
CWudfDefaultDispatcher::QueryInterface
(unknown)
FileDescription
FileVersion
CompanyName
CWudfIoDispatcher::_CancelRoutine
MFgCWudfIoDispatcher::_CancelInternal
m_hFile == INVALID_HANDLE_VALUE
hFile != INVALID_HANDLE_VALUE
CWudfRemoteDispatcher::BindToHandle
CWudfDeviceStack::CloseFile
pHostFile should not be NULL
CloseFile called on non-driver created file
CWudfIrpT<class CWudfIoIrp,struct IWudfIoIrp2,struct _WUDFMESSAGE_IO_HEADER *,struct _WUDFMESSAGE_REPLY_HEADER *>::Cancel
Unexpected Condition
WudfMarshaller::Create
CWudfIoStackLocation::GetCreateParameters
CWudfDeviceStack::LoadDrivers
/bCWudfIoStackLocation::GetWriteParameters
Internal error: Client process was not retrieved properly
CWudfIrp::GetRequestorProcessId
ReleaseWait was already called
WudfHidMarshaller::OverrideTransferFlags
minkernel\wdf\framework\umdf\driverhost\wudfhost\wudfmarshaller.cpp
Unexpected IOCTL recieved
Ensure Flags Match
PPTP00
PPTP00
PPTP00-
IoEventPortName:
-IoCancelEventPortName:
-SystemEventPortName:
-HostGUID:
-NonStateChangingEventPortName:
PPTP00
PPTP00
PPTP00
PPTP00
PPTP00m
inkernel\wdf\framework\umdf\driverhost\wudfhost\WudfLoader.h
m_FxListEntry not empty
m_EntryList not empty
m_ClassListHead not empty
m_ModEntryPt should be NULL
CWudfModuleInfo::~CWudfModuleInfo
CWudfModuleInfo::Release
m_DriverObject->ThreadPoolGroup should not be NULL
CThreadpool::SetMinimumThreadCount
m_ThreadPool should not be NULL
minkernel\wdf\framework\umdf\driverhost\wudfhost\WudfThreadpool.h
Power IRP completion message arrvied for an unexpected minor function
CWudfDeviceStack::InvokePowerIrpCompletionCallback
Driver at this slot did not add a device to the stack.  Should not call VerifyAndAssignPTM in that case
OriginalValue parameter is not a valid value
NewValue parameter is not a valid value
CWudfDeviceStack::MergeIoTypeValues
CWudfDeviceStack::VerifyAndAssignPreferredTransferMode
R"USB SS idle callback reply ID being overwritten!
CWudfDeviceStack::InvokeUsbSSEventHandler
CWudfUsbDispatcher::QueryInterface
CWudfPnpIrp::Cancel
Cancellation of a PnP IRP other than wait-wake IRP is not supported
Expected Query or Set Information Request
CWudfDefaultDispatcher::SubmitQuerySetInformation
m_FxBindInfo should be NULL
BindInfo should not be NULL
CWudfModuleInfo::SetFxBindInfo
CWudfDeviceStack::CreateDeviceHelper
pMsgDispatch should not be NULL
ppWudfDevice should not be NULL
CWudfDevice::_CreateAndInitialize
CWudfDeviceStack::SignalUsbSSCallbackProcessingComplete
Invalid USB SS idle callback reply ID!
CWudfFileObj::UpdateKeepAliveCount
Over-decrementing file object keep alive count
minkernel\wdf\framework\umdf\driverhost\wudfhost\WudfTable.h
CWudfTable<class CWudfIrp>::~CWudfTable
CWudfTable<class CWudfDeviceStack>::~CWudfTable
HostProcessDbgBreakOnStart
CWudfTable<class CWudfModuleInfo>::~CWudfTable
RPCRT4.dll
api-ms-win-security-sddl-l1-1-0.dll
DEVOBJ.dll
WINUSB.DLL
dbghelp.dll
Invalid data in TLS
CWudfHostGlobals::IsThreadTlsFlagSet
-LifetimeId:
-DeviceGroupId:
-ImagePath:
-HostArg:
WudfDefaultDevicePool
WUDFTrace
WudfHost_ext_
\Drivers\UMDF\
?tEEt
Invalid parsing of module name
CWudfModuleInfo::_GetModuleNameFromImagePath
ModuleInfo contains invalid module name
CWudfModuleInfo::GetName
WUDFx02000
WUDFx02000.dll
ImagePath
ComCLSID
UMDF: About to unload module %S. Please clear any breakpoints using 
    bc "%.*S!*"
UMDF: About to unload module %S. Please clear any breakpoints.
CWudfModuleTable::FindModuleAndReference
*ppFxModInfo should not be NULL
\driverstore\
UMDF: Breaking on load of module %S
FxDriverEntryUm
FxFrameworkEntryUm
Microsoft_WDF_UMDF_Version
Driver is not using correct CLSID
CWudfModuleTable::LoadComponentAndCreateInstance
WUDFx%02d000
%s%02d%02d
Fm_FxModInfo should not be NULL
CWudfModuleInfo::GetFxModuleInfo
CWudfTable<class CWudfModuleInfo>::Insert
CWudfTable<class CWudfModuleInfo>::Remove
CThreadpool::SetMaximumThreadCount
WaitForMultipleObjects wait failed
CWaiterThreads::WorkerThread
minkernel\wdf\framework\umdf\driverhost\wudfhost\wudfwaiterthreads.cpp
Unexpected return from WaitForMultipleObjects
SetEvent m_ThreadsStoppingEvent failed
CWaiterThreads::StopWaitingOnHandle
WaitForSingleObject m_Threads failed
\QAGp}
Parameters\Wdf
TrackObjects
TrackRefCounts
MaxRefCountChangesTracked
MaxStackDepthTracked
Leaking host objects
CleanupObjectTracking
minkernel\wdf\framework\umdf\driverhost\wudfhost\wudfdiagnostic.cpp
%ProgramData%\Microsoft\WDF\
user-mode
user or kernel-mode
\\.\pipe\DriverTestSvc
io cancel
system
lpc should be NULL
CLpcNotification::CreateLpcAndThreads
minkernel\wdf\framework\umdf\driverhost\wudfhost\wudflpc.cpp
CWudfDeviceStack::ReleaseWait
Waiting for all refs to be released is taking a long time
CWudfDeviceStack::CreateDevice2
*ppIWudfDevice should not be NULL
CWudfDeviceStack::CreateDevice
CWudfDeviceStack::CreateWdfFileForOpenHandle
hFile is not a valid handle
Not all driver created files are closed, this maybe due to pending requests.
Trailing name count was less than WudfRefStringMax
WinUsb
NativeUSB
FileHandle
Having UMDF 2.0 and previous versions of UMDF drivers in same device stack is not supported. 
modInfo should not be NULL
modInfo->m_DriverObject should not be NULL
CWudfDeviceStack::InvalidateDeviceState
WW-IRP completion function/context being overwritten!
*pReferenceString == L'\0'
CWudfDeviceStack::CreateSymbolicLinkW
PreserveIrpCompletionStatusCompatibility
WudfPowerPolicySettings
IdleInWorkingState
CWudfDeviceStack::RegisterMultiTransportDispatcher
No more than one Driver in a stack can be multi-transport aware. Prior Driver: %ls This Driver: %ls
No more than one device in a stack can be the Power Policy Owner.
CWudfDeviceStack::SetPPO
pDeviceInterfaceGuid should not be NULL
CWudfDeviceStack::RegisterRemoteInterfaceNotification
An object should only have one outstanding Target Device Registration with the Device Stack
CWudfDeviceStack::CancelUsbSS
Unknown USB SS event sent to host!
Invalid device instance string
ReadWriteTransferMode
IoctlTransferMode
TransferModeMismatchReported
MappedSystemAddress should not be NULL
CWudfDeviceStack::MapIoSpace
Size should be > 0
MappedAddress should not be NULL
CWudfDeviceStack::UnmapIoSpace
CWudfDeviceStack::WriteToHardware
reqReply.RdInterruptContext should not be NULL
CWudfDeviceStack::InitializeInterrupt
CWudfDeviceStack::PoFxUnregisterDevice
CWudfDeviceStack::PoFxStartDevicePowerManagement
CWudfDeviceStack::PoFxCompleteDevicePowerNotRequired
CWudfDeviceStack::PoFxReportDevicePoweredOn
CWudfDeviceStack::PoFxSimulateDevicePowerRequiredInReflector
CWudfDeviceStack::PoFxSetDeviceIdleTimeout
CWudfDeviceStack::PoFxCompleteDirectedPowerDown
increment
decrement
Overflow in file object keep alive count
pDevice should not be NULL
pdwIndex should not be NULL
CWudfDeviceStack::GetDriverID
pReply should be NULL
CWudfIrpT<class CWudfIoIrp,struct IWudfIoIrp2,struct _WUDFMESSAGE_IO_HEADER *,struct _WUDFMESSAGE_REPLY_HEADER *>::CreateAndInitialize
Trying to make close/cleanup irp cancelable
CWudfIoIrp::SetCancelRoutine
Invalid operation: doesn't support cancel
CWudfIrp::SetCancelRoutine
CWudfIoStackLocation::GetQuerySetInformationParameters
Unexpected request type
CWudfIoStackLocation::SetQuerySetInformationParameters
CWudfIrp::PrepareToForwardToSelf
CWudfTable<class CWudfDeviceStack>::Insert
CWudfTable<class CWudfDeviceStack>::Remove
q7,.C0
Non Io message passed to CWudfIoIrp
unexpected type in CWudfIoIrp
Completing unknown type of IRP
UM irp not present in global table while attempting to remove it from the global table
CWudfIoStackLocation::SetFlushParameters
CWudfTable<class CWudfIrp>::Insert
CWudfTable<class CWudfIrp>::Remove
uGA non-io Irp passed to win32 dispatcher
CWudfDefaultDispatcher::SubmitIo
CWudfDefaultDispatcher::DoFlushBuffers
Query
CWudfUsbDispatcher::CreateUsbDispatcher
WINUSB.DLL
WinUsb_Free failed
CWudfUsbDispatcher::SubmitIo
Invalid type of Irp passed to USB dispatcher
pUmUrb->UmUrbHeader.Length == sizeof(_UMURB_SELECT_INTERFACE)
pUmUrb->UmUrbHeader.Length == sizeof(_UMURB_QUERY_PIPE)
pUmUrb->UmUrbHeader.Length == sizeof(_UMURB_GET_ASSOCIATED_INTERFACE)
pUmUrb->UmUrbHeader.Length == sizeof(_UMURB_HEADER)
pUmUrb->UmUrbHeader.Length == sizeof(_UMURB_DEVICE_INFORMATION)
pUmUrb->UmUrbHeader.Length == sizeof(_UMURB_DESCRIPTOR_REQUEST)
Overwriting create context
CWudfFileObj::SetCreateContext
`zCWudfWin32Dispatcher::CreateWin32Dispatcher
minkernel\wdf\framework\umdf\driverhost\wudfhost\wudfwin32dispatcher.cpp
ppWin32Dispatcher should not be NULL
CWudfWin32Dispatcher::Create
CWudfWin32Dispatcher::QueryInterface
CWudfWin32Dispatcher::SubmitIo
CWudfNativeUsbDispatcher::CreateNativeUsbDispatcher
ppNativeUsbDispatcher should not be NULL
CWudfNativeUsbDispatcher::Create
CWudfNativeUsbDispatcher::QueryInterface
CWudfNativeUsbDispatcher::SubmitIo
,pWudfDevice should not be NULL
CWudfDevice::AttachDevice
Yx[Only Read/Write/IOCTL can be passed to Remote Dispatcher
CWudfRemoteDispatcher::SubmitIo
WudfMarshaller::OverrideTransferFlags
Unexpected code path
WudfMarshaller::UpdateInformationForOutputBuffer
GetFileObjAndDevStackFromMessage called for an unexpected message type
GetIoReplyMessageSize called for non-io message
Unrecognized Pofx event received
COM pointer failed QI for its interface
0 != msg->InterfaceContext
0 != msg->TargetContext
CLpcNotification::InitializeDeviceStack
DebugModeFlags
DebugModeBinaries
RegCloseKey failed
CLpcNotification::GetDeviceStackConfiguration
SYSTEM\CurrentControlSet\Control\SafeBoot\Minimal
SYSTEM\CurrentControlSet\Control\SafeBoot\Network
CWudfIrpT<class CWudfPnpIrp,struct IWudfPnpIrp,struct _WUDFMESSAGE_IRP *,union _WUDFMESSAGE_PNP_REPLY_ALL *>::CreateAndInitialize
CWudfIrpT<class CWudfPnpIrp,struct IWudfPnpIrp,struct _WUDFMESSAGE_IRP *,union _WUDFMESSAGE_PNP_REPLY_ALL *>::Cancel
m_pMultiTransportDispatcher should not be NULL
CWudfDeviceStack::GetMultiTransportDispatcher
%s:%u(%S)
WdfCensusEvtLinkClientToCx
PartA_PrivTags
CxImageName
ClientImageName
ClientVersionMajor
ClientVersionMinor
ClientVersionBuild
Microsoft.Wdf.UMDF.Host
WUDFHost.pdb
.text
.text$di
.text$lp00SPGO
.text$mn
.text$mn$00
.text$x
.text$yd
.rdata$brc
.idata$5
.00cfg
.CRT$XCA
.CRT$XCU
.CRT$XCZ
.CRT$XIA
.CRT$XIZ
.gehcont
.gfids
.giats
.rdata
.rdata$voltmd
.rdata$zETW0
.rdata$zETW1
.rdata$zETW2
.rdata$zETW9
.rdata$zzzdbg
.xdata
.didat$2
.didat$3
.didat$4
.didat$6
.didat$7
.didat$8
.edata
.idata$2
.idata$3
.idata$4
.idata$6
.data$brc
.data
.pdata
.didat$5
.rsrc$01
.rsrc$02
UuidFromStringW
ConvertStringSidToSidW
DevObjCreateDeviceInfoList
DevObjGetClassDevs
DevObjEnumDeviceInfo
DevObjGetDeviceRegistryProperty
DevObjDestroyDeviceInfoList
DevObjGetDeviceInstanceId
DevObjOpenDevRegKey
WinUsb_ControlTransfer
WinUsb_ReadPipe
WinUsb_WritePipe
WinUsb_SetCurrentAlternateSetting
WinUsb_GetCurrentAlternateSetting
WinUsb_SetPipePolicy
WinUsb_GetPipePolicy
WinUsb_AbortPipe
WinUsb_ResetPipe
WinUsb_FlushPipe
WinUsb_SetPowerPolicy
WinUsb_GetPowerPolicy
WinUsb_QueryDeviceInformation
WinUsb_GetDescriptor
WinUsb_Initialize
WinUsb_Free
WinUsb_QueryPipe
WinUsb_GetAssociatedInterface
WinUsb_QueryInterfaceSettings
ImageDirectoryEntryToDataEx
WUDFHost.exe
Microsoft_WDF_UMDF_Version
wcsncmp
_wcsnicmp
wcstoul
_wcsicmp
_vsnwprintf_s
__C_specific_handler
wcscpy_s
wcsncpy_s
wcsstr
_vsnprintf_s
wcscat_s
wcsrchr
api-ms-win-core-crt-l1-1-0.dll
_purecall
_initterm_e
_initterm
__dllonexit3
_onexit
api-ms-win-core-crt-l2-1-0.dll
__wgetmainargs
DbgPrintEx
RtlInitUnicodeString
RtlNtStatusToDosError
RtlVerifyVersionInfo
VerSetConditionMask
RtlSetIoCompletionCallback
NtQueryInformationFile
NtSetInformationFile
RtlCaptureContext
RtlLookupFunctionEntry
RtlVirtualUnwind
ntdll.dll
TraceMessage
TlsFree
TlsAlloc
GetLastError
TlsSetValue
GetOsSafeBootMode
TlsGetValue
GetTraceLoggerHandle
GetTraceEnableLevel
GetTraceEnableFlags
RegisterTraceGuidsW
UnregisterTraceGuids
EventUnregister
EventRegister
EventSetInformation
EventWriteTransfer
HeapSetInformation
GetSystemDirectoryW
CoInitializeEx
CoUninitialize
InitializeCriticalSectionAndSpinCount
LeaveCriticalSection
EnterCriticalSection
DeleteCriticalSection
RegQueryValueExW
ExpandEnvironmentStringsW
CLSIDFromString
FreeLibrary
CloseThreadpoolCleanupGroupMembers
CloseThreadpoolCleanupGroup
CreateThreadpoolCleanupGroup
LoadLibraryExW
GetProcAddress
CreateFileW
GetFileSizeEx
CreateFileMappingW
MapViewOfFile
UnmapViewOfFile
CloseHandle
RegOpenKeyExW
RegCloseKey
SetThreadpoolThreadMinimum
SetThreadpoolThreadMaximum
CloseThreadpool
CreateThreadpool
CreateThreadpoolWait
SetThreadpoolWait
WaitForThreadpoolWaitCallbacks
CloseThreadpoolWait
WaitForMultipleObjectsEx
CreateEventW
CreateThread
SetEvent
WaitForSingleObject
WaitNamedPipeW
SetNamedPipeHandleState
GetCurrentProcessId
WriteFile
TransactNamedPipe
LocalFree
SetLastError
DeviceIoControl
InitializeCriticalSection
GetOverlappedResult
GetModuleFileNameA
HeapAlloc
GetProcessHeap
HeapFree
RegSetValueExW
SetEnvironmentVariableW
RevertToSelf
GetCurrentThread
Sleep
EventActivityIdControl
ReadFile
FlushFileBuffers
VirtualProtect
LoadLibraryExA
ReleaseSRWLockExclusive
AcquireSRWLockExclusive
RaiseException
GetSystemInfo
VirtualQuery
UnhandledExceptionFilter
SetUnhandledExceptionFilter
GetCurrentProcess
TerminateProcess
QueryPerformanceCounter
GetCurrentThreadId
GetSystemTimeAsFileTime
GetTickCount
api-ms-win-eventing-classicprovider-l1-1-0.dll
api-ms-win-core-processthreads-l1-1-0.dll
api-ms-win-core-errorhandling-l1-1-0.dll
api-ms-win-core-sysinfo-l1-2-0.dll
api-ms-win-eventing-provider-l1-1-0.dll
api-ms-win-core-heap-l1-1-0.dll
api-ms-win-core-sysinfo-l1-1-0.dll
api-ms-win-core-com-l1-1-0.dll
api-ms-win-core-synch-l1-1-0.dll
api-ms-win-core-registry-l1-1-0.dll
api-ms-win-core-processenvironment-l1-1-0.dll
api-ms-win-core-libraryloader-l1-2-0.dll
api-ms-win-core-threadpool-l1-2-0.dll
api-ms-win-core-file-l1-1-0.dll
api-ms-win-core-memory-l1-1-0.dll
api-ms-win-core-handle-l1-1-0.dll
api-ms-win-core-namedpipe-l1-1-0.dll
api-ms-win-core-heap-l2-1-0.dll
api-ms-win-core-io-l1-1-0.dll
api-ms-win-security-base-l1-1-0.dll
api-ms-win-core-synch-l1-2-0.dll
api-ms-win-core-profile-l1-1-0.dll
GetAndInitializePlatformObject
InitializePlatformLibrary
WdfGetLpcInterface
SetPlatformErrorReportingCallbacks
ShutdownPlatformLibrary
WudfIsKernelDebuggerPresent
WudfIsUserDebuggerPresent
WudfDebugBreakPoint
WudfWaitForDebugger
WUDFPlatform.dll
memcpy
memset
UMDF_VERSION
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<!-- Copyright (c) Microsoft Corporation -->
<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0">
    <compatibility xmlns="urn:schemas-microsoft-com:compatibility.v1">
        <application>
            <!-- Windows 7 -->
            <supportedOS Id="{4a2f28e3-53b9-4441-ba9c-d69d4a4a6e38}"/>
            <!-- Windows 8 -->
            <supportedOS Id="{35138b9a-5d96-4fbd-8e2d-a2440225f93a}"/>
            <!-- Windows 8.1 -->
            <supportedOS Id="{1f676c76-80e1-4239-95bb-83d0f6d0da78}"/>
            <!-- Windows 10 -->
            <supportedOS Id="{8e0f7a12-bfb3-4fe8-b9a5-48fd50a15a9a}"/>
        </application>
    </compatibility>
    <assemblyIdentity 
        version="5.1.0.0"
        processorArchitecture="amd64"
        name="Microsoft.Umdf.WUDFHost.exe"
        type="win32" />
    <description>Windows User-Mode Driver Framework Host Process</description>
    <trustInfo xmlns="urn:schemas-microsoft-com:asm.v3">
        <security>
            <requestedPrivileges>
                <requestedExecutionLevel level="asInvoker" uiAccess="false" />
            </requestedPrivileges>
        </security>
    </trustInfo>
</assembly>
VS_VERSION_INFO
StringFileInfo
040904B0
CompanyName
Microsoft Corporation
FileDescription
Windows Driver Foundation - User-mode Driver Framework Host Process
FileVersion
10.0.22621.1 (WinBuild.160101.0800)
InternalName
WUDFHost.exe
LegalCopyright
 Microsoft Corporation. All rights reserved.
OriginalFilename
WUDFHost.exe
ProductName
Microsoft
 Windows
 Operating System
ProductVersion
10.0.22621.1
VarFileInfo
Translation
en-US
