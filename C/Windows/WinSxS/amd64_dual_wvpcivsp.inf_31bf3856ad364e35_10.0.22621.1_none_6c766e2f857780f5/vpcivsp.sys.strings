!This program cannot be run in DOS mode.
.text
h.rdata
H.data
.pdata
H.idata
HNONPAGE
`fothk
`INIT
bGFIDS
B.rsrc
B.reloc
D$(E3
tP8Y)rKI
x AUAVAWH
fD93t
fD93t
A_A^A]
WAVAWH
A_A^_
UVWATAUAVAWH
D$HH9Hpu,H
HxH;L$Pu!
VPCIH
VPCIH
L$XH3
`A_A^A]A\_^]
VPCIH
WAVAWH
@A_A^_
VPCIH
D$ E3
WAVAWH
0A_A^_
WAVAWH
@A_A^_
D$(fD
x AVH
@8y)r|I
D$(fD
D$(fD
D$(fD
D$(fD
D$(fD
D$(fD
{ ATAVAWH
tQ8Y)rLI
A_A^A\
tP8Y)rKI
D$(fD
tq@8y)rkI
D$(fD
WAVAWH
A_A^_
x AVH
VWAVH
D$ `y
VPCIH
VPCIH
L$XH3
WATAUAVAWH
f9yHt D
A_A^A]A\_
x ATAVAWH
A_A^A\
X UVWAVAWH
y.H9-
0A_A^_^]
{ AVH
f9iHt"H
@8k@t
VPCIH
WAVAWH
0A_A^_
UVWATAUAVAWH
A_A^A]A\_^]
fD9HHt&H
SUVWATAUAVAWH
8A_A^A]A\_^][
SUVWATAUAVAWH
D9_pu
VPCIH
VPCIH
VPCIA
D9_pu
d$@E+
VPCIH
L$8fC
T$0fE;\
VPCIH
VPCIH
VPCII
VPCIH
VPCIH
hA_A^A]A\_^][
VPCIH
@USVWATAUAVAWH
VPCIA
L$ E3
fD9k(
D$ E3
fD9iHtbA
VPCIH
A_A^A]A\_^[]
l$ VWAVH
tKH9=
y@H9=f
L$xH3
VWAVH
t2H95
L$XH3
t$ WAVAWH
VPCIH
VPCIH
L$pH3
A_A^_
t$ WAVAWH
L$ E3
0A_A^_
UVWATAUAVAWH
`A_A^A]A\_^]
t$ WATAUAVAWH
A_A^A]A\_
x AVH
VPCIH
VPCIH
\$ UVWATAUAVAWH
A_A^A]A\_^]
s WAVAWH
@A_A^_
L$ SVWH
t:8Y)r5I
D$(fD
WAVAWH
t$(fD
A_A^_
x ATAVAWH
l$(fD
A_A^A\
VPCIH
{ AVH
H;CpuwI
H;CxumH
VWAVH
 A^_^
VWATAVAWH
 A_A^A\_^
VPCIH
H WAVAWH
VPCIH
VPCII
A_A^_
WAVAWH
A_A^_
L$(E3
L$hH3
D$<I!C
@USVWAWH
`A__^[]
L$ USVWAUAVAWH
A_A^A]_^[]
VPCIH
VPCIH
VPCIH
VPCIH
WAVAWH
VPCIH
0A_A^_
D$ E3
@USVWATAVAWH
D$(E3
VPCIH
D$ E3
A9~Pu
VPCIH
@A_A^A\_^[]
t$ WH
VPCIH
D$ E3
VPCIH
UWAVH
D$ E3
D$ E3
D8T$8t H
VPCIH
VPCIH
x UATAUAVAWH
L$HE3
|$ E3
D$(E3
D$(E3
t$ E3
A_A^A]A\]
UWAVH
D$ E3
98v(H
)D$ I;
)D$ M;
VPCIH
VPCIH
VPCIH
;PuWH
x AVH
@8h0t$H
9(u"H
AsrtH
AsrtH
x UATAUAVAWH
D9d$h
D$XE3
D$ E3
A_A^A]A\]
L$8E3
x AVH
-fffffff
fffffff
fffffff
fffffff
.fffffff
fffffff
fffffff
fffff
AQAPRQPH
(D$ H
0XYZAXAY
ffffff
fffff
fffff
COMMON_PROXY_IOTARGET_CONTEXT
)(,@K
Y eJ#VPCI_VSP_DEVICE_CONTEXT
VSP_FILE_CONTEXT
VSP_IOCTL_VMBUS_HANDLE_CONTEXT
IOCTL_VPCI_CREATE_DEVICE
IOCTL_VPCI_QUERY_ERRATA_INFO
IOCTL_VPCI_QUERY_MITIGATIONS
IOCTL_VPCI_COMPLETE_MITIGATIONS
IOCTL_VPCI_RESTORE_STATE
IOCTL_VPCI_FASTSAVE_DEVICE
IOCTL_VPCI_ALLOCATE_HARDWARE
IOCTL_VPCI_FREE_HARDWARE
IOCTL_VPCI_CONNECT_PARTITION
IOCTL_VPCI_CONNECT_PARTITION_BY_HANDLE
IOCTL_VPCI_MAP_MMIO_RESOURCES
IOCTL_VPCI_UNMAP_MMIO_RESOURCES
IOCTL_VPCI_MAP_INTERRUPT
IOCTL_VPCI_UNMAP_INTERRUPT
IOCTL_VPCI_REMOVE_DEVICE
IOCTL_VPCI_SET_DEVICE_POWER_STATE
IOCTL_VPCI_BACK_CHANNEL_READ
IOCTL_VPCI_BACK_CHANNEL_WRITE
IOCTL_VPCI_CLIENT_NOTIFICATION_REQUEST
IOCTL_VPCI_QUERY_MAPPED_INTERRUPT
IOCTL_VPCI_RESTORE_MAPPED_INTERRUPT
IOCTL_VPCI_QUERY_RESTORED_STATE
IOCTL_VPCI_QUERY_PF_LUID
IOCTL_VPCI_QUERY_ALLOCATED_HARDWARE
IOCTL_VPCI_DISCONNECT_PARTITION
VpciFastIoctlReadWriteConfig
Device removal in progress: LogicalDeviceId = 0x%llx
Serialized IOCTL %x already in progress
VspEvtIoDeviceControl
File context must be connected to a partition before assigning a device
VpciIoctlCreateDevice
CreateDevice: LogicalId = 0x%llx, TargetVtl = %u, DeviceLuid = %x.%x, VfIndex = %u, VfLuid = %x.%x, Restore = %u, LogicalInterrupts = %u, UseAnyHardware = %u
VpciIoctlQueryErrataInfo
VpciIoctlQueryMitigations
VpciIoctlCompleteMitigations
VpciFastIoctlReadRegister
VpciFastIoctlWriteRegister
VpciIoctlRestoreState
VpciFastIoctlDeliverInterrupt
Device removal in progress
WinHvAssertDeviceInterrupt failed: MsiAddress = %llx, MsiData = %x
VpciIoctlFastSaveDevice
NewLength: %u
VpciIoctlAllocateHardware
DirectTranslatedP2P is globally disabled
ProviderGuid = {%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}
Provider allocated VF: ProviderType = %u, ProviderGuid = {%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}, DeviceLuid = 0x%08x'%08x, VirtualFunctionLuid = 0x%08x'%08x, VirtualFunctionIndex = %u
VpciIoctlFreeHardware
Free VF: ProviderType = %u, DeviceLuid = 0x%08x'%08x, VirtualFunctionLuid = 0x%08x'%08x, VirtualFunctionIndex = %u
VpciIoctlConnectPartition
Client context is already associated to a VMBUS handle
PartitionPath = %wZ
fileContext->VirtualDevice != nullptr
VpciIoctlDisconnectPartition
VpciIoctlMapMmioResources
MMIO resources already mapped: LogicalDeviceId = 0x%llx
Device not powered on while mapping MMIO resources: LogicalDeviceId = 0x%llx
Device is fast saved, cannot map MMIO resources: LogicalDeviceId = 0x%llx
VpciIoctlUnmapMmioResources
VpciIoctlMapInterrupt
Device is fast saved, cannot map interrupts: LogicalDeviceId = 0x%llx
VpciIoctlUnmapInterrupt
VpciIoctlRemoveDevice
VpciIoctlSetDevicePowerState
Device is fast saved, cannot power on: LogicalDeviceId = 0x%llx
VpciIoctlBackChannelRead
Invalid back channel data size: %u
VpciIoctlBackChannelWrite
VpciIoctlClientNotificationRequest
VpciIoctlQueryMappedInterrupt
Invalid interrupt index %u: LogicalDeviceId = 0x%llx
Interrupt entry at index %u is unused: LogicalDeviceId = 0x%llx
VpciIoctlRestoreMappedInterrupt
VpciIoctlQueryRestoredState
VMBUS channel state is not present (PhuItemGetData --> 0x%x)
VpciIoctlQueryPfLuid
VpciIoctlQueryAllocatedHardware
IsListEmpty(&fileContext->AllocatedVfLuidsHead)
MuxInitialize
MuxContext->ProxyMux == nullptr
MuxAttach
MuxGetMmioMappedPageList
MuxClient->ProxyNode == nullptr
MuxReadWriteMitigatedRegister
deviceMitigation == nullptr
MuxSendVmBusHandle
MuxGetHwVirtLevel
MuxQueryProbedBars
MuxReadVfConfig
MuxWriteVfConfig
MuxReadVfConfigBlock
backChannel == nullptr
MuxWriteVfConfigBlock
MuxGetDeviceLocations
MuxGetVendorAndDevice
MuxQueryLuidForVfIndex
MuxGetResources
MuxSetVfPowerState
MuxResetVf
MuxFreeFlexIovDevice
MuxAllocFlexIovDevice
MuxUpdateIntMappings
MuxResetAnyVf
MuxEnableDisableDirectTranslatedP2P
deviceP2PItf == nullptr
MuxEnableDisableAts
MuxGetAtsInvalidateQueueDepth
MuxQueryDevicePath
VirtualDeviceCreateSingleInterrupt
Interrupt entry not found: Address = %llx, Data = %x, Index = %u
VirtualDeviceDeleteSingleInterrupt
VirtualDeviceRestoreSingleInterrupt
VirtualDeviceEnableEndpointAcs
VirtualDeviceSetBusMasterEnable
VirtualDeviceEnableDma
VirtualDeviceCreateMemoryBlocks
Device->MmioMappingState != VirtualDeviceMmioMappingState::Uninitialized
VirtualDeviceStartMappingBARs
Device->MmioMappingState != VirtualDeviceMmioMappingState::Started
VirtualDeviceFinishMappingBARs
VirtualDeviceProxyD0
VirtualDevicePrepareForHsr
VirtualDeviceProxyDx
VirtualDeviceResetFunction
Detaching device from partition: LogicalDeviceID = 0x%llx
VirtualDeviceDetachHv
VirtualDeviceDetach
Attaching device to partition: LogicalDeviceId = 0x%llx, VF RID = %x:%x:%x, Flags = 0x%08X, PF RID = 0x%04x
VirtualDeviceAttachHv
VirtualDeviceAttach
VirtualDeviceMapInterrupt
MsiAddress = %I64x, MsiData = %08x
VirtualDeviceUnmapInterrupts
VirtualDeviceRestoreInterrupts
PfEvent
VirtualDeviceMapMmioSpace
VirtualDeviceMapMdlMmioSpace
VirtualDeviceMapGpaRangeToMemoryBlock
VirtualDeviceSetMbClientContext
VirtualDeviceMitigatePages
VirtualDeviceContinueSave
VirtualDeviceRunRestoreStateMachine
DeviceEndPhu
VirtualDeviceCollectResourceRequirements
VirtualDeviceCollectMmioMappings
VirtualDeviceCollectHostResources
RemapMmioResources
VirtualDeviceUpdateInterruptRequest
MitigatedRangesOutput.get() == nullptr
VirtualDeviceBuildUnmitigatedMmioPageList
UpdateMitigations
VirtualDeviceMinimalRemap
Too many PCI segments
VirtualDeviceCheckFreeIrtEntries
Requested IRT entries = %u, free entries = %u
VirtualDeviceUpdateIDTTrackingTable
VirtualDeviceEnableDisableAts
enable
disable
VirtualDeviceEnableDisableDirectTranslatedP2P
VirtualDeviceEnableDisableIommuAts
hostResourceIndex >= Device->HostResourceCount
VirtualDeviceMapMmioRangeToClientVA
sourceMdl->MdlFlags & (MDL_MAPPED_TO_SYSTEM_VA | MDL_SOURCE_IS_NONPAGED_POOL)
physicalBaseAddress == 0 || (physicalBaseAddress % PAGE_SIZE) != 0
Invalid host resource type: Device = %p, HostResourceNumber = %u
mappedVA == nullptr
Device->GuestMappings[barIndex] == nullptr
VirtualDeviceMapBARsToClientVA
VpciGetDevicePnpIds
VpciScanDeviceCapabilities
VpciPhuRestoreDevice
VpciGetHypervisorDeviceIds
(Device->HwVirtualizedLevel & FIOV_FLAG_HOST_VIRTUAL_DEVICE) == 0
!newDeviceIds
VpciInsertDevice
Device assigned with DirectTranslatedP2P enabled: LogicalDeviceId = 0x%llx
VpciFreeAllPersistedPhu
PhuItemUnregister failed: VMID = {%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}, ItemID = {%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}
Hardware has not bee allocated to this client context
VpciPinAllocatedVf
PF LUID = 0x%x.%x, VF LUID = 0x%x.%x, VF Index = %u
PsGetVersion
WmiTraceMessage
WmiQueryTraceInformation
EtwRegisterClassicProvider
EtwUnregister
vpcivsp.sys
DriverEntry
VPCIVP driver loaded (SoftBoot = %u)
\DosDevices\vpcivsp
MmioRemappingTimeoutSeconds
SafeBoot
VspEvtDeviceAdd
Hypervisor not present
KSR support not installed: 0x%08X
FileCreate
VspEvtDeviceFileCreate
FileClose
Provider failed to to free virtual function: ProviderType = %u, DeviceLUID = 0x%8xl'%8xl, VfLUID = 0x%8xl'%8xl, VfIndex = %u
VspEvtFileClose
PickupVidInterfaces
Received IRP_MN_SET_POWER for KSR
VspEvtPreProcessPower
VidPhuCallbackReasonEnd
VpciPhupCallback
VidPhuCallbackReasonFree
\Callback\VidPhu
VpciPhuCallbackRegister
VspExposeInterfaces
onecore\vm\dv\vpci\vsp\vpcivsp.c
FlexIovGuestMemoryAccess_LockChildRange
\Callback\SoftRestart
VspKsrNotifyRegister
DeviceContext->KsrCallbackRegistration == nullptr
Received KSR PREPARE notification
VspKsrNotificationCallback
Received KSR CANCEL notification
\??\SRIOVPROVIDER#{%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}
VpciAllocateSriovVf
VpciFreeSriovVf
VpciGuestMemoryInterface
newCommonProxy == nullptr
CommonProxy::Create
newTargetName == nullptr
CommonProxy::Initialize
m_RemoveInProgress
CommonProxy::AttachMuxClient
mitigatedRanges[mmioRangeCount].VirtualBasePageNumber != currentPage
CommonProxy::ValidateMitigationRanges
mitigatedRanges[mmioRangeCount].PageCount > MAX_MMIO_MAPPING_LENGTH_PAGES
currentPage > (BarLength >> PAGE_SHIFT)
currentPage != (BarLength >> PAGE_SHIFT)
Restored PCI security scenario 0x%08X on device %wZ
CommonProxy::RestoreKsrStates
CommonProxy::PnpNotificationCompletion
%p: Unexpected event code %u from Proxy/PF
CommonProxy::MmioRangeUpdateCompletion
!foundDevice
CommonProxy::InvalidateBlockCompletion
CommonProxy::GetPfDeviceId
!IsEqualGUID(busType, GUID_BUS_TYPE_PCI)
CommonProxy::GetPfPnpInstanceId
newSharedProxy == nullptr
CreateSharedProxy
IoTarget == nullptr
FlexiovProxy::Initialize
ProxyNode == nullptr
!m_NotificationWorkItem.get()
!m_MmioUpdateWorkItem.get()
AttachedToTarget:FlexIOV
FlexiovProxy::SendAttach
DetachFromTarget
FlexiovProxy::DropProxy
BarLength % PAGE_SIZE != 0
FlexiovProxy::GetMmioMappedPageList
rangeCounts[BarNumber] == 0
!rawNewRanges
!mitigatedRangesOutput
m_IoTarget == nullptr
FlexiovProxy::MmioRangeUpdate
!m_IsAttached
!WdfRequestSend(m_MmioRangeUpdateRequest.get(), m_IoTarget, WDF_NO_SEND_OPTIONS)
m_FlexiovInterface.UpdateIntMappings == nullptr
FlexiovProxy::UpdateInterruptMappings
!rawFiovResourceList
!rawFiovHwResourceList
m_FlexiovInterface.GetDeviceLocation == nullptr
FlexiovProxy::GetDeviceLocation
!Rids
m_FlexiovInterface.ResetVf == nullptr
FlexiovProxy::ResetVf
m_FlexiovInterface.SetPartPowerState == nullptr
FlexiovProxy::SetPowerState
m_FlexiovInterface.QueryLuid == nullptr
FlexiovProxy::QueryLuid
m_FlexiovInterface.GetBackingResource == nullptr
FlexiovProxy::GetBackingResources
!Resources
mdl && resource.Type != CmResourceTypeNull
FlexiovProxy::SendNotificationRequest
!WdfRequestSend(m_NotificationRequest.get(), m_IoTarget, WDF_NO_SEND_OPTIONS)
m_FlexiovInterface.GetVirtualizationFlags == nullptr
FlexiovProxy::GetHwVirtLevel
FlexiovProxy::SetFunctionVmbus
ResourcesInfo == nullptr
FlexiovProxy::AllocateVirtualFunction
m_FlexiovInterface.AllocateVf == nullptr
m_FlexiovInterface.FreeVf == nullptr
FlexiovProxy::FreeVirtualFunction
m_FlexiovInterface.GetMmioRangeCount == nullptr
FlexiovProxy::GetMmioRangeCount
m_FlexiovInterface.GetMmioRanges == nullptr
FlexiovProxy::GetMmioRanges
FlexiovProxyV2::Initialize
AttachedToTarget:Flexible-IOV V2
FlexiovProxyV2::SendAttach
m_FlexibleiovInterface.AttachToPhysicalFunction == nullptr
FlexiovProxyV2::SendDetach
FlexiovProxyV2::DropProxy
FlexiovProxyV2::GetMmioMappedPageList
rawNewRanges.get() == nullptr
FlexiovProxyV2::MmioRangeUpdate
m_FlexibleiovInterface.UpdateVirtualDeviceInterruptMappings == nullptr
FlexiovProxyV2::UpdateInterruptMappings
m_FlexibleiovInterface.GetVirtualDeviceRids == nullptr
FlexiovProxyV2::GetDeviceLocation
!newRids
m_FlexibleiovInterface.ResetVirtualDevice == nullptr
FlexiovProxyV2::ResetVf
m_FlexibleiovInterface.SetVirtualDevicePowerState == nullptr
FlexiovProxyV2::SetPowerState
m_FlexibleiovInterface.QueryPhysicalFunctionLuid == nullptr
FlexiovProxyV2::QueryLuid
m_FlexibleiovInterface.GetVirtualDeviceMmioResourceCount == nullptr
FlexiovProxyV2::GetBackingResources
m_FlexibleiovInterface.GetVirtualDeviceMmioResource == nullptr
m_FlexibleiovInterface.GetVirtualDeviceProperties == nullptr
FlexiovProxyV2::GetHwVirtLevel
FlexiovProxyV2::SetFunctionVmbus
m_FlexibleiovInterface.AllocateVirtualDevice == nullptr
FlexiovProxyV2::AllocateVirtualFunction
m_FlexibleiovInterface.FreeVirtualDevice == nullptr
FlexiovProxyV2::FreeVirtualFunction
m_FlexibleiovInterface.GetVirtualDeviceMmioRangeCounts == nullptr
FlexiovProxyV2::GetMmioRangeCount
m_FlexibleiovInterface.GetVirtualDeviceMmioRanges == nullptr
FlexiovProxyV2::GetMmioRanges
Ranges.size() == 0
VspPersistentState::Initialize
Persisted state available, size = %u, proxy state count = %u
!stateBlock
VspPersistentState::ClaimPersistedState
!runs
!previousStateBlock
previousState == nullptr
m_KsrBlockId != 0
VspPersistentState::Persist
runCount == 0
VspPersistentState::CreateProxyState
!newStateBlock
newProxyMux == nullptr
SharedProxyMux::Create
SharedProxyMux::Initialize
SharedProxyMux::Attach
%p: Attached client %p to existing target proxy: LUID = 0x%x-%x
luidEntry == nullptr
%p: Attached client %p to new target proxy: %wZ, LUID = 0x%x-%x
%p: Detaching from client %p, device LUID = 0x%x-%x
SharedProxyMux::Detach
SharedProxyMux::ResetAnyVf
Cleared PCI security scenario 0x%08X on device %wZ
Failed to reset Flexiov V2 VF: %wZ, LUID = 0x%x-%x
Failed to reset Flexiov VF: %wZ, LUID = 0x%x-%x
Failed to reset Sriov VF: %wZ, VF Index = %u
m_AssignedDevicesCount > 0
SharedProxyMux::DevicesCanSleep
SharedProxyMux::AllocFlexIovDevice
deviceCount == 0
deviceList == nullptr
%wZ: Open target failed
DeviceInstance->MaximumLength < deviceInfo->TargetName.Length
AllocateVf Interface succeeded %wZ: DeviceLuid: 0x%xl'%xl VF LUID:0x%xl'%xl
SharedProxyMux::FreeFlexIovDevice
flexiovInterface.FreeVf == nullptr
SharedProxyMux::DeviceInterfaceCallback
SharedProxyMux::DeviceArrivalCallback
DeviceInterfaceArrival: %wZ, LUID = %x.%x
DeviceInterfaceRemoval
SharedProxyMux::DeviceRemovalCallback
DevicePathLength < entry->TargetName.Length / sizeof(WCHAR) + 1
SharedProxyMux::QueryDevicePath
SriovProxy::Initialize
!m_InvalidationWorkItem.get()
AttachedToTarget:GPUP
AttachedToTarget:SRIOV
SriovProxy::SendAttach
SriovProxy::DropProxy
SriovProxy::GetMmioMappedPageList
SriovProxy::MmioRangeUpdate
m_SriovInterface.GetDeviceLocation == nullptr
SriovProxy::GetDeviceLocation
m_SriovInterface.ResetVf == nullptr
SriovProxy::ResetVf
m_SriovInterface.SetVfPowerState == nullptr
SriovProxy::SetPowerState
m_SriovInterface.QueryLuid == nullptr
SriovProxy::QueryLuid
SriovProxy::GetBackingResources
m_SriovInterface.ReadVfConfig == nullptr
SriovProxy::ReadVfConfig
m_SriovInterface.WriteVfConfig == nullptr
SriovProxy::WriteVfConfig
m_SriovInterface.QueryLuidVf == nullptr
SriovProxy::QueryLuidForVfIndex
m_SriovInterface.QueryVfLuid == nullptr
SriovProxy::QueryVfIndexForLuid
SriovProxy::SendNotificationRequest
SriovProxy::QueryProbedBars
m_SriovInterface.QueryProbedBars == nullptr
m_SriovInterface.GetVendorAndDevice == nullptr
SriovProxy::GetVendorAndDevice
SriovProxy::GetHwVirtLevel
SriovProxy::SetFunctionVmbus
SriovProxy::SendBlockInvalidateRequest
!WdfRequestSend(m_InvalidationRequest.get(), m_IoTarget, WDF_NO_SEND_OPTIONS)
!RtlIsZeroLuid(&VfId.VfLuid)
SriovProxy::ReadVfConfigBlock
m_SriovInterface.ReadVfConfigBlock == nullptr
SriovProxy::WriteVfConfigBlock
m_SriovInterface.WriteVfConfigBlock == nullptr
SriovProxy::ReadMitigatedRegister
m_MitigationInterface.ReadWriteMitigatedRegister == nullptr
SriovProxy::WriteMitigatedRegister
!(m_SecurityInterface.SupportedScenarios & scenario)
SriovProxy::EnableDisableDirectTranslatedP2P
proxyState == nullptr
m_AtsInterface.SetAddressTranslationServices == nullptr
SriovProxy::EnableDisableAts
SriovProxy::GetAtsInvalidateQueueDepth
SriovProxy::GetSriovMmioRangeCount
SriovProxy::GetSriovMmioRanges
SriovProxy::GetFlexiovMmioRangeCount
m_FlexIovInterface.GetMmioRanges == nullptr
SriovProxy::GetFlexiovMmioRanges
!rawSriovMmioRanges
SriovProxy::BuildSriovMitigationRanges
!MitigatedRangesOutput
KmdfLibrary
DriverEntry failed 0x%x for driver %wZ
FxStubBindClasses: invalid driver image, the address of symbol __KMDF_CLASS_BIND_START 0x%p is greater than the address of symbol __KMDF_CLASS_BIND_END 0x%p, status 0x%x
FxGetNextClassBindInfo failed
FxStubBindClasses: ClientBindClass %p, WDF_CLASS_BIND_INFO 0x%p, class %S, returned status 0x%x
FxStubBindClasses: VersionBindClass WDF_CLASS_BIND_INFO 0x%p, class %S, returned status 0x%x
FxStubInitTypes: invalid driver image, the address of symbol __KMDF_TYPE_INIT_START 0x%p is greater than the address of symbol __KMDF_TYPE_INIT_END 0x%p, status 0x%x
FxGetNextObjectContextTypeInfo failed
<unknown>
TELASSERT
VpciVspFileOp
status
clientid
VpciVspTrace
source
status
clientid
VpciVspTrace
source
status
clientid
value
VpciVspTrace
source
status
clientid
value
VpciVspHandleCounts
handleCount
VpciVspTrace
source
status
clientid
message
VpciVspFileOp
status
clientid
VpciVspTrace
source
status
clientid
message
VpciVspFileOp
status
clientid
AssertWithArgs
assertVersion
timestamp
imageSize
imageName
count
totalHits
originatingBinary
bucketArgument1
bucketArgument2
message
Assert
assertVersion
timestamp
imageSize
imageName
count
totalHits
message
AssertWER
assertVersion
timestamp
imageSize
imageName
count
totalHits
Status
&'1FY
Microsoft.Windows.HyperV.VPCIVSP
TelemetryAssert
TelemetryAssertDiagTrack_KM
TelemetryAssertDiagTrack
RSDS@Q3
vpcivsp.pdb
.text
.text$mn
.text$mn$00
.text$mn$21
.rdata$brc
.gehcont
.giats
.rdata
.rdata$zETW0
.rdata$zETW1
.rdata$zETW2
.rdata$zETW9
.rdata$zzzdbg
.xdata
.data$brc
.data
.kmdfclassbind$a
.kmdfclassbind$c
.kmdfclassbind$d
.kmdftypeinit$a
.kmdftypeinit$c
.pdata
.idata$5
.00cfg
.idata$2
.idata$3
.idata$4
.idata$6
NONPAGE
fogrp
.gfids
.rsrc$01
.rsrc$02
__C_specific_handler
KeAcquireSpinLockRaiseToDpc
RtlCmDecodeMemIoResource
IoGetRelatedDeviceObject
ObfDereferenceObject
RtlInitUnicodeString
KeReleaseSpinLock
IoFileObjectType
KeSetEvent
ExAllocatePool2
ObReferenceObjectByHandle
ExAcquireRundownProtection
ExFreePoolWithTag
ZwClose
ExReleaseRundownProtection
IoConvertFileHandleToKernelHandle
KeDelayExecutionThread
IoAllocateWorkItem
IoBuildPartialMdl
ObfReferenceObjectWithTag
IoAllocateMdl
ExWaitForRundownProtectionRelease
ExInitializeRundownProtection
MmIsIoSpaceActive
KeStackAttachProcess
IoFreeMdl
PsGetCurrentProcess
IoFreeWorkItem
ObfDereferenceObjectWithTag
KeReleaseGuardedMutex
KeInitializeEvent
IoQueueWorkItem
MmUnmapLockedPages
MmMapLockedPagesSpecifyCache
KeAcquireGuardedMutex
KeWaitForSingleObject
KeUnstackDetachProcess
KeResetEvent
MmAllocateMdlForIoSpace
RtlAppendUnicodeStringToString
RtlAppendUnicodeToString
RtlFreeUnicodeString
ObReferenceObjectByHandleWithTag
RtlCopyUnicodeString
RtlStringFromGUID
ExEventObjectType
_vsnwprintf
ExReleaseSpinLockExclusive
RtlRegisterFeatureConfigurationChangeNotification
RtlQueryFeatureConfiguration
EtwSetInformation
KeInitializeGuardedMutex
ExRegisterCallback
ExIsSoftBoot
RtlRbInsertNodeEx
ExCreateCallback
_vsnprintf
IoClearActivityIdThread
IoGetActivityIdThread
RtlQueryFeatureConfigurationChangeStamp
EtwWriteTransfer
ExReleaseSpinLockShared
EtwActivityIdControl
ExAcquireSpinLockShared
ExAcquireSpinLockExclusive
RtlUnregisterFeatureConfigurationChangeNotification
RtlRbRemoveNode
EtwUnregister
MmGetSystemRoutineAddress
HalDispatchTable
EtwRegister
IoWMIRegistrationControl
InitSafeBootMode
IofCompleteRequest
IoSetActivityIdThread
IoGetDeviceInterfaces
ExUnregisterCallback
KeClearEvent
IoGetDeviceProperty
IoGetDevicePropertyData
_purecall
MmAllocatePagesForMdlEx
MmSizeOfMdl
MmFreePagesFromMdl
IoUnregisterPlugPlayNotificationEx
IoRegisterPlugPlayNotification
RtlDuplicateUnicodeString
RtlCompareUnicodeString
ntoskrnl.exe
WppAutoLogTrace
WppAutoLogStart
imp_WppRecorderReplay
WppAutoLogStop
WppRecorder.sys
WinHvAssertDeviceInterrupt
WinHvSetPhysicalDeviceProperty
WinHvDetachDeviceRemote
WinHvReserveDeviceInterruptRemote
WinHvQueryDeviceInterruptTarget
WinHvMapDeviceInterruptEx
WinHvReserveDeviceInterrupt
WinHvAttachDevice
WinHvUnmapDeviceInterrupt
WinHvDetachDevice
WinHvAttachDeviceRemote
WinHvReportPresentHypervisor
winhvr.sys
KsrEnumeratePersistedMemory
KsrClaimPersistedMemory
KsrMdlToMemoryRuns
KsrPersistMemory
KsrFreePersistedMemoryBlock
ext-ms-win-ntos-ksr-l1-1-2.dll
DbgPrintEx
KeGetCurrentIrql
DbgkWerCaptureLiveKernelDump
RtlInitAnsiString
KeQueryTimeIncrement
KeInitializeSpinLock
WdfVersionUnbind
WdfLdrQueryInterface
WdfVersionBind
WdfVersionUnbindClass
WdfVersionBindClass
WDFLDR.SYS
VWAUAVAWH
|$0E2
PA_A^A]_^
|$ UH
UVWATAUAVAWH
fD9iHt
8t,A+
fD9iHt
A_A^A]A\_^]
UVWAVAWH
pA_A^_^]
WATAUAVAWH
 A_A^A]A\_
@SVWH
H9D$Xs
VWAVH
VWAVH
|$PE2
L$pE3
D$0E3
VWATAVAWH
t$HL;
L$hH3
pA_A^A\_^
X UVWATAUAVAWH
VPCIH
A_A^A]A\_^]
VWATAVAWH
fD9y 
D;L$Tt
VPCIH
A_A^A\_^
UATAUAVAWH
H!t$(
VPCIH
A_A^A]A\]
D$ E3
UVWAVAWH
0A_A^_^]
UVWAVAWH
`A_A^_^]
VWATAVAWH
A_A^A\_^
UVWATAUAVAWH
D8uBt[
UCfC;T
`A_A^A]A\_^]
UVWATAUAVAWH
fD9*A
D9]Xt D
D8]@t
VPCII
pA_A^A]A\_^]
UVWATAUAVAWH
H!t$(E
H!t$@L
A_A^A]A\_^]
UVWATAUAVAWH
D$ E3
M\9_ u
9O$txH
D$ E3
PA_A^A]A\_^]
D$ E3
(D$0H
(D$0H
D$ E3
D$ E3
(D$0L
D$ E3
(D$0H
(D$0L
(D$0L
D$ E3
D$ E3
(D$@H
D$ E3
(D$0L
(L$@L
UVWATAUAVAWH
t`E8N
H#t$H
t$@E3
VPCIH
VPCII
VPCII
VPCII
`A_A^A]A\_^]
x AVH
UVWATAUAVAWH
L9='E
VPCII
VPCIA
l$du7E
L9=nA
D8l$`
D8l$atL
VPCII
VPCII
L9=O?
A_A^A]A\_^]
s WAVAWH
A_A^_
UVWATAUAVAWH
u:L9%{<
tJD9z
uDD8{@t>L9
u5L9%
L9%l8
fD9yHt{H
PA_A^A]A\_^]
VWATAVAWH
)t$@@
D$ E3
D$ E3
VPCIH
(t$@L
A_A^A\_^
D$ E3
UVWATAUAVAWH
D$ E3
`A_A^A]A\_^]
t$ WATAUAVAWH
L9d0 u
A_A^A]A\_
|$ UATAUAVAWH
A_A^A]A\]
)t$PuGH
D$ E3
(t$PH
VPCIH
VPCIH
VPCIH
f9yHt H
UVWATAUAVAWH
A_A^A]A\_^]
UVWATAUAVAWH
D$X@8
VPCIH
L$hH3
pA_A^A]A\_^]
UVWATAUAVAWH
D$hM+
fE;D7
L$xD;
D$dfA
y\L9=
A_A^A]A\_^]
L$0E3
L$`H3
SUVWATAVAWH
d$0E3
L$hH3
pA_A^A\_^][
x AVH
s WATAUAVAWH
L$PE3
VPCIH
VPCIH
A_A^A]A\_
D$ E3
f!D$h
VWAVH
\$ VWATAVAWH
\$ E3
\$ E3
H9^HA
\$ E3
A_A^A\_^
D$ E3
WAVAWH
D$ E3
(t$@L
A_A^_
@USVWATAVAWH
ubfD9e@
PA_A^A\_^[]
UVWAVAWH
VPCIH
VPCIH
@A_A^_^]
@USWH
D$ E3
D;M r
UATAUAVAWH
D$ VPCIM
D$ E3
t4H95
A_A^A]A\]
VPCIH
WAVAWH
u2D9z
A_A^_
VWAVH
u2D9r
 A^_^
D$ H!D$ H
L$8H3
UVWAVAWH
A1/A3
 A_A^_^]
L$0H3
t$ WATAUAVAWH
A_A^A]A\_
f9yHt
|$ UATAUAVAWH
D9(v/H
T$XE3
T$XE3
A_A^A]A\]
@USVWATAVAWH
A_A^A\_^[]
t$ WH
xW@8l$`uKH
VPCIH
UWATAVAWH
fD9"u;
A_A^A\_]
D$ E3
@USVWAVH
A^_^[]
` UAVAWH
A_A^]
VWAVH
D8F`t*H
L$@E3
L$0E3
x AVH
^$tDH
l$ VWATAVAWH
D$ E3
L$`H3
A_A^A\_^
UAVAWH
0A_A^]
D$ E3
x8f9{
UATAUAVAWH
D$ E3
D$ E3
A_A^A]A\]
WATAUAVAWH
A_A^A]A\_
L$xH3
L$xH3
\$ UVWATAUAVAWH
D$ E3
D$ E3
D$ E3
D$ E3
D$ E3
L$hH3
pA_A^A]A\_^]
D$ E3
(D$0f
WATAUAVAWH
0A_A^A]A\_
@SVWH
D$ E3
D$ E3
D$ E3
@USVWATAUAVAWH
L9aXu+
hA_A^A]A\_^[]
D$ E3
L$xH3
D$ E3
D$ E3
WAVAWH
A_A^_
\$ UVWATAUAVAWH
L$hH3
pA_A^A]A\_^]
D$ E3
D$ E3
D$ E3
D$@u(
D$ E3
D$ E3
(D$0f
WATAUAVAWH
0A_A^A]A\_
UWATAVAWH
D$ E3
D$ E3
A_A^A\_]
D$ E3
D$ E3
D$ E3
|$ UAVAWH
A_A^]
D$ E3
D$ E3
D$ E3
UVWATAUAVAWH
D9n$t
D$ E3
D$ E3
`A_A^A]A\_^]
D$8E3
D$ E3
@USVWATAUAVAWH
D9|$X
A_A^A]A\_^[]
D$ E3
p AWH
q(u-H
VPCIH
@USVWAVH
D$PE3
D$(E3
D$ E3
A^_^[]
D9@$t
|$ UATAUAVAWH
t$(fD
t$(fD
D8s@t
D$ D8s@t
A_A^A]A\]
L$xH3
L$xH3
@USVWATAUAVAWH
A_A^A]A\_^[]
D$ E3
D$ E3
D$ E3
D$ E3
D$ E3
D$ E3
D$ E3
D$ E3
D$ E3
@USVWATAUAVAWH
H9;u+
hA_A^A]A\_^[]
D$ E3
D$ E3
D$ E3
D$ E3
D$ E3
L$xH3
D$ E3
D$ E3
!\$dA
!\$tI![
D$ E3
WAVAWH
0A_A^_
D$ E3
D$ E3
UVWATAUAVAWH
D$ E3
A_A^A]A\_^]
WAVAWH
D$8@8k
sCH9+u
H9/u5H
L$@H3
A_A^_
UWAWH
D$(VPCI3
D$ E3
VS_VERSION_INFO
StringFileInfo
040904B0
CompanyName
Microsoft Corporation
FileDescription
Virtual PCI VSP Driver
FileVersion
10.0.22621.1 (WinBuild.160101.0800)
InternalName
vpcivsp.sys
LegalCopyright
 Microsoft Corporation. All rights reserved.
OriginalFilename
vpcivsp.sys
ProductName
Microsoft
 Windows
 Operating System
ProductVersion
10.0.22621.1
VarFileInfo
Translation
\6\M\
^Y^@_
[&]j^
(PDP?V|V
VAXqX
U+WAW
W=WqW
TLXwX
^;^^^
R6R]R
S)SPSwS~U
V=VdVgY2[m_
XIYlY
QfStT
S!TFT
U&UKU
Y%YJY_^
^Q_v_
RURzR
UOVtV
\L^q^
P!QJSoS
VJWkW
Z$[=[
RUR0TXT
X0Y}Y
^&^t^
QEQJRcR
TnT!U
U(VIV
U&V{V
V`W!XqX
PVQ~Q
R9SaS
V3VwV"W
S$TLT
UBUiU
V?VwV
Y YLYmY
[:\{\
\S]u]
R2SzS
TUV>W_X
X<Y;Z
[.\v\
]#^h^
R6RnR
T,UoU
U/V?V
\{]7_
]z]^^
[2\Y\
]O]v]
^(_`_
S3SRS
TBUdU
W!Y)ZQ[
Y.ZvZ
[#\h\
RxS8T
Washington1
Redmond1
Microsoft Corporation1.0,
%Microsoft Windows Production PCA 20110
210902182341Z
220901182341Z0p1
Washington1
Redmond1
Microsoft Corporation1
Microsoft Windows0
2y80T
I0G1-0+
$Microsoft Ireland Operations Limited1
229879+4675800
M0K0I
Chttp://www.microsoft.com/pkiops/crl/MicWinProPCA2011_2011-10-19.crl0a
U0S0Q
Ehttp://www.microsoft.com/pkiops/certs/MicWinProPCA2011_2011-10-19.crt0
Et,@8
Zof1G
WaNja
T^r|B
uOi@Y
Washington1
Redmond1
Microsoft Corporation1200
)Microsoft Root Certificate Authority 20100
111019184142Z
261019185142Z0
Washington1
Redmond1
Microsoft Corporation1.0,
%Microsoft Windows Production PCA 20110
O0M0K
Ehttp://crl.microsoft.com/pki/crl/products/MicRooCerAut_2010-06-23.crl0Z
N0L0J
>http://www.microsoft.com/pki/certs/MicRooCerAut_2010-06-23.crt0
TlP0X
R!s4Z
Washington1
Redmond1
Microsoft Corporation1.0,
%Microsoft Windows Production PCA 2011
,0OWmEGUW364BngoL0I0uvs1qrV2JETyeIQ7V1J/mkYA=0Z
"Microsoft Window
 http://www.microsoft.com/windows0
20220506222538.133Z0
Washington1
Redmond1
Microsoft Corporation1-0+
$Microsoft Ireland Operations Limited1&0$
Thales TSS ESN:179E-4BB0-82461%0#
Microsoft Time-Stamp Service
Washington1
Redmond1
Microsoft Corporation1&0$
Microsoft Time-Stamp PCA 20100
211028192742Z
230126192742Z0
Washington1
Redmond1
Microsoft Corporation1-0+
$Microsoft Ireland Operations Limited1&0$
Thales TSS ESN:179E-4BB0-82461%0#
Microsoft Time-Stamp Service0
;DdxYo
j"d6A
N kJ~@(
LbZz:
X0V0T
Nhttp://www.microsoft.com/pkiops/crl/Microsoft%20Time-Stamp%20PCA%202010(1).crl0l
`0^0\
Phttp://www.microsoft.com/pkiops/certs/Microsoft%20Time-Stamp%20PCA%202010(1).crt0
Washington1
Redmond1
Microsoft Corporation1200
)Microsoft Root Certificate Authority 20100
210930182225Z
300930183225Z0|1
Washington1
Redmond1
Microsoft Corporation1&0$
Microsoft Time-Stamp PCA 20100
q\Q17
&S|9a
!]_0t
U0S0Q
3http://www.microsoft.com/pkiops/Docs/Repository.htm0
O0M0K
Ehttp://crl.microsoft.com/pki/crl/products/MicRooCerAut_2010-06-23.crl0Z
N0L0J
>http://www.microsoft.com/pki/certs/MicRooCerAut_2010-06-23.crt0
>NGdx
fg:SM
xSu$W
as.,k{n?,
J>f;O
!TkjE
Washington1
Redmond1
Microsoft Corporation1-0+
$Microsoft Ireland Operations Limited1&0$
Thales TSS ESN:179E-4BB0-82461%0#
Microsoft Time-Stamp Service
Washington1
Redmond1
Microsoft Corporation1&0$
Microsoft Time-Stamp PCA 20100
20220507042831Z
20220508042831Z0t0:
1,0*0
1(0&0
Vu)f\
Washington1
Redmond1
Microsoft Corporation1&0$
Microsoft Time-Stamp PCA 2010
Washington1
Redmond1
Microsoft Corporation1&0$
Microsoft Time-Stamp PCA 2010
Ka:~ 
7v.&"
V(jgH
