!This program cannot be run in DOS mode.
\MgRich
.text
`.rdata
@.data
.pdata
@.rsrc
@.reloc
t$ UWAVH
f9<Bu
fA9<@u
fA9<@u
D$pE3
t$ UWAWH
fA9<@u
fA9<@u
fA9<@u
D$pE3
WAVAWH
9A98uCA9x
pcPZt
0A_A^_
L$ SVWAVH
(A^_^[
L$ SUVWH
L$hH+
f9,Cu
(_^][
UVWAVAWH
t,D8=
L9{Hu
A_A^_^]
x AVH
L$ SVWH
WATAUAVAWH
f9,Au
f9,Ou
fD9t}
 A_A^A]A\_
q*Z~:
UVWATAUAVAWH
ty@8=
t"@8=
fA9>u
PA_A^A]A\_^]
D$(E3
D$@E3
x UAVAWH
T$0H+
L$0fD
A_A^]
t/HcL$$A
HcD$ H
x AVH
h UAVAWH
L$@I+
L$PH;
T$PL;
A_A^]
{ ATAVAWH
 A_A^A\
p WAVAWH
 A_A^_
WAVAWH
fD9?w
C9fD9?u0
 A_A^_
WATAUAVAWH
T$8L+
A_A^A]A\_
L$ UVWATAUAVAWH
pA_A^A]A\_^]
D97t<A
x UATAUAVAWH
C @8}Wu
A_A^A]A\]
@UVWATAUAVAWH
T$dfD
D$hfE
D+D$x
D+D$xD
A_A^A]A\_^]
WAVAWH
}0H+}(H
@A_A^_
@VWAVH
0A^_^
WAVAWH
@A_A^_
@VWATAVAWH
0A_A^A\_^
@SUVWAVAWH
s8D8{@uXL9>u$E3
L$@H3
XA_A^_^][
VWATAVAWH
@A_A^A\_^
UWAVH
@8y(t
VWATAVAWH
@A_A^A\_^
SVWAVH
8A^_^[
UVWATAUAVAWH
L$@L+
L$@fD
A_A^A]A\_^]
WATAUAVAWH
0A_A^A]A\_
tAfA9(t;H
fA9,@u
@UVWATAUAVAWH
D9l$(|
D$,D8-$
t(D8-
@USVWATAVAWH
fD9!H
D9d$(
t(D8%#
A_A^A\_^[]
x AVH
t+I9^
@SUVWATAVAWH
A_A^A\_^][
@USVWH
D$ E3
H_^[]
UWAVH
fD9u 
@USVWAVH
u@fD9u0A
.L9u8t7L
pA^_^[]
@UVWH
UVWAVAWH
L$hH3
pA_A^_^]
UWAWH
UVWAVAWH
A_A^_^]
WATAUAVAWH
fD9+tt
fD9+u
fD9+tSH
A_A^A]A\_
UATAUAVAWH
tjD9|$Xvc
A_A^A]A\]
@USVWATAUAWH
A_A]A\_^[]
@UVWH
UAVAWH
L$8E3
A_A^]
@UWAVH
fD9u8
PA^_]
@USVWATAVAWH
p)W\j
D9d$L
D9d$L
p)W\j
D9d$L
D8d$P
t0E9&
L$HD8
A_A^A\_^[]
UWATAUAWH
t9L9h
A_A]A\_]
UVATAVAWH
`A_A^A\^]
UWAWH
@USVWAVH
@A^_^[]
UWAUAVAWH
D8mwtnL
A_A^A]_]
UVWATAUAVAWH
|$A@8
@8|$@t
D$DE;
A8}0t
A8}0t
A_A^A]A\_^]
UATAUAVAWH
D$HE3
|$1D8
A_A^A]A\]
D$ E3
D$ E3
UAVAWH
fD9e8A
fD9e8A
A_A^]
@USVWAVH
@A^_^[]
@USVWAVH
@A^_^[]
UWAUAVAWH
A_A^A]_]
UATAUAVAWH
A_A^A]A\]
ATAVAWH
A_A^A\
UWAVH
H!\$8H!\$0H!\$(H!\$ 3
@USWH
` UAVAWH
a tSH
A_A^]
UWAVH
fD9u 
UWAVH
fD9u 
UAVAWH
fD9$Ou
fF9$Au
A_A^]
WAVAWH
0A_A^_
@USWH
USVWATAUAVAWH
t$hL9|$`u
L9|$xu
L9t$Hu
L9t$Hu
L9t$Hu
L9|$Hu
A_A^A]A\_^[]
WATAUAVAWH
\$ E3
@A_A^A]A\_
\$ UVWH
UVWATAUAVAWH
L9u@L
fD94Hu
D$ E3
PA_A^A]A\_^]
@UVWH
@WAVAWH
@A_A^_
UWAWH
@USVWAVH
uHfD9u8A
L9u@uw
pL9u@tRD8
PA^_^[]
ATAVAWH
A_A^A\
UAUAVH
A^A]]
@USWH
UWAUAVAWH
D$`fD98t
fD98t
A_A^A]_]
x AVH
@USVWAVH
H!\$8H!\$0H!\$(H!\$ L
A^_^[]
@USVWAUAVH
A^A]_^[]
@USVWATAUAVAWH
t_L9h
t%H9p
t%H9p
|$hA;
A_A^A]A\_^[]
@USVWATAUAVAWH
t$0E3
D8|$0
cD8|$0t9I
A_A^A]A\_^[]
UVWAVAWH
D9|$Du
A_A^_^]
@USVWATAUAVAWH
L9t$8u
tjH9X
A_A^A]A\_^[]
UVWATAUAVAWH
D$`H9|$Xu
D$pI9_
A8_1u
A8_2u
8\$@A
A8_0t
A8_0t
A_A^A]A\_^]
UWAWH
VWAVH
UATAUAVAWH
tAH9X
L9t$xu
A_A^A]A\]
UVWATAUAVAWH
D$PH9\$Hu
E8~1u
E8~2u
L9d$Hu
A_A^A]A\_^]
t$ UWAWH
L$(E3
@UWAVH
@A^_]
@UVWH
@USVWAVAWH
A_A^_^[]
UATAUAVAWH
fE9,Au
D$ E3
A_A^A]A\]
UVWATAUAVAWH
L!l$8L!l$0L!l$(L!l$ L
D8d$@t5L
A_A^A]A\_^]
UWATH
UWATAUAVH
D9 u]H
D8d$1
D8d$0t)L
D8d$0u[M
A^A]A\_]
USVWAVH
H!\$83
H!\$0H!\$(H!\$ 3
A^_^[]
UAVAWH
A_A^]
UWAUAVAWH
A_A^A]_]
WAVAWH
0A_A^_
UWATAVAWH
D$`E3
D8d$0u;L
A_A^A\_]
L$`H3
UVWAVAWH
A_A^_^]
UVWATAUAVAWH
A_A^A]A\_^]
UAVAWH
A_A^]
WAVAWH
PA_A^_
@VWAVH
0A^_^
@USVWATAVAWH
cfD9}o
}gfD9}o
fD9}ot>D8}g
tOD8}gtBH
D8}gt%H
A_A^A\_^[]
UAVAWH
A_A^]
@USVWAUAVAWH
t$`uFE3
A_A^A]_^[]
@USVWAVH
A^_^[]
UATAUAVAWH
A_A^A]A\]
UVWATAVH
PA^A\_^]
UWATH
UATAUAVAWH
A_A^A]A\]
UAVAWI
A_A^]
UWAUAVAWH
A_A^A]_]
UAVAWH
A_A^]
UATAUAVAWH
A_A^A]A\]
UVWAVAWH
A_A^_^]
USWATAUAVAWH
fE9 H
fD9 t
A_A^A]A\_[]
@UWAVH
PA^_]
UVWATAUAVAWH
fD9/A
fF9,wu
A_A^A]A\_^]
@UVWH
@USWH
UAVAWH
D8M8A
A_A^]
UVWAVAWH
pA_A^_^]
UWAWH
H!EwH
UVWAVAWH
I;v@r
`A_A^_^]
USVWATAUAVAWH
H!MX3
H!E`M
HA_A^A]A\_^[]
WAVAWH
D;}(r
 A_A^_
UVWATAUAVAWH
A9~0u
E9f(v)I
E;f(r
@A_A^A]A\_^]
VWATAVAWH
H!|$x
D;}(r
H!t$x
0A_A^A\_^
t$ WAVAWH
0A_A^_
UVWATAUAVAWH
!0H!t$pI
A9u0t)H!|$pH
0A_A^A]A\_^]
VWATAVAWH
0A_A^A\_^
UVWAVAWH
H!\$8H!\$0H!\$(H!\$ L
H!\$8H!\$0H!\$(H!\$ L
A_A^_^]
UWAVH
H!\$8H!\$0H!\$(H!\$ L
|$ AVH
H!\$83
H!\$0H!\$(H!\$ 3
UVWATAUAVAWH
D$(D8eXt
A_A^A]A\_^]
VWAVH
UVWAVAWH
\zV&8
pA_A^_^]
UWAVH
\zV&8
UWAVH
\zV&8
VWAVH
T$PE3
VWAVH
T$PE3
VWAVH
T$PE3
UWATAVAWH
D$XL9d$Pu
D$ E3
A_A^A\_]
UWATAVAWH
L9d$`u
D$ E3
A_A^A\_]
UVATAVAWH
H!\$8H!\$0H!\$(H!\$ L
A_A^A\^]
UWAUAVAWH
H!\$8H!\$0H!\$(H!\$ L
H!\$8H!\$0H!\$(H!\$ L
A_A^A]_]
UVWATAUAVAWH
D$`E3
A_A^A]A\_^]
UWATAVAWH
H!\$8H!\$0H!\$(H!\$ L
A_A^A\_]
UWAUAVAWH
H!\$8H!\$0H!\$(H!\$ L
H!\$8H!\$0H!\$(H!\$ L
A_A^A]_]
UVWATAUAVAWH
A_A^A]A\_^]
UVWATAUAVAWH
fD9$Au
fD9$qu
`A_A^A]A\_^]
UWATAVAWH
fD9$Au
A_A^A\_]
UVWAVAWH
H!\$8H!\$0H!\$(H!\$ L
A_A^_^]
t$ UWAVH
H!\$83
H!\$0H!\$(H!\$ 3
UVWAVAWH
`A_A^_^]
UVWAVAWH
\zV&8
`A_A^_^]
UVWATAUAVAWH
D$`E3
A_A^A]A\_^]
UVWAVAWH
H!\$8H!\$0H!\$(H!\$ L
H!\$8H!\$0H!\$(H!\$ L
A_A^_^]
UVWATAUAVAWH
H!|$8L
L$DH!|$0L
D$PH!|$(3
H!|$ H
H!|$8D
H!|$0A
H!|$(H!|$ H
A_A^A]A\_^]
UVWATAUAVAWH
A_A^A]A\_^]
qB^Xh
UVWATAUAVAWH
H!\$8H!\$0H!\$(H!\$ L
A_A^A]A\_^]
UWATAVAWH
H!\$8H!\$0H!\$(H!\$ L
H!\$8H!\$0H!\$(H!\$ L
A_A^A\_]
UWATAVAWH
A_A^A\_]
UWATAVAWH
D8|$@u)L
L$`E3
D8|$@uUL
A_A^A\_]
UAVAWH
A_A^]
l$ VWAVH
H!\$8L
L$@H!\$0L
D$PH!\$(3
H!\$ H
l$ VWAVH
H!\$8L
L$@H!\$0L
D$PH!\$(3
H!\$ H
VWAUAVAWH
o(;o(v
@A_A^A]_^
t$ WATAUAVAWH
D;v(r
0A_A^A]A\_
UVWAVAWH
L$`9L$Pu
 A_A^_^]
9O4tN
A,9A(
BX9A4t
EX9G4t6
UVWATAUAVAWH
~(D8n8t@H
l$pE3
EX9F4tZ
0A_A^A]A\_^]
qB^Xh
EX9G$tV
9N4tN
9O4t>
p AWH
9O4t?A
p AWH
9N4t\A
x AVH
p WATAUAVAWH
d$pA!,$I
D$`D;
 A_A^A]A\_
p WATAUAVAWH
d$pA!,$I
D$`D;
 A_A^A]A\_
p WAVAWH
 A_A^_
@UAVAWH
D9|$(|
D8=bb
t(D8=(b
f9<Au
t$ WH
L$0H3
VWATAVAWH
@A_A^A\_^
@VWAVH
0A^_^
UVWATAUAVAWH
t$ E3
l$ E3
>ARI8u!A
:TOC8uJD9B
RCV2D9
A_A^A]A\_^]
v$A+I
5fD9n
UVWAVAWH
5@8}PtZH
`A_A^_^]
f94Cu
f94Ku
UVWAVAWH
ubH!]@H
D$ E3
MHH!}@H
H9}@tX3
pA_A^_^]
UAVAWH
A_A^]
D$ E3
WATAUAVAWH
D$xE3
D$xE3
fD9,Vu
0A_A^A]A\_
D$(E3
D$ E3
WATAVH
L$(E3
0A^A\_
L$ VWAVH
t$XE3
t$PE3
t$ WAVAWH
|$XE3
|$PE3
A_A^_
\$ UVW
WAVAWH
 A_A^_
x AVH
VWAVH
 A^_^
x AVH
t$ WAVAWH
fD98t
L$XfD
D8|$XA
0A_A^_
t$ WH
x AVH
@SUVWATAUAVAWH
fA9T>
fD9DO
A_A^A]A\_^][
<@\t=fB
<@/t5L
<P/u(
t[f9+tV
UVWATAUAVAWH
L$8E3
A_A^A]A\_^]
<A\t.H
VWAVH
fA9,Pu
 A^_^
VWATAVAWH
0A_A^A\_^
t$ WATAUAVAWH
fD9(t
r#fD9
 A_A^A]A\_
ATAVAWH
fD9 t
tgfD9e
fD9 t
tyfD9"tsH
fD9 t
 A_A^A\
@UVWH
UWAUAVAWH
|$DE3
D9|$D
xmD8|$@ufD
fD9<Au
A_A^A]_]
@UVWATAUAVAWH
A_A^A]A\_^]
WAVAWH
fD98t
fD98t
0A_A^_
\$ E3
VWAVH
@USVWATH
\$hH!EHH
pxU>w&i
A\_^[]
:%|fUu=
H9Q tCH
UWAVH
@A^_]
VWAVH
H9{ tCH
 A^_^
@UVWH
UWAVH
PA^_]
\$ UVWAVAWH
fD9u0
ffD9u0
`A_A^_^]
@UVWH
p WvA>
UAVAWH
`A_A^]
t`H!\$HH
t`H!\$HH
}bwu=
@USVWATAVAWH
pA_A^A\_^[]
UWAWH
UWATAVAWH
A_A^A\_]
UWAVH
fD9u0u
UWAVH
@UWAVH
0A^_]
WAVAWH
0A_A^_
@UVWAVAWH
0A_A^_^]
@USVWAVH
`A^_^[]
@UVWAVAWH
}HD8}8
]HD8}8
@A_A^_^]
q)W\j
WAVAWH
 A_A^_
@VWAVH
fB9<[u
@A^_^
\$ UVWAVAWH
fD98t
A_A^_^]
x AVH
WATAVH
 A^A\_
UVWATAUAVAWH
|$hE3
D$`D8\$ht
 A_A^A]A\_^]
q0R^G'
ATAVAWH
p0R^G'
 A_A^A\
q:_0#
VWAVH
\$ E3
D$HE3
D$HE3
LcA<E3
HcQ<H
\$ UH
 H3E H3E
x AVH
E(=csm
E8=csm
EH=csm
EX=csm
Eh=csm
Ex=csm
Exception
ReturnNt
ReturnHr
LogNt
LogHr
FailFast
%hs(%u)\%hs!%p: 
%hs!%p: 
(caller: %p) 
%hs(%d) tid(%x) %08X %ws
Msg:[%ws] 
CallContext:[%hs] 
[%hs(%hs)]
[%hs]
kernelbase.dll
lntdll.dll
RtlRegisterFeatureConfigurationChangeNotification
RtlUnregisterFeatureConfigurationChangeNotification
RtlNotifyFeatureUsage
NtQueryWnfStateData
NtUpdateWnfStateData
onecore\internal\sdk\inc\wil\opensource\wil\resource.h
onecore\internal\sdk\inc\wil/Staging.h
WilStaging_02
%CSIDL_LOCAL_APPDATA%\Microsoft\Windows\Notifications
appdb.dat
%CSIDL_LOCAL_APPDATA%\Packages\$\SystemAppData
Software\Classes\ActivatableClasses
Software\Classes\Extensions
Software\Classes\PackagedCom
Software\Classes\Local Settings\Software\Microsoft\Windows\CurrentVersion\AppModel\Mappings
Software\Classes\Local Settings\Software\Microsoft\Windows\CurrentVersion\AppModel\PackageRepository\Packages
Software\Classes\Local Settings\Software\Microsoft\Windows\CurrentVersion\AppModel\Repository\Packages
Software\Microsoft\Windows\CurrentVersion\AppX\ByteCodeQueue
Software\Microsoft\Windows\CurrentVersion\AppModel\StateChange
Software\RegisteredApplications
AppX*
%ProgramData%\Microsoft\Windows\AppRepository\winstore_*_cw5n1h2txyewy.xml
%ProgramData%\Microsoft\Windows\AppRepository\windows.immersivecontrolpanel_*_cw5n1h2txyewy.xml
%ProgramData%\Microsoft\Windows\AppRepository\CheckPoint.VPN_*_cw5n1h2txyewy.xml
%ProgramData%\Microsoft\Windows\AppRepository\f5.vpn.client_*_cw5n1h2txyewy.xml
%ProgramData%\Microsoft\Windows\AppRepository\FileManager_*_cw5n1h2txyewy.xml
%ProgramData%\Microsoft\Windows\AppRepository\JuniperNetworks.JunosPulseVpn_*_cw5n1h2txyewy.xml
%ProgramData%\Microsoft\Windows\AppRepository\Microsoft.MoCamera_*_cw5n1h2txyewy.xml
%ProgramData%\Microsoft\Windows\AppRepository\SonicWALL.MobileConnect_*_cw5n1h2txyewy.xml
Software\Classes\AppX$
Software\Classes\Folder
Software\Classes\FolderTypes
Software\Classes\Local Settings\Software\Microsoft\Windows\CurrentVersion\AppContainer\Storage\$\ManifestLanguagesList
Software\Classes\Local Settings\Software\Microsoft\Windows\CurrentVersion\AppModel\SystemAppData
Software\Microsoft\Windows\CurrentVersion\AppContainer\Storage\$\ManifestLanguagesList
Software\Microsoft\Windows\CurrentVersion\AppSync
Software\Microsoft\Windows\CurrentVersion\AppHost\IndexedDB
Software\Microsoft\Windows\CurrentVersion\DeviceCapabilities
Software\Microsoft\Windows\CurrentVersion\PushNotifications
AppDB
Software\Microsoft\Windows\CurrentVersion\Authentication\LogonUI\Notifications\Alarm
Software\Microsoft\Windows\CurrentVersion\Authentication\LogonUI\Notifications\BackgroundCapability
Software\Microsoft\Windows\CurrentVersion\Authentication\LogonUI\Notifications\Badge
Software\Microsoft\Windows\CurrentVersion\Authentication\LogonUI\Notifications\Tile
Software\Microsoft\Windows\CurrentVersion\Explorer\AutoplayHandlers\Handlers
Local\SM0:%lu:%lu:%hs
Windows.Management.Deployment.PackageManager
Windows.Management.Deployment.Internal.PackageManagerInternal
Windows.Internal.StateRepository.Management.RepositoryManager
{OX,*
Windows.Internal.StateRepository.Package
APPID
S-1-1-0
S-1-5-18
AppxMetadata\AppxBundleManifest.xml
AppxManifest.xml
Software\Microsoft\Windows\CurrentVersion\Appx
\InfusedApps
\Applications\
\Frameworks\
\Packages\
Upgrade
\Microsoft\Windows\AppxDeploymentClient
AppInstallerUpdater
StubPreference
PreferStub
ManifestCacheOptions
onecore\admin\appmodel\Common\ManifestCache.hpp
false
\PluginExecutedFixStateRepository
SYSTEM\Setup\Upgrade\Appx
AppxAllUserStore
AppxUpgradeMigrationPlugin.dll
\Autogen
Autogen
%ProgramFiles%\WindowsApps\
%SystemRoot%\System32\
\microsoft.system.package.metadata
TotalTimeTaken
S-1-15-3-1024-3635283841-2530182609-996808640-1887759898-3848208603-3313616867-983405619-2501854204
_Classes
\Local Settings\Software\Microsoft\Windows\CurrentVersion\AppContainer\Storage
\OSRollbackPackages.txt
PluginHasExecutedOffline
AppxUpgradeNeeded
NoReRegisterOnUpgrade
DownlevelOSVersion
FixStateRepositoryIntegrityCompleted
ApplyTrustOffline.exe
/OfflineSoftwareHive:"
Applications
Bundle
BundleFullName
BundleManifestInfo
DownlevelGather
DownlevelInstalled
DownlevelPackageRepositoryRoot
DownlevelPackageRoot
EndOfLife
ExcludeFiles
ExcludeInfusedApps
Framework
InSingleInstanceStore
InstalledPackages
InstallState
IsFramework
IsStub
Optional
PackageInstallState
PackageRepositoryRoot
PackageRoot
PackageStatus
PackagesToCheckForStagingCompletion
PackagesToRemove
PackagesToReRegister
PackageType
ProcessPackagesToApplyUsingGatheredData
Resource
SisDirectory
Staged
StagedUserAcquired
StateChange
Windows.MiracastView_6.3.0.0_neutral_neutral_cw5n1h2txyewy
Microsoft.Windows.SecondaryTileExperience_10.0.0.0_neutral__cw5n1h2txyewy
Clipchamp.Clipchamp_yxz26nhyzhsrt
flipgrid.com-8F71AE01_mthbhdxggzve2
Microsoft.BingNews_8wekyb3d8bbwe
Microsoft.BingWeather_8wekyb3d8bbwe
Microsoft.CommsPhone_8wekyb3d8bbwe
Microsoft.549981C3F5F10_8wekyb3d8bbwe
Microsoft.D3DMappingLayers_8wekyb3d8bbwe
Microsoft.DesktopAppInstaller_8wekyb3d8bbwe
Microsoft.GamingApp_8wekyb3d8bbwe
Microsoft.GetHelp_8wekyb3d8bbwe
Microsoft.Getstarted_8wekyb3d8bbwe
Microsoft.HEIFImageExtension_8wekyb3d8bbwe
Microsoft.Messaging_8wekyb3d8bbwe
Microsoft.MicrosoftOfficeHub_8wekyb3d8bbwe
Microsoft.MicrosoftPowerBIForWindows_8wekyb3d8bbwe
Microsoft.MicrosoftSkyDrive_8wekyb3d8bbwe
Microsoft.MicrosoftSolitaireCollection_8wekyb3d8bbwe
Microsoft.MicrosoftStickyNotes_8wekyb3d8bbwe
Microsoft.MicrosoftTeamsforSurfaceHub_8wekyb3d8bbwe
Microsoft.MinecraftEducationEdition_8wekyb3d8bbwe
Microsoft.MixedReality.Portal_8wekyb3d8bbwe
Microsoft.Office.Desktop_8wekyb3d8bbwe
Microsoft.Office.Desktop.Access_8wekyb3d8bbwe
Microsoft.Office.Desktop.Excel_8wekyb3d8bbwe
Microsoft.Office.Desktop.OneNote_8wekyb3d8bbwe
Microsoft.Office.Desktop.Outlook_8wekyb3d8bbwe
Microsoft.Office.Desktop.PowerPoint_8wekyb3d8bbwe
Microsoft.Office.Desktop.Project_8wekyb3d8bbwe
Microsoft.Office.Desktop.Publisher_8wekyb3d8bbwe
Microsoft.Office.Desktop.SkypeForBusiness_8wekyb3d8bbwe
Microsoft.Office.Desktop.Visio_8wekyb3d8bbwe
Microsoft.Office.Desktop.Word_8wekyb3d8bbwe
Microsoft.OneConnect_8wekyb3d8bbwe
Microsoft.Office.Excel_8wekyb3d8bbwe
Microsoft.Office.PowerPoint_8wekyb3d8bbwe
Microsoft.Office.Word_8wekyb3d8bbwe
Microsoft.Paint_8wekyb3d8bbwe
Microsoft.People_8wekyb3d8bbwe
Microsoft.PowerAutomateDesktop_8wekyb3d8bbwe
Microsoft.ScreenSketch_8wekyb3d8bbwe
Microsoft.SecHealthUI_8wekyb3d8bbwe
Microsoft.SkypeApp_kzf8qxf38zg5c
Microsoft.StorePurchaseApp_8wekyb3d8bbwe
Microsoft.Todos_8wekyb3d8bbwe
Microsoft.VCLibs.140.00_8wekyb3d8bbwe
Microsoft.UI.Xaml.2.4_8wekyb3d8bbwe
Microsoft.UI.Xaml.2.7_8wekyb3d8bbwe
Microsoft.Xbox.TCUI_8wekyb3d8bbwe
Microsoft.VP9VideoExtensions_8wekyb3d8bbwe
Microsoft.WebMediaExtensions_8wekyb3d8bbwe
Microsoft.WebpImageExtension_8wekyb3d8bbwe
Microsoft.Whiteboard_8wekyb3d8bbwe
Microsoft.Windows.Photos_8wekyb3d8bbwe
Microsoft.WindowsAlarms_8wekyb3d8bbwe
Microsoft.WindowsCalculator_8wekyb3d8bbwe
Microsoft.WindowsCamera_8wekyb3d8bbwe
Microsoft.WindowsCommunicationsApps_8wekyb3d8bbwe
Microsoft.WindowsFeedbackHub_8wekyb3d8bbwe
Microsoft.WindowsMaps_8wekyb3d8bbwe
Microsoft.WindowsNotepad_8wekyb3d8bbwe
Microsoft.WindowsSoundRecorder_8wekyb3d8bbwe
Microsoft.WindowsStore_8wekyb3d8bbwe
Microsoft.WindowsTerminal_8wekyb3d8bbwe
Microsoft.XboxGameOverlay_8wekyb3d8bbwe
Microsoft.XboxGamingOverlay_8wekyb3d8bbwe
Microsoft.XboxIdentityProvider_8wekyb3d8bbwe
Microsoft.XboxSpeechToTextOverlay_8wekyb3d8bbwe
Microsoft.YourPhone_8wekyb3d8bbwe
Microsoft.ZuneMusic_8wekyb3d8bbwe
Microsoft.ZuneVideo_8wekyb3d8bbwe
MicrosoftWindows.Client.WebExperience_cw5n1h2txyewy
outlook.office.com-F53E19B5_akxy2sb7nnr06
\Local Settings\Software\Microsoft\Windows\CurrentVersion\AppModel\Repository\Packages
MigXml
PackageRootFolder
HasCellularModem
CellularAppsRemoved
SOFTWARE\Microsoft\Messaging
LOG_IF_FAILED(%hs) failed with 0x%x
onecore\admin\appmodel\appxupgrademigrationplugin\src\appxupgrademigrationpluginclass.cpp
RtlGetDeviceFamilyInfoEnum
GetVersionInfo(&osVersion)
RETURN_IF_FAILED(%hs) failed with 0x%x
Appx Migration Plugin will not perform re-registration of Packages (OSupgradeInPlace)
Appx Migration Plugin will perform re-registration of Packages (OSswap)
Appx Migration Plugin called RtlGetDeviceFamilyInfoEnum: downlevelOSVersion=0x%llx
InitializeSystemSisFullPath()
InitializePackageRepositoryRoot()
this->pluginAppxKey.Create(HKEY_LOCAL_MACHINE, pluginRegistryKeyPath, KEY_ALL_ACCESS)
this->pluginAppxKey.SetStringValue(s_DownlevelPackageSisRoot, this->singleInstanceStore.GetChars())
this->pluginAppxKey.SetStringValue(s_DownlevelPackageRepositoryRoot, this->packageRepository.GetChars())
this->pluginAppxKey.CreateSubKey(s_Applications, KEY_READ | KEY_WRITE, &applicationsKey)
applicationsKey.SetUInt32Value(appxUpgradeNeededValueName, this->appxUpgradeNeeded ? 1 : 0)
applicationsKey.SetUInt32Value(noReRegisterOnUpgradeValueName, this->noReRegisterOnUpgrade ? 1 : 0)
applicationsKey.SetUInt64Value(downlevelOSVersionValueName, this->downlevelOSVersion)
this->pluginAppxKey.GetStringValue(s_DownlevelPackageSisRoot, &this->singleInstanceStore)
this->pluginAppxKey.GetStringValue(s_DownlevelPackageRepositoryRoot, &this->packageRepository)
this->pluginAppxKey.OpenSubKey(s_Applications, KEY_READ, &applicationsKey)
applicationsKey.GetUInt32Value(appxUpgradeNeededValueName, &appxUpgradeNeededValue)
applicationsKey.GetUInt32Value(noReRegisterOnUpgradeValueName, &noReRegisterOnUpgradeValue)
applicationsKey.GetUInt64Value(downlevelOSVersionValueName, &this->downlevelOSVersion)
this->GetContext()->get_UserSidString(&userSid)
valueNameBuilder.AppendString(pluginHasExecutedOfflineValueName)
valueNameBuilder.AppendString(userSid ? userSid.get() : L"")
this->GetContext()->GetOfflineStatus(&offlineExecution)
GetOfflineRegistryPath(RegistryHive::HKLM, pluginRegistryKeyPath, &regPath)
hrCreateKey
Failed to create reg key %ls with 0x%x
GetPluginHasExecutedOfflineValueName(valueName)
hrSetValue
Failed with 0x%x to set %ls key value
SetPluginHasExecutedOffline succeeded for value-name: %ls.
GetEffectiveRegistryPath(RegistryHive::HKLM, pluginRegistryKeyPath, offlineExecution, effectivePluginKeyPathBuffer, effectivePluginKeyPath)
hrOpenKey
Failed to open reg key %ls with 0x%x
key.ValueExists(valueName.GetChars(), &hasExecutedOffline)
GetPluginHasExecutedOffline: %d for context %ls
RtlGetVersion failed with error code: 0x%x
!(wil::verify_bool(versionSize > 0))
RETURN_LAST_ERROR_IF(%hs) failed with 0x%x
versionData.IsNull()
RETURN_HR_IF(%hs) failed with 0x%x
GetFileVersionInfoEx(FILE_VER_GET_LOCALISED | FILE_VER_GET_NEUTRAL, appxUpgradeMigrationPluginFileName, 0, versionSize, versionData)
RETURN_IF_WIN32_BOOL_FALSE(%hs) failed with 0x%x
Appx Migration Plugin version number is %d.%d.%d.%d
!(wil::verify_bool(QueryServiceStatus(service.get(), &serviceStatus)))
GetServiceStatus(serviceName, &status)
%ls service status = 0x%x
AppxSvc
StateRepository
AppReadiness
ExpandEnvironmentStrings(appRepositoryPath, expandedPath, ARRAYSIZE(expandedPath)) == 0
fileNameBuilder.AppendString(expandedPath)
fileNameBuilder.AppendChar('\\')
fileNameBuilder.AppendString(stateRepositoryMachineDatabase)
Common::FileExists(fileName.GetChars(), &fileExists)
%ls file exists
%ls file does not exist
fileNameBuilder.AppendString(stateRepositoryWalFile)
Plugin registry key after Gather:
registryKey->OpenSubKey(subKeyName, KEY_READ, &subKey)
hrEnumSubkeys
result == 0
Unexpected failure from ExpandEnvironmentStrings on string %ls. Buffer size %u characters. Required size %u characters
fullFilePathBuilder.AppendString(expandedSystem32Path)
fullFilePathBuilder.AppendString(path)
fullFilePath->SetValue( moduleFullPath, static_cast<ULONG>(lastBackslash + 1 - moduleFullPath))
pathBuilder.AppendString(path)
GetModuleFileName failed 0x%x -- unable to create full file path for %ls
bstrOnlineFilePath.CopyFromString(onlineFilePath)
this->context->GetOfflineFileLocation( bstrOnlineFilePath.Value(), &bstrOfflineFilePath)
offlineFilePath->SetValueFromString(reinterpret_cast<PCWSTR>(bstrOfflineFilePath.Value()))
HKLM\
registryPathBuilder.AppendString(hivePrefix)
registryPathBuilder.AppendString(onlineRegistryPath)
bstrOnlineRegistryPath.CopyFromString(onlineRegistryPathBuffer.GetChars())
this->context->GetOfflineRegistryLocation( bstrOnlineRegistryPath.Value(), &bstrOfflineRegistryPath)
offlineRegistryPath->SetValueFromString((reinterpret_cast<PCWSTR>(bstrOfflineRegistryPath.Value())) + hivePrefixLength)
GetOfflineRegistryPath(hive, path, &resultBuffer)
*cursor == L'\0'
familyName->SetLength(familyNameLength)
familyName->SetValue(fullName, nameLength)
familyNameBuilder.AppendString(cursor)
familyName->GetLength() == familyNameLength
RETURN_HR_IF_FALSE(%hs) failed with 0x%x
this->pluginDownlevelGatherKey.OpenSubKey(allUserStoreRegistryKeyName, KEY_READ, &allUserStoreKey)
allUserStoreKey.OpenSubKeyIfExists(AppxAllUserStore::allUserApplicationsString, KEY_READ, &allUserApplicationsKey)
this->allUserPackages.InsertIgnoreDuplicates(subKey)
allUserApplicationsKey.OpenSubKey(subKey, KEY_READ, &mainPackageKey)
mainPackageKey.GetUInt32ValueIfExists(AppxAllUserStore::regValueIsLOBApp, &isLOBApp, &valueExists)
GetFamilyNameFromFullName(subKey, &packageFamilyName)
this->lobProvisionedPackageFamilyNameSet.InsertIgnoreDuplicates(packageFamilyName.GetChars())
this->allUserFrameworkSet.InsertIgnoreDuplicates(subKey)
metadataPathBuilder.AppendString(sisPath)
metadataPathBuilder.AppendString(fullName)
metadataPathBuilder.AppendString(systemMetadataFolder)
this->includeMetadataSet.InsertIgnoreDuplicates(metadataPath.GetChars())
source.OpenSubKey(subKeyName, KEY_READ, &sourceSubKey)
destination.CreateSubKey(subKeyName, KEY_READ | KEY_WRITE, &destinationSubKey)
CopyRegistryKeyWithoutAcls(sourceSubKey, destinationSubKey)
nameBuffer.SetCapacity(nameBufferLength)
valueBuffer.SetCapacity(valueBufferLength)
HRESULT_FROM_WIN32(enumResult)
destination.SetValue(nameBuffer.GetChars(), valueBuffer.GetBufferPtr(), valueLength, valueType)
AppxUpgradeMigration::IsWirelessWanInterfaceType mib.PhysicalMediumType = %lu
AppxUpgradeMigration::IsWirelessWanInterfaceType mib.MediaType = %lu
AppxUpgradeMigration::IsWirelessWanInterfaceType GetIfEntry2 error = %lu
AppxUpgradeMigration::IsWirelessWanInterfaceType ConvertInterfaceGuidToLuid error = %lu
messagingKey.OpenIfExists(HKEY_LOCAL_MACHINE, c_messagingKeyPath, KEY_READ)
messagingKey.GetUInt32Value(c_hasCellularModemValue, &hasModem)
AppxUpgradeMigration::FoundCellularModemInstalled: Found a modem from a prior run = %lu.
AppxUpgradeMigration::FoundCellularModemInstalled: value doesn't exist
this->pluginAppxKey.GetUInt32Value(c_hasCellularModemValue, &hasModem)
AppxUpgradeMigration::FoundCellularModemInstalled: Found a modem from the 'gather' phase
AppxUpgradeMigration::FoundCellularModemInstalled: failed to find a modem from the 'gather' phase
AppxUpgradeMigration::CheckForCellularModemInstalledOrFoundBefore: Enter
AppxUpgradeMigration::CheckForCellularModemInstalledOrFoundBefore: has modem = %lu
INVALID_HANDLE_VALUE == deviceInfoList.get()
DevObjGetClassDevs(deviceInfoList.get(), &GUID_DEVCLASS_NET, nullptr, DOGCF_PRESENT, nullptr, 0)
AppxUpgradeMigration::CheckForCellularModemInstalledOrFoundBefore: index = %lu
AppxUpgradeMigration::CheckForCellularModemInstalledOrFoundBefore: failed DevObjOpenDevRegKey error = %lu
NetCfgInstanceId
AppxUpgradeMigration::CheckForCellularModemInstalledOrFoundBefore: failed NetCfgInstanceId error = %lu
AppxUpgradeMigration::CheckForCellularModemInstalledOrFoundBefore: CLSIDFromString error = %8.8X
AppxUpgradeMigration::CheckForCellularModemInstalledOrFoundBefore: Found wireless WAN
AppxUpgradeMigration::CheckForCellularModemInstalledOrFoundBefore: foundCellularModem = %lu
messagingKey.OpenIfExists(HKEY_LOCAL_MACHINE, c_messagingKeyPath, KEY_WRITE)
AppxUpgradeMigration::CheckForCellularModemInstalledOrFoundBefore: Failed to write cellular reg key value in the uplevel OS
AppxUpgradeMigration::CheckForCellularModemInstalledOrFoundBefore: Failed to write cellular reg key value
AppxUpgradeMigration::CheckForCellularModemInstalledOrFoundBefore: found only one interface, skipping check
AppxUpgradeMigration::CheckForCellularModemInstalledOrFoundBefore: Exit
pathBstr.CopyFromString(path)
context->ExpandEnvironmentVariables(pathBstr, &expandedPath)
context->GetOfflineStatus(&offlineExecution)
context->GetOfflineFileLocation(expandedPath, &offlinePath)
effectivePath.SetValueFromString(offlinePath)
effectivePath.SetValueFromString(expandedPath)
CreateAppxProvisionFactory(&appxProvisionFactory)
%PROGRAMDATA%\Microsoft\Windows\AppxProvisioning.xml
AppxProvisioning.xml not found in programdata folder, trying system32 location
%WINDIR%\System32\AppxProvisioning.xml
hrGetProvisionXmlPath
0x%x: Could not get path to provisioning XML -- not performing EOL and provisioned-package cleanup
Reading provisioning XML from location: %ls
hrCreateProvisionStreamingReaderFromFile
Could not open %ls: 0x%x -- not performing EOL and provisioned-package cleanup
reader->GetListEnumerator( ProvisionPackageList_EndOfLife, &eolPackages)
eolPackages->GetCurrent(&package)
package->GetPackageFamilyName(&familyName)
this->endOfLifePackageFamilyNameSet.InsertIgnoreDuplicates(familyName)
Package family %ls is end-of-lifed
CallRtlGetDeviceFamilyInfoEnumIfFunctionAvailable(nullptr, &deviceFamily, nullptr)
this->endOfLifePackageFamilyNameSet.InsertIgnoreDuplicates(desktopOnlyEndOfLifePackageFamilyName)
[Desktop Only]Package family %ls is end-of-lifed
GetOfflineRegistryPath(RegistryHive::HKLM, c_messagingKeyPath, &offlineAppxRegKeyPath)
AppxUpgradeMigration::AppxUpgradeMigration: failed reading EOL reg vaue
AppxUpgradeMigration::AppxUpgradeMigration: cellular apps was already EOL %lu
AppxUpgradeMigration::AppxUpgradeMigration: cellular apps was already EOL
this->endOfLifePackageFamilyNameSet.InsertIgnoreDuplicates(desktopOnlyMessagingEndOfLifePackageFamilyName)
this->endOfLifePackageFamilyNameSet.InsertIgnoreDuplicates(desktopOnlyMobilePlansEndOfLifePackageFamilyName)
AppxUpgradeMigration::AppxUpgradeMigration: Failed to write cellular already EOL reg key value
[Desktop Only] Failed to find cellular modem in the descover phase.
reader->GetListEnumerator( ProvisionPackageList_Provisioned, &provisionedPackages)
provisionedPackages->GetCurrent(&package)
package->GetPackageFullName(&fullName)
Uplevel Provisioned package: %ls found in appxprovisioning.xml
GetFamilyNameFromFullName(fullName, &familyName)
PreserveMetadataForPackage(fullName)
this->excludePackageFullNameSet.InsertIgnoreDuplicates(fullName)
this->uplevelProvisionedPackageFamilyNameSet.InsertIgnoreDuplicates(familyName.GetChars())
GetIsPackageDeprovisionedInAllUserStoreUsingGatheredData(familyName.GetChars(), false , &packageDeprovisioned)
package->GetProperties(&packageProperty)
familyNameBuffer.SetValueFromString(familyName.GetChars())
this->uplevelProvisionedPackageMap.Insert(familyNameBuffer.GetChars(), newEntry.get())
(packageBundle->bundleFullName.GetLength() > 0)
RETURN_HR_IF_MSG(%hs) failed with 0x%x. Message is below:
Unexpected - bundle full name already added for the family. Existing bundle full name: %ls, full name to be added: %ls
packageBundle->bundleFullName.SetValueFromString(fullName)
(packageBundle->mainPackageFullName.GetLength() > 0)
Unexpected - main full name already added for the family. Existing main full name: %ls, full name to be added: %ls
packageBundle->mainPackageFullName.SetValueFromString(fullName)
fullNameBuffer->SetValueFromString(fullName)
packageBundle->resourcePackageFullNames.Add(fullNameBuffer.get())
Is a LOB app
this->lobProvisionedPackageFamilyNameSet.InsertIgnoreDuplicates(familyName.GetChars())
Is a top level package
Is being DROPPED because it is a de-provisioned package
Is a main or bundle package
InsertToPreferredMapUsingGatheredData(fullName, &familyNameBuffer, &this->combinedProvisionedMap, true , false , &comparison)
Is a resource package
Common::Deployment::GetVersionlessNameFromPackageFullName( fullName, &versionlessName)
InsertToPreferredMapUsingGatheredData(fullName, &versionlessName, &this->resourceMap, true , false )
Is a framework package
InsertToPreferredMapUsingGatheredData(fullName, &versionlessName, &this->frameworkMap, true , false )
Ignoring package %ls with unknown property type %x
Gathering bundle manifest data for %ls
GatherDataForProcessBundleManifestPackages(packageFullName)
AppxAllUserStore::GetAllUserApplicationsFullPath(&allUserStoreApplicationsPath)
allUserApplicationsKey.OpenIfExists(HKEY_LOCAL_MACHINE, allUserStoreApplicationsPath.GetChars(), KEY_READ)
%ls key not found, skipping GatherDataForProcessAllUserStorePackages
EnumerateAndCachePackagesInAllUserStoreUsingGatheredData()
GetFamilyNameFromFullName(packageFullName, &packageFamilyName)
Processing downlevel all-user provisioned package %ls 
Package is being end of lifed so its package root will be excluded
this->excludePackageFullNameSet.InsertIgnoreDuplicates(packageFullName)
Package is uplevel provisioned.
Package is LOB and will be carried forward.
Package is not uplevel provisioned or LOB and will be carried forward. Since it's downlevel provisioned, but not uplevel provisioned implies this is an OEM package
this->oemProvisionedPackageFamilyNameSet.InsertIgnoreDuplicates(packageFamilyName.GetChars())
InsertToPreferredMapUsingGatheredData( packageFullName, &packageFamilyName, &this->combinedProvisionedMap, false , false , &comparison)
Processing downlevel all-user framework package %ls 
ProcessFrameworkUsingGatheredData(packageFullName)
packageManager->FindUsers(packageFullName, userInfoCollection.GetAddressOf())
userInfoCollection->First(userInfoIterator.GetAddressOf())
userInfoIterator->get_HasCurrent(&hasCurrent)
userInfoIterator->get_Current(userInfo.GetAddressOf())
userInfo->get_UserSecurityId(userInfoSid.Address())
userInfoSid.GetLpcwstr(&userAsLpcwstr)
userInfoIterator->MoveNext(&hasCurrent)
userInfo.Get()->get_InstallState(&installStateValue)
Package is in paused state. This package will be treated the same as if it were staged
api-ms-win-appmodel-runtime-l1-1-1.dll
this->appModelRuntimeApisetHandle
RETURN_LAST_ERROR_IF_NULL(%hs) failed with 0x%x
GetStagedPackagePathByFullName
this->GetStagedPackagePathByFullName
Successful delay-load of GetStagedPackagePathByFullName
packageInfo->get_Id(&packageId)
packageId->get_FullName(packageFullName.GetAddressOf())
ERROR_INSUFFICIENT_BUFFER != this->GetStagedPackagePathByFullName(packageFullName.GetRawBuffer(nullptr), &packageRootLength, nullptr)
packagePath.Initialize(packageRoot.get(), packageRootLength)
package8->get_InstalledPath(packagePath.ReleaseAndGetAddressOf())
EnsureDelayLoadGetStagedPackagePath()
Use get_InstalledLocation to get package root
packageInfo->get_InstalledLocation(&installedLocation)
installedLocation.As(&installedLocationStorageItem)
installedLocationStorageItem->get_Path(packagePath.ReleaseAndGetAddressOf())
this->pluginDownlevelGatherKey.OpenSubKey(s_SisDirectory, KEY_READ, &sisDirectoryKey)
sisDirectoryKey.OpenSubKeyIfExists(packageFullName, KEY_READ, &subKey)
GetSystemSisManifestPathFromPackageFullName( bundleFullName, &manifestPath)
CoCreateInstance( __uuidof(OpcFactory), NULL, CLSCTX_INPROC_SERVER, __uuidof(IOpcFactory), &opcFactory)
opcFactory->CreateStreamOnFile( manifestPath.GetChars(), OPC_STREAM_IO_READ, NULL, FILE_ATTRIBUTE_NORMAL, &manifestStream)
CoCreateInstance( __uuidof(AppxBundleFactory), NULL, CLSCTX_INPROC_SERVER, __uuidof(IAppxBundleFactory), &appxFactory)
appxFactory->CreateBundleManifestReader(manifestStream.Get(), bundleManifestReader.GetAddressOf())
this->pluginDownlevelGatherKey.CreateSubKey(s_BundleManifestInfo, KEY_READ | KEY_WRITE, &bundleInfoRootKey)
bundleInfoRootKey.CreateSubKey(bundleFullName, KEY_READ | KEY_WRITE, &bundleKey)
bundleManifestReader->GetPackageInfoItems(&packages)
packages->GetCurrent(&package)
package->GetPackageType(&packageType)
package->GetPackageId(&manifestPackageID)
manifestPackageID->GetPackageFullName(&packageFullName)
GetPackageDirectoryExistsUsingGatheredData(packageFullName, &exists)
bundleKey.CreateSubKey(packageFullName, KEY_READ | KEY_WRITE, &packageKey)
packageKey.SetUInt32Value(s_PackageType, packageType)
bundleKey.OpenSubKey(packageFullName, KEY_READ, &packageKey)
packageKey.GetUInt32Value(s_PackageType, &packageType)
Inserting %ls since it was brought by a bundle %ls
InsertToPreferredMapUsingGatheredData( packageFullName, &packageFamilyName, &this->combinedProvisionedMap, false , true , &packagePreferenceComparison)
Common::Deployment::GetVersionlessNameFromPackageFullName(packageFullName, &versionlessName)
InsertToPreferredMapUsingGatheredData(packageFullName, &versionlessName, &this->resourceMap, false , true )
this->pluginDownlevelGatherKey.OpenSubKey(s_BundleManifestInfo, KEY_READ, &bundleInfoRootKey)
bundleInfoRootKey.OpenSubKey(bundleFullName, KEY_READ, &bundleKey)
Package %ls will be preserved because package registration is preserved
Paused package %ls will be preserved as it will likely be the best version when it completes 
Package root of %ls will be excluded as it is less preferred
bundleAndMainPackage->bundle.SetValueFromString(packageFullName)
bundleAndMainPackage->mainPackage.SetValueFromString(packageFullName)
GetStubPreferenceKey(KEY_READ, stubPreferenceKey)
GetStubPreferenceFromKey(stubPreferenceKey, packageFamilyName->GetChars(), &packageIsStub)
GetPackageIsStubUsingGatheredData(packageFullName, &packageIsStub)
GetPackageIsPausedUsingGatheredData(packageFullName, &packageIsPaused)
hrProcessBundleManifestPackages
Failed to process bundle manifest packages: 0x%x. Excluding Bundle.
Package family not found yet, adding new entry
SetPreferredBundleAndMainPackageFields(newBundleAndMainPackage, packageFullName, isBundle, packageIsPaused, packageIsStub, false )
preferredMap->Insert(packageFamilyName->GetChars(), newBundleAndMainPackage.Value())
Main package
%ls not found yet, filling entry
SetPreferredBundleAndMainPackageFields(existingBundleAndMainPackage, packageFullName, isBundle, packageIsPaused, packageIsStub, true )
Same package was already found
Is less preferred than %ls
ExcludePackageRootIfNecessaryUsingGatheredData(packageFullName, packageFamilyName->GetChars(), checkIfLessPreferredShouldBePreserved, packageIsPaused)
Is more preferred than %ls
ExcludePackageRootIfNecessaryUsingGatheredData(existingFullName, packageFamilyName->GetChars(), checkIfLessPreferredShouldBePreserved, existingPackageIsPaused)
Has same main package as %ls
GetIsStubPreferredForPackageFamilyUsingGatheredData(packageFamilyName->GetChars(), &preferStubForFamily)
Matches stub preference while %ls doesn't
Doesn't match stub preference while %ls does
Common::Deployment::GetPackageIDFromPackageMoniker( existingFullName, nullptr, &existingPackageID)
Common::Deployment::GetPackageIDFromPackageMoniker( packageFullName, nullptr, &currentPackageID)
Is higher version than %ls
Is lower version than %ls
Is same version as %ls
GetFamilyNameFromFullName(packageFullName, &familyName)
GetStubPreferenceFromKey(stubPreferenceKey, familyName.GetChars(), &packageIsStub)
GetIsStubPreferredForPackageFamilyUsingGatheredData(familyName.GetChars(), &preferStubForFamily)
ExcludePackageRootIfNecessaryUsingGatheredData(packageFullName, familyName.GetChars(), checkIfLessPreferredShouldBePreserved, packageIsPaused)
ExcludePackageRootIfNecessaryUsingGatheredData(existingFullName, familyName.GetChars(), checkIfLessPreferredShouldBePreserved, existingPreferredPackage->isPaused)
preferredMap->Remove(packageLineageName->GetChars())
currentPackage->packageFullName.SetValueFromString(packageFullName)
preferredMap->Insert(packageLineageName->GetChars(), currentPackage)
Package %ls is being end of lifed so its package root will be excluded
InsertToPreferredMapUsingGatheredData( packageFullName, &packageFamilyName, &this->combinedProvisionedMap, false , true , &comparison)
WritePackageRegistryKey( packageFamilyName.GetChars(), packageFullName, userSid, &this->pluginStagedUserAcquiredKey, s_Staged)
Common::Deployment::GetVersionlessNameFromPackageFullName( packageFullName, &versionlessName)
InsertToPreferredMapUsingGatheredData( packageFullName, &versionlessName, &this->frameworkMap, false , false )
Common::StateSeparation::GetPersistedRegKeyPath(Common::StateSeparation::AppModelRoot, &s_StubPreference, 1, &stubPreferenceKeyPath)
Getting stub preference key. stubPreferenceKeyPath:  %ls
Getting stub preference key with offlineExecution: %d
GetEffectiveRegistryPath(RegistryHive::HKLM, stubPreferenceKeyPath, offlineExecution, effectiveStubPreferenceKeyPathBuffer, effectiveStubPreferenceKeyPath)
Opening the effective stub preference key path: %ls
key.Open(HKEY_LOCAL_MACHINE, effectiveStubPreferenceKeyPath, access)
key.OpenSubKeyIfExists(packageFamilyName, KEY_READ, &packageFamilyKey)
packageFamilyKey.GetUInt32ValueIfExists(s_PreferStub, &value, &valueExists)
this->pluginDownlevelGatherKey.OpenSubKeyIfExists(s_StubPreference, KEY_READ, &stubPreferenceRootKey)
GetStubPreferenceFromKey(stubPreferenceRootKey, packageFamilyName, stubPreferred)
this->pluginDownlevelGatherKey.OpenSubKeyIfExists(s_PackageInstallState, KEY_READ, &installStateRootKey)
installStateRootKey.OpenSubKeyIfExists(packageFullName, KEY_READ, &packageKey)
packageKey.GetUInt32ValueIfExists(s_IsStub, &isStubValue, &valueExists)
packageKey.GetUInt32ValueIfExists(s_InstallState, &packageInstallState, &valueExists)
Processing Package %ls
this->pluginDownlevelGatherKey.OpenSubKey(s_PackageInstallState, KEY_READ, &installStateRootKey)
packageKey.GetUInt32Value(s_InstallState, &packageInstallState)
Framework package is paused so its package root and backup manifest will be excluded
this->stagedOnlyManifestPackageFullNameSet.InsertIgnoreDuplicates(packageFullName)
ProcessMainOrBundlePackageUsingGatheredData(packageFullName)
ProcessResourcePackageUsingGatheredData(packageFullName)
registryKey->IsNull()
Writing %ls Key %ls\%ls
packageSubKeyBuilder.AppendString(userSid)
packageSubKeyBuilder.AppendChar(L'\\')
packageSubKeyBuilder.AppendString(packageFamilyName)
packageSubKeyBuilder.AppendString(packageFullName)
registryKey->CreateSubKey(packageSubKey.GetChars(), KEY_READ | KEY_WRITE, subKey)
subKey->SetStringValue(AppxAllUserStore::regValuePath, *packagePath)
GetSystemSisManifestPathFromPackageFullName( packageFullName, &manifestPath)
WritePackageRegistryKeyWithPath( packageFamilyName, packageFullName, userSid, registryKey, keyName, manifestPath.GetString(), createdKey)
Writing %ls Key %ls
packageSubKey->SetValueFromString(packageFullName)
stringArray->Add(packageSubKey)
GatherDataForProcessAllBundleResourceAndOptionalPackages()
GatherDataForProcessAllMainAndFrameworkPackages()
ProcessAllBundleResourceAndOptionalPackagesUsingGatheredData()
ProcessAllMainAndFrameworkPackagesUsingGatheredData()
GetPackageInstalledPath(package, packageRootPath)
package->get_IsFramework(&isFramework)
frameworkPackagesKey.CreateSubKey(packageFullName, KEY_READ | KEY_WRITE, &packageKey)
mainPackagesKey.CreateSubKey(packageFullName, KEY_READ | KEY_WRITE, &packageKey)
Gathering data for main or framework package %ls
Windows::Foundation::ActivateInstance(strActivatableClassId.Get(), &packageManager)
everyoneSid.Initialize(Common::Deployment::EveryoneSid.chars, Common::Deployment::EveryoneSid.length)
this->pluginDownlevelGatherKey.CreateSubKey(s_InstalledPackages, KEY_READ | KEY_WRITE, &installedPackagesKey)
installedPackagesKey.CreateSubKey(s_Main, KEY_READ | KEY_WRITE, &mainPackagesKey)
installedPackagesKey.CreateSubKey(s_Framework, KEY_READ | KEY_WRITE, &frameworkPackagesKey)
hrIteratePackages
hrProcessPackage
Failed processing main package %ls with 0x%x. Ignoring failure to continue with processing
Failed processing framework package %ls with 0x%x. Ignoring failure to continue with processing
this->pluginDownlevelGatherKey.OpenSubKey(s_InstalledPackages, KEY_READ, &installedPackagesKey)
installedPackagesKey.OpenSubKey(s_Main, KEY_READ, &mainPackagesKey)
hrEnumMainPackages
installedPackagesKey.OpenSubKey(s_Framework, KEY_READ, &frameworkPackagesKey)
hrEnumFrameworks
Gathering data for bundle %ls
bundlesKey.CreateSubKey(packageFullName, KEY_READ | KEY_WRITE, &packageKey)
Gathering data for resource package %ls
resourcePackagesKey.CreateSubKey(packageFullName, KEY_READ | KEY_WRITE, &packageKey)
Gathering data for optional package %ls
optionalPackagesKey.CreateSubKey(packageFullName, KEY_READ | KEY_WRITE, &packageKey)
If the OS doesn't support packageManager2 interface then no resource and bundles can be installed--no bundles and resources to process. 
hrActivateInstance
packageManager2.As(&packageManager)
installedPackagesKey.CreateSubKey(s_Bundle, KEY_READ | KEY_WRITE, &bundlesKey)
hrIterateBundles
installedPackagesKey.CreateSubKey(s_Resource, KEY_READ | KEY_WRITE, &resourcePackagesKey)
hrIterateResourcePackages
installedPackagesKey.CreateSubKey(s_Optional, KEY_READ | KEY_WRITE, &optionalPackagesKey)
hrIterateOptionalPackages
Failed processing bundle %ls with 0x%x. Ignoring failure to continue with processing
Failed processing resource package %ls with 0x%x. Ignoring failure to continue with processing
Failed processing optional package %ls with 0x%x. Ignoring failure to continue with processing
installedPackagesKey.OpenSubKey(s_Bundle, KEY_READ, &bundlesKey)
hrEnumBundles
installedPackagesKey.OpenSubKey(s_Resource, KEY_READ, &resourcePackagesKey)
hrEnumResourcePackages
installedPackagesKey.OpenSubKey(s_Optional, KEY_READ, &optionalPackagesKey)
hrEnumOptionalPackages
Downlevel OS already had package %ls registered, not writing to Staged Key
WritePackageRegistryKey( packageElement->GetKey(), bundleFullName, userSid, &this->pluginStagedKey, s_Staged)
WritePackageRegistryKey( packageElement->GetKey(), mainPackageFullName, userSid, &this->pluginStagedKey, s_Staged)
hrWriteFrameworkMap
hrWriteResourceMap
GetOfflineRegistryPath(RegistryHive::HKLM, Common::Deployment::AppXRegKeyPath.chars, &offlineAppxRegKeyPath)
registry.Open(HKEY_LOCAL_MACHINE, offlineAppxRegKeyPath.GetChars(), KEY_READ)
registry.GetStringValue(s_PackageRoot, MAX_EXTENDED_PATH, &this->singleInstanceStore)
Getting single instance store path failed with %x, switching to use legacy location
registry.Open(HKEY_LOCAL_MACHINE, Common::Deployment::AppXRegKeyPath.chars, KEY_READ)
registry.GetStringValue(s_PackageRepositoryRoot, MAX_EXTENDED_PATH, &this->packageRepository)
Common::Deployment::Configuration::GetPackageRepositoryRoot(&this->packageRepository)
manifestPathBuilder.AppendString(&Common::Deployment::ExtendedPathPrefix)
manifestPathBuilder.AppendString(this->singleInstanceStore.GetChars())
manifestPathBuilder.AppendChar(L'\\')
manifestPathBuilder.AppendString(packageFullName)
manifestPathBuilder.AppendString(&Common::Deployment::BundleManifestFileName)
manifestPathBuilder.AppendString(&Common::Deployment::ManifestFileName)
packageManifestPath->InitializeFromString(manifestPath.GetChars())
Writing out to include registry key %ls in XML Writer.
hrIncludeRegistryKey
Failed to include registry %ls in XML Writer: 0x%x
Writing out to include registry key %ls, value %ls in XML Writer.
hrIncludeRegistryValue
Failed to include registry key %ls, value %ls in XML Writer: 0x%x
Writing out to include directory %ls in XML Writer.
hrIncludePath
Failed to include directory %ls in XML Writer: 0x%x
Writing out to include directory %ls, file %ls in XML Writer.
Failed to include directory %ls, file %ls in XML Writer: 0x%x
Writing out to merge registry key %ls in XML Writer.
hrMergeRegistryKey
Failed to merge registry %ls in XML Writer: 0x%x
Writing out to merge registry key %ls, value %ls in XML Writer.
hrMergeRegistryValue
Failed to merge registry key %ls, value %ls in XML Writer: 0x%x
PackageList
Common::StateSeparation::GetPersistedRegKeyPath(Common::StateSeparation::AppxStateChange, subkeys, ARRAYSIZE(subkeys), &fullPath)
this->pluginDownlevelGatherKey.CreateSubKey(s_StateChange, KEY_READ | KEY_WRITE, &stateChangeKey)
CopyRegistryKeyWithoutAcls(packageStateKey, stateChangeKey)
MigXmlWriter::Create(true , &this->pluginDownlevelGatherKey, &xmlWriter)
this->pluginAppxKey.GetStringValue(s_DownlevelPackageSisRoot, packageRoot)
this->pluginAppxKey.GetStringValue(s_DownlevelPackageRepositoryRoot, backupManifestDir)
packageRootBuilder.AppendChar(L'\\')
this->pluginDownlevelGatherKey.OpenSubKey(s_StateChange, KEY_READ, &stateChangeKey)
Package %ls has an in-place update pending, can't move it away.
packageRoot.SetLength(packageRootLength)
packageRootBuilder.AppendString(package)
Writing out to move directory %ls to backup folder in XML Writer for OS downgrade.
hrMovePathToBackupFolder
Failed to move directory %ls to backup folder in XML Writer: 0x%x
backupManifestPathBuilder.AppendString(backupManifestDir.GetString())
backupManifestPathBuilder.AppendString(L"\\")
backupManifestPathBuilder.AppendString(package)
backupManifestPathBuilder.AppendString(L".xml")
Writing out to exclude file %ls in XML Writer.
hrExcludeFile
Failed to exclude file %ls in XML Writer: 0x%x
WriteOutRegistryIncludeRules( MigXmlRules::perMachineRegistryRules, ARRAYSIZE(MigXmlRules::perMachineRegistryRules), true, xmlWriter)
Writing out to registry %ls in XML Writer.
hrExcludeKey
Failed to exclude registry %ls in XML Writer: 0x%x
MigXmlWriter::Create(false , nullptr, &xmlWriter)
WriteOutRegistryIncludeRules( MigXmlRules::perUserRegistryRules, ARRAYSIZE(MigXmlRules::perUserRegistryRules), false, xmlWriter)
Processing appx provision XML
hrPopulateAppxProvisionXmlLists
Failed to process AppxProvisioning XML for end of life packages 0x%x. Proceeding as if AppxProvisioning XML does not exist so user acquired apps get processed
Processing all user store packages
hrProcessAllUserStorePackages
Failed to process all user store packages with 0x%x
Processing all installed packages
hrProcessAllInstalledPackages
Failed to process all installed packages with 0x%x
AppxUpgradeMigration::Discover called
AppxUpgradeMigration::Discover done (0x%x)
OpenFileInMachineWorkingDirectory(PluginExecutedFixStateRepositoryFilename, true , &fileHandle)
OpenFileInMachineWorkingDirectory(PluginExecutedFixStateRepositoryFilename, false , &file)
this->context->get_WorkingDir(&workingDir)
%ls\%ls%ls
StringCchPrintfW(pathname.get(), pathnameLength, L"%ls\\%ls%ls", workingDir.get(), subdir, filename)
(lastError != ERROR_FILE_NOT_FOUND)
File: %ls
created
not found
exists
File %ls in working dir: %ls
FixStateRepositoryOrResetMaintenance called
IsFixStateRepositoryAlreadyExecuted(alreadyExecuted)
FixStateRepositoryOrResetMaintenance already executed
FixStateRepositoryIfPossible(disposition)
ResetStateRepositoryMaintenance()
SetFixStateRepositoryAlreadyExecuted()
FixStateRepositoryOrResetMaintenance done
FixStateRepositoryIfPossible called
FixStateRepositoryViaExport(disposition)
FixStateRepositoryViaRepositoryManager(disposition)
FixStateRepositoryIfPossible completed Disposition=%d
FixStateRepositoryIfPossible failed (0x%x) Disposition=%d
CheckOrFixStateRepositoryViaExport called to %ls
ext-ms-onecore-appmodel-staterepository-internal-l1-1-2.dll
SRCheckIntegrity
srCheckIntegrity(options, &disposition)
Appx Migration Plugin called SRCheckIntegrity(%ls): Entrypoint not found (0x%x)
Appx Migration Plugin called SRCheckIntegrity(%ls): Module (%ls) not present
Appx Migration Plugin called SRCheckIntegrity(%ls): Module not loaded (0x%x)
Fixing
CheckOrFixStateRepositoryViaExport done %ls. Disposition: %d
FixStateRepositoryViaRepositoryManager called
Windows::Foundation::ActivateInstance(acid.Get(), &inspectable)
Found IRepositoryManager
repositoryManager->CheckIntegrity(options, &integrityDisposition, &countOfErrorsCorrected)
CheckRepository(Fix) reports Disposition=%d, #ErrorsCorrected=%I64u
Error retrieving IRepositoryManager 0x%x
Found IRepositoryManager_4b7906ca_2e76_43c5_8532_306ad2ffbcfa
repositoryManager_4b7906ca_2e76_43c5_8532_306ad2ffbcfa->CheckIntegrity(Windows::Internal::StateRepository::Management::IntegrityOptions_Fix)
RETURN_IF_FAILED_MSG(%hs) failed with 0x%x. Message is below:
Error retrieving IRepositoryManager_4b7906ca_2e76_43c5_8532_306ad2ffbcfa
FixStateRepositoryViaRepositoryManager done. Disposition %d
ResetStateRepositoryMaintenance called
SOFTWARE\Microsoft\Windows\CurrentVersion\AppModel\StateRepositoryStatus
regkey.Open(HKEY_LOCAL_MACHINE, stateRepositoryRegistryStatusSubkey, KEY_READ | KEY_WRITE)
MaintenanceLastPerformed
regkey.DeleteValueIfExists(L"MaintenanceLastPerformed")
AutoCheckIntegrity
regkey.SetUInt32Value(stateRepositoryRegistryNameAutoCheckIntegrity, autoCheckIntegrityOptions_FixIntegrity)
ResetStateRepositoryMaintenance done
system
Starting AppxUpgradeMigration Plugin during Discover for %ls
GetEffectiveRegistryPath(RegistryHive::HKLM, pluginRegistryKeyPath, offlineExecution, effectivePluginPathBuffer, effectivePluginPath)
LoadUpgradeDataFromPluginKey()
OS Upgrade running from an OS older than Win 8, so no work needed for Appx sub-system. Skip running Discover.
Plugin sub key found -- we're on uplevel system during apply phase for system context. Generate MigXml for Discover.
GenerateSystemMigrationXml(xmlStream)
Plugin sub key found -- we're on uplevel system during apply phase for user context. Skip running Discover.
hrInitializeUpgradeData
Determining if no re-registration of packages is needed failed with 0x%x. We will just default to re-registering all apps.
hrWriteOutPerUserMigrationXml
Failed to write out migration XML with 0x%x
Not generating migration XML on downlevel system since new packages can still be provisioned on uplevel image.  Migration XML will be generated during Discover on uplevel system.
Successfully finished processing all packages during AppxUpgradeMigration Discover
Found cached migration XML
Did not find cached migration XML, generating new one
hrReadAppXMigrationStores
Reading Appx Migration Stores failed with 0x%x. Ignoring this error so we attempt to write migration XML.
hrExcludeLeftoverManifestFiles
Exclude leftover manifest files failed with 0x%x. Ignoring this error.
hrExcludeLeftoverInvalidRegistries
Exclude leftover invalid registries failed with 0x%x. Ignoring this error.
hrExcludeAllInfusedApps
Exclude infused apps failed with 0x%x. Ignoring this error.
hrWriteOutPerMachineMigrationXml
this->pluginAppxKey.SetBinaryValue(migXmlRegValueName, migXml, (SysStringLen(migXml) + 1) * sizeof(OLECHAR))
this->pluginDownlevelGatherKey.CreateSubKey(s_ExcludeFiles, KEY_READ | KEY_WRITE, &excludeFilesKey)
searchStringBuilder.AppendString(this->packageRepository.GetString())
\*.xml
searchStringBuilder.AppendString(L"\\*.xml")
fileName.SetValueFromString(findFileData.cFileName)
fileName.SetLength(fileName.GetLength() - wcslen(L".xml"))
hrGetPackageIDFromPackageMoniker
fullFilePathBuilder.AppendString(this->packageRepository.GetString())
fullFilePathBuilder.AppendString(L"\\")
fullFilePathBuilder.AppendString(findFileData.cFileName)
excludeFilesKey.CreateSubKey(fileName.GetChars(), KEY_READ | KEY_WRITE, &fileKey)
fileKey.SetStringValue(s_Path, fullFilePath.GetChars())
excludeFilesKey.OpenSubKey(file, KEY_READ, &fileKey)
fileKey.GetStringValue(s_Path, &filePath)
this->excludeFilesSet.InsertIgnoreDuplicates(filePath.GetChars())
this->pluginDownlevelGatherKey.OpenSubKeyIfExists(s_ExcludeFiles, KEY_READ, &excludeFilesKey)
upgradeKey.OpenSubKey(userSid, KEY_READ, &userSidKey)
pathBuilder.AppendString(upgradePath.GetString())
pathBuilder.AppendString(userSid)
pathBuilder.AppendString(L"\\")
ExcludePackagesWithinKeyUsingGatheredData(&userSidKey, &fullPathToUserSidKey)
allUserStoreKey.OpenSubKeyIfExists(AppxAllUserStore::upgradeApplicationsString, KEY_READ, &upgradeKey)
AppxAllUserStore::GetUpgradeApplicationsFullPath(&upgradePath)
allUserStoreKey.OpenSubKeyIfExists(AppxAllUserStore::stagedApplicationsString, KEY_READ, &stagedKey)
AppxAllUserStore::GetStagedApplicationsFullPath(&allUserStoreStagedPath)
ExcludePackagesWithinKeyUsingGatheredData(&stagedKey, &allUserStoreStagedPath)
excludeInfusedAppsKey.CreateSubKey(packageFullName, KEY_READ | KEY_WRITE, &packageKey)
packageKey.SetStringValue(s_Path, packageFullPath)
Common::DirectoryExists(folderPath, &folderExists)
this->pluginDownlevelGatherKey.CreateSubKey(s_ExcludeInfusedApps, KEY_READ | KEY_WRITE, &excludeInfusedAppsKey)
hrEnumSubfolders
GetSystemWindowsDirectory(systemWindowsDirectory, ARRAYSIZE(systemWindowsDirectory)) == 0
infusedPathBuilder.AppendString(systemWindowsDirectory)
infusedPathBuilder.AppendString(Common::Deployment::infusedAppsDir)
applicationsPathBuilder.AppendString(infusedAppsFolder.GetChars())
applicationsPathBuilder.AppendString(Common::Deployment::applicationsDir)
frameworksPathBuilder.AppendString(infusedAppsFolder.GetChars())
frameworksPathBuilder.AppendString(Common::Deployment::frameworksDir)
packagesPathBuilder.AppendString(infusedAppsFolder.GetChars())
packagesPathBuilder.AppendString(Common::Deployment::packagesDir)
GatherDataForExcludeAllInfusedAppsInFolder(applicationsFolder.GetChars())
GatherDataForExcludeAllInfusedAppsInFolder(frameworksFolder.GetChars())
GatherDataForExcludeAllInfusedAppsInFolder(packagesFolder.GetChars())
excludeInfusedAppsKey.OpenSubKey(package, KEY_READ, &packageKey)
packageKey.GetStringValue(s_Path, &packageFullPath)
Excluding InfusedApps folder %ls
this->excludeInfusedAppsFolderSet.InsertIgnoreDuplicates(packageFullPath.GetChars())
this->pluginDownlevelGatherKey.OpenSubKeyIfExists(s_ExcludeInfusedApps, KEY_READ, &excludeInfusedAppsKey)
GetPackageDirectoryExistsUsingGatheredData(fullName, &exists)
Package %ls does not exist in SIS. Don't carry it forward
pathBuilder.AppendString(path->GetString())
pathBuilder.AppendString(familyName)
pathBuilder.AppendString(fullName)
this->excludeRegistriesSet.InsertIgnoreDuplicates(fullPath.GetChars())
key->OpenSubKey(familyName, KEY_READ, &packageFamilyKey)
hrEnumPackages
Package family %ls does not exist in SIS. Don't carry it forward
hrEnumFamilies
Common::String::CaseInsensitiveStartsWith(subKey, L"S-", &isUserSid)
userSid->SetValueFromString(subKey)
this->userSids.Add(userSid)
userSidAsInternalString.Initialize(userSid, static_cast<ULONG>(wcslen(userSid)))
packagefamilyNameAsInternalString.Initialize( packageFamilyName, static_cast<ULONG>(wcslen(packageFamilyName)))
packageManager2->FindPackagesByUserSecurityIdPackageFamilyNameWithPackageTypes( userSidAsInternalString, packagefamilyNameAsInternalString, Windows::Management::Deployment::PackageTypes_Bundle, collection)
packageKey.GetStringValueIfExists(s_BundleFullName, bundleFullName, &hasBundle)
Bundle %ls is being written to the downlevel installed key
WritePackageRegistryKey( packageFamilyName, bundleFullName->GetChars(), userSid, &this->pluginDownlevelInstalledKey, s_DownlevelInstalled)
allUserStoreKey.OpenSubKeyIfExists(AppxAllUserStore::inboxApplicationsString, KEY_READ, &inboxApplicationsKey)
manifestPath.SetValueFromString(packageRoot.GetRawBuffer(nullptr))
pathBuilder.AppendChar(L'\\')
pathBuilder.AppendString(Common::Deployment::ManifestFileName.chars)
Processing DevMode or Inbox Package %ls for user %ls
GetIsInboxPackageUsingGatheredData(packageFullName, &isInboxPackage)
packageKey.GetStringValue(s_PackageRoot, &packageRoot)
... Package's root is %ls
... Package %ls is being end of lifed so it's being written to the EndOfLife key
WritePackageRegistryKey( packageFullName, userSid, &this->pluginEndOfLifeKey, s_EndOfLife)
WritePackageRegistryKeyWithPath( packageFamilyName, packageFullName, userSid, &this->pluginDownlevelInstalledKey, s_DownlevelInstalled, packageRoot.GetString(), &downlevelInstalledKey)
... Package %ls is dev mode. Writing to upgrade keys
downlevelInstalledKey->SetUInt32Value(AppxAllUserStore::regValueIsDevModeApp, 1)
WritePackageRegistryKeyWithPath( packageFamilyName, packageFullName, userSid, &this->pluginUpgradeKey, s_Upgrade, packageRoot.GetString(), &upgradeKey)
upgradeKey->SetUInt32Value(AppxAllUserStore::regValueIsDevModeApp, 1)
Processing Package %ls for user %ls
... Package %ls is not installed. Nothing to do
... Package %ls is NOT being end of lifed so it's being written to the Downlevel Installed key
WritePackageRegistryKey( packageFamilyName, packageFullName, userSid, &this->pluginDownlevelInstalledKey, s_DownlevelInstalled)
packageKey.GetUInt32Value(s_IsFramework, &isFrameworkValue)
... Package %ls is OEM so no need to write its upgrade key
... Package %ls is LOB so no need to write its upgrade key
... Package %ls is all-user installed so no need to write its upgrade key
ProcessBundleForUserUsingGatheredData( packageKey, packageFamilyName, userSid, &bundleFullName)
familyNameBuffer.SetValueFromString(packageFamilyName)
fullNameBuffer.SetValueFromString(fullNameToWrite)
provisionedInstalledPackageFullNames->Insert(familyNameBuffer.GetChars(), fullNameBuffer.GetChars())
Downlevel OS already had package %ls registered for user %ls, writing to UserSid Key
WritePackageAlreadyInstalledForUserKey(userSid, fullNameToWrite)
WritePackageRegistryKey( packageFamilyName, fullNameToWrite, userSid, &this->pluginUpgradeKey, s_Upgrade, &createdKey)
packageKey.GetStringValueIfExists(AppxAllUserStore::regPackageVolumeKeyString, &value, &valueExists)
createdKey->SetStringValue(AppxAllUserStore::regPackageVolumeKeyString, value.GetChars())
packageKey.GetStringValueIfExists(AppxAllUserStore::regPackageVolumeNameString, &value, &valueExists)
createdKey->SetStringValue(AppxAllUserStore::regPackageVolumeNameString, value.GetChars())
packageKey.GetStringValueIfExists(AppxAllUserStore::regAppDataVolumeKeyString, &value, &valueExists)
createdKey->SetStringValue(AppxAllUserStore::regAppDataVolumeKeyString, value.GetChars())
packageKey.GetStringValueIfExists(AppxAllUserStore::regAppDataVolumeNameString, &value, &valueExists)
createdKey->SetStringValue(AppxAllUserStore::regAppDataVolumeNameString, value.GetChars())
fullNameAsString.Initialize(packageFullName)
GetPackageInstallState(packageManager, fullNameAsString, userSid, &packageInstallState)
packageKey.SetUInt32Value(s_InstallState, packageInstallState)
packageInfo->get_IsFramework(&isFrameworkValue)
packageKey.SetUInt32Value(s_IsFramework, isFrameworkValue ? 1 : 0)
GetInstalledBundleForUser(packageFamilyName, userSid, &bundleName)
packageKey.SetStringValue(s_BundleFullName, bundleName.GetChars())
systemMetadataDirectoryForPackage.IsNull()
Common::DirectoryExists(systemMetadataDirectoryForPackage, &systemMetadataForPackageExists)
pathBuilder.AppendString(systemMetadataDirectoryForPackage)
pathBuilder.AppendString(&RecoveryReader::recoveryExtension)
Common::FileExists(recoveryFileFullPath.GetChars(), &recoveryFileExists)
hrProcessRecoveryData
... Unable to process recovery info for package 0x%x. Assume this app is fully on system volume
packageManager->FindPackagesByUserSecurityId(userSidAsInternalString, collection)
userKey.CreateSubKey(packageFullName, KEY_READ | KEY_WRITE, &packageKey)
packageKey.SetUInt32Value(s_InSingleInstanceStore, inSingleInstanceStore ? 1 : 0)
GatherPackageDataForUser(packageManager.Get(), package, packageFullName, userSid, packageKey)
GetInboxOrDevModePackageManifestPath(packageRootPath, manifestPath)
packageKey.SetStringValue(s_PackageRoot, manifestPath.GetChars())
Gathering data for user package %ls
hrGatherData
Gathering packages installed for user %ls
this->pluginDownlevelGatherKey.CreateSubKey(userSid, KEY_READ | KEY_WRITE, &userKey)
userKey.OpenSubKey(packageFullName, KEY_READ, &packageKey)
packageKey.GetUInt32Value(s_InSingleInstanceStore, &inSingleInstanceStoreValue)
hrProcessPackageForUser
Failed Processing package for user with 0x%x. Ignoring failure to continue with processing
hrProcessInboxOrDevModePackageForUser
Failed Processing inbox or devmode package for user with 0x%x. Ignoring failure to continue with processing
Processing all Packages for user %ls
this->pluginDownlevelGatherKey.OpenSubKey(userSid, KEY_READ, &userKey)
allUserStoreKey.OpenSubKey(userSid, KEY_READ, &userKey)
provisionedAttemptedPackageFamilies->InsertIgnoreDuplicates(packageFamilyName.GetChars())
Checking downlevel installed package for the user %ls and package %ls
Downlevel installed package not found for the user %ls and package %ls
hrEnumerate
Failed to enumerate downlevel installed packages for the user %ls with 0x%x, will re-install all apps
provisionedUninstalledPackageFullNames->InsertIgnoreDuplicates(bundleFullName)
provisionedUninstalledPackageFullNames->InsertIgnoreDuplicates(mainPackageFullName)
this->pluginAllUserStoreKey.CreateSubKey(userSid, KEY_READ | KEY_WRITE, &perUserInstalledKey)
perUserInstalledKey.CreateSubKey(package, KEY_READ | KEY_WRITE, &perUserInstalledSubKey)
perUserInstalledSubKey.SetUInt32Value(lastReturnValueRegistryValueName, S_OK)
this->pluginPackagesToReRegisterKey.CreateSubKey(userSid, KEY_READ | KEY_WRITE, &perUserReRegistrationKey)
GetIsStubPreferredForPackageFamilyUsingGatheredData(packageFamilyName, &preferStub)
GetPackageIsStubUsingGatheredData(provisionedInstalledPackageFullName, &provisionedInstalledPackageIsStub)
GetPackageIsPausedUsingGatheredData(provisionedInstalledPackageFullName, &provisionedInstalledPackageIsPaused)
Common::Deployment::GetPackageIDFromPackageMoniker( provisionedInstalledPackageFullName, nullptr, &existingPackageID)
perUserReRegistrationKey.CreateSubKey(mainPackageFullName, KEY_READ | KEY_WRITE, &perUserReRegistrationSubKey)
WriteAllProvisionedUninstalledPackageKeysToListUsingGatheredData( userSid, provisionedInstalledPackageFullNames, &provisionedUninstalledPackageFullNames)
WritePackageAlreadyInstalledForUserKey(userSid, package)
Failed to enumerate packages for the user %ls with 0x%x
hrWriteUninstalledKeys
Failed to write oem uninstalled packages for user %ls with 0x%x
hrWritePackagesToReRegisterKeys
Failed to write packages to re-register for user %ls with 0x%x
GetEffectiveRegistryPath(RegistryHive::HKLM, pluginRegistryKeyPath, offlineMode, effectivePluginPathBuffer, effectivePluginPath)
this->pluginAppxKey.Open(HKEY_LOCAL_MACHINE, effectivePluginPath, KEY_ALL_ACCESS)
this->pluginAppxKey.CreateSubKey( allUserStoreRegistryKeyName, KEY_READ | KEY_WRITE, &this->pluginAllUserStoreKey)
this->pluginAllUserStoreKey.CreateSubKey( s_Upgrade, KEY_READ | KEY_WRITE, &this->pluginUpgradeKey)
this->pluginAllUserStoreKey.CreateSubKey( s_DownlevelInstalled, KEY_READ | KEY_WRITE, &this->pluginDownlevelInstalledKey)
this->pluginAllUserStoreKey.CreateSubKey( s_EndOfLife, KEY_READ | KEY_WRITE, &this->pluginEndOfLifeKey)
this->pluginAllUserStoreKey.CreateSubKey( s_Staged, KEY_READ | KEY_WRITE, &this->pluginStagedKey)
this->pluginAppxKey.CreateSubKey( s_StagedUserAcquired, KEY_READ | KEY_WRITE, &this->pluginStagedUserAcquiredKey)
this->pluginAppxKey.CreateSubKey( s_Applications, KEY_READ | KEY_WRITE, &this->pluginApplicationsKey)
this->pluginAllUserStoreKey.CreateSubKey( AppxAllUserStore::deprovisionedString, KEY_READ | KEY_WRITE | WRITE_DAC, &this->pluginDeprovisionedKey)
this->pluginAppxKey.CreateSubKey( s_PackagesToCheckForStagingCompletion, KEY_READ | KEY_WRITE, &this->pluginPackagesToCheckForStagingCompletionKey)
this->pluginAppxKey.CreateSubKey( s_PackagesToRemove, KEY_READ | KEY_WRITE, &this->pluginPackagesToRemoveKey)
this->pluginAppxKey.CreateSubKey( s_PackagesToReRegister, KEY_READ | KEY_WRITE, &this->pluginPackagesToReRegisterKey)
GetSystemSisManifestPathFromPackageFullName(packageToWrite, &packageManifestPath)
No need to write Applications Key because uplevel provisioned package %ls is the most preferred version
packageSubKeyBuilder.AppendString(packageToWrite)
Writing Applications Key %ls
this->pluginApplicationsKey.CreateSubKey( packageSubKey.GetChars(), KEY_ALL_ACCESS, &mainPackageKey)
allUserApplicationsKey.CopyTree(packageToWrite, mainPackageKey)
allUserApplicationsKey.OpenSubKey(allUserPackageFullName, KEY_READ, &downlevelAllUserPackageKey)
downlevelAllUserPackageKey.GetStringValueIfExists(AppxAllUserStore::regValueRegions, &regionsValue, &valueExists)
mainPackageKey.SetStringValue(AppxAllUserStore::regValueRegions, regionsValue.GetChars())
mainPackageKey.GetStringValueIfExists(AppxAllUserStore::regValueRegions, &regionsValue, &valueExists)
Overwriting unexpected previously set regions value %ls for package %ls 
mainPackageKey.SetStringValue(AppxAllUserStore::regValueRegions, AppxAllUserStore::allRegionsString)
mainPackageKey.SetStringValue( AppxAllUserStore::regValuePath, packageManifestPath.GetStringRef())
mainPackageKey.SetUInt32Value(AppxAllUserStore::regValueIsLOBApp, 1)
hrWrite
Failed to write provisioned packages to staged list with 0x%x
Writing Package to PackagesToCheckForStagingCompletion Key: %ls
this->pluginPackagesToCheckForStagingCompletionKey.CreateSubKey( packageFullName, KEY_READ | KEY_WRITE, &packageKey)
GetStubPreferenceFromKey(stubPreferenceKey, packageFamilyName, &uplevelProvisionedPackageIsStub)
Common::Deployment::GetPackageIDFromPackageMoniker( uplevelProvisionedPackage, nullptr, &provisionedPackageID)
Up-level provisioned package %ls is less preferred than existing package %ls. Writing it to PackagesToRemove Key
WritePackageBundleToRemoveKey(uplevelProvisionedPackageBundle)
this->pluginDownlevelGatherKey.OpenSubKey(s_PackageInstallState, KEY_READ, &installStateKey)
GetIsPackageDeprovisionedInAllUserStoreUsingGatheredData(packageFamilyName, false , &packageDeprovisioned)
Unexpected - uplevel provisioned package family does not have main and/or bundle package. Package family name: %ls, number of resource packages: %u
installStateKey.OpenSubKeyIfExists(provisionedPackageFullName, KEY_READ, &packageKey)
Not Removing up-level provisioned deprovisioned Package because a user has it still installed: %ls
Writing up-level provisioned deprovisioned Package to PackagesToRemove Key: %ls
AppxUpgradeMigration::Gather called
FixStateRepositoryOrResetMaintenance()
Starting AppxUpgradeMigration Plugin during Gather
SaveUpgradeDataToPluginKey()
OS Upgrade running from an OS older than Win 8, so no work needed for Appx sub-system. Skip running Gather.
GatherDownlevelData()
Failed looking for a cellular modem
Successfully finished processing all users and packages during AppxUpgradeMigration Gather
this->pluginAppxKey.ValueExists(s_ProcessPackagesToApplyUsingGatheredData, &valueExists)
Skipping ProcessPackagesToApplyUsingGatheredData since it has already executed.
Starting ProcessPackagesToApplyUsingGatheredData
ReadAppXMigrationStoresUsingGatheredData()
hrCreatePerMachineKeys
Failed to create per-machine keys 0x%x
hrEnumerateUsersAndPopulateUserSids
Failed to enumerate all users with 0x%x
ProcessPackagesForUserUsingGatheredData(this->userSids.At(i)->GetChars())
WriteDeprovisionListToPluginAllUserStoreUsingGatheredData()
WritePackagesToCheckPostUpgradeToSetupKeyUsingGatheredData()
MigrateDownlevelStubPreference()
this->pluginAppxKey.SetUInt32Value(s_ProcessPackagesToApplyUsingGatheredData, 1)
ProcessPackagesToApplyUsingGatheredData completed successfully
deprovisionedKey.KeyExists(packageFamilyName, &isInDeprovisionedKey)
FixDeprovisionedKey: Deprovisioned key has %ls, while Applications key has %ls. Deleting package from Deprovisioned key.
deprovisionedKey.DeleteSubKey(packageFamilyName)
pluginAllUserStoreKey.OpenSubKey(s_Applications, KEY_READ, &applicationsKey)
pluginAllUserStoreKey.OpenSubKeyIfExists(AppxAllUserStore::deprovisionedString, KEY_READ | KEY_WRITE, &deprovisionedKey)
DeprovisionedKey does not exist. FixDeprovisionedKey has nothing to do.
this->pluginAppxKey.CreateSubKey(s_DownlevelGather, KEY_ALL_ACCESS, &this->pluginDownlevelGatherKey)
AppxAllUserStore::GetAllUserStoreFullPath(&allUserStorePath)
allUserStoreKey.Open(HKEY_LOCAL_MACHINE, allUserStorePath.GetChars(), KEY_READ)
this->pluginDownlevelGatherKey.CreateSubKey(allUserStoreRegistryKeyName, KEY_READ | KEY_WRITE, &pluginAllUserStoreKey)
CopyRegistryKeyWithoutAcls(allUserStoreKey, pluginAllUserStoreKey)
FixDeprovisionedKey(pluginAllUserStoreKey)
this->pluginDownlevelGatherKey.CreateSubKey(s_StubPreference, KEY_READ | KEY_WRITE, &stubPreferenceKeyCopy)
CopyRegistryKeyWithoutAcls(stubPreferenceKey, stubPreferenceKeyCopy)
GatherInstallStateForAllPackages()
GatherSingleInstanceStoreDirectories()
GatherDataForProcessAllUserStorePackages()
GatherDataForProcessAllInstalledPackages()
GatherDataForExcludeLeftoverManifestFiles()
GatherDataForExcludeAllInfusedApps()
GatherDataForWriteOutPerMachineMigrationXml()
EnumerateUsersAndPopulateUserSids()
GatherDataForProcessPackagesForUser(this->userSids.At(i)->GetChars())
context->get_WorkingDir(&workingDir)
filenameBuilder.AppendString(workingDir)
filenameBuilder.AppendString(OSRollbackPackagesFilename)
Common::Deployment::SaveWindowsAppsPackageListToFile(filename.GetChars())
MigXmlWriter::GatherDataForEnvironmentStrings(this->pluginDownlevelGatherKey)
Gathering install state for package %ls
GatherInstallStateForPackage(packageManager.Get(), package, packageFullName, installStateRootKey)
this->pluginDownlevelGatherKey.CreateSubKey(s_PackageInstallState, KEY_READ | KEY_WRITE, &installStateRootKey)
fullName.Initialize(packageFullName)
GetPackageInstallState(packageManager, fullName, nullptr , &packageInstallState)
installStateRootKey.CreateSubKey(packageFullName, KEY_READ | KEY_WRITE, &packageKey)
package8->get_IsStub(&isStub)
packageKey.SetUInt32Value(s_IsStub, isStub)
sisDirectoryKey.CreateSubKey(subFolderName, KEY_READ | KEY_WRITE, &directoryKey)
this->pluginDownlevelGatherKey.CreateSubKey(s_SisDirectory, KEY_READ | KEY_WRITE, &sisDirectoryKey)
AppxAllUserStore::GetAllUserStoreFullPath(&allUserStorePathBuffer)
GetEffectiveRegistryPath(RegistryHive::HKLM, allUserStorePathBuffer.GetChars(), offlineMode, effectiveAllUserStorePathBuffer, effectiveAllUserStorePath)
allUserStoreKey.Open( HKEY_LOCAL_MACHINE, effectiveAllUserStorePath, KEY_READ | KEY_WRITE | WRITE_DAC)
allUserStoreKey.OpenSubKey( s_Staged, KEY_READ | KEY_WRITE | WRITE_DAC, &stagedKey)
allUserStoreKey.OpenSubKey( s_EndOfLife, KEY_READ | KEY_WRITE | WRITE_DAC, &endOfLifeKey)
allUserStoreKey.OpenSubKey( s_Applications, KEY_READ | KEY_WRITE | WRITE_DAC, &allUserApplicationsKey)
allUserApplicationsKey.SetUInt32Value(regIuiPolicyCheckedString, 1)
allUserStoreKey.CreateSubKey( AppxAllUserStore::deprovisionedString, KEY_READ | KEY_WRITE | WRITE_DAC, &deprovisionedKey)
allUserStoreKey.GetKeySecurity(DACL_SECURITY_INFORMATION, allUserStoreSD)
stagedKey.GetKeySecurity(DACL_SECURITY_INFORMATION, stagedSD)
endOfLifeKey.GetKeySecurity(DACL_SECURITY_INFORMATION, endOfLifeSD)
deprovisionedKey.GetKeySecurity(DACL_SECURITY_INFORMATION, deprovisionedSD)
this->pluginAllUserStoreKey.CopyTree(nullptr, allUserStoreKey)
hrAllUserStoreKeySetKeySecurity
Unable to set security descriptor for all user store key with 0x%x
hrStagedKeySetKeySecurity
Unable to set security descriptor for staged key with 0x%x
hrEndOfLifeKeySetKeySecurity
Unable to set security descriptor for end of life key with 0x%x
hrDeprovisionedKeySetKeySecurity
Unable to set security descriptor for deprovisioed key with 0x%x
AddUplevelPackageToDelete(subKey, keysToDelete)
IsPluginDeprovisionedPackage(&allUserStoreKey, packageFamilyName, &isDeprovisioned)
Removed deprovisioned package %ls from uplevel key.
Deleting Uplevel all-user key %ls because downlevel had a more preferred version
allUserApplicationsKey.DeleteSubKeyTree(keysToDelete[i]->GetChars())
this->pluginApplicationsKey.OpenSubKey(subKey, KEY_READ, &packageFamilyKey)
Writing Downlevel all-user key %ls to uplevel key
packageFamilyKey.CopyTree(nullptr, allUserApplicationsKey)
autogenDirectoryPath.SetValueFromString(this->singleInstanceStore.GetChars())
pathBuilder.AppendString(packageFullName)
pathBuilder.AppendString(systemMetadataFolder)
pathBuilder.AppendString(autogenDirectorySubPath)
Common::DirectoryExists(autogenDirectoryPath.GetChars(), &folderExists)
ExpandEnvironmentStrings(appRepositoryPath, appRepositoryExpandedPath, ARRAYSIZE(appRepositoryExpandedPath)) == 0
pathBuilder.AppendString(appRepositoryExpandedPath)
pathBuilder.AppendChar('\\')
*isPackageEndOfLife
key->OpenSubKey(userSid, KEY_READ, &userSidKey)
userSidKey.KeyExists(packageFullName, isPackageEndOfLife)
AppxAllUserStore::GetEndOfLifeApplicationsFullPath(&endOfLifePath)
endOfLifeKey.Open(HKEY_LOCAL_MACHINE, endOfLifePath.GetChars(), KEY_READ)
GetPluginRelativeFullPath(L"", &manifestPathBuffer)
IsPackageInEndOfLifeKey(endOfLifeMissingManifestFixablePackageFullNames[i], &isInEndOfLifeKey)
targetBackupManifestFilePathBuilder.AppendString(appRepositoryExpandedPath)
targetBackupManifestFilePathBuilder.AppendChar('\\')
targetBackupManifestFilePathBuilder.AppendString(endOfLifeMissingManifestFixablePackageFullNames[i])
targetBackupManifestFilePathBuilder.AppendString(backupManifestFileExtension)
Common::FileExists(targetBackupManifestFilePath.GetChars(), &targetFileExists)
sourceBackupManifestFilePathBuilder.AppendString(manifestPathBuffer.GetChars())
sourceBackupManifestFilePathBuilder.AppendString(endOfLifeMissingManifestFixablePackageFullNames[i])
sourceBackupManifestFilePathBuilder.AppendString(backupManifestFileExtension)
Common::FileExists(sourceBackupManifestFilePathBuilder.GetChars(), &sourceFileExists)
Package %ls is End Of Life and missing a backup manifest, but we could not fix this.
CopyFile(sourceBackupManifestFilePath.GetChars(), targetBackupManifestFilePath.GetChars(), FALSE)
Package %ls is End Of Life and was missing a backup manifest, but we were able to replace the backup manifest.
Processing Staged package %ls for preregister
hrEnsureAutogenDeleted
Ignoring error: Package %ls failed to ensure deleted Autogen: 0x%x
this->pluginPackagesToRemoveKey.KeyExists(fullName, &isPackageToBeRemoved)
%ls is in plugin PackagesToRemove key. Skip preregister
AddPackageRegistryKeyToArray(fullName, &bundleFullNames)
AddPackageRegistryKeyToArray(fullName, &packageFullNames)
PreRegistering Staged package %ls
hrAppxPreRegisterPackage
Ignoring error: Package %ls failed to preregister: 0x%x
stagedKey.Open( HKEY_LOCAL_MACHINE, allUserStoreStagedPath.GetChars(), KEY_READ | KEY_WRITE | WRITE_DAC)
PreRegistering uplevel image packages
PreRegisterPackagesInRegistryKey(&stagedKey, PreRegisterOptions::ApplyTrustAce)
AppxDeploymentClient.dll
this->deploymentClientDllModule
EnsureAppxDeploymentClientDllLoaded(&deploymentClientModule)
AppxPreRegisterPackage
this->AppxPreRegisterPackage
AppxPreRegisterAllInboxPackages
this->AppxPreRegisterAllInboxPackages
PreRegisterAllInboxPackages()
PreRegisterAllInboxPackages failed 0x%x
hrPluginAppxKeyOpen
No Plugin key found--Discover/Gather failed 0x%x. Preregistering uplevel image's key
PreRegisterUplevelImagePackages()
this->pluginAllUserStoreKey.OpenSubKey(s_Staged, KEY_READ, &this->pluginStagedKey)
No Plugin Staged key found--Discover/Gather failed 0x%x. Preregistering uplevel image's key
PreRegistering packages in plugin Staged key
PreRegisterPackagesInRegistryKey(&this->pluginStagedKey)
pluginAppxKey.OpenSubKey( s_StagedUserAcquired, KEY_READ, &this->pluginStagedUserAcquiredKey)
No Plugin StagedUserAcquired key found. As far as we know, User had no packages
PreRegistering packages in plugin StagedUserAcquired key
PreRegisterPackagesInRegistryKey(&this->pluginStagedUserAcquiredKey)
PreRegisterAllPackages finished
Calling ApplyTrustLabel
Failed to ApplyTrustLabel - InitializeProcThreadAttributeList Failed - 0x%x - %ls
Failed to ApplyTrustLabel - UpdateProcThreadAttribute Failed - 0x%x - %ls
Failed to ApplyTrustLabel - CreateProcess Failed - 0x%x - %ls
Failed to ApplyTrustLabel - GetExitCodeProcess Failed - 0x%x - %ls
cmdLineBuilder.AppendString(applicationPath)
cmdLineBuilder.AppendChar(L' ')
cmdLineBuilder.AppendString(offlineSoftwareHiveParam)
cmdLineBuilder.AppendString(offlineSoftwareHive)
cmdLineBuilder.AppendChar(L'\"')
InitializeCmdLine(applicationPath, offlineSoftwareHive, cmdLineBuilder)
ApplyTrustLabel(cmdLineBuilder.GetChars())
cmdLineBuilder.SetLength(0)
cmdLineBuilder.AppendString(packagePath)
hrAppendFullName
Processing package %ls for ApplyTrustLabel
registryKey->OpenSubKey(fullName, KEY_READ, &packageFullNameKey)
packageFullNameKey.GetStringValue(s_Path, &packagePath)
packagePathBuilder.SetLength(packagePathBuilder.GetLength() - (ARRAYSIZE(appxManifestRelativePath) - 1))
packagePathBuilder.SetLength(packagePathBuilder.GetLength() - (ARRAYSIZE(appxBundleManifestRelativePath) - 1))
Registry Package entry has invalid Path
GetOfflineFilePath(packagePath.GetChars(), &offlinePackagePath)
offlinePathBuilder.InsertChars(0, L" \"", 2)
offlinePathBuilder.AppendChar(L'\"')
AppendPackagePathAndApplyTrustLabel(offlinePackagePath.GetChars(), applicationPath, offlineSoftwareHive, cmdLineBuilder)
ApplyTrustLabelToPackagesUnderRegistryKey(&packageFamilyKey, applicationPath, offlineSoftwareHive, cmdLineBuilder)
GetSystem32FullPath(applyTrustLabelApplication, &applyTrustLabelAppFullPath)
Common::FileExists(applyTrustLabelAppFullPath.GetChars(), &fileExists)
No %ls found - cannot apply trust labels
GetOfflineRegistryPath(RegistryHive::HKLM, softwareHive, &offlineSoftwareHive)
cmdLine.get() != nullptr
No Plugin Staged key found. As far as we know, user had no packages to ApplyTrustLabel
hrApplyTrustLabelToPluginStagedPackages
Failed to ApplyTrustLabel offline to Plugin Staged Packages - 0X%x
No Plugin StagedUserAcquired key found. As far as we know, user had no packages to ApplyTrustLabel
hrApplyTrustLabelToPluginStagedUserAcquiredPackages
Failed to ApplyTrustLabel offline to Plugin Staged User Acquired Packages - 0X%x
No Plugin Applications key found. Downlevel had no OEM apps or newer all-user apps to copy over
GetOfflineRegistryPath(RegistryHive::HKLM, allUserStorePath.GetChars(), &offlineAllUserStorePath)
allUserStoreKey.Open(HKEY_LOCAL_MACHINE, offlineAllUserStorePath.GetChars(), KEY_READ)
allUserStoreKey.OpenSubKey(s_Staged, KEY_READ, &allUserStagedKey)
hrApplyTrustLabelToPreInstalledPackages
Failed to ApplyTrustLabel offline to PreInstalled Packages - 0X%x
Windows::Foundation::ActivateInstance( Microsoft::WRL::Wrappers::HStringReference(RuntimeClass_Windows_Management_Deployment_Internal_PackageManagerInternal).Get(), &packageManager)
%ls: %ls
stringVector->Append(Microsoft::WRL::Wrappers::HStringReference(subKeyName).Get())
this->noReRegisterOnUpgrade
No PackagesToReRegister Plugin key found
hrPluginOpenPackagesToReRegister
Windows::Foundation::Collections::Internal::Vector<HSTRING>::Make(&packagesToReRegister)
EnumAndAddSubKeysToStringVector(&userPackagesToRegisterKey, packagesToReRegister.Get(), s_PackagesToReRegister)
hrUserPackagesToReRegisterKey
AppxAllUserStore::GetInboxApplicationsFullPath(&inboxPackagesBuffer)
inboxPackagesKey.Open(HKEY_LOCAL_MACHINE, inboxPackagesBuffer.GetChars(), KEY_READ)
EnumAndAddSubKeysToStringVector(&inboxPackagesKey, packagesToReRegister.Get(), s_PackagesToReRegister)
EnumAndAddPackagesNotKnownToCapAuth(userSid, packagesToReRegister.Get())
packagesToReRegister->get_Size(&vectorCount)
packageManager->SetupOutdatedPackagesForReRegistration(userSidString.Get(), packagesToReRegister.Get())
Starting EnumAndAddPackagesNotKnownToCapAuth
Unnecessary. Skipping EnumAndAddPackagesNotKnownToCapAuth
Loading ext-ms-win-security-capauthz-l1-1-1.dll
ext-ms-win-security-capauthz-l1-1-1.dll
QueryApplicationCapabilitiesEx
Enumerating pre-Win10 packages registered to %ls but not known to CapAuth
Windows::Foundation::GetActivationFactory(acid.Get(), &packageStatics)
packageStatics->FindPackageFullNamesByUserSidAndPackageTypeAndTargetDeviceFamily( userSidAsHString.Get(), Windows::Internal::StateRepository::PackageType_Main, DEVICEFAMILYINFOENUM_WINDOWS_8X, &packageFullNames)
packageFullNames->get_Size(&size)
packageFullNames->GetAt(index, packageFullName.GetAddressOf())
%ls for user %ls isn't known to CapAuth (needs Registration)
packageFullNamesToReRegister->Append(packageFullName)
Failed querying CapAuth for user=%ls package=%ls: 0x%X
%ls for user %ls is known to CapAuth
Completed EnumAndAddPackagesNotKnownToCapAuth
PackagesToCheckForStagingCompletion: %ls
packagesToCheckForStagingCompletion->Append(Microsoft::WRL::Wrappers::HStringReference(subKeyName).Get())
Windows::Foundation::Collections::Internal::Vector<HSTRING>::Make(&packagesToCheckForStagingCompletion)
Package %ls destage completed with hr = 0x%x.
AppxDestagePackage
Removing uplevel provisioned unneeded packages
No Plugin key found--downlevel had no apps or Discover/Gather failed.
hrPluginAppxKeyOpenAppxAllUserStore
No Applications Plugin key found--downlevel had no OEM apps or newer all-user apps to copy over
hrPluginAppxKeyOpenSubKeyApplications
No PackagesToCheckForStagingCompletion Plugin key found
hrPluginOpenPackagesToCheckForStagingCompletion
No PackagesToRemove Plugin key found
hrOpenPackagesToRemove
Keep thread running start.
AppxUpgradeMigration discontinuing plug-in timeout extension.
AppxUpgradeMigration executing longer than expected.
About to call ResetPluginTimer.
GetPluginHasExecutedOffline(executedOffline)
AppXUpgradeMigration signaling extension thread.
AppXUpgradeMigration exiting.
Starting AppxUpgradeMigration Plugin during Apply Success
CoMarshalInterThreadInterfaceInStream(IID_IMigrationContext, this->context, &pStream)
!(wil::verify_bool(hKeepRunningThread))
CreateTopLevelKeys(offlineExecution)
this->pluginAppxKey.OpenSubKey(s_DownlevelGather, KEY_READ, &this->pluginDownlevelGatherKey)
OS Upgrade running from an OS older than Win 8, so no work needed for Appx sub-system. Skip running ApplySuccess.
S-1-0-0
No work to do for DEFAULT user. Skipping.
ProcessPackagesToApplyUsingGatheredData()
InitializePluginRegistryKeys(offlineExecution, &appxKeyFound)
Finished AppxUpgradeMigration ApplySuccess offline with 0x%x
hrRepairStateRepository
MACHINE
Unable to repair StateRepository for %ls: 0x%x
Finished AppxUpgradeMigration ApplySuccess for %ls with 0x%x
Failed to set the FlushInboxCachedManifests in the AppxAllUserStore with 0x%x
Failed to PerformApplySuccessOnlinePerMachineTasks with 0x%x
UpdateAppInstallerScheduledTask()
Successfully finished processing all packages during AppxUpgradeMigration ApplySuccess
Failed to processing all packages during AppxUpgradeMigration ApplySuccess with 0x%x
hrEnsureRegistryKeyPermissions
Failed to update registry ACLs for '%ls': 0x%x.
hrRepairPackageRootFolderPath
Unable to repair PackageRootFolder values for packages: 0x%x
hrRepairBadPathsInHKU
Unable to repair bad path values in HKEY_USERS: 0x%x
hrGetWorkingDir
Failed to get WorkingDir 0x%x
GetOfflineRegistryPath(RegistryHive::HKLM, allUserStorePathBuffer.GetChars(), &offlineAllUserStorePathBuffer)
Calling DeleteOSRollbackPackagesRegistry
hrDeleteOSRollbackPackagesRegistry
Unable to DeleteOSRollbackPackagesRegistry: 0x%x
Calling SavePackageListFromFileToRegistry
hrSavePackageListFromFileToRegistry
Unable to SavePackageListFromFileToRegistry: 0x%x
EnsureAppRootPermissions(offlineMode)
hrRepairPackageRepository
Unable to repair Package Repository registry key values for packages: 0x%x
Performing AppxUpgradeMigration Plugin offline tasks
hrWriteAllUserStoreKeys
Unable to write all user store keys 0x%x
hrApplyTrustLabelToPackages
ApplyTrustLabelToPackages failed 0x%x
PerformApplySuccessPerMachineTasks(true )
PerformApplySuccessPerUserTasks(userSidString, true )
SetPluginHasExecutedOffline()
PerformApplySuccessPerUserTasks(userSidString, false )
ImportPackageUserStatusToStateRepository(userSidString)
hrSetupPackagesForReRegistration
Unable to set up packages for re-registration: 0x%x
folderPathBuilder.AppendString(this->singleInstanceStore.GetChars())
folderPathBuilder.AppendString(L"\\")
folderPathBuilder.AppendString(backupFolderNameWithSlash)
folderPathBuilder.AppendString(fullName)
folderPathBuilder.AppendString(systemMetadataFolder)
searchString.SetValueFromString(sourceDirectory)
searchStringBuilder.AppendString(L"\\*")
error != ERROR_NO_MORE_FILES
DirectoryPaths::CreateFullFileName(sourceDirectory, findFileData.cFileName, &srcPath)
DirectoryPaths::CreateFullFileName(destDirectory, findFileData.cFileName, &destPath)
!(wil::verify_bool(CopyFileW(srcPath.GetChars(), destPath.GetChars(), 0)))
RecursiveCopyDirectoryExceptAutogen(srcPath.GetChars(), destPath.GetChars())
Processing Staged package %ls to copy metadata
GetMetadataFolderForPackage(fullName, true , &metadataFolderInSharedLimitedTime)
Common::DirectoryExists(metadataFolderInSharedLimitedTime.GetChars(), &packageExistsInSharedLimitedTime)
SharedLimitedTime metadata directory exists: Preparing to copy metadata
GetMetadataFolderForPackage(fullName, false , &metadataFolder)
Common::DirectoryExists(metadataFolder.GetChars(), &metadataExistsInPackageRoot)
SharedLimitedTime metadata directory exists but metadata directory does not exist for %ls. Not copying files
RecursiveCopyDirectoryExceptAutogen(metadataFolderInSharedLimitedTime.GetChars(), metadataFolder.GetChars())
stagedKey.Open(HKEY_LOCAL_MACHINE, allUserStoreStagedPath.GetChars(), KEY_READ)
package->get_NeedsSingletonRegistration(&needsSingletonRegistration)
package->get__PackageID(&packageId)
packageStatics->UpdateIsSingletonRegistered(packageId, false)
package->get_PackageFullName(&packageFullName)
packageManager->SetPackageStatusBlocking(packageFullName)
GetFamilyNameFromFullName(WindowsGetStringRawBuffer(packageFullName, nullptr), &packageFamilyName)
AppxAllUserStore::SetPackageOverrideSetupPhaseHelper(packageFamilyName.GetChars(), AppxAllUserStore::c_setupPhase_PostShell)
Windows::Foundation::GetActivationFactory( Microsoft::WRL::Wrappers::HStringReference(RuntimeClass_Windows_Internal_StateRepository_Package).Get(), &packageStatics)
packageStatics->Find(&packages)
hrPreRegisterAllPackages
Unable to pre register packages: 0x%x
hrReIndexPackagesForFeatureLightUp = ReIndexPackagesForFeatureLightUp()
Unable to re index packages for feature light up: 0x%x
hrCopyMetadataIfRequired = CopyMetadataIfRequired()
Unable to copy metadata: 0x%x
hrMarkUplevelProvisionedPausedPackagesAsStaged = MarkUplevelProvisionedPausedPackagesAsStaged()
Unable to Mark up-level provisioned paused packages as staged: 0x%x
hrRemoveUplevelProvisionedUnneededPackages = RemoveUplevelProvisionedUnneededPackages()
Unable to Remove up-level provisioned unneeded packages: 0x%x
PerformApplySuccessPerMachineTasks(false )
hrCleanupSystemAppsMigratedToFOD
Unable to clean-up SystemApps migrated to FOD: 0x%x
hrCleanupOrphanPackages
Unable to clean-up orphan packages: 0x%x
hrCopyBackupManifestForEndOfLifePackagesIfNecessary
Unable to copy backup manifest for end of life packages if necessary: 0x%x
hrProcessSingletonPackages
Unable to clear IsSingletonRegisteredFlags: 0x%x
upgradeKey.Open(HKEY_LOCAL_MACHINE, upgradePath.GetChars(), KEY_READ | KEY_WRITE)
upgradeKey.SetUInt64Value(timeElapsedValueName, timeElapsed)
Starting EnsureRegistryKeyPermissions
perUserRegistryPathBufferBuilder.AppendString(userSid)
perUserRegistryPathBufferBuilder.AppendString(registryClassesPrefix)
perUserRegistryPathBufferBuilder.AppendString(appContainerStorageRegistrySubKey)
GetEffectiveRegistryPath(RegistryHive::HKU, perUserRegistryPathBuffer.GetChars(), offlineMode, effectivePerUserRegistryPathBuffer, effectivePerUserRegistryPath)
USERS\
perUserACLPathBufferBuilder.AppendString(L"USERS\\")
perUserACLPathBufferBuilder.AppendString(effectivePerUserRegistryPath)
ConvertStringSidToSid(packageContentsCapabilitySid, &packageContentsSid)
EnsureACLOnObject(SE_REGISTRY_KEY, perUserACLPathBuffer.GetChars(), packageContentsSid.get())
Completed EnsureRegistryKeyPermissions
IsPackageRegistrationPreservedAcrossUpgrade()
Starting EnsureAppRootPermissions
GetOfflineFilePath(this->singleInstanceStore.GetChars(), &offlineSystemSisPath)
searchPathBuilder.AppendString(offlineSystemSisPath.GetChars())
searchPathBuilder.AppendString(this->singleInstanceStore.GetChars())
searchPathBuilder.AppendString(L"\\*")
HRESULT_FROM_WIN32(GetLastError())
fullFilePathBuilder.AppendString(this->singleInstanceStore.GetChars())
EnsureACLOnObject(SE_FILE_OBJECT, fullFilePath.GetChars(), packageContentsSid.get())
hrGetTarget
Failed to get junction target for : %ls - 0x%x
EnsureACLOnObject(SE_FILE_OBJECT, targetPath.GetChars(), packageContentsSid.get())
Completed EnsureAppRootPermissions - processed %i of %i directories.
Error getting SD for %ls - 0x%x
Error getting effective rights from ACL for %ls - 0x%x
Erroring adding to ACL to %ls - 0x%x
Erroring setting new SD for %ls - 0x%x
allUserStoreKey.OpenSubKeyIfExists(AppxAllUserStore::deprovisionedString, KEY_READ, &deprovisionKey)
deprovisionKey.KeyExists(familyName, packageDeprovisioned)
allUserStoreKey->OpenSubKey(AppxAllUserStore::deprovisionedString, KEY_READ, &deprovisionKey)
deprovisionKey.CopyTree(nullptr, this->pluginDeprovisionedKey)
uplevelPackageToDelete->SetValueFromString(fullNameKey)
keysToDelete.Add(uplevelPackageToDelete)
Skipping AppxPreRegisterAllInboxPackages
Starting AppxPreRegisterAllInboxPackages
hrPreRegister
AppxPreRegisterAllInboxPackages failed: 0x%x
Completed AppxPreRegisterAllInboxPackages
userPathBuilder.AppendString(userSidKeyName)
userPathBuilder.AppendString(subKey)
GetEffectiveRegistryPath(RegistryHive::HKU, userPath.GetChars(), offlineMode, effectiveUserPathBuffer, effectiveUserPath)
Opening reg key HKEY_USERS\%ls to enumerate
registryKey->Open(HKEY_USERS, effectiveUserPath, KEY_READ | KEY_WOW64_64KEY)
userClassesKeyNameBuilder.AppendString(userSid)
userClassesKeyNameBuilder.AppendString(registryClassesPrefix)
OpenPerUserSubKey(userClassesKeyName.GetChars(), subKey, offlineMode, registryKey)
Starting RepairPackageRootFolderPathInRepositoryRegistryKey
OpenPerUserClassesSubKey(userSid, appxMiniRepositoryPackagesSubkey, offlineMode, &packagesKey)
bstrSisPath.CopyFromString(sisPath)
this->context->ExpandEnvironmentVariables(bstrSisPath, &bstrExpandedSisPath)
Unexpected failure from ExpandEnvironmentVariables on string %ls
Expanded SIS path: %ls
packagesKey.OpenSubKey(packageFullName.GetChars(), KEY_READ | KEY_WRITE, &packageKey)
Processing %ls
Failed to repair reg value [%ls] for package %ls, hr: 0x%x
EnumKey for [%ls] failed: 0x%x
Completed RepairPackageRootFolderPathInRepositoryRegistryKey
Starting RepairBadPathsInHKU
\SOFTWARE\Microsoft\Windows\CurrentVersion\App Paths
\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Fonts
RepairPathValueInUserRegistryKey(userSid, keyPath, bstrExpandedSisPath.Value(), offlineMode)
LOG_IF_FAILED_MSG(%hs) failed with 0x%x. Message is below:
Error returned when repairing reg key HKEY_USERS\%ls%ls
Completed RepairBadPathsInHKU
Starting RepairPathValueInUserRegistryKey. Inspect all immediate sub-keys under HKEY_USERS\%ls%ls and repair key values containing bad paths
OpenPerUserSubKey(userSid, rootKeyPath, offlineMode, &rootKey)
Failed to open reg key HKEY_USERS\%ls%ls, offlineMode: %ls
Failed to open sub-key %ls of root key %ls, hr: 0x%x
Processing sub-key %ls
Failed to repair reg value [%ls] for reg key %ls, hr: 0x%x
EnumValue for [%ls] failed: 0x%x
Completed RepairPathValueInUserRegistryKey
Starting RepairPackageRepositoryKeyInHKLM
Common::StateSeparation::GetPackageRepositoryPackagesPath(nullptr, &packageRepositoryPackagesKeyPath)
GetEffectiveRegistryPath(RegistryHive::HKLM, packageRepositoryPackagesKeyPath, offlineMode, effectivePackageRepositoryPackagesKeyPathBuffer, effectivePackageRepositoryPackagesKeyPath)
Opening reg key HKEY_LOCAL_MACHINE\%ls to enumerate
packagesKey.Open(HKEY_LOCAL_MACHINE, effectivePackageRepositoryPackagesKeyPath, KEY_READ | KEY_WOW64_64KEY)
Completed RepairPackageRepositoryKeyInHKLM
(Default)
Registry key value [%ls] does not exist. The package may not be fully registered yet.
hrGetValue
Failed to get Registry key value [%ls]
bstrPath.CopyFromString(path.GetChars())
this->context->ExpandEnvironmentVariables(bstrPath, &bstrExpandedPath)
StringCchLengthW(expandedPath, Common::String::MaxLength, &expandedPathLength)
StringCchLengthW(expandedSisPath, Common::String::MaxLength, &sisPathLength)
Skipping package root folder path value not in single instance store (for example, system apps): %ls. Value length: %u
Expanded Path value: %ls, value length: %u
Found bad path in reg key value [%ls] that needs repair: %ls
StringCchCopy(packageFullNameChunk, packageFullNameChunkLength, trimmedChunk)
Replacing bad path in reg key value [%ls] with: %ls
packageKey.SetStringValue(pathValueName, expandedPath)
Starting FixStateRepositoryIntegrity.
Plugin Appx key not found which should be present on up-level -- abandoning FixStateRepositoryIntegrity.
Completed FixStateRepositoryIntegrity successfully.
Completed FixStateRepositoryIntegrity -- was already run so no action needed.
Starting RepairStateRepository for %ls.
Windows::Foundation::ActivateInstance( Windows::Internal::StringReference(RuntimeClass_Windows_Internal_StateRepository_Management_RepositoryManager).Get(), &repositoryManager)
FixStateRepositoryIntegrity(repositoryManager)
repositoryManager->Repair(Windows::Internal::StringReference(userSid == nullptr ? L"" : userSid).Get(), ((userSid == nullptr) || (userSid[0] == L'\0')) ? Windows::Internal::StateRepository::Management::RepairOptions_NoUser : Windows::Internal::StateRepository::Management::RepairOptions_NoMachine, &found, &deleted)
Found Ghosts Entries: %d. Repaired Ghost Entries: %d.
Completed RepairStateRepository successfully.
Cleaning up orphan packages from downlevel OS
AppxCleanupOrphanPackages
AppxCleanupOrphanPackages()
Cleaning up SystemApps migrated to FOD
AppxCleanupSystemAppsMigratedToFOD
AppxCleanupSystemAppsMigratedToFOD()
Failed with 0x%08lx reading %ls value PackageStatus, assuming package has no in-place update pending
FlushInboxCachedManifests
Common::Deployment::ManifestCache::UpdateOptions(Common::Deployment::ManifestCache::Options_ReloadAllInbox)
GetStubPreferenceKey(KEY_READ | KEY_WRITE, uplevelStubPreferenceKey)
GetIsStubPreferredForPackageFamilyUsingGatheredData(packageFamilyName.GetChars(), &downlevelPreference)
GetStubPreferenceFromKey(uplevelStubPreferenceKey, packageFamilyName.GetChars(), &uplevelPreference)
Applying downlevel stub preference %d for package %ls
uplevelStubPreferenceKey.CreateSubKey(packageFamilyName.GetChars(), KEY_READ | KEY_WRITE, &packageFamilyKey)
packageFamilyKey.SetUInt32Value(s_PreferStub, downlevelPreference)
Starting ImportPackageUserStatusToStateRepository
ext-ms-onecore-appmodel-staterepository-internal-l1-1-6.dll
SRImportPackageUserStatus
Did not find module %ls: 0x%x
userPathBuilder.AppendString(userSidString)
userPathBuilder.AppendString(registryClassesPrefix)
userPathBuilder.AppendString(appxMiniRepositoryPackagesSubkey)
srImportPackageUserStatus(userSidString, userPath.GetChars(), &numImported, &numFailedToImport)
ImportPackageUserStatusToStateRepository imported status from %d packages and failed to import status from %d packages
Did not find export %ls: 0x%x.
CoCreateInstance(CLSID_TaskScheduler, NULL, CLSCTX_INPROC_SERVER, IID_ITaskService, static_cast<void**>(&taskService))
taskService->Connect(variantNull, variantNull, variantNull, variantNull)
rootFolderPathBstr.CopyFromString(Common::Deployment::appxDeploymentClientTaskFolder)
taskNameBstr.CopyFromString(Common::Deployment::appInstallerUpdateAllTaskName)
taskService->GetFolder(rootFolderPathBstr, &taskFolder)
taskFolder->DeleteTask(taskNameBstr, 0)
Common::Deployment::CreateAppInstallerTask()
Writing bundle package full name to PackagesToRemove Key: %ls
this->pluginPackagesToRemoveKey.CreateSubKey( bundleFullName, KEY_READ | KEY_WRITE, &packageKey)
Writing main package full name to PackagesToRemove Key: %ls
this->pluginPackagesToRemoveKey.CreateSubKey( mainPackageFullName, KEY_READ | KEY_WRITE, &packageKey)
Writing resource package full name to PackagesToRemove Key: %ls
this->pluginPackagesToRemoveKey.CreateSubKey( resourcePackageFullName, KEY_READ | KEY_WRITE, &packageKey)
findMethod(packageInfoCollection.GetAddressOf())
packageInfoCollection->First(packageInfoIterator.GetAddressOf())
packageInfoIterator->get_HasCurrent(&hasCurrent)
packageInfoIterator->get_Current(packageInfo.GetAddressOf())
packageId->get_FullName(packageFullNameAsString.GetAddressOf())
processElementMethod(packageInfo.Get(), packageFullNameAsString.GetRawBuffer(nullptr))
packageInfoIterator->MoveNext(&hasCurrent)
Cannot find package %ls in SIS, not writing to Staged Key
Package %ls is not needed, not writing to Staged Key
WritePackageRegistryKey( packageFamilyName, packageFullName, userSid, &this->pluginStagedKey, s_Staged)
searchStringBuilder.AppendString(packagePath)
fullFilePathBuilder.AppendString(packagePath)
subFolderActionFunction(findFileData.cFileName, fullFilePath.GetChars())
Windows.Foundation.Collections.IIterator`1<String>
Windows.Foundation.Collections.IVectorView`1<String>
Windows.Foundation.Collections.IVector`1<String>
Regions
AppDataVolumeName
AppDataVolumeKey
PackageVolumeName
PackageVolumeKey
IsDevModeApp
Fonecore\admin\appmodel\appxupgrademigrationplugin\src\AppxUpgradeMigrationPluginClass.h
IsLOBApp
Deleted\
SharedLimitedTime\
\AppxMetadata\AppxBundleManifest.xml
\AppxManifest.xml
staterepository-machine.srd
%ProgramData%\Microsoft\Windows\AppRepository
LastReturnValue
IUIPolicyChecked
Software
Deprovisioned
OverrideConfig
Upgrade
Staged
EndOfLife
InboxApplications
Applications
<migXml xmlns=""><rules context=
"system" applyFilter="Yes">
"user">
</rules></migXml>
<include><objectSet>
</objectSet></include>
<exclude><objectSet>
</objectSet></exclude>
<locationModify script="MigXmlHelper.RelativeMove(&apos;%ProgramFiles%\WindowsApps&apos;,&apos;%ProgramFiles%\WindowsApps\SharedLimitedTime&apos;)"><objectSet>
<locationModify script="MigXmlHelper.RelativeMove(&apos;%windir%\InfusedApps&apos;,&apos;%ProgramFiles%\WindowsApps\SharedLimitedTime\InfusedApps&apos;)"><objectSet>
</objectSet></locationModify>
<merge script="MigXmlHelper.SourcePriority()"><objectSet>
<merge script="MigXmlHelper.DestinationPriority()"><objectSet>
</objectSet></merge>
<pattern type="File">
\* [*]</pattern>
]</pattern>
<unconditionalExclude><objectSet>
</objectSet></unconditionalExclude>
<pattern type="Registry">
HKCU\
onecore\admin\appmodel\appxupgrademigrationplugin\src\migxmlwriter.cpp
LocationModifyStringForWindowsApps
LocationModifyStringForInfusedApps
<String too big>
.recovery
onecore\admin\appmodel\appxupgrademigrationplugin\src\recoveryreader.cpp
AppModelPackageRepository
Software\Classes\Local Settings\Software\Microsoft\Windows\CurrentVersion\AppModel\PackageRepository
AppModelRoot
Software\Microsoft\Windows\CurrentVersion\AppModel
Software\Microsoft\Windows\CurrentVersion\Appx\AppxAllUserStore
AppxPackageVolumes
Software\Microsoft\Windows\CurrentVersion\Appx\PackageVolumes
AppxRoot
AppxStateChange
Packages
onecore\base\appmodel\common\stateseparation.cpp
RtlIsStateSeparationEnabled
GetPersistedRegistryLocationW
onecore\base\appmodel\common\registrykey.cpp
RegQueryInfoKey
SetCapacity %u
onecore\base\appmodel\common\stringbuilder.cpp
onecore\base\appmodel\common\widestring.cpp
onecore\base\appmodel\common\stringset.cpp
onecore\base\appmodel\common\bytebuffer.cpp
onecore\base\appmodel\common\pathhelpers.cpp
\\?\UNC\
arm64
x86a64
neutral
unknown
onecore\internal\base\inc\appmodel\package\ProcessorArchitecture.hpp
onecore\admin\appmodel\common\packagefullnameutilities.cpp
%s_%s_%s_%s
onecore\admin\appmodel\common\PackageID.inl
SetupPhase
onecore\admin\appmodel\common\alluserstorepaths.cpp
Microsoft\Windows\CurrentVersion\Appx\AppxAllUserStore\
OSDATA\Software\
Software\
onecore\admin\appmodel\common\configuration.cpp
SisPath
OSRollbackPackages
onecore\admin\appmodel\common\downlevelhelper.cpp
onecore\admin\appmodel\common\directorypaths.cpp
%s\%s
onecore\admin\appmodel\common\mountedfolder.cpp
onecore\admin\appmodel\common\scheduledtaskhelper.cpp
<Task xmlns="http://schemas.microsoft.com/windows/2004/02/mit/task">            <RegistrationInfo>                <SecurityDescriptor>D:(A;;GA;;;SY)(A;;FRFX;;;LS)(A;;FA;;;BA)</SecurityDescriptor>            </RegistrationInfo>            <Principals>                <Principal id="LocalSystem">                    <UserId>S-1-5-18</UserId>                </Principal>            </Principals>            <Triggers>                <TimeTrigger>                    <Repetition>                        <Interval>PT8H</Interval>                        <StopAtDurationEnd>false</StopAtDurationEnd>                    </Repetition>                    <StartBoundary>2017-01-01T00:00:00Z</StartBoundary>                    <Enabled>true</Enabled>                    <RandomDelay>PT8H</RandomDelay>                </TimeTrigger>            </Triggers>            <Settings>                <MultipleInstancesPolicy>IgnoreNew</MultipleInstancesPolicy>                <DisallowStartIfOnBatteries>true</DisallowStartIfOnBatteries>                <StopIfGoingOnBatteries>false</StopIfGoingOnBatteries>                <AllowHardTerminate>false</AllowHardTerminate>                <StartWhenAvailable>true</StartWhenAvailable>                <RunOnlyIfNetworkAvailable>true</RunOnlyIfNetworkAvailable>                <AllowStartOnDemand>true</AllowStartOnDemand>                <Enabled>true</Enabled>                <Hidden>false</Hidden>                <RunOnlyIfIdle>true</RunOnlyIfIdle>                <WakeToRun>false</WakeToRun>                <Priority>8</Priority>                <UseUnifiedSchedulingEngine>true</UseUnifiedSchedulingEngine>            </Settings>            <Actions Context="LocalSystem">                <Exec>                    <Command>%windir%\system32\rundll32.exe</Command>                    <Arguments>%windir%\system32\AppxDeploymentClient.dll,ScheduleAppInstallerBackgroundUpdate</Arguments>                </Exec>            </Actions>        </Task>
%|fUN<
m:AppxProvisionList
m:EndOfLife/m:Package
m:Provisioned/m:Package
onecore\base\appmodel\appxprovisionpackage\src\appxprovisionreader.cpp
http://schemas.microsoft.com/appx/2013/appxprovisionpackage
m:EndOfLife
m:Provisioned
m:Package
@FullName
@FamilyName
AppxProvisionList
Provisioned
Package
FullName
FamilyName
ProvisionSourceIsBundle
bundle
framework
resource
onecore\base\appmodel\appxprovisionpackage\src\appxprovisionwriter.cpp
version="1.0" encoding="utf-8"
@ProvisionSourceIsBundle
@PackageType
@IsLOBApp
onecore\base\appmodel\appxprovisionpackage\src\appxprovisionpackage.cpp
xmlns:m="http://schemas.microsoft.com/appx/2013/appxprovisionpackage"
m:AppxProvisionList/m:Provisioned/m:Package/@FullName
m:AppxProvisionList/m:EndOfLife/m:Package/@FamilyName
<?xml version="1.0" encoding="utf-8"?><xs:schema attributeFormDefault="unqualified" elementFormDefault="qualified" targetNamespace="http://schemas.microsoft.com/appx/2013/appxprovisionpackage" xmlns="http://schemas.microsoft.com/appx/2013/appxprovisionpackage" xmlns:m="http://schemas.microsoft.com/appx/2013/appxprovisionpackage" xmlns:xs="http://www.w3.org/2001/XMLSchema"><xs:element name="AppxProvisionList">  <xs:complexType>    <xs:all>      <xs:element name="EndOfLife" type="CT_EndOfLife" minOccurs="0"/>      <xs:element name="Provisioned" type="CT_Provisioned" minOccurs="0"/>    </xs:all>  </xs:complexType>  <xs:unique name="Package_FamilyName">    <xs:selector xpath="m:EndOfLife/m:Package"/>    <xs:field xpath="@FamilyName"/>  </xs:unique>  <xs:unique name="Package_FullName">    <xs:selector xpath="m:Provisioned/m:Package"/>    <xs:field xpath="@FullName"/>  </xs:unique></xs:element><xs:complexType name="CT_EndOfLife">  <xs:sequence>    <xs:element name="Package" maxOccurs="unbounded">      <xs:complexType>        <xs:attribute name="FamilyName" type="ST_FamilyName" use="required"/>      </xs:complexType>    </xs:element>  </xs:sequence></xs:complexType><xs:complexType name="CT_Provisioned">  <xs:sequence>    <xs:element name="Package" maxOccurs="unbounded">      <xs:complexType>        <xs:attribute name="FullName" type="ST_FullName" use="required"/>        <xs:attribute name="PackageType" type="ST_PackageType"/>        <xs:attribute name="ProvisionSourceIsBundle" type="xs:boolean"/>        <xs:attribute name="IsLOBApp" type="xs:boolean"/>      </xs:complexType>    </xs:element>  </xs:sequence></xs:complexType><xs:simpleType name="ST_FamilyName">  <xs:restriction base="xs:string">    <xs:minLength value="17"/>    <xs:maxLength value="64"/>  </xs:restriction></xs:simpleType><xs:simpleType name="ST_FullName">  <xs:restriction base="xs:string">    <xs:minLength value="30"/>    <xs:maxLength value="127"/>  </xs:restriction></xs:simpleType><xs:simpleType name="ST_PackageType">  <xs:restriction base="xs:string">    <xs:enumeration value="resource"/>    <xs:enumeration value="framework"/>    <xs:enumeration value="bundle"/>  </xs:restriction></xs:simpleType></xs:schema>
onecore\base\appmodel\appxprovisionpackage\src\commonhelpers.cpp
NewParser
SelectionNamespaces
onecore\base\appmodel\appxprovisionpackage\src\appxprovisionpackageenumerator.cpp
)onecore\base\appmodel\runtime\src\systemmetadatainternal.cpp
com1.
com2.
com3.
com4.
com5.
com6.
com7.
com8.
com9.
lpt1.
lpt2.
lpt3.
lpt4.
lpt5.
lpt6.
lpt7.
lpt8.
lpt9.
.xn--
1234567890abcdefghjkmnpqrstvwxyzABCDEFGHJKMNPQRSTVWXYZ
onecore\base\appmodel\common\autocotaskmemstring.cpp
ProcessSingletonPackagesHelperFailed
packageFullName
ApplySuccessFailed
HResult
DownlevelOSVersion
NoReRegisterOnUpgrade
PluginExecutedInOfflineMode
GatherFailed
HResult
DownlevelOSVersion
Gather.FixStateRepositoryOrResetMaintenance.Failed
HResult
DiscoverFailed
HResult
DownlevelOSVersion
AppxUpgradeMigration:EOL-Messaging/MobilePlans
HasModem
AppsEOL
PartA_PrivTags
FallbackError
PartA_PrivTags
wilResult
hresult
fileName
lineNumber
module
failureType
message
threadId
callContext
originatingContextId
originatingContextName
originatingContextMessage
currentContextId
currentContextName
currentContextMessage
FallbackError
PartA_PrivTags
wilResult
hresult
fileName
lineNumber
module
failureType
message
threadId
callContext
originatingContextId
originatingContextName
originatingContextMessage
currentContextId
currentContextName
currentContextMessage
failureId
failureCount
function
Microsoft.Windows.AppxMigrationPlugin
RSDS^Bxk
!v0I&
AppxUpgradeMigrationPlugin.pdb
.text
.text$di
.text$mn
.text$mn$00
.text$x
.text$yd
.rdata$brc
.idata$5
.00cfg
.CRT$XCA
.CRT$XCL
.CRT$XCU
.CRT$XCZ
.CRT$XIA
.CRT$XIAA
.CRT$XIZ
.gehcont
.gfids
.giats
.rdata
.rdata$voltmd
.rdata$zETW0
.rdata$zETW1
.rdata$zETW2
.rdata$zETW9
.rdata$zzzdbg
.xdata
.xdata$x
ATL$__a
ATL$__m
ATL$__z
.edata
.idata$2
.idata$3
.idata$4
.idata$6
.data$brc
.data$r$brc
.data
.pdata
.rsrc$01
.rsrc$02
!v0I&
APPXUPGRADEMIGRATIONPLUGIN.dll
DllCanUnloadNow
DllGetClassObject
__CxxFrameHandler3
__C_specific_handler
_vsnwprintf
memcpy_s
_purecall
??1exception@@UEAA@XZ
??0exception@@QEAA@XZ
??0exception@@QEAA@AEBV0@@Z
_vsnprintf_s
memmove_s
wcsrchr
_wcsnicmp
_wcsicmp
malloc
realloc
_XcptFilter
_amsg_exit
_initterm
msvcrt.dll
?terminate@@YAXXZ
_lock
_unlock
__dllonexit
_onexit
??1type_info@@UEAA@XZ
CreateSemaphoreExW
HeapFree
SetLastError
EnterCriticalSection
ReleaseSemaphore
LeaveCriticalSection
InitializeCriticalSection
CoTaskMemFree
InitializeCriticalSectionEx
WaitForThreadpoolTimerCallbacks
WaitForSingleObject
GetCurrentThreadId
ReleaseMutex
FormatMessageW
GetLastError
ReleaseSRWLockExclusive
OutputDebugStringW
CloseThreadpoolTimer
AcquireSRWLockExclusive
WaitForSingleObjectEx
OpenSemaphoreW
CloseHandle
SetThreadpoolTimer
ReleaseSRWLockShared
CreateThreadpoolTimer
HeapAlloc
GetProcAddress
CreateMutexExW
AcquireSRWLockShared
DeleteCriticalSection
GetCurrentProcessId
GetProcessHeap
GetModuleHandleW
FreeLibrary
RegCloseKey
IsDebuggerPresent
DisableThreadLibraryCalls
RaiseException
CoCreateInstance
FindClose
GetFileAttributesW
CoInitializeEx
CoUninitialize
LoadLibraryW
GetFileVersionInfoSizeExW
GetFileVersionInfoExW
VerQueryValueW
OpenSCManagerW
OpenServiceW
QueryServiceStatus
ExpandEnvironmentStringsW
GetModuleFileNameW
RegEnumKeyExW
RegEnumValueW
RegQueryValueExW
CLSIDFromString
EventUnregister
EventWriteTransfer
InitOnceBeginInitialize
InitOnceComplete
EventSetInformation
EventRegister
CompareStringOrdinal
CreateFileW
FindFirstFileW
FindNextFileW
GetSystemWindowsDirectoryW
CopyFileW
LoadLibraryExW
InitializeProcThreadAttributeList
UpdateProcThreadAttribute
CreateProcessW
GetExitCodeProcess
CoGetInterfaceAndReleaseStream
SetEvent
CreateEventW
CoMarshalInterThreadInterfaceInStream
CreateThread
GetTickCount64
ConvertStringSidToSidW
GetNamedSecurityInfoW
SetEntriesInAclW
SetNamedSecurityInfoW
LocalFree
RegGetKeySecurity
RegGetValueW
CloseServiceHandle
CoTaskMemAlloc
InitializeSRWLock
CoGetApartmentType
Sleep
RtlCaptureContext
RtlLookupFunctionEntry
RtlVirtualUnwind
UnhandledExceptionFilter
SetUnhandledExceptionFilter
GetCurrentProcess
TerminateProcess
QueryPerformanceCounter
GetSystemTimeAsFileTime
GetTickCount
api-ms-win-core-synch-l1-1-0.dll
api-ms-win-core-heap-l1-1-0.dll
api-ms-win-core-errorhandling-l1-1-0.dll
api-ms-win-core-com-l1-1-0.dll
api-ms-win-core-threadpool-l1-2-0.dll
api-ms-win-core-processthreads-l1-1-0.dll
api-ms-win-core-localization-l1-2-0.dll
api-ms-win-core-debug-l1-1-0.dll
api-ms-win-core-handle-l1-1-0.dll
api-ms-win-core-libraryloader-l1-1-0.dll
api-ms-win-core-registry-l1-1-0.dll
api-ms-win-core-file-l1-1-0.dll
api-ms-win-core-kernel32-legacy-l1-1-0.dll
api-ms-win-core-version-l1-1-0.dll
api-ms-win-service-management-l1-1-0.dll
api-ms-win-service-winsvc-l1-1-0.dll
api-ms-win-core-processenvironment-l1-1-0.dll
api-ms-win-eventing-provider-l1-1-0.dll
api-ms-win-core-synch-l1-2-0.dll
api-ms-win-core-string-l1-1-0.dll
api-ms-win-core-sysinfo-l1-1-0.dll
api-ms-win-security-sddl-l1-1-0.dll
api-ms-win-security-provider-l1-1-0.dll
api-ms-win-core-heap-obsolete-l1-1-0.dll
api-ms-win-core-rtlsupport-l1-1-0.dll
api-ms-win-core-profile-l1-1-0.dll
RtlCompareUnicodeString
RtlInitializeGenericTableAvl
RtlDeleteElementGenericTableAvl
RtlInitUnicodeString
RtlEnumerateGenericTableWithoutSplayingAvl
RtlGetVersion
RtlLookupElementGenericTableAvl
RtlIsGenericTableEmptyAvl
RtlInsertElementGenericTableAvl
EtwEventRegister
EtwEventWrite
EtwEventUnregister
NtCreateSection
NtClose
RtlNtStatusToDosErrorNoTeb
NtMapViewOfSection
NtUnmapViewOfSection
ntdll.dll
ConvertInterfaceGuidToLuid
GetIfEntry2
IPHLPAPI.DLL
PackageFamilyNameFromFullName
GetEffectiveRightsFromAclW
OLEAUT32.dll
KERNEL32.dll
ADVAPI32.dll
RoActivateInstance
RoGetActivationFactory
api-ms-win-core-winrt-l1-1-0.dll
WindowsDeleteString
WindowsGetStringRawBuffer
WindowsStringHasEmbeddedNull
WindowsCreateString
WindowsCreateStringReference
WindowsDuplicateString
api-ms-win-core-winrt-string-l1-1-0.dll
RoOriginateError
RoTransformError
api-ms-win-core-winrt-error-l1-1-0.dll
DevObjCreateDeviceInfoList
DevObjGetClassDevs
DevObjEnumDeviceInfo
DevObjOpenDevRegKey
DevObjDestroyDeviceInfoList
DEVOBJ.dll
wcsstr
RegOpenKeyExW
RegDeleteKeyExW
RegDeleteTreeW
RegCopyTreeW
RegCreateKeyExW
RegDeleteValueW
RegSetValueExW
RegSetKeySecurity
RegQueryInfoKeyW
DeleteFileW
RemoveDirectoryW
SetFileAttributesW
WriteFile
ReadFile
DeviceIoControl
api-ms-win-core-io-l1-1-0.dll
RtlAllocateHeap
RtlReAllocateHeap
RtlFreeHeap
RtlReleaseSRWLockShared
RtlAcquireSRWLockShared
RtlReleaseSRWLockExclusive
RtlAcquireSRWLockExclusive
_CxxThrowException
memcmp
memcpy
memmove
memset
wcscmp
.?AVResultException@wil@@
.?AVexception@@
VS_VERSION_INFO
StringFileInfo
040904B0
CompanyName
Microsoft Corporation
FileDescription
Appx Upgrade Migration Plugin
FileVersion
10.0.22621.586 (WinBuild.160101.0800)
InternalName
AppxUpgradeMigrationPlugin.dll
LegalCopyright
 Microsoft Corporation. All rights reserved.
OriginalFilename
AppxUpgradeMigrationPlugin.dll
ProductName
Microsoft
 Windows
 Operating System
ProductVersion
10.0.22621.586
VarFileInfo
Translation
8]\.t
Washington1
Redmond1
Microsoft Corporation1.0,
%Microsoft Windows Production PCA 20110
220505192314Z
230504192314Z0p1
Washington1
Redmond1
Microsoft Corporation1
Microsoft Windows0
H`>sC
8twt0P
E0C1)0'
 Microsoft Operations Puerto Rico1
229879+4700210
M0K0I
Chttp://www.microsoft.com/pkiops/crl/MicWinProPCA2011_2011-10-19.crl0a
U0S0Q
Ehttp://www.microsoft.com/pkiops/certs/MicWinProPCA2011_2011-10-19.crt0
Washington1
Redmond1
Microsoft Corporation1200
)Microsoft Root Certificate Authority 20100
111019184142Z
261019185142Z0
Washington1
Redmond1
Microsoft Corporation1.0,
%Microsoft Windows Production PCA 20110
O0M0K
Ehttp://crl.microsoft.com/pki/crl/products/MicRooCerAut_2010-06-23.crl0Z
N0L0J
>http://www.microsoft.com/pki/certs/MicRooCerAut_2010-06-23.crt0
TlP0X
R!s4Z
Washington1
Redmond1
Microsoft Corporation1.0,
%Microsoft Windows Production PCA 2011
8]\.t
,45rTznX0lCJdFgP1NgKPJscHxGueerKGk4X4KXxqhMU=0Z
"Microsoft Window
 http://www.microsoft.com/windows0
E+V(l
wB&s$f
h"/1X
20220817031156.525Z0
Washington1
Redmond1
Microsoft Corporation1)0'
 Microsoft Operations Puerto Rico1&0$
Thales TSS ESN:60BC-E383-26351%0#
Microsoft Time-Stamp Service
Washington1
Redmond1
Microsoft Corporation1&0$
Microsoft Time-Stamp PCA 20100
220302185121Z
230511185121Z0
Washington1
Redmond1
Microsoft Corporation1)0'
 Microsoft Operations Puerto Rico1&0$
Thales TSS ESN:60BC-E383-26351%0#
Microsoft Time-Stamp Service0
frPy=?=
``PJn
X0V0T
Nhttp://www.microsoft.com/pkiops/crl/Microsoft%20Time-Stamp%20PCA%202010(1).crl0l
`0^0\
Phttp://www.microsoft.com/pkiops/certs/Microsoft%20Time-Stamp%20PCA%202010(1).crt0
|jyd&1
 MR^o
"XkU-
Washington1
Redmond1
Microsoft Corporation1200
)Microsoft Root Certificate Authority 20100
210930182225Z
300930183225Z0|1
Washington1
Redmond1
Microsoft Corporation1&0$
Microsoft Time-Stamp PCA 20100
q\Q17
&S|9a
!]_0t
U0S0Q
3http://www.microsoft.com/pkiops/Docs/Repository.htm0
O0M0K
Ehttp://crl.microsoft.com/pki/crl/products/MicRooCerAut_2010-06-23.crl0Z
N0L0J
>http://www.microsoft.com/pki/certs/MicRooCerAut_2010-06-23.crt0
>NGdx
fg:SM
xSu$W
as.,k{n?,
J>f;O
!TkjE
Washington1
Redmond1
Microsoft Corporation1)0'
 Microsoft Operations Puerto Rico1&0$
Thales TSS ESN:60BC-E383-26351%0#
Microsoft Time-Stamp Service
Washington1
Redmond1
Microsoft Corporation1&0$
Microsoft Time-Stamp PCA 20100
20220817055052Z
20220818055052Z0w0=
1/0-0
1(0&0
Washington1
Redmond1
Microsoft Corporation1&0$
Microsoft Time-Stamp PCA 2010
Washington1
Redmond1
Microsoft Corporation1&0$
Microsoft Time-Stamp PCA 2010
U^J@X
!4p:x
