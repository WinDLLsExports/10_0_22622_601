!This program cannot be run in DOS mode.
)HRich
.text
`.rdata
@.data
.pdata
@.didat
.rsrc
@.reloc
L$0H3
{ AVH
|$8E3
q3UZ"
q0R^G'
q!P6{'
q*Px'
q`X>L
q(Qr9
qB]pu
q0R^G'
ATAVAWH
p0R^G'
 A_A^A\
q:_0#
VWAVH
\$ E3
D$HE3
D$HE3
LcA<E3
HcQ<H
\$ UH
 H3E H3E
oD$ f
oL$0f
oT$@f
o\$PH
oD$ f
oL$0f
oT$@f
o\$PH
oD$ f
oL$0f
oT$@f
o\$PH
oD$ f
oL$0f
oT$@f
o\$PH
oD$ f
oL$0f
oT$@f
o\$PH
oD$ f
oL$0f
oT$@f
o\$PH
oD$ f
oL$0f
oT$@f
o\$PH
oD$ f
oL$0f
oT$@f
o\$PH
oD$ f
oL$0f
oT$@f
o\$PH
oD$ f
oL$0f
oT$@f
o\$PH
\$ UVWATAUAVAWH
D9l$(|
D$,D8-
t(D8-fV
UVWAVAWH
D9|$(
t(D8=
D8=2S
A_A^_^]
t<fA9(t6I
|$ UH
x AVH
VWATAVAWH
fD9 t
D$0fD9 t
A_A^A\_^
WAVAWH
 A_A^_
\$ UVWAVAWH
t,D8=
L9{Hu
A_A^_^]
D$xE3
D$8E3
D$@E3
@SUVWH
D$0L;
UVWATAUAVAWH
@8=P;
ty@8=
t"@8=
fA9>u
@A_A^A]A\_^]
L$ SWH
L$XH+
L$ UVWATAUAVAWH
vpD8]
.u fA9G
 tWH;
>.u+H
fD9<Cu
fF9<`u
s#D9}
fD9;u
A_A^A]A\_^]
t$ WH
WATAUAVAWH
H9/sDH
 A_A^A]A\_
x AVH
uPH9i
D$0H+
D$(L+
D$@L+
)L$0A
L$PH3
x UAVAWH
fD98t
D$@fD98t
HcD$$HcL$ H
A_A^]
D$(E3
\$ UVWAVAWH
A_A^_^]
D$(E3
L$PH3
D$PE3
L$PH3
UVWATAUAVAWH
ttEH;
A_A^A]A\_^]
UATAUAVAWH
x=H+}
x0H;u
E`H+]
A_A^A]A\]
USVWATAUAVAWH
A_A^A]A\_^[]
UVWATAUAVAWH
|$8H+
HH9|$8u
|$8t+fA
>ft$fA
t)@88t$I
t;@89t6I
|$0H+
A_A^A]A\_^]
L$`H3
L$@H3
9T$hwL3
9T$hH
f;D$h
|$ AVH
cw;tY
\$ WH
x UAVAWH
I|$0E
A_A^]
@USVWAVH
H!\$0H
A^_^[]
L$@E3
L$ WH
WATAUAVAWH
fD94{u
fE94\u
fE9tM
 A_A^A]A\_
p9Tz,
E(=csm
E8=csm
EH=csm
EX=csm
Eh=csm
Ex=csm
L$ VWAVH
|$@H;
 A^_^
H!x0H!x8H!
H WAVAWH
0A_A^_
|$PH;
t$ WH
t$HE3
@SUVWAVH
T$PE3
A^_^][
WAVAWH
 A_A^_
T$(E3
x AVH
VWAVH
T$(E3
@A^_^
VWAVH
@A^_^
L$ SVWAVH
(A^_^[
VWAVH
 A^_^
t$ UWAVH
x ATAVAWH
;1}8H
0A_A^A\
WAVAWH
tI9i8u*D8y<u$H
A_A^_
t$ WH
UVWATAUAVAWH
D$AE3
A_A^A]A\_^]
UVWATAUAVAWH
(D$pL
D$pE3
t$`L9>t L
A_A^A]A\_^]
D$@Hi
t$ WH
l$8Hi
D$8Hi
T$ E3
T$ E3
x AVH
t$ WH
VWAVH
 A^_^
p WAVAWH
 A_A^_
t$ WAVAWH
D$`Hi
 A_A^_
UVWATAUAVAWH
0A_A^A]A\_^]
D$HHi
x UAVAWH
@8|$@tYH
A_A^]
t$ WATAUAVAWH
A_A^A]A\_
L$ WH
x AVH
L$0H3
f9,Wu
\$ UVWH
VWAVH
@A^_^
UVWAVAWH
 A_A^_^]
UVWAVAWH
 A_A^_^]
x AVH
pbWzN
qi[P%6
9L$0t
9L$0t
9L$0t
9L$0t
q1Xr8
qzUvg.
9L$0t
pa\vT>
VWAVH
0A^_^
WAVAWH
G8;G<}
0A_A^_
VWAVH
0A^_^
psPXM
p WAVAWH
 A_A^_
p WAVAWH
 A_A^_
VWAVH
0A^_^
VWAVH
0A^_^
t$ WH
p0\:#7
L$@H3
\$ UVWAVAWH
L$pH3
A_A^_^]
L$0H3
WAVAWH
0A_A^_
qaV<M
p"\rJ
9L$0t
qBX0{
qy]t.
RrV'1
9L$0t
9L$0t
9L$0t
L$0H3
L$0H3
L$0H3
L$0H3
L$0H3
L$0H3
L$0H3
L$0H3
PtC6Q
pX]>j
q3^4/
x AVH
x AVH
@SVWH
@SUVWAVH
A^_^][
x UAUAVH
H+D$Pu
H+D$XH
H+D$Pu
H+D$XH
A^A]]
x UAVAWH
D9|$@t/
A_A^]
x AVH
x fD9t$8t
\$ WH
\$ WH
f;D$ u
f;D$ u
f;D$ u
f;D$ u
f;D$ u
f;D$ u&
f;D$ u
\$ E3
|$ E3
WAVAWH
@A_A^_
\$ E3
VWAVH
8\$@u
 A^_^
t$ WH
x AVH
x AVH
@SUVWAVH
A^_^][
t$ WH
\$ UVWATAUAVAWH
L$XE3
L9t$8t
H#D$X3
A_A^A]A\_^]
UVWAVAWH
A_A^_^]
t$ WH
Stw7`
\$ UVWATAUAVAWH
D$HA9\$ t7I
H9\$XtMH9\$@tFH
H9\$8tLI
9\$H|
8\$0t
A_A^A]A\_^]
\$ UVWAVAWH
pqR|5
A_A^_^]
t$ WH
8\$0u
qyYz"
p3^4/
UVWAVAWH
|$@\u
A_A^_^]
qQUxf'H
|$ UH
|$0\u
|$ UATAUAVAWH
A_A^A]A\]
x AVH
x AVH
@SVWH
VWAVH
UWATAVAWH
A_A^A\_]
L$PE3
T$PE3
x AVH
x AVH
@SUVWATAVAWH
A_A^A\_^][
T$ t+
UWAVH
|$\\u
D$0E3
L$0H3
UVWATAUAVAWH
fD;u.
f;E.u
fD;u0
`A_A^A]A\_^]
(D$ L
@SVWH
@SVWH
t$ WAVAWH
fD;9tyL
fE9<[u
f;D< u
A_A^_
t$ WH
L$ E3
\$ UVWATAUAVAWH
fD;)u
fD;*u
fD9,Yu
fE9,vu
f;D| u
A_A^A]A\_^]
f;D$ u
f;D$(
L$8H3
@USVWAVH
L$`E3
L$0E3
A^_^[]
f;D$ u
f;D$ u
f;D$0u
f;D$8
t$ UWAVH
D9s t
D9s$u
L$\D9s t6
l$ VWAVH
\$ WH
\$ WH
f;L$ u
f;D$ u
t$P0C
\$Xu+H
WAVAWH
 A_A^_
D$0E3
{ AVH
f;D$@u
f;D$H@
@SUVWATAVAWH
D$<A+
+D$0;
D9D$0t
A_A^A\_^][
\$ UVWATAUAVAWH
A_A^A]A\_^]
\$ UVWATAUAVAWH
D$@E3
A_A^A]A\_^]
\$ E3
f;D$ uaH
f;D$Hu
D$0D;
LcD$4H
UVWATAUAVAWH
PA_A^A]A\_^]
VWAVH
p"QTg
0A^_^
D$(E3
L$PH3
@SVWH
\$ WH
L$HH3
{ AVH
{ AVH
q"\rJ
p3^4/
tA9\$8v*H
D$@E3
;\$8r
L$ E3
qbWzN
` UAVAWH
fD9$Wu
xqD9e
A_A^]
UWAWH
M(f91t>H
UWAWH
|$ UATAVH
fD94Wu
A^A\]
f;T$(
qi[P%6
fA9<Su
f9,Su
f9,Su
x:9l$Ht
` UAVAWH
fD9$Wu
A_A^]
|$ UAUAVH
A^A]]
|$ UAUAVH
A^A]]
` UAVAWH
fD9$Wu
xqD9e
A_A^]
f;T$(
UWATH
UWATAVAWH
A_A^A\_]
UWATAVAWH
A_A^A\_]
|$ UAUAVH
A^A]]
UWAVH
`A^_]
t$ WH
qa\vT>
f;L$(
UATAVH
A^A\]
f94Su
f94Su
UWAWH
T$ E3
pyYz"
qsPXM
pQUxf'H
@USVWAVH
D$0L+
D$0L+
A^_^[]
qX]>j
t$ UH
t$ UH
UWAVH
`A^_]
UATAVH
A^A\]
UATAUAVAWH
fD9,Vu
A_A^A]A\]
x AVH
l$ VWATAVAWH
0A_A^A\_^
` UAVAWH
A_A^]
UAVAWH
A_A^]
UATAUAVAWH
fD9,Wu
A_A^A]A\]
t$ WH
t$ WATAUAVAWH
~@D:xPs
0A_A^A]A\_
t$ WAVAWH
 A_A^_
VWATAVAWH
0A_A^A\_^
)t$ I
(t$ H
@USVWAVH
A^_^[]
f9,Bu
D$@E3
UVAVH
H9l$@v1D
M~fF9
L;D$@r
 A^^]
\$ UVWH
L$pH3
VWAVH
 A^_^
R$fA;Z*
fA9Z*v#A
|$ UATAUAVAWH
A_A^A]A\]
Stw7`
UAVAWH
A_A^]
qpUT?
UAVAWH
A_A^]
\$ UVWATAUAVAWH
U@H!u@I
Stw7`
`A_A^A]A\_^]
f;D$ u
UWATAVAWH
ppUT?
A_A^A\_]
KH9{0@
t$ WH
L$pH3
x AVH
x AVH
VWAVH
 A^_^
t$ WH
WATAUAVAWH
fA;Dn
 A_A^A]A\_
p WAVAWH
L$PD;
 A_A^_
VWAVH
0A^_^
VWAVH
fA9,Cu
p1Xr8
@USVWATAVAWH
D8e@t
 A_A^A\_^[]
l$ VWAVH
D8t$0t
t$ WH
x AVH
t$8E3
x AVH
x ATAVAWH
@A_A^A\
|$@E3
\$hE3
L$(E3
t$ WH
T$0E3
x AVH
@USVWATAUAVAWH
T$(E3
D$ E3
D$ E3
T$`E3
A_A^A]A\_^[]
` UAVAWH
t<fD;'u6H
A_A^]
f9/t9I
ZvY?!
H!]8H!]
p WATAVH
H!D$`E3
@A^A\_
|$ UATAUAVAWH
A_A^A]A\]
uaI!K
UATAUAVAWH
x/L!d$(L
A_A^A]A\]
L$ UVWATAUAVAWH
H9|$X
H9|$X
A_A^A]A\_^]
UWATAVAWH
A_A^A\_]
VWAVH
L$0E3
PA^_^
UVWATAUAVAWH
@A_A^A]A\_^]
UVWATAUAVAWH
@A_A^A]A\_^]
@USVWAVH
pA^_^[]
\$ UVWAVAWH
A_A^_^]
UWAUAVAWH
L$HE3
A_A^A]_]
|$ UATAUAVAWH
A_A^A]A\]
UWATAVAWH
pq[\x
A_A^A\_]
VWAVH
p;U^?
T$ E3
USVWATAUAVAWH
fE9!tkH
HA_A^A]A\_^[]
x AVH
{ AVH
p AWH
x AVH
fD94Ju
fD94Bu
x AVH
^Z26H
|$ AWH
D$x9D$0u6H
^XH9;t
VWAVH
D9t$ht
0A^_^
UVWAVAWH
P8,/P
@A_A^_^]
@USWH
D$ E3
@SUVWAVH
[rt6x
T$xE3
0A^_^][
ATAVAWH
 A_A^A\
!KH!KLH
C@;CDs8D
L$8E3
t$ WH
L$8H3
UWAWH
D$HH;
D$@H;
D$@Hi
L$PH;
t$ UWAVH
v)H;E
UVWAVAWH
H!}@H
E@!}0L
pA_A^_^]
x ATAVAWH
0A_A^A\
UVWAVAWH
@A_A^_^]
D$ E3
T$ E3
\$ VWAVH
UVWATAUAVAWH
D$@H9
#D$`@
A_A^A]A\_^]
 t'H;
t$ WH
L$pH3
UWAVH
T$0E3
piY0Y7$
\$ UVWH
T$DD#
t$ WH
D$0E3
|$ UH
x UATAVH
\$HI;
D$0E3
A^A\]
VWAVH
WAVAWH
0A_A^_
L$8H3
qqR|5
@SUVWAVH
\$8E3
A^_^][
t$ WH
L$hH3
x AVH
VWATAVAWH
0A_A^A\_^
@SUVWAVH
L$pH3
A^_^][
@SUVWAVH
L$pH3
A^_^][
\$ UVWATAUAVAWH
A_A^A]A\_^]
qbZTa
VWAVH
0A^_^
VWATAVAWH
0A_A^A\_^
VWATAVAWH
0A_A^A\_^
VWATAVAWH
0A_A^A\_^
|$ @u
|$ Hu
T$ E3
\$ VWATAVAWH
A_A^A\_^
VWAVH
UVWAUAWH
L!|$(H
A_A]_^]
WAVAWH
0A_A^_
@SVWAVAWH
0A_A^_^[
@SVWAVAWH
A_A^_^[
qiY0Y7$
@SVWH
D$8E3
L$XH3
T$PE3
t$ WH
L$(E3
p WAVAWH
 A_A^_
L$(E3
K\f;LF
UVWATAUAVAWH
L$ E3
A_A^A]A\_^]
{ AVH
\$PE3
\$0E3
UVWATAUAVAWH
@A_A^A]A\_^]
UWATAVAWH
A_A^A\_]
f;D$@u
f;D$H
\$ UVWAVAWH
A_A^_^]
D9H A
@USVATAUAVAWH
t$Pu4A
l$ E3
A_A^A]A\^[]
WAVAWH
0A_A^_
T$(E3
p AWH
D$8E3
t$8E3
D$0E3
VWAVH
x AVH
UAVAWH
A_A^]
T$8E3
@USVWAUAVAWH
xEfD;}
A_A^A]_^[]
@USVWATAVAWH
xBL9cht<L
L9chu
A_A^A\_^[]
H9AXt
H9A`t
UAVAWH
pqR|5
A_A^]
\$ VWAVH
 A^_^
x AVH
f;D$0u
f;D$ u
t$ WAVAWH
D8t$Ht
 A_A^_
t$ E3
VWAVH
 A^_^
WAVAWH
 A_A^_
UVWATAUAVAWH
pA_A^A]A\_^]
VWAVH
 A^_^
WAVAWH
 A_A^_
q"QTg
t$ WH
D$(E3
L$xH3
x AVH
x AVH
@SUVWAVAWH
A_A^_^][
t$ WH
L$ WH
T$XE3
x ATAVAWH
@A_A^A\
@SUVWAVH
L$XH3
`A^_^][
@SUVWATAVAWH
d$ E3
L$PE3
fD9d$Pt
A_A^A\_^][
t$ WH
L$ E3
L$0H3
@SUVWAVH
L$PH3
`A^_^][
x ATAVAWH
 A_A^A\
UWAVH
L$@E3
x AVH
A(+B(
t$ WH
t$ WH
x AVH
t$0H;
UATAUAVAWH
0A_A^A]A\]
f;D$ u
f;D$(
D$ 9H
@USVWAVAWH
A_A^_^[]
f;D$ u!H
@SVWH
T$(E3
HcT$ H
L$XH3
@SVWH
HcT$ H
L$XH3
UVWAVAWH
@A_A^_^]
@SUVWAVH
L$HH3
PA^_^][
t$ UWATAVAWH
A_A^A\_]
@SVWH
L$@H3
` UAVAWH
A_A^]
UVWATAUAVAWH
A_A^A]A\_^]
WAVAWH
@A_A^_
UATAUAVAWH
upt+D
A_A^A]A\]
@SUVWAVAWH
A_A^_^][
D$0E3
T$xE3
VWAVH
 A^_^
VWAVH
 A^_^
@SUVWAVH
L$XH3
`A^_^][
UVWAVAWH
T$0E3
;l$<r
L$HH3
PA_A^_^]
VWAUAVAWH
 A_A^A]_^
s WAVAWH
T$PE3
0A_A^_
t$ WH
!D$4k
T$8E3
9\$<vN
;\$<r
L$HH3
@USVWATAVAWH
HcT$0I
A_A^A\_^[]
WAVAWH
@A_A^_
x ATAVAWH
A_A^A\
f;D$ u
UVWAVAWH
@A_A^_^]
@USVWATAUAVAWH
A_A^A]A\_^[]
UVWATAUAVAWH
L$8I;
pA_A^A]A\_^]
D$(H;D$ v
H+D$ 
L$@H3
L$PE3
UVWATAUAVAWH
H!t$0L
H!t$(
xRD8l$qtKI
!t$xH
xqHcU
|8L9m
~2H+M
A_A^A]A\_^]
VWAVH
0A^_^
L$HE3
D$0H+
@SVWH
f94Au
@SUVWATAUAVAWH
D$0H;
A_A^A]A\_^][
f9sbu
f9,Yu
p WAVAWH
fD9<Fu
fD9<Cu
kf9;u
 A_A^_
p WAVAWH
fD9<^u
 A_A^_
VWATAVAWH
fE9$Fu
fD9$Ou
0A_A^A\_^
x AVH
A[f;D}
UWATAVAWH
fD;%.
\$~H;
f9D$@u
A_A^A\_]
\$ UVWH
|$0\u
|$0\u
f;GLu
f;G`u
UVWATAVH
fD;5x
f9D$0u
A^A\_^]
t$ WH
t$ UWATAVAWH
f9D$0u
A_A^A\_]
VWAVH
f94Su
f94Su
f94Au
fB94Qu
x AVE3
fF94Qu
|$(A^
L$ E3
l$ VWAVH
~f9(t
f9<Qu
<H\t_fA9,Ht
UVWAVAWH
fD9<Au
A_A^_^]
WAVAWH
fD9<yu
 A_A^_
\$0E3
D$(E3
@SUVWAVH
A^_^][
t$ WH
|$0\u
L$`H3
|$0\u
L$ E3
L$ SVW
f94Au
L$ SVWH
9D$Ht
t$ WH
t$ WH
t>f9.t9
@USWH
t9HcE(H
qqW<:
UVWATAVH
L$=fD
A^A\_^]
UATAUAVAWH
A_A^A]A\]
UWATAVAWH
D9}gt
A_A^A\_]
qq[\x
WAVAWH
 A_A^_
WAVAWH
 A_A^_
WAVAWH
 A_A^_
@USWH
E(H;E H
L$ UWATAVAWH
0A_A^A\_]
t$ E3
x AVH
p AWH
UVWAVAWH
H!]8L
E8H!\$ E3
@A_A^_^]
UWATAVAWH
x 9]0u
A_A^A\_]
x AVH
x AVH
UVWATAUAVAWH
fD9d$0
D$0fD9 t
fD9d$0t H
A_A^A]A\_^]
|$ AVH
tVH!t$0L
D$0L;
UVWAVAWH
A_A^_^]
UVWAVAWH
A_A^_^]
UVWAVAWH
A_A^_^]
UVWAVAWH
 A_A^_^]
q{]~o
H9iHu
D$ H9l$(t,H
@USWATAUAVAWH
H9y0u&
A_A^A]A\_[]
UVWAVAWH
A_A^_^]
H9q8u%
Mg+Mw
WAVAWH
 A_A^_
WAVAWH
 A_A^_
WAVAWH
 A_A^_
VWAVH
 A^_^
|$ AVH
tBH!t$0L
D$0L;
UWAUAVAWH
A_A^A]_]
x AVH
@8szt
WATAUAVAWH
D$hE3
D9%qo
D9%]o
L$0H#
D9d$0
fE9$Au
L$hH3
A_A^A]A\_
x AVH
H+AHu
H+APH
u 9iXtDH
qs^<7
x ATAVAWH
 A_A^A\
@8yyt9@8yxt
UWAUAVAWH
pyT:K
A_A^A]_]
x AVH
9|$`t8H
UVWAVAWH
H9w v%3
 H;w r
L$0H3
@A_A^_^]
{ AVH
L$`E3
UATAUAVAWH
L$0E3
t$HHc
D#d$tA
L$`E3
x5D;|$8t.H
A_A^A]A\]
UVWAVAWH
p;Rz].
@A_A^_^]
UVWATAUAVAWH
pyT:K
`A_A^A]A\_^]
x AVH
x UAUAVH
H!|$hH
H!|$XL
D$ fD
x_fD;l$puMH
A^A]]
x UAVAWH
L$@E3
\$@fD
fD94Cu
A_A^]
L$8H3
VWAVH
0A^_^
K`H!C`H
u39C(t)
x AVH
WAVAWH
th9o(t^
f9,Zu
 A_A^_
x AVH
f9,Au
f9,~u
T$8E3
WATAUAVAWH
fD9,Bu
fE9,Fu
A_A^A]A\_
T$8E3
@SVWH
t$ WAVAWH
fD9<Bu
 A_A^_
f94xu
VWATAVAWH
fD9$Au
fE9$Fu
0A_A^A\_^
t$ WH
L$ E3
f94Bu
L$ E3
\$ E3
D$ E3
VWATAVAWH
A_A^A\_^
x AVH
WAVAWH
fD9<yu
 A_A^_
tsfD9
@SUVWAVH
A^_^][
UVWAVAWH
pQW:J
p(ZR-
@A_A^_^]
@SUVWAV
u?9D$0v
T$@E3
A^_^][
UVWATAUAVAWH
\Zu/<
T$<E3
un9D$0t
A_A^A]A\_^]
t$ UWAVH
t$ WH
|$ E3
TP00D
q0S6S
^z]?0
L$XH3
@USVWATAVAWH
A_A^A\_^[]
t$ WAVAWH
 A_A^_
x AVH
;\$xs!H
x AVH
;\$xs!H
x AVH
qQW:J
\Zu/<
q(ZR-
@SVWH
L$`H;
@USVWATAUAVAWH
T$@E3
|$0E3
|$0E3
D$(E3
xifD9e
A_A^A]A\_^[]
x AVH
8\$0t
@USVWATAUAVAWH
tHfE9
tKfD9
\$xE3
tHfD9
\$xE3
A_A^A]A\_^[]
UVWAVAWH
tBfE99t<L
A_A^_^]
L$ WH
VWATAVAWH
@A_A^A\_^
UVWATAUAVAWH
tDfE9(t>L
D8l$0u0H
T$PE3
A_A^A]A\_^]
SVWATAUAVAWH
PA_A^A]A\_^[
SVWAVH
HA^_^[
WAVAWH
 A_A^_
ATAVAWH
A_A^A\
L$ UVWATAUAVAWH
A_A^A]A\_^]
UVWATAUAVAWH
D8a:t
D8a:t
}HD8a9t
D8a8t
@A_A^A]A\_^]
UVWAVAWH
@A_A^_^]
UVWATAUAVAWH
D$H'g
A_A^A]A\_^]
SVWAVAWH
@A_A^_^[
t$ WAVAWH
D$8'g
A_A^_
D$pA;
D$0H;
\$(E3
UVWATAUAVAWH
A_A^A]A\_^]
ATAVAWH
CD!CT
CL!CX
A_A^A\
USVWAUAVAWH
D$8M+
]PH;]
PA_A^A]_^[]
K VWAVH
D$8'g
\$0H9
SVWATAUAVAWH
L$PI;
D$HI;
t$ E3
t$ E3
`A_A^A]A\_^[
L$8H3
@USVWAVH
A^_^[]
x AVH
VWAVH
L$@M;
xBL;L$@u;H
L$`I+
 A^_^
UATAUAVAWH
A_A^A]A\]
\$ E3
D$ E3
VWATAVAWH
@A_A^A\_^
h UAVAWH
A_A^]
@USVWAVH
0A^_^[]
D$HE3
\$ UVWAVAWH
`A_A^_^]
USVWATAUAVAWH
MOL+MOL
A_A^A]A\_^[]
L$PH+
H+\$P3
L$0E3
SVWATAUAVAWH
D$8'g
+T$hA
D$8'g
A_A^A]A\_^[
H UATAUAVAWH
I!4$H!0A
]pL;]P
xqL;]xukA
t?H;uHs9H
]pL;]P
0A_A^A]A\]
UWAUAVAWH
MPH9]
A_A^A]_]
SVWATAUAVAWH
\$|D;
B8<>t
A_A^A]A\_^[
{ AVH
D$0E3
fD94Au
t$ WH
VWAVH
 A^_^
L$XE3
|$@ t4
L$hH3
WAVAWH
A_A^_
x AVH
t$ WH
L$(E3
L$XE3
t$ WH
L$8E3
\$8I;
UVWATAUAVAWH
`A_A^A]A\_^]
USVWATAUAVAWH
hA_A^A]A\_^[]
t$ WAVAWH
H!s !s(I;
0A_A^_
L$ UVWATAUAVAWH
@A_A^A]A\_^]
L$HE3
t$ UWAWH
D$0E3
x AVD
t$ A^
t$ WH
D$@E3
D$ E3
t$ WATAUAVAWH
A_A^A]A\_
VWATAUAVH
@A^A]A\_^
L$hH3
UWAVH
t09.r#D
t$ WATAUAVAWH
^9=|V
A_A^A]A\_
x ATAVAWH
A_A^A\
x ATAUAVAWH
A_A^A]A\
p AWL
fD94z
4BD8\
4BD8\
4BD8\
4BD8\
x ATAUAVAWL
A_A^A]A\
x ATAUAVAWL
|$@fA
\$(A_A^A]A\
WATAUAVAWH
 }1Lc
 A_A^A]A\_
L$XH3
VWAVH
0A^_^
@USVWATAUAVAWH
A_A^A]A\_^[]
VWAVH
D$0E3
L$XH3
\$ UVWH
x`f;u
@SUVWH
L$HH3
X_^][
\$ UVWH
L$HH3
D$0E3
L$HH3
|$ UAVAWH
A_A^]
)D$ H
)D$@I
x AVH
)D$PI
\$ WH
VWATAVAWH
(!i H9i
D8>t:
rl;K$v
 A_A^A\_^
x AVH
@USVWH
rp;K$v
x AVH
k,H9k
D$PE3
D$(E3
L$XH3
x UATAUAVAWH
L$`fD
d$NfD
$!< u
|$R;v
L$NfA+
D$<9\$0t!iD$0
D$8Hi
D$89\$4t
kL$4<Hc
A_A^A]A\]
\$ WH
L$PH3
\$ UVWATAUAVAWH
T$0E3
T$0E3
L$hH3
pA_A^A]A\_^]
UVWATAUAVAWH
PA_A^A]A\_^]
{ AVH
L)D$ H
t$ WAVAWH
r&fD;
 A_A^_
\$ WH
L$0H3
t$ WATAUAVAWH
T$`E3
T$`E3
0A_A^A]A\_
WATAUAVAWH
0A_A^A]A\_
D$PE3
UAVAWH
A_A^]
t$ WAVAWH
L$HHc
 A_A^_
)D$`I
UAVAWH
A_A^]
UWATAVAWH
D$`f9
D$`f9
A_A^A\_]
f9\$PuSL
WATAUAVAWH
tvHcD;
(A;,$
 A_A^A]A\_
UWAUAVAWH
A_A^A]_]
x AWH
fD98u"fD9x
WAVAWH
@A_A^_
@USVWAWH
D$@fD
A__^[]
9L$0}
L$HE3
VAVAWH
H9D$0
D$x9D$0u%H
@A_A^^
t$ UWAVH
fD90t
t$ WH
L$8H3
q9Tz,
T$0E3
WAVAWH
\$`E3
 A_A^_
UWAWH
0A__]
UWAVH
D$@L+
D$@L+
D$@H+
x AVH
VWAVH
xMD8t$XtF
 A^_^
!D$HH
@SVWH
D$0E3
D$(0u
VWAVH
tvH9_
@A^_^
K H99t
UVWATAUAVAWH
L9l$@t
l$8E3
A_A^A]A\_^]
UVWAVAWH
@A_A^_^]
|$ UH
VWAVH
0A^_^
VWATAVAWH
|gLc0
9|$Pt
 A_A^A\_^
l$ VWATAVAWH
fE9$Au
0A_A^A\_^
VWATAVAWH
 A_A^A\_^
qkYR:
HcT$HH
@SUVWATAVAWH
A_A^A\_^][
H9i(uJH
t$ WH
9|$0t+H
HcT$@H
WAVAWH
 A_A^_
UVWAVAWH
A_A^_^]
9y uYL
fA9,Au
9yPuZH
t$ WAVAWH
D$49D$0usI
A_A^_
WAVAWH
 A_A^_
@SUVWATAVAWH
A_A^A\_^][
UVWATAUAVAWH
0A_A^A]A\_^]
9l$Pt
t$ WH
HcT$HH
x ATAVAWH
0A_A^A\
x ATAVAWH
PuzHc
PuCHc
 A_A^A\
UVWATAUAVAWH
 A_A^A]A\_^]
@USWH
T$ E3
UVWATAUAVAWH
D$ E3
fD9,Hu
fD9,ru
A_A^A]A\_^]
f9l$Pt
f9,Au
\$ UVWH
x AVH
VWAVH
 A^_^
t$ UWAVH
tpH!}(H
@A^_]
D8q`u
UVWAVAWH
PA_A^_^]
UVWATAUAVAWH
]oD9eo
A_A^A]A\_^]
T$0H9
UWATAVAWH
fD9$Wu
A_A^A\_]
p*SZp
t$ UWAVH
L$xE3
fE94Pu
L$PH;
fD94Ku
L$hE;
T$XA;
L$xfD
T$ E3
WATAUAVAWH
 A_A^A]A\_
UVWATAUAVAWH
 I;,$r
@A_A^A]A\_^]
qB]pu
L$8E3
L$`fI
WATAUAVAWH
0A_A^A]A\_
K8H91t
x AVH
t$ UWAVH
'9\$@H
UATAVH
A^A\]
x AVH
UATAUAVAWH
A_A^A]A\]
x AWH
UATAUAVAWH
A_A^A]A\]
UWAVH
UWAUAVAWH
A_A^A]_]
UWAWH
9U(smH
H;]Wr
x AWH
x AVH
UWATAVAWH
A_A^A\_]
WAVAWH
 A_A^_
t$ UWAVH
D9t$4u
fD9t$@t
xYfD9t$@tQ
fD9t$@t
@USVWATAVAWH
t:fD9&t4H
A_A^A\_^[]
VWAVH
0A^_^
D$XfD
@USVWAVH
D$09D$4t
A^_^[]
x AVH
@SUVWAV
f9,Au
A^_^][
fA9,Iu
fA9,Au
VWAVH
 A^_^
L$ WH
\$ UVWH
VWAVH
fE90t
@A^_^
x AVH
\$ UVW
VWATAVAWH
9|$`u
9|$`u
9|$`u
 A_A^A\_^
WATAWH
A_A\_
UWATAVAWH
0A_A^A\_]
UVWATAUAVAWH
A_A^A]A\_^]
VWAUAVAWH
A_A^A]_^
t$ AVH
l$ VWAVH
L$HL+
 A^_^
|$ AVH
D$8L+
x AVH
t"9|$Pr E
D$pE3
t$ WH
@USVWATAVAWH
A_A^A\_^[]
WAVAWH
t1A;.t13
@A_A^_
@USVWATAVAWH
A_A^A\_^[]
UWATAVAWH
fD9$Bu
fD9$Zu
A_A^A\_]
UVWATAUAVAWH
y3M9/t.A
E9,$v
A_A^A]A\_^]
UVWATAUAVAWH
D$@E3
|$PE3
l$ E3
l$8E3
A_A^A]A\_^]
UAVAWH
A_A^]
@SVWH
UVAVH
L$`E3
@A^^]
L$0E3
VWAVH
@A^_^
x AVH
t$`E3
t$(E3
WAVAWH
D$ E3
@A_A^_
D$ E3
l$@E3
9+vAH
f94Gu
|$@ uN3
L$hH3
x AVH
VWAVH
f9l$`u
0A^_^
@SUVWAVH
A^_^][
@USVWAVAWH
pIWx7
A_A^_^[]
UVWATAUAVAWH
 A_A^A]A\_^]
WAVAWH
 A_A^_
>w'tV
D$\D+
L$`H3
L$`H3
WATAUAVAWD
QZ^&A
A_A^A]A\_
qIWx7
x ATAVAWH
D$p3D$x
D$t3D$|
0A_A^A\
Ng0D+
`[@D+
i|,D+
`[@D+
D$@L+
UVWAVAWH
A_A^_^]
USVWATAUAVAWH
HA_A^A]A\_^[]
ATAVAWH
 A_A^A\
x AVH
x UATAUAVAWH
fD9$Au
D$ L+
D$ L+
A_A^A]A\]
x AVH
VWAVH
 A^_^
D$@L;
t$ UWATAVAWH
fE9 t
A_A^A\_]
x AVH
fD94xu
fD94Zu
H SUVWH
(_^][
x AVH
USER32.dll
ole32.dll
OLEAUT32.dll
CRYPT32.dll
SHELL32.dll
WININET.dll
urlmon.dll
) i3%
M,UDX
IEFRAME.dll
K.$msIso.dll
Dw=|:s
PROPSYS.dll
Feed Arbitration Shared Memory [ User : %s ]
Feed Arbitration Shared Memory Mutex [ User : %s ]
Software\Microsoft\Feeds
Current
Feed Eventing Shared Memory %s
Feed Eventing Shared Memory Mutex %s
MaxItemCount
feedplat
http://www.microsoft.com/schemas/rss/monitoring/2007
HtmlEscape
title
updated
published
author
mon:expiration
endtime
mon:X-UA-Compatible
**** Task Info ******
SyncStatus
BitsJobs
BitsQueue
description
image/url
language
copyright
skipDays
skipHours
lastBuildDate
pubDate
comments
atom:updated
length
EnclosureLocalFilename
EnclosureDownloadUrl
EnclosureDownloadMimeType
rss/channel
http://www.microsoft.com/schemas/rss/core/2005/internal
Not Downloaded
cfi:downloadstatus
In Progress
Downloaded
Error
Exception
ReturnNt
ReturnHr
LogNt
LogHr
FailFast
%hs(%u)\%hs!%p: 
%hs!%p: 
(caller: %p) 
%hs(%d) tid(%x) %08X %ws
Msg:[%ws] 
CallContext:[%hs] 
[%hs(%hs)]
[%hs]
kernelbase.dll
RaiseFailFastException
onecore\internal\sdk\inc\wil\opensource\wil\resource.h
WilError_03
ntdll.dll
RtlDllShutdownInProgress
RtlDisownModuleHeapAllocation
WilFailureNotifyWatchers
RtlAreLongPathsEnabled
\UNC\
\\?\UNC\
::$DATA
\\?\Volume
Local\SM0:%lu:%lu:%hs
{5588ACFD-6436-411B-A5CE-666AE6A92D3D}
{5588ACFD-6436-411B-A5CE-666AE6A92D3D}\WebSlices
Extension
entry-content
entry-title
property
feedurl
TITLE
hslice
CurrentVersion
Software\Microsoft\Windows Search
ierss://
%s{%s}/%s
%s{%s}/
iehistory://
SELECT 
 FROM SystemIndex..SCOPE() 
o:$~%
touch
non-touch
TouchType
Local\IEHistJournalFm_24c20119-753b-4f33-887d-f2381810562d_
Local\IEHistJournalMx_1699bb90-bebe-4437-b6e8-a6b7123fa38e_
HistoryJournalCertificate
HKCU\
MSIEHistoryJournal
about:home
about:Start
about:Tabs
about:blank
SelectionLanguage
SelectionNamespaces
XPath
LOCAL
UNDEFINED
-Rss2Normalizer.xsl
Rss1Normalizer.xsl
Atom03Normalizer.xsl
Atom1Normalizer.xsl
LogTraffic
Software\Microsoft\Internet Explorer\Feeds
NormalizeDateToIso8601
CombineUrls
CleanHtmlToPlainText
CleanHtmlToSafeHtml
CleanXhtmlToPlainText
CleanXhtmlToSafeXhtml
ValidateUrl
NormalizeUri
style
position:fixed
class
__feedview__
slc.dll
SLGetWindowsInformation
shell32-license-UseBingAsDefaultSearchProvider
Internet-Browser-License-LicensedPartnerID
zh-cn
!x-sys-default-locale
zh-CN
SLGetWindowsInformationDWORD
{8C3078A0-9AAB-4371-85D1-656CA8E46EE8}
EUPPSYNCLOCK
&pc=UE00
&OCID=
_EUPP_
EUPP_
bing.
%s_%s
{0633EE93-D776-472f-A0FF-E1416B8B2E3A}
https://api.bing.com/qsml.aspx?query={searchTerms}&market={language}&maxwidth={ie:maxWidth}&rowheight={ie:rowHeight}&sectionHeight={ie:sectionHeight}&FORM=IESS02
https://www.bing.com/favicon.ico
https://www.bing.com/search?q={searchTerms}&src=IE-SearchBox&FORM=IENTTR
https://www.bing.com/search?q={searchTerms}&src=IE-SearchBox&FORM=IENTSR
https://go.microsoft.com/fwlink/?LinkID=403856&language={language}&scale={scalelevel}&contrast={contrast}
https://api.bing.com/qsml.aspx?query={searchTerms}&market={language}&maxwidth={ie:maxWidth}&rowheight={ie:rowHeight}&sectionHeight={ie:sectionHeight}&FORM=IENTSS
https://www.bing.com/search?q={searchTerms}&src=IE-SearchBox&FORM=IESR02
{461B4783-36F5-45B9-883E-35BA5ED4A823}
https://www.haosou.com/s?src=win10&ie=utf-8&q={searchTerms}
https://www.sogou.com/tx?hdq=sogou-wsse-6abba5d8ab1f4f32&query={searchTerms}
{2562B2EF-500D-49FC-A350-5BC0D4C56EE3}
{64AF4D11-6492-4C25-B014-B6C6CEE3B0C5}
https://www.baidu.com/s?tn=80035161_2_dg&wd={searchTerms}
http://www.baidu.com/favicon.ico
https://suggest.yandex.ru/suggest-ff.cgi?srv=ie11&part={searchTerms}&clid=2233627
https://yandex.ru/search/?text={searchTerms}&clid=2233627
http://www.yandex.com/favicon.ico
AVRES000
FORM=IESR4N
FORM=IESR4A
FORM=IESR3N
FORM=IESR3A
FORM=IENAD1
FORM=IENAE1
FORM=IENAD2
FORM=IENAE2
FORM=IEMAD2
FORM=IEMAE2
FORM=IEMAD1
FORM=IEMAE1
FORM=IESS4A
FORM=IESR02
FORM=IESS3A
FORM=IESS4N
FORM=IENSE1
FORM=IESS3N
FORM=IENSE2
FORM=IENSD1
FORM=IEMSE2
FORM=IENSD2
FORM=IEMSE1
FORM=IEMSD2
FORM=IESS02
FORM=IEMSD1
FORM=IESR3S
FORM=IESR4S
FORM=IENDS2
FORM=IENDS1
FORM=IEMDS1
FORM=IEMDS2
FORM=IESS3S
FORM=IESS4S
FORM=IENSS2
FORM=IENSS1
FORM=IEMSS1
FORM=IEMSS2
bing.com
&pc=%s
msn.cn
about:newsfeed
msn.com
about:tabs
thumbprint
status
signvalue
publiccertificate
NOTFOUND
https://ieonline.microsoft.com/EUPP/v1/service?action=setfirstruncomplete&appid=Microsoft_IE_EUPP
IE Enhanced User Preference Protection
1.3.6.1.4.1.311.13.1
AcceptLanguage
Software\Microsoft\Internet Explorer\International
onecoreuap\inetcore\lib\tracelogging\legacydll.cpp
Windows.Devices.Input.TouchCapabilities
api-ms-win-core-winrt-string-l1-1-0.dll
WindowsDeleteString
WindowsCreateString
api-ms-win-core-winrt-l1-1-0.dll
RoGetActivationFactory
MSFEEDSSYNC.EXE
IEXPLORE.EXE
EXPLORER.EXE
SYSPREP.EXE
WWAHOST.EXE
LOADER42.EXE
TE.EXE
IEUTLAUNCH.EXE
FAKEVIRTUALSURFACETESTAPP.EXE
Te.ProcessHost.exe
NETPLWIZ.EXE
MSOOBE.EXE
MSHTMPAD.EXE
USERACCOUNTBROKER.EXE
RESTOREOPTIN.EXE
FirstLogonAnim.exe
DCIScanner
microsoftedgecp.exe
microsoftedge.exe
microsoftedgedevtools.exe
microsoftedgebchost.exe
microsoftedgesh.exe
browser_broker.exe
pickerhost.exe
authhost.exe
jshost.exe
{00000000-0000-0000-0000-000000000000}
WS not installed
WS not running
WS disabled
WS scopes not configured
WS PKEYs not registered
iwz$m
iwz$m
iwz$m
ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/
2r|Bj 
ZF^!W-JM
Z)4U1m
 !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`ABCDEFGHIJKLMNOPQRSTUVWXYZ{|}~
NormalizeDateToInetDate
ka-GE
kk-KZ
hy-AM
ru-RU
ro-MD
ky-KG
tg-Cyrl-TJ
tk-TM
uz-Cyrl-UZ
uz-Latn-UZ
tr-TR
be-BY
az-Cyrl-AZ
az-Latn-AZ
uk-UA
https://suggest.yandex.com.tr/suggest-ff.cgi?srv=ie11&uil=tr&part={searchTerms}&clid=2233630
https://suggest.yandex.kz/suggest-ff.cgi?srv=ie11&part={searchTerms}&clid=2233627
https://suggest.yandex.ua/suggest-ff.cgi?srv=ie11&part={searchTerms}&clid=2233627
https://suggest.yandex.by/suggest-ff.cgi?srv=ie11&part={searchTerms}&clid=2233627
https://yandex.ua/search/?text={searchTerms}&clid=2233627
https://yandex.com.tr/search/?text={searchTerms}&clid=2233630
https://yandex.by/search/?text={searchTerms}&clid=2233627
https://yandex.kz/search/?text={searchTerms}&clid=2233627
http://www.yandex.com.tr/favicon.ico
Yandex
{searchTerms
{count
{startIndex
{language
{startPage
UTF-8
{outputEncoding
{referrer:source
{inputEncoding
{ie:sectionheight
{ie:maxwidth
{ie:rowheight
@IEHomepageChanged
sessionID
userInputID
UTCReplace_AppSessionGuid
newPrimaryHomepage
oldHomepage
homepageChangeReason
EuppProtectionEvent
sessionID
userInputID
UTCReplace_AppSessionGuid
eventID
Microsoft.Windows.App.Browser
Feed Arbitration Lock Event [ Process : 0x%08x ]
Feed Arbitration Unlock Event [ Process : 0x%08x ]
Feed Arbitration Unlock Event [ Write Request : %s ]
Feed Arbitration Validity Mutex [ Write Request : %s ]
%s\%s
*.feed-ms
forcesync
msfeedssync.exe
Microsoft_RssPlatform_*
FeedMinInterval
M,UD~
%s:%s
RssPlatformCred
Microsoft_RssPlatform_%s
MaxFeedSize
https://ieonlinews.microsoft.com/
<!DOCTYPE
If-Modified-Since
If-None-Match
Accept-Language
Device-Touch-Type
Device-Manufacturer
Device-Model
Content-Type
Last-Modified
/rss/channel/cf:noMoreUpdates
X-UA-Compatible
/rss/channel
/rss/channel/*[local-name() = 'expiration' and namespace-uri() = 'http://www.microsoft.com/schemas/rss/monitoring/2007']
/rss/channel/*[local-name() = 'X-UA-Compatible' and namespace-uri() = 'http://www.microsoft.com/schemas/rss/monitoring/2007']
@Qm6t
RSS Eventing Connection Database Mutex %08x
RSS Eventing Event Event %08x
BackgroundSync
DefaultInterval
feedplat:
u\m%C
http://www.w3.org/2005/Atom
http://purl.org/rss/1.0/modules/syndication/
<BASE HREF="
<STYLE>
}</STYLE>
mon:descriptionStyles
version="1.0" encoding="UTF-8"
alternate
entry
entry-content
content
entry-summary
summary
vcard
email
bookmark
atom:link
category
scheme
hourly
daily
weekly
monthly
yearly
sy:updatePeriod
sy:updateFrequency
IE=%u
charset
binary/octet-stream
text/html
Set-Cookie
IE 11.0
Windows-RSS-Platform/%s (%s; Windows NT %d.%d)
User-Agent
Cookie
Current Time: 
Save Next To Sync: 
Next Download Time: 
Last Run Time: 
MinScheduleInterval
Next Scheduled Time: 
Modified Feed: 
Next To Sync Feed: 
Next To Sync Time: 
Modified Time: 
guidFeed: 
ftLastDownloadTime: 
Compare Time: 
Save Last Run Time: 
DownloadThreadCount
System_Feed_Scheduler_Mutex
msfeeds.txt
**** Schedule Cache ******
>>> entry %d >>>
guidFeed: %s
APIPath: %s
fss: %u
uiInterval: %u
uiTTL: %u
ftLastDownloadTime: %d/%d/%d %d:%d:%d:%d
uiLastErrorInterval: %u
fDownloaded: %u
<<<<<<
Feeds Schedules Rebuild Required
fDownloaded
uiInterval
ftLastDownloadTime
uiLastErrorInterval
SyncSetting
uiTTL
Schedule
FeedDataCache
item[string(.)='%s']
LastRunTime
NextToSync
Feeds Store Mutex %s
Local\Feeds Store Mutex LoRIE
item[@id='%d' and string(.)='%s']
ItemCounts
Count
UnreadCount
BackgroundTaskScheduler
MaxItemCharacterCount
cf:treatAs
enclosure
ItemData
cfi:id
cfi:effectiveId
false
cfi:read
cfi:downloadurl
cfi:lastdownloadtime
cfi:path
cfi:lastdownloaderror
Failed
Invalid Feed Format
Normalization Failed
Persistance Failed
Download Blocked
Canceled
Unsupported Auth
Background Download Disabled
Not Exist
Unsupported MSXML
Unsupported DTD
Size Limit Exceeded
Access Denied
Auth Failed
Auth Denied
ItemData/item
Item Data
Local\MsFeeds_IEORC_d8863854-886e-4a8e-b2e5-e580ab17661c
.feed-ms
FeedsStore.feedsdb-ms
Feeds Cache
~t.d:c"q?m*s/f<l>g|p
MIME\Database\Content Type\
MIME\Database\Content Type\%s
shortcut icon
about:blank
%ProgramFiles%\Internet Explorer\ie9props.propdesc
WSearch
file:///%s
SystemIndex
Microsoft.IE.TargetUrl
Microsoft.IE.TargetUrlHostName
Microsoft.IE.TargetUrlPath
Microsoft.IE.VisitCount
Microsoft.IE.SelectionCount
Microsoft.IE.Title
Microsoft.IE.FeedItemLocalId
%04lu/%02lu/%02lu %02lu:%02lu:%02lu
(System.EndDate < '%s')
%s{%s}/%s?0%ld
?0%ld
file:%s
http://
https://
file:
ftp://
System.Link.TargetUrlHostName
System.Link.TargetUrlPath
System.Link.TargetUrl
System.History.TargetUrlHostName
System.Link.TargetParsingPath
System.Title
System.History.VisitCount
System.History.SelectionCount
System.Link.DateVisited
System.Search.Rank
System.RecordedTV.ProgramDescription
System.ItemPathDisplay
System.ItemUrl
System.Media.UserWebUrl
System.OriginalFileName
System.Contact.WebPage
System.AcquisitionID
System.RecordedTV.ChannelNumber
System.ContentStatus
System.SourceItem
System.Category
System.ContentType
System.ItemNameDisplay
System.Subject
System.ItemFolderPathDisplay
System.FileName
System.Author
System.ItemFolderNameDisplay
System.Document.WordCount
System.Document.PageCount
System.Link.FeedItemLocalId
System.DateModified
System.DateCreated
Application=Windows
SELECT TOP %u 
(CONTAINS(
RANK BY COERCION(Absolute, %u)) 
 AND 
) RANK BY COERCION(ABSOLUTE,1)
 OR (
 SCOPE='%s://{%s}/' 
 SCOPE='%s' 
 WHERE 
 ORDER BY 
 ASC 
 DESC 
 ORDER BY System.Search.Rank DESC
Dw=c:s
Dw=]:s
Dw=y:s
Dw=|:s
("%s" = '%s')
iehistory
ierss
Manufacturer/Model
ROOT\CIMV2
SELECT Manufacturer, Model FROM Win32_ComputerSystem
Manufacturer
Model
Local\IEHistJournalGlobal_3bf1c317-e96b-46f6-ba88-50c001d497aa
FileVersion
SuggestedSites.dat
SHA256
1.3.6.1.4.1.311.76.12.1
[)Pyk5I
j`https://
Microsoft Enhanced RSA and AES Cryptographic Provider
v&=tM
|ma[_
TL%0%I
^{xn1
"}U2:
ProhibitDTD
AllowDocumentFunction
xmlns:cf='http://www.microsoft.com/schemas/rss/core/2005' xmlns:cfi='http://www.microsoft.com/schemas/rss/core/2005/internal' xmlns:atom='http://www.w3.org/2005/Atom'
FILETIME_remainder
Control Panel\International\Calendars\TwoDigitYearMax
urn:microsoft:feed-normalization
downloadUrl
xmlns:xsl='http://www.w3.org/1999/XSL/Transform'
//xsl:import[@href='res://msfeeds.dll/SharedNormalizer.xsl']
SharedNormalizer.xsl
*[local-name(.)='rss' and namespace-uri(.)='']/@version[number(.)=2.0]
*[local-name(.)='rss' and namespace-uri(.)='']/@version[number(.)=0.91]
*[local-name(.)='rss' and namespace-uri(.)='']/@version[number(.)=0.92]
*[local-name(.)='feed' and namespace-uri(.)='http://purl.org/atom/ns#']/@version[number(.)=0.3]
*[local-name(.)='feed' and namespace-uri(.)='http://www.w3.org/2005/Atom']
*[local-name(.)='RDF' and namespace-uri(.)='http://www.w3.org/1999/02/22-rdf-syntax-ns#']/*[local-name(.)='channel' and namespace-uri(.)='http://purl.org/rss/1.0/']
-%04d%02d%02d%02d%02d%02d
-Slice
-Norm
http://www.w3.org/1999/xhtml
&quot;
#document-fragment
&amp;
http://hao.360.cn/?src=lm&ls=n55dfe5b796
http://hao.qq.com/?unc=Af31022
http://go.microsoft.com/fwlink/?LinkId=625119
%s&clocalename=%s
http://go.microsoft.com/fwlink/?LinkId=625115
Software\Microsoft\Internet Explorer\SearchScopes
{5312EE61-79E3-4A24-BFE1-132B85B23C3A}
SOFTWARE\Microsoft\Cryptography
MachineGuid
&pc=WCUG
&pc=EPSPC
&pc=UE04
about:home
%.*s%s%s=%s%.*s
IE-Address
IE-SearchBox
MIE-Address
IE-ContextMenu
MIE-SearchBox
MIE-ContextMenu
Missing
http://go.microsoft.com/fwlink/?LinkId=392206
<request/>
product
Internet Explorer
trademark
Microsoft
euppid
hashvalue
<?xml version="1.0" encoding="utf-8"?>
source
IE_EUPP
Content-Type: text/xml; charset=utf-8
&mac=
&clientkey=
https://ieonline.microsoft.com/EUPP/v1/service?action=needfirstrun&appid=Microsoft_IE_EUPP
https://ieonline.microsoft.com/EUPP/v1/service?action=downloadcert&appid=Microsoft_IE_EUPP
https://ieonline.microsoft.com/EUPP/v1/service?action=signvalue&appid=Microsoft_IE_EUPP
Trust
%%%02x
ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/{
SUB_PRD}
shell:%s
{SUB_OS}
{SUB_PVER}
{SUB_OLCID}
{SUB_OVER}
{SUB_CLSID}
{SUB_CLCID}
{SUB_RFC1766}
%#04lx
gY?&%:E
ServicesActive
\StringFileInfo\%04X%04X\%s
\VarFileInfo\Translation
\StringFileInfo\040904E4\%s
\StringFileInfo\040904B0\%s
\StringFileInfo\04090000\%s
?RSDS
msfeeds.pdb
.text
.text$di
.text$lp00msfeeds.dll!20_pri7
.text$mn
.text$mn$00
.text$np
.text$x
.text$yd
.text$zz
.rdata$brc
.rdata$00$brc
.rdata$T$brc
.rdata$zz$brc
.idata$5
.00cfg
.CRT$XCA
.CRT$XCU
.CRT$XCZ
.CRT$XIA
.CRT$XIAA
.CRT$XIZ
.CRT$XLA
.CRT$XLZ
.gehcont
.gfids
.giats
.rdata
.rdata$00
.rdata$voltmd
.rdata$zETW0
.rdata$zETW1
.rdata$zETW2
.rdata$zETW9
.rdata$zz
.rdata$zzzdbg
.tls$
.tls$ZZZ
.xdata
.didat$2
.didat$3
.didat$4
.didat$6
.didat$7
.edata
.idata$2
.idata$3
.idata$4
.idata$6
.data$00$brc
.data$dk00$brc
.data
.data$00
.data$dk00
.data$pr00
.data$zz
.bss$00
.bss$dk00
.bss$pr00
.bss$zz
.pdata
.didat$5
.rsrc$01
.rsrc$02
TranslateMessage
PeekMessageW
DispatchMessageW
MsgWaitForMultipleObjects
StringFromGUID2
CoTaskMemFree
StgOpenStorageEx
StgCreateStorageEx
PropVariantClear
CoTaskMemAlloc
CoCreateInstance
CoUninitialize
CoInitializeEx
CLSIDFromString
CoCreateGuid
CryptUnprotectData
CryptProtectData
SHGetInstanceExplorer
ShellExecuteW
SHGetFolderPathW
FindFirstUrlCacheContainerW
CreateUrlCacheContainerW
InternetQueryOptionW
FindNextUrlCacheContainerW
FindCloseUrlCache
CoInternetCombineUrlEx
CreateAsyncBindCtx
CreateURLMonikerEx
CoInternetCreateSecurityManager
URLDownloadToCacheFileW
IESetProtectedModeCookie
IEGetProtectedModeCookie
SendMessageTimeoutW
CharNextW
LoadStringW
CryptHashCertificate2
CertOpenStore
CertEnumCertificatesInStore
CertCloseStore
CertGetCertificateContextProperty
CertGetCertificateChain
CertVerifyCertificateChainPolicy
CertFreeCertificateChain
CertGetIntendedKeyUsage
CertGetEnhancedKeyUsage
CertFreeCertificateContext
CryptStringToBinaryA
CertDeleteCertificateFromStore
CertCreateCertificateContext
CertAddCertificateContextToStore
CryptImportPublicKeyInfo
CryptBinaryToStringA
CryptStringToBinaryW
CertGetNameStringW
CertFindCertificateInStore
CryptHashCertificate
SHCreateDirectoryExW
CommitUrlCacheEntryW
CreateUrlCacheEntryW
FindFirstUrlCacheEntryW
GetUrlCacheEntryInfoW
FindNextUrlCacheEntryW
DeleteUrlCacheEntryW
InternetCrackUrlW
InternetTimeFromSystemTimeW
InternetCanonicalizeUrlW
InternetOpenW
InternetConnectW
HttpOpenRequestW
InternetCloseHandle
HttpSendRequestW
HttpQueryInfoW
InternetReadFile
CoInternetIsFeatureEnabled
CoInternetCombineUrl
CoInternetCombineIUri
PSGetPropertyKeyFromName
PSRegisterPropertySchema
PSCreateMemoryPropertyStore
msfeeds.dll
DllCanUnloadNow
DllGetClassObject
MsfeedsCreateInstance
_vsnwprintf
memcpy_s
__C_specific_handler
srand
_itow_s
_ultow_s
wcspbrk
iswalpha
wcschr
wcsncmp
_XcptFilter
_amsg_exit
malloc
_initterm
msvcrt.dll
_lock
_unlock
__dllonexit
_onexit
RtlCaptureContext
RtlLookupFunctionEntry
RtlVirtualUnwind
ntdll.dll
ReadFile
CreateEventExW
EnterCriticalSection
GetCurrentProcess
RegisterWaitForSingleObject
InitializeCriticalSectionAndSpinCount
LeaveCriticalSection
SetFilePointer
WaitForSingleObject
CreateFileW
OpenEventW
ReleaseMutex
UnmapViewOfFile
DuplicateHandle
CreateEventW
GetLastError
SetEvent
CloseHandle
CreateMutexExW
UnregisterWaitEx
DeleteCriticalSection
GetCurrentProcessId
CreateFileMappingW
MapViewOfFile
OpenMutexW
OpenProcess
MultiByteToWideChar
SystemTimeToTzSpecificLocalTime
CreateDirectoryW
CompareFileTime
FindFirstFileW
FindNextFileW
RemoveDirectoryW
FindClose
GetFileAttributesW
SetFileAttributesW
DeleteFileW
MoveFileExW
SystemTimeToFileTime
GetSystemTimeAsFileTime
GetSystemTime
FileTimeToSystemTime
LocalAlloc
LocalFree
HeapFree
DisableThreadLibraryCalls
HeapAlloc
GetProcessHeap
OpenFileMappingW
ResetEvent
GetModuleFileNameW
GlobalAlloc
GlobalFree
GlobalLock
LocalReAlloc
GlobalUnlock
GetVersionExW
WriteFile
WaitForMultipleObjects
CreateMutexW
Sleep
CreateThread
FileTimeToLocalFileTime
QueryPerformanceFrequency
GetFileSize
WideCharToMultiByte
QueryPerformanceCounter
GetModuleFileNameA
CreateSemaphoreExW
SetLastError
ReleaseSemaphore
GetModuleHandleExW
GetCurrentThreadId
FormatMessageW
OutputDebugStringW
WaitForSingleObjectEx
OpenSemaphoreW
GetProcAddress
GetModuleHandleW
DebugBreak
IsDebuggerPresent
UnhandledExceptionFilter
SetUnhandledExceptionFilter
TerminateProcess
ReleaseSRWLockExclusive
AcquireSRWLockExclusive
WakeAllConditionVariable
SleepConditionVariableSRW
GetTickCount
RaiseFailFastException
RaiseException
KERNEL32.dll
StrCmpIW
StrCmpW
PathFindFileNameW
SHStrDupW
PathFileExistsW
ChrCmpIW
StrStrIW
StrCmpNIW
StrChrW
SHRegGetValueW
StrToInt64ExW
StrRChrW
SHCreateStreamOnFileW
StrTrimW
HashData
SHLWAPI.dll
RpcServerInqCallAttributesW
RPCRT4.dll
CreateUri
CreateUriWithFragment
CreateIUriBuilder
iertutil.dll
TraceEvent
TraceMessage
CredDeleteW
CredFree
CredEnumerateW
CredReadW
CredWriteW
EventUnregister
UnregisterTraceGuids
RegisterTraceGuidsW
GetTraceEnableLevel
GetTraceEnableFlags
GetTraceLoggerHandle
EventSetInformation
EventRegister
RegSetValueExW
RegCreateKeyExW
RegCloseKey
RegGetValueW
RegOpenKeyExW
ConvertSidToStringSidW
OpenProcessToken
GetTokenInformation
EventWriteTransfer
EventWriteEx
CryptAcquireContextW
CryptGenRandom
CryptReleaseContext
CryptEncrypt
CryptGetKeyParam
CryptCreateHash
CryptHashData
CryptDeriveKey
CryptDestroyHash
CryptDestroyKey
CryptSetHashParam
CryptGetHashParam
CryptSetKeyParam
RegOpenKeyExA
RegQueryValueExA
ADVAPI32.dll
MLANG.dll
PathRemoveExtensionW
PathIsPrefixW
PathFindExtensionW
api-ms-win-core-shlwapi-legacy-l1-1-0.dll
NetGetJoinInformation
wkscli.dll
NetApiBufferFree
netutils.dll
CoWaitForMultipleHandles
CoSetProxyBlanket
PropVariantCopy
api-ms-win-core-com-l1-1-0.dll
TelIsTelemetryTypeAllowed
DiagnosticDataSettings.dll
lstrlenW
lstrlenA
StrToIntA
lstrcmpiA
GetUserDefaultLocaleName
GetSystemDefaultLocaleName
OpenGlobalizationUserSettingsKey
KERNELBASE.dll
_wcsicmp
_vsnprintf
wcstok_s
_wtoi
_wcsnicmp
_vsnwprintf_s
wcsncpy_s
wcsnlen
strnlen
isalnum
rand_s
sprintf_s
NtClose
CompareStringW
SetFileTime
GetFileSizeEx
GetFullPathNameW
LCMapStringW
SetEndOfFile
FlushFileBuffers
GetFileTime
FlushViewOfFile
GetTimeZoneInformation
GetDiskFreeSpaceExW
InitializeCriticalSection
QueueUserWorkItem
IsDBCSLeadByteEx
GetStringTypeExA
IsDBCSLeadByte
GetTempPathW
GetLocalTime
GetProductInfo
GetUserPreferredUILanguages
GetSystemInfo
LoadLibraryW
FreeLibrary
LocaleNameToLCID
GetSystemDefaultLCID
GetUserDefaultLCID
ResolveDelayLoadedAPI
DelayLoadFailureHook
SHGetValueW
StrStrW
PathIsNetworkPathW
SHCreateStreamOnFileEx
StrToIntExW
StrCmpNW
StrCmpNIA
StrStrNIW
UrlEscapeW
UrlUnescapeW
StrCmpNA
PathIsURLW
UrlCanonicalizeW
UrlCreateFromPathW
UrlApplySchemeW
UuidCreateSequential
UuidEqual
CryptVerifySignatureW
OpenSCManagerW
OpenServiceW
CloseServiceHandle
QueryServiceConfigW
GetFileVersionInfoSizeExW
GetFileVersionInfoExW
VerQueryValueW
api-ms-win-downlevel-version-l1-1-0.dll
VerSetConditionMask
FindResourceExW
SizeofResource
LoadResource
LockResource
VerifyVersionInfoW
GetVersionExA
InitOnceExecuteOnce
GetCurrentDirectoryW
memcmp
memcpy
memmove
memset
wcscmp
oeY<9
[_9*O
SHAREDNORMALIZER.XSL
RSS2NORMALIZER.XSL
RSS1NORMALIZER.XSL
ATOM03NORMALIZER.XSL
ATOM1NORMALIZER.XSL
TYPELIB
VS_VERSION_INFO
StringFileInfo
040904B0
CompanyName
Microsoft Corporation
FileDescription
Microsoft Feeds Manager
FileVersion
11.00.22621.1 (WinBuild.160101.0800)
InternalName
msfeeds
LegalCopyright
 Microsoft Corporation. All rights reserved.
OriginalFilename
msfeeds.dll
ProductName
Internet Explorer
ProductVersion
11.00.22621.1
OleSelfRegister
VarFileInfo
Translation
<?xml version="1.0"?>
<xsl:stylesheet version="1.0"
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:atom="http://www.w3.org/2005/Atom"
    xmlns:cf="http://www.microsoft.com/schemas/rss/core/2005" 
    xmlns:msfeednorm="urn:microsoft:feed-normalization"
    exclude-result-prefixes="msfeednorm"
    >
<!-- IMPORTANT: This shared XSL gets imported using our code by copying all the xsl:stylesheet's children, 
so all of the above namespace declarations must be present in each other XSL where this is imported into. -->
<!-- Download URL is inserted from the normalization code -->
  <xsl:param name="downloadUrl" />
<!-- 
Namespaces commonly used in RSS feeds 
<xsl:variable name="_NSatom1" select="'http://www.w3.org/2005/Atom'" />
<xsl:variable name="_NSatom03" select="'http://purl.org/atom/ns#'" />
<xsl:variable name="_NSsy" select="'http://purl.org/rss/1.0/modules/syndication/'" />
<xsl:variable name="_NScontent" select="'http://purl.org/rss/1.0/modules/content/'" />
<xsl:variable name="_NSrdf" select="'http://www.w3.org/1999/02/22-rdf-syntax-ns#'" />
<xsl:variable name="_NSrss" select="'http://purl.org/rss/1.0/'" />
<xsl:variable name="_NSdc" select="'http://purl.org/dc/elements/1.1/'" />
<xsl:variable name="_NSdcterms" select="'http://purl.org/dc/terms/'" />
<xsl:variable name="_NSslash" select="'http://purl.org/rss/1.0/modules/slash/'" />
<xsl:variable name="_NSwfw" select="'http://wellformedweb.org/CommentAPI/'" />
<xsl:variable name="_NScf" select="'http://www.microsoft.com/schemas/rss/core/2005'" />
<xsl:variable name="_NScfi" select="'http://www.microsoft.com/schemas/rss/core/2005/internal'" />
<xsl:variable name="_NSxhtml" select="'http://www.w3.org/1999/xhtml'" />
<xsl:variable name="_NSmon" select="'http://www.microsoft.com/schemas/rss/monitoring/2007'" />
Conversion and utility/helper templates
<!-- Find if current node is a first one of its kind; returns strings 'true' when first or 'false' when not -->
<xsl:template name="_IsFirstChildOfItsKind">
  <xsl:param name="value" />
  <xsl:variable name="_nameSpace" select="namespace-uri($value)" />
  <xsl:variable name="_localName" select="local-name($value)" />
  <xsl:variable name="_currentId" select="generate-id($value)"/>
  <xsl:variable name="_firstId" select="generate-id($value/../*[namespace-uri(.) = $_nameSpace and local-name(.) = $_localName])"/>
  <xsl:choose>
    <xsl:when test="$_currentId = $_firstId">
      <xsl:value-of select="'true'" />
    </xsl:when>
    <xsl:otherwise>
      <xsl:value-of select="'false'" />
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>
<!-- Convert updateFrequency and updatePeriod to ttl -->
  <xsl:template name="_ConvertUpdatesToTtl">
    <xsl:param name="updateFrequency" />
    <xsl:param name="updatePeriod" />
    <xsl:variable name="_updateFrequencyNum" select="number($updateFrequency)"/>
    <xsl:variable name="_updatePeriodTmp">
      <xsl:choose>
        <xsl:when test="$updatePeriod = 'hourly'">60</xsl:when>
        <xsl:when test="$updatePeriod = 'daily'">1440</xsl:when>
        <xsl:when test="$updatePeriod = 'weekly'">10080</xsl:when>
        <xsl:when test="$updatePeriod = 'monthly'">40320</xsl:when>
        <xsl:when test="$updatePeriod = 'yearly'">483840</xsl:when>
        <xsl:otherwise>-1</xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="_updatePeriodNum" select="number($_updatePeriodTmp)" />
    <xsl:if test="$_updateFrequencyNum > 0 and $_updatePeriodNum > 0">
      <ttl>
        <xsl:value-of select="$_updatePeriodNum div $_updateFrequencyNum" />
      </ttl>
    </xsl:if>
  </xsl:template>
<!-- Convert author strings to Atom format (very simple implementation) -->
  <!-- NOTE: Assumes that value has been properly scrubbed and only needs to be parsed -->
  <xsl:template name="_ConvertAuthorToAtomAuthor">
    <xsl:param name="value" />
    <xsl:if test="string($value)">
      <atom:author>
        <xsl:choose>
          <!-- No email -->
          <xsl:when test="contains($value, '@') = false">
            <atom:name><xsl:value-of select="$value" /></atom:name>
          </xsl:when>
          <!-- Name and email -->
          <xsl:when test="contains($value, '(') and contains($value, ')')">
            <xsl:variable name="_BeforeOpenParen" select="substring-before($value, '(')" />
            <xsl:variable name="_AfterCloseParen" select="substring-after($value, ')')" />
            <xsl:variable name="_WithinParens" select="substring-after(substring-before($value, ')'), '(')" />
            <xsl:choose>
              <!-- Simple check for some possible weird cases -->
              <xsl:when test="contains($_BeforeOpenParen, ')') or contains($_AfterCloseParen, '(') or contains($_WithinParens, '(')">
                <atom:name><xsl:value-of select="$value" /></atom:name>
              </xsl:when>
              <!-- Email within parens -->
              <xsl:when test="contains($_WithinParens, '@')">
                <atom:name><xsl:value-of select="concat($_BeforeOpenParen, $_AfterCloseParen)" /></atom:name>
                <atom:email><xsl:value-of select="$_WithinParens" /></atom:email>
              </xsl:when>
              <!-- Name within parens -->
              <xsl:otherwise>
                <atom:name><xsl:value-of select="$_WithinParens" /></atom:name>
                <xsl:choose>
                  <!-- Email before parens -->
                  <xsl:when test="contains($_BeforeOpenParen, '@')">
                    <atom:email><xsl:value-of select="$_BeforeOpenParen" /></atom:email>
                  </xsl:when>
                  <!-- Email after parens -->
                  <xsl:otherwise>
                    <atom:email><xsl:value-of select="$_AfterCloseParen" /></atom:email>
                  </xsl:otherwise>
                </xsl:choose>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:when>
          <!-- Only email -->
          <xsl:otherwise>
            <atom:email><xsl:value-of select="$value" /></atom:email>
          </xsl:otherwise>
        </xsl:choose>
      </atom:author>
    </xsl:if>
  </xsl:template>
<!-- Convert Atom author strings to RSS 2.0 format with email and name -->
  <xsl:template name="_ConvertAtomAuthorToAuthor">
    <xsl:param name="name" />
    <xsl:param name="email" />
    <xsl:choose>
      <xsl:when test="string($name) and string($email)"><xsl:value-of select="concat($email, ' (', $name, ')')" /></xsl:when>
      <xsl:when test="string($email)"><xsl:value-of select="string($email)" /></xsl:when>
      <xsl:otherwise><xsl:value-of select="string($name)" /></xsl:otherwise>
    </xsl:choose>
  </xsl:template>
<!-- Map type values to Atom 1.0 type -->
<!-- Note that our sanitization code can parse but cannot output XHTML, so xhtml gets converted to html -->
  <xsl:template name="_NormalizeAtomTextTypeAttr">
    <xsl:param name="value" />
    <xsl:choose>
      <xsl:when test="not(string($value)) or normalize-space($value) = ''"><xsl:attribute name="type">text</xsl:attribute></xsl:when>
      <xsl:when test="$value = 'text/plain' or $value = 'text'"><xsl:attribute name="type">text</xsl:attribute></xsl:when>
      <xsl:when test="$value = 'text/html' or $value = 'html'"><xsl:attribute name="type">html</xsl:attribute></xsl:when>
      <xsl:when test="$value = 'application/xhtml+xml' or $value = 'xhtml'"><xsl:attribute name="type">html</xsl:attribute></xsl:when>
    </xsl:choose>
  </xsl:template>
<!-- Validate bool -->
  <xsl:template name="_ValidateBool">
    <xsl:param name="value" />
    <xsl:choose>
      <xsl:when test="normalize-space($value) = 'true'">true</xsl:when>
      <xsl:when test="normalize-space($value) = 'false'">false</xsl:when>
    </xsl:choose>
  </xsl:template>
<!-- Build a list of nodes that are referenced from the cf:sort or cf:group -->
  <xsl:template name="_BuildCfReferenceList">
    <xsl:param name="value" />
    <!-- We format the node references as "'namespace-uri':local-name;" -->
    <xsl:for-each select="$value/cf:listinfo/cf:sort">
      <xsl:choose>
        <xsl:when test="@element">'<xsl:value-of select="@ns"/>':<xsl:value-of select="@element" />;</xsl:when>
        <xsl:otherwise>'<xsl:value-of select="@ns"/>':<xsl:value-of select="@label" />;</xsl:otherwise>
      </xsl:choose>
    </xsl:for-each>
    <xsl:for-each select="$value/cf:listinfo/cf:group">
      <xsl:choose>
        <xsl:when test="@element">'<xsl:value-of select="@ns"/>':<xsl:value-of select="@element" />;</xsl:when>
        <xsl:otherwise>'<xsl:value-of select="@ns"/>':<xsl:value-of select="@label" />;</xsl:otherwise>
      </xsl:choose>
    </xsl:for-each>
  </xsl:template>
<!-- Ensure XHTML is the default namespace; needs to run prior to sanitization; exact preserving of namespace prefixes
is not important because sanitization will drop all the unknown elements anyway -->
  <xsl:template name="_NormalizeXhtmlNamespacePrefix">
    <xsl:param name="value" />
    <xsl:for-each select="$value">
      <xsl:choose>
        <xsl:when test="self::text() or self::comment() or self::processing-instruction()">
          <xsl:copy />
        </xsl:when>
        <!-- xhtml is default namespace: just copy and process children -->
        <xsl:when test="namespace-uri(.) = $_NSxhtml and not(contains(name(.), ':'))">
          <xsl:copy>
            <xsl:for-each select="@*"><xsl:copy /></xsl:for-each>
            <xsl:call-template name="_NormalizeXhtmlNamespacePrefix">
              <xsl:with-param name="value" select="*|text()" />
            </xsl:call-template>
          </xsl:copy>
        </xsl:when>
        <xsl:otherwise>
          <xsl:choose>
            <!-- xhtml element in non-default namespace: fix namespace and process children -->
            <xsl:when test="namespace-uri(.) = $_NSxhtml">
              <xsl:element name="{local-name(.)}" namespace="{$_NSxhtml}">
                <xsl:for-each select="@*"><xsl:copy /></xsl:for-each>
                <xsl:call-template name="_NormalizeXhtmlNamespacePrefix">
                  <xsl:with-param name="value" select="*|text()" />
                </xsl:call-template>
              </xsl:element>
            </xsl:when>
            <!-- non-xhtml element in default namespace: fix namespace and process children -->
            <xsl:otherwise>
              <xsl:element name="{concat('x:', local-name(.))}" namespace="{namespace-uri(.)}">
                <xsl:for-each select="@*"><xsl:copy /></xsl:for-each>
                <xsl:call-template name="_NormalizeXhtmlNamespacePrefix">
                  <xsl:with-param name="value" select="*|text()" />
                </xsl:call-template>
              </xsl:element>
            </xsl:otherwise>
          </xsl:choose>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:for-each>
  </xsl:template>
<!-- Combine base and relative URLs -->
  <xsl:template name="_CombineUrls">
    <xsl:param name="baseUrl" />
    <xsl:param name="relUrl" />
    <xsl:choose>
      <xsl:when test="string($baseUrl)">
        <xsl:value-of select="msfeednorm:CombineUrls(string($baseUrl), string($relUrl))"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="string($relUrl)"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>
<!-- Check for URL and combine it with base (complete the URL) -->
  <xsl:template name="_CompleteUrl">
    <xsl:param name="Url" />
    <xsl:param name="baseUrl" />
    <xsl:if test="string($Url)">
      <xsl:value-of select="msfeednorm:CombineUrls(string($baseUrl), string($Url))"/>
    </xsl:if>
  </xsl:template>
<!-- Complete URL in order: baseUrl1 + baseUrl2 + Url -->
  <xsl:template name="_CompleteUrlTwoBase">
    <xsl:param name="Url" />
    <xsl:param name="baseUrl1" />
    <xsl:param name="baseUrl2" />
    <xsl:variable name="combinedBase">
      <xsl:call-template name="_CombineUrls">
        <xsl:with-param name="baseUrl" select="$baseUrl1" />
        <xsl:with-param name="relUrl" select="$baseUrl2" />
      </xsl:call-template>
    </xsl:variable>
    <xsl:call-template name="_CompleteUrl">
      <xsl:with-param name="Url" select="$Url" />
      <xsl:with-param name="baseUrl" select="$combinedBase" />
    </xsl:call-template>
  </xsl:template>
<!-- Figure out the base URL for the feed -->
  <xsl:template name="_GetFeedBaseUrl">
    <xsl:param name="downloadUrl" />
    <xsl:param name="rootNode" />
    <xsl:choose>
      <xsl:when test="string($rootNode/@xml:base)">
        <xsl:call-template name="_CombineUrls">
          <xsl:with-param name="baseUrl" select="$downloadUrl" />
          <xsl:with-param name="relUrl" select="$rootNode/@xml:base" />
        </xsl:call-template>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="string($downloadUrl)" />
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>
Sanitization and validation templates
<!-- Invoke sanitization and/or transformation based on the from and to types -->
  <xsl:template name="_CleanByType">
    <xsl:param name="value" />
    <xsl:param name="fromType" />
    <xsl:param name="toType" />
    <xsl:param name="baseUrl" />
    <xsl:variable name="fromTypeN" select="normalize-space($fromType)" />
    <xsl:variable name="toTypeN" select="normalize-space($toType)" />
    <xsl:choose>
      <xsl:when test="not(string($fromTypeN)) or $fromTypeN = 'text' or $fromTypeN = 'text/plain'">
        <xsl:choose>
          <!-- text->text: just copy -->
          <xsl:when test="not(string($toTypeN)) or $toTypeN = 'text' or $toTypeN = 'text/plain'">
            <xsl:value-of select="$value" />
          </xsl:when>
          <!-- text->html: escape -->
          <xsl:when test="$toTypeN = 'html' or $toTypeN = 'text/html'">
            <xsl:value-of select="msfeednorm:HtmlEscape(string($value))" />
          </xsl:when>
        </xsl:choose>
      </xsl:when>
      <xsl:when test="$fromTypeN = 'html' or $fromTypeN = 'text/html'">
        <xsl:choose>
          <!-- html->text: drop all html and unescape -->
          <xsl:when test="not(string($toTypeN)) or $toTypeN = 'text' or $toTypeN = 'text/plain'">
            <xsl:value-of select="msfeednorm:CleanHtmlToPlainText(string($value))" />
          </xsl:when>
          <!-- html->html: drop unsafe html -->
          <xsl:when test="$toTypeN = 'html' or $toTypeN = 'text/html'">
            <xsl:value-of select="msfeednorm:CleanHtmlToSafeHtml(string($baseUrl), string($value))" />
          </xsl:when>
        </xsl:choose>
      </xsl:when>
      <xsl:when test="$fromTypeN = 'xhtml' or $fromTypeN = 'application/xhtml+xml'">
        <xsl:variable name="normXhtml">
          <xsl:call-template name="_NormalizeXhtmlNamespacePrefix">
            <xsl:with-param name="value" select="$value/*" />
          </xsl:call-template>
        </xsl:variable>
        <xsl:choose>
          <!-- xhtml->text: drop all html and unescape -->
          <xsl:when test="not(string($toTypeN)) or $toTypeN = 'text' or $toTypeN = 'text/plain'">
            <xsl:value-of select="msfeednorm:CleanXhtmlToPlainText($normXhtml)" />
          </xsl:when>
          <!-- xhtml->html: drop unsafe html -->
          <xsl:when test="$toTypeN = 'html' or $toTypeN = 'text/html'">
            <xsl:value-of select="msfeednorm:CleanXhtmlToSafeXhtml(string($baseUrl), $normXhtml)" />
          </xsl:when>
        </xsl:choose>
      </xsl:when>
      <!-- Note that any unknown type value will yield empty output -->
    </xsl:choose>
  </xsl:template>
Generic output templates
<!-- Output attribute with plain text value -->
  <xsl:template name="_OutputTextAttribute">
    <xsl:param name="tagName" />
    <xsl:param name="nameSpace" select="''" />
    <xsl:param name="value" />
    <xsl:variable name="_validatedValue">
      <xsl:call-template name="_CleanByType">
        <xsl:with-param name="value" select="$value" />
        <xsl:with-param name="fromType" select="'text'" />
        <xsl:with-param name="toType" select="'text'" />
      </xsl:call-template>
    </xsl:variable>
    <xsl:if test="string($_validatedValue)">
      <xsl:attribute name="{$tagName}" namespace="{$nameSpace}"><xsl:value-of select="$_validatedValue" /></xsl:attribute>
    </xsl:if>
  </xsl:template>
<!-- Output attribute with bool value -->
  <xsl:template name="_OutputBoolAttribute">
    <xsl:param name="tagName" />
    <xsl:param name="nameSpace" select="''" />
    <xsl:param name="value" />
    <xsl:variable name="_validatedValue">
      <xsl:call-template name="_ValidateBool"><xsl:with-param name="value" select="$value" /></xsl:call-template>
    </xsl:variable>
    <xsl:if test="string($_validatedValue)">
      <xsl:attribute name="{$tagName}" namespace="{$nameSpace}"><xsl:value-of select="$_validatedValue" /></xsl:attribute>
    </xsl:if>
  </xsl:template>
<!-- Output attribute with URL value -->
  <xsl:template name="_OutputUrlAttribute">
    <xsl:param name="tagName" />
    <xsl:param name="nameSpace" select="''" />
    <xsl:param name="value" />
    <xsl:variable name="_validatedValue" select="msfeednorm:ValidateUrl(normalize-space($value))" />
    <xsl:if test="string($_validatedValue)">
      <xsl:attribute name="{$tagName}" namespace="{$nameSpace}"><xsl:value-of select="$_validatedValue" /></xsl:attribute>
    </xsl:if>
  </xsl:template>
  <xsl:template name="_OutputUriAttribute">
    <xsl:param name="tagName" />
    <xsl:param name="nameSpace" select="''" />
    <xsl:param name="value" />
    <xsl:variable name="_validatedValue" select="msfeednorm:NormalizeUri(normalize-space($value))" />
    <xsl:if test="string($_validatedValue)">
      <xsl:attribute name="{$tagName}" namespace="{$nameSpace}"><xsl:value-of select="$_validatedValue" /></xsl:attribute>
    </xsl:if>
  </xsl:template>
<!-- Output attribute with mime-type value -->
  <xsl:template name="_OutputMimeTypeAttribute">
    <xsl:param name="tagName" />
    <xsl:param name="nameSpace" select="''" />
    <xsl:param name="value" />
    <xsl:variable name="_validatedValue" select="normalize-space($value)" />
    <xsl:if test="string($_validatedValue)">
      <xsl:attribute name="{$tagName}" namespace="{$nameSpace}"><xsl:value-of select="$_validatedValue" /></xsl:attribute>
    </xsl:if>
  </xsl:template>
<!-- Output attribute with non-negative number value -->
  <xsl:template name="_OutputPositiveNumberAttribute">
    <xsl:param name="tagName" />
    <xsl:param name="nameSpace" select="''" />
    <xsl:param name="value" />
    <xsl:variable name="_validatedValue" select="number($value)" />
    <xsl:if test="(string($_validatedValue) != 'NaN') and ($_validatedValue >= 0)">
      <xsl:attribute name="{$tagName}" namespace="{$nameSpace}"><xsl:value-of select="$_validatedValue" /></xsl:attribute>
    </xsl:if>
  </xsl:template>
<!-- Output element with plain text value -->
  <xsl:template name="_OutputTextElement">
    <xsl:param name="tagName" />
    <xsl:param name="nameSpace" select="''" />
    <xsl:param name="value" />
    <xsl:param name="type" select="'text'" />
    <xsl:param name="outputTypeAttribute" select="'false'" />
    <xsl:variable name="_validatedValue">
      <xsl:call-template name="_CleanByType">
        <xsl:with-param name="value" select="$value" />
        <xsl:with-param name="fromType" select="$type" />
        <xsl:with-param name="toType" select="'text'" />
      </xsl:call-template>
    </xsl:variable>
    <xsl:if test="string($_validatedValue)">
      <xsl:element name="{$tagName}" namespace="{$nameSpace}">
        <xsl:if test="$outputTypeAttribute = 'true'">
          <xsl:attribute name="cf:type" namespace="{$_NScf}">text</xsl:attribute>
        </xsl:if>
        <xsl:value-of select="$_validatedValue" />
      </xsl:element>
    </xsl:if>
  </xsl:template>
<!-- Output element with URL value -->
  <xsl:template name="_OutputUrlElement">
    <xsl:param name="tagName" />
    <xsl:param name="nameSpace" select="''" />
    <xsl:param name="value" />
    <xsl:variable name="_validatedValue" select="msfeednorm:ValidateUrl(normalize-space($value))" />
    <xsl:if test="string($_validatedValue)">
      <xsl:element name="{$tagName}" namespace="{$nameSpace}"><xsl:value-of select="$_validatedValue" /></xsl:element>
    </xsl:if>
  </xsl:template>
<!-- Output element with inet date value -->
  <xsl:template name="_OutputDateElement">
    <xsl:param name="tagName" />
    <xsl:param name="nameSpace" select="''" />
    <xsl:param name="value" />
    <xsl:param name="outFormat" select="'inetDate'" />
    <xsl:variable name="_validatedValue">
      <xsl:choose>
        <xsl:when test="$outFormat = 'inetDate'">
          <xsl:value-of select="msfeednorm:NormalizeDateToInetDate(normalize-space($value))"/>
        </xsl:when>
        <xsl:when test="$outFormat = 'iso8601'">
          <xsl:value-of select="msfeednorm:NormalizeDateToIso8601(normalize-space($value))"/>
        </xsl:when>
      </xsl:choose>
    </xsl:variable>
    <xsl:if test="string($_validatedValue)">
      <xsl:element name="{$tagName}" namespace="{$nameSpace}"><xsl:value-of select="$_validatedValue" /></xsl:element>
    </xsl:if>
  </xsl:template>
<!-- Output element with a non-negative number value -->
  <xsl:template name="_OutputPositiveNumberElement">
    <xsl:param name="tagName" />
    <xsl:param name="nameSpace" select="''" />
    <xsl:param name="value" />
    <xsl:variable name="_validatedValue" select="number($value)" />
    <xsl:if test="(string($_validatedValue) != 'NaN') and ($_validatedValue >= 0)">
      <xsl:element name="{$tagName}" namespace="{$nameSpace}"><xsl:value-of select="$_validatedValue" /></xsl:element>
    </xsl:if>
  </xsl:template>
<!-- Output RSS 2.0 author or managingEditor element and convert into atom:author -->
  <xsl:template name="_OutputAuthorOrEditor">
    <xsl:param name="tagName" />
    <xsl:param name="value" />
    <xsl:param name="convertToAtom" select="'false'" />
    <xsl:variable name="_validatedValue" select="normalize-space($value)" />
    <xsl:if test="string($_validatedValue)">
      <xsl:element name="{$tagName}"><xsl:value-of select="$_validatedValue" /></xsl:element>
      <xsl:if test="$convertToAtom = 'true'">
        <xsl:call-template name="_ConvertAuthorToAtomAuthor"><xsl:with-param name="value" select="$_validatedValue" /></xsl:call-template>
      </xsl:if>
    </xsl:if>
  </xsl:template>
<!-- Output atom:author or atom:contributor (have identical handling) -->
  <xsl:template name="_OutputAtomAuthorOrContributor">
    <xsl:param name="tagName" />
    <xsl:param name="name" />
    <xsl:param name="email" />
    <xsl:param name="uri" />
    <xsl:variable name="_validatedName" select="normalize-space($name)" />
    <xsl:variable name="_validatedEmail" select="normalize-space($email)" />
    <xsl:if test="string($_validatedName) or string($_validatedEmail)">
      <xsl:element name="{$tagName}" namespace="{$_NSatom1}">
        <xsl:if test="string($_validatedName)">
          <atom:name><xsl:value-of select="$_validatedName" /></atom:name>
        </xsl:if>
        <xsl:if test="string($_validatedEmail)">
          <atom:email><xsl:value-of select="$_validatedEmail" /></atom:email>
        </xsl:if>
        <xsl:variable name="_validatedUri" select="msfeednorm:NormalizeUri(normalize-space($uri))" />
        <xsl:if test="string($_validatedUri)">
          <atom:uri><xsl:value-of select="$_validatedUri" /></atom:uri>
        </xsl:if>
      </xsl:element>
    </xsl:if>
  </xsl:template>
Common feed format output templates
<!-- xml:lang -->
  <xsl:template name="_OutputXmlLang">
    <xsl:param name="value" />
    <xsl:call-template name="_OutputTextAttribute">
      <xsl:with-param name="tagName" select="'xml:lang'" />
      <xsl:with-param name="value" select="$value" />
    </xsl:call-template>
  </xsl:template>
<!-- xml:base -->
  <xsl:template name="_OutputXmlBase">
    <xsl:param name="value" />
    <xsl:call-template name="_OutputUrlAttribute">
      <xsl:with-param name="tagName" select="'xml:base'" />
      <xsl:with-param name="value" select="$value" />
    </xsl:call-template>
  </xsl:template>
<!-- title -->
  <xsl:template name="_OutputTitle">
    <xsl:param name="value" />
    <xsl:param name="type" />
    <xsl:call-template name="_OutputTextElement">
      <xsl:with-param name="tagName" select="'title'" />
      <xsl:with-param name="value" select="$value" />
      <xsl:with-param name="type" select="$type" />
      <xsl:with-param name="outputTypeAttribute" select="'true'" />
    </xsl:call-template>
  </xsl:template>
<!-- link -->
  <xsl:template name="_OutputLink">
    <xsl:param name="value" />
    <xsl:call-template name="_OutputUrlElement">
      <xsl:with-param name="tagName" select="'link'" />
      <xsl:with-param name="value" select="$value" />
    </xsl:call-template>
  </xsl:template>
<!-- plain-text description -->
  <xsl:template name="_OutputTextDescription">
    <xsl:param name="value" />
    <xsl:param name="type" />
    <xsl:call-template name="_OutputTextElement">
      <xsl:with-param name="tagName" select="'description'" />
      <xsl:with-param name="value" select="$value" />
      <xsl:with-param name="type" select="$type" />
      <xsl:with-param name="outputTypeAttribute" select="'true'" />
    </xsl:call-template>
  </xsl:template>
<!-- pubDate -->
  <xsl:template name="_OutputPubDate">
    <xsl:param name="value" />
    <xsl:call-template name="_OutputDateElement">
      <xsl:with-param name="tagName" select="'pubDate'" />
      <xsl:with-param name="value" select="$value" />
    </xsl:call-template>
  </xsl:template>
<!-- language -->
  <xsl:template name="_OutputLanguage">
    <xsl:param name="value" />
    <xsl:call-template name="_OutputTextElement">
      <xsl:with-param name="tagName" select="'language'" />
      <xsl:with-param name="value" select="$value" />
    </xsl:call-template>
  </xsl:template>
<!-- copyright -->
  <xsl:template name="_OutputCopyright">
    <xsl:param name="value" />
    <xsl:param name="type" />
    <xsl:call-template name="_OutputTextElement">
      <xsl:with-param name="tagName" select="'copyright'" />
      <xsl:with-param name="value" select="$value" />
      <xsl:with-param name="type" select="$type" />
      <xsl:with-param name="outputTypeAttribute" select="'true'" />
    </xsl:call-template>
  </xsl:template>
<!-- lastBuildDate -->
  <xsl:template name="_OutputLastBuildDate">
    <xsl:param name="value" />
    <xsl:call-template name="_OutputDateElement">
      <xsl:with-param name="tagName" select="'lastBuildDate'" />
      <xsl:with-param name="value" select="$value" />
    </xsl:call-template>
  </xsl:template>
<!-- managingEditor -->
  <xsl:template name="_OutputManagingEditor">
    <xsl:param name="value" />
    <xsl:param name="convertToAtom" select="'false'" />
    <xsl:call-template name="_OutputAuthorOrEditor">
      <xsl:with-param name="tagName" select="'managingEditor'" />
      <xsl:with-param name="value" select="$value" />
      <xsl:with-param name="convertToAtom" select="$convertToAtom" />
    </xsl:call-template>
  </xsl:template>
<!-- webMaster -->
  <xsl:template name="_OutputWebMaster">
    <xsl:param name="value" />
    <xsl:call-template name="_OutputTextElement">
      <xsl:with-param name="tagName" select="'webMaster'" />
      <xsl:with-param name="value" select="$value" />
    </xsl:call-template>
  </xsl:template>
<!-- category -->
  <xsl:template name="_OutputCategory">
    <xsl:param name="value" />
    <xsl:param name="domain" />
    <xsl:variable name="_validatedValue" select="normalize-space($value)" />
    <xsl:if test="string($_validatedValue)">
      <xsl:element name="category">
        <xsl:call-template name="_OutputTextAttribute">
          <xsl:with-param name="tagName" select="'domain'" />
          <xsl:with-param name="value" select="$domain" />
        </xsl:call-template>
        <xsl:value-of select="$_validatedValue" />
      </xsl:element>
    </xsl:if>
  </xsl:template>
<!-- generator -->
  <xsl:template name="_OutputGenerator">
    <xsl:param name="value" />
    <xsl:param name="uri" />
    <xsl:param name="version" />
    <xsl:variable name="_validatedValue" select="normalize-space($value)" />
    <xsl:if test="string($_validatedValue)">
      <xsl:element name="generator">
        <xsl:call-template name="_OutputUriAttribute">
          <xsl:with-param name="tagName" select="'cf:uri'" />
          <xsl:with-param name="nameSpace" select="$_NScf" />
          <xsl:with-param name="value" select="$uri" />
        </xsl:call-template>
        <xsl:call-template name="_OutputTextAttribute">
          <xsl:with-param name="tagName" select="'cf:version'" />
          <xsl:with-param name="nameSpace" select="$_NScf" />
          <xsl:with-param name="value" select="$version" />
        </xsl:call-template>
        <xsl:value-of select="$_validatedValue" />
      </xsl:element>
    </xsl:if>
  </xsl:template>
<!-- docs -->
  <xsl:template name="_OutputDocs">
    <xsl:param name="value" />
    <xsl:call-template name="_OutputUrlElement">
      <xsl:with-param name="tagName" select="'docs'" />
      <xsl:with-param name="value" select="$value" />
    </xsl:call-template>
  </xsl:template>
<!-- cloud -->
  <xsl:template name="_OutputCloud">
    <xsl:param name="value" />
    <!-- We always output this element and clean any attribute it has into text -->
    <cloud>
      <xsl:for-each select="$value/@*">
        <xsl:attribute name="{name(.)}"><xsl:value-of select="normalize-space(.)"/></xsl:attribute>
      </xsl:for-each>
    </cloud>
  </xsl:template>
<!-- ttl -->
  <xsl:template name="_OutputTtl">
    <xsl:param name="value" />
    <xsl:call-template name="_OutputPositiveNumberElement">
      <xsl:with-param name="tagName" select="'ttl'" />
      <xsl:with-param name="value" select="$value" />
    </xsl:call-template>
  </xsl:template>
<!-- image -->
  <xsl:template name="_OutputImage">
    <xsl:param name="url" />
    <xsl:param name="title" />
    <xsl:param name="titleType" select="'text'" />
    <xsl:param name="link" />
    <xsl:param name="width" />
    <xsl:param name="height" />
    <xsl:param name="description" />
    <xsl:param name="subnodesToCopy" />
    <xsl:variable name="_validatedUrl" select="msfeednorm:ValidateUrl(normalize-space($url))" />
    <xsl:if test="string($_validatedUrl)">
      <image>
        <url><xsl:value-of select="$_validatedUrl" /></url>
        <xsl:call-template name="_OutputTextElement">
          <xsl:with-param name="tagName" select="'title'" />
          <xsl:with-param name="value" select="$title" />
          <xsl:with-param name="type" select="$titleType" />
        </xsl:call-template>
        <xsl:call-template name="_OutputUrlElement">
          <xsl:with-param name="tagName" select="'link'" />
          <xsl:with-param name="value" select="$link" />
        </xsl:call-template>
        <xsl:call-template name="_OutputPositiveNumberElement">
          <xsl:with-param name="tagName" select="'width'" />
          <xsl:with-param name="value" select="$width" />
        </xsl:call-template>
        <xsl:call-template name="_OutputPositiveNumberElement">
          <xsl:with-param name="tagName" select="'height'" />
          <xsl:with-param name="value" select="$height" />
        </xsl:call-template>
        <xsl:call-template name="_OutputTextElement">
          <xsl:with-param name="tagName" select="'description'" />
          <xsl:with-param name="value" select="$description" />
        </xsl:call-template>
        <xsl:if test="boolean($subnodesToCopy)">
          <xsl:for-each select="$subnodesToCopy">
            <xsl:copy-of select="." />
          </xsl:for-each>
        </xsl:if>
      </image>
    </xsl:if>
  </xsl:template>
<!-- rating -->
  <xsl:template name="_OutputRating">
    <xsl:param name="value" />
    <xsl:call-template name="_OutputTextElement">
      <xsl:with-param name="tagName" select="'rating'" />
      <xsl:with-param name="value" select="$value" />
    </xsl:call-template>
  </xsl:template>
<!-- textInput -->
  <xsl:template name="_OutputTextInput">
    <xsl:param name="title" />
    <xsl:param name="name" />
    <xsl:param name="link" />
    <xsl:param name="description" />
    <xsl:param name="subnodesToCopy" />
    <xsl:variable name="_validatedName" select="normalize-space($name)" />
    <xsl:variable name="_validatedLink" select="msfeednorm:ValidateUrl(normalize-space($link))" />
    <xsl:if test="string($_validatedName) and string($_validatedLink)">
      <textInput>
        <name><xsl:value-of select="$_validatedName" /></name>
        <link><xsl:value-of select="$_validatedLink" /></link>
        <xsl:call-template name="_OutputTextElement">
          <xsl:with-param name="tagName" select="'title'" />
          <xsl:with-param name="value" select="$title" />
        </xsl:call-template>
        <xsl:call-template name="_OutputTextElement">
          <xsl:with-param name="tagName" select="'description'" />
          <xsl:with-param name="value" select="$description" />
        </xsl:call-template>
        <xsl:if test="boolean($subnodesToCopy)">
          <xsl:for-each select="$subnodesToCopy">
            <xsl:copy-of select="." />
          </xsl:for-each>
        </xsl:if>
      </textInput>
    </xsl:if>
  </xsl:template>
<!-- skipHours -->
  <xsl:template name="_OutputSkipHours">
    <xsl:param name="value" />
    <xsl:if test="$value/hour[number(.)>=0 and number(.)&lt;=23]">
      <skipHours>
        <xsl:for-each select="$value/hour">
          <xsl:variable name="_numberHour" select="number(.)" />
          <xsl:if test="$_numberHour >= 0 and $_numberHour &lt;= 23">
            <hour><xsl:value-of select="$_numberHour" /></hour>
          </xsl:if>
        </xsl:for-each>
      </skipHours>
    </xsl:if>
  </xsl:template>
<!-- skipDays -->
  <xsl:template name="_OutputSkipDays">
    <xsl:param name="value" />
    <xsl:if test="$value/day[string(.) = 'Monday' or string(.) = 'Tuesday' or string(.) = 'Wednesday' or string(.) = 'Thursday' or string(.) = 'Friday' or string(.) = 'Saturday' or string(.) = 'Sunday']">
      <skipDays>
        <xsl:for-each select="$value/day">
          <xsl:variable name="_stringDay" select="string(.)" />
          <xsl:if test="$_stringDay = 'Monday' or $_stringDay = 'Tuesday' or $_stringDay = 'Wednesday' or $_stringDay = 'Thursday' or $_stringDay = 'Friday' or $_stringDay = 'Saturday' or $_stringDay = 'Sunday'">
            <day><xsl:value-of select="$_stringDay" /></day>
          </xsl:if>
        </xsl:for-each>
      </skipDays>
    </xsl:if>
  </xsl:template>
<!-- author -->
  <xsl:template name="_OutputAuthor">
    <xsl:param name="value" />
    <xsl:param name="convertToAtom" select="'false'" />
    <xsl:call-template name="_OutputAuthorOrEditor">
      <xsl:with-param name="tagName" select="'author'" />
      <xsl:with-param name="value" select="$value" />
      <xsl:with-param name="convertToAtom" select="$convertToAtom" />
    </xsl:call-template>
  </xsl:template>
<!-- comments -->
  <xsl:template name="_OutputComments">
    <xsl:param name="value" />
    <xsl:call-template name="_OutputUrlElement">
      <xsl:with-param name="tagName" select="'comments'" />
      <xsl:with-param name="value" select="$value" />
    </xsl:call-template>
  </xsl:template>
<!-- enclosure -->
  <xsl:template name="_OutputEnclosure">
    <xsl:param name="url" />
    <xsl:param name="length" />
    <xsl:param name="type" />
    <xsl:variable name="_validatedUrl" select="msfeednorm:ValidateUrl(normalize-space($url))" />
    <xsl:if test="string($_validatedUrl)">
      <enclosure>
        <xsl:attribute name="url"><xsl:value-of select="$_validatedUrl"/></xsl:attribute>
        <xsl:call-template name="_OutputPositiveNumberAttribute">
          <xsl:with-param name="tagName" select="'length'" />
          <xsl:with-param name="value" select="$length" />
        </xsl:call-template>
        <xsl:call-template name="_OutputMimeTypeAttribute">
          <xsl:with-param name="tagName" select="'type'" />
          <xsl:with-param name="value" select="$type" />
        </xsl:call-template>
      </enclosure>
    </xsl:if>
  </xsl:template>
<!-- guid -->
  <xsl:template name="_OutputGuid">
    <xsl:param name="value" />
    <xsl:param name="isPermaLink" />
    <xsl:param name="channelGuid" select="'false'" />
    <xsl:variable name="_validatedValue">
      <xsl:choose>
        <xsl:when test="normalize-space($isPermaLink) = 'true' or not(string($isPermaLink))">
          <xsl:value-of select="msfeednorm:ValidateUrl(normalize-space($value))" />
        </xsl:when>
        <xsl:otherwise>
          <xsl:value-of select="string($value)" />
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:if test="string($_validatedValue)">
      <xsl:choose>
        <xsl:when test="$channelGuid = 'false'">
          <xsl:element name="guid">
            <xsl:call-template name="_OutputBoolAttribute">
              <xsl:with-param name="tagName" select="'isPermaLink'" />
              <xsl:with-param name="value" select="$isPermaLink" />
            </xsl:call-template>
            <xsl:value-of select="$_validatedValue" />
          </xsl:element>
        </xsl:when>
        <xsl:otherwise>
          <xsl:element name="cf:guid" namespace="{$_NScf}">
            <xsl:call-template name="_OutputBoolAttribute">
              <xsl:with-param name="tagName" select="'isPermaLink'" />
              <xsl:with-param name="value" select="$isPermaLink" />
            </xsl:call-template>
            <xsl:value-of select="$_validatedValue" />
          </xsl:element>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:if>
  </xsl:template>
<!-- source -->
  <xsl:template name="_OutputSource">
    <xsl:param name="value" />
    <xsl:param name="url" />
    <xsl:variable name="_validatedValue" select="normalize-space($value)" />
    <xsl:if test="string($_validatedValue)">
      <xsl:element name="source">
        <xsl:call-template name="_OutputUrlAttribute">
          <xsl:with-param name="tagName" select="'url'" />
          <xsl:with-param name="value" select="$url" />
        </xsl:call-template>
        <xsl:value-of select="$_validatedValue" />
      </xsl:element>
    </xsl:if>
  </xsl:template>
<!-- rich-text description -->
  <xsl:template name="_OutputDescription">
    <xsl:param name="value" />
    <xsl:param name="type" />
    <xsl:param name="baseUrl" />
    <!-- Description is always html -->
    <description cf:type="html">
      <xsl:call-template name="_CleanByType">
        <xsl:with-param name="value" select="$value" />
        <xsl:with-param name="fromType" select="$type" />
        <xsl:with-param name="toType" select="'html'" />
        <xsl:with-param name="baseUrl" select="$baseUrl" />
      </xsl:call-template>
    </description>
  </xsl:template>
<!-- atom:summary -->
  <xsl:template name="_OutputAtomSummary">
    <xsl:param name="value" />
    <xsl:param name="type" />
    <xsl:param name="xmlBase" />
    <xsl:param name="baseUrl" />
    <atom:summary>
      <xsl:call-template name="_OutputXmlBase"><xsl:with-param name="value" select="$xmlBase" /></xsl:call-template>
      <xsl:call-template name="_NormalizeAtomTextTypeAttr"><xsl:with-param name="value" select="$type" /></xsl:call-template>
      <xsl:call-template name="_CleanByType">
        <xsl:with-param name="value" select="$value" />
        <xsl:with-param name="fromType" select="$type" />
        <xsl:with-param name="toType" select="$type" />
        <xsl:with-param name="baseUrl" select="$baseUrl" />
      </xsl:call-template>
    </atom:summary>
  </xsl:template>
<!-- description and summary (if it exists) -->
  <xsl:template name="_OutputDescriptionAndSummary">
    <xsl:param name="description" />
    <xsl:param name="descriptionType" />
    <xsl:param name="descriptionBaseUrl" />
    <xsl:param name="summary" />
    <xsl:param name="summaryType" />
    <xsl:param name="summaryXmlBase" />
    <xsl:param name="summaryBaseUrl" />
    <xsl:call-template name="_OutputDescription">
      <xsl:with-param name="value" select="$description" />
      <xsl:with-param name="type" select="$descriptionType" />
      <xsl:with-param name="baseUrl" select="$descriptionBaseUrl" />
    </xsl:call-template>
    <xsl:if test="string($summary)">
      <xsl:call-template name="_OutputAtomSummary">
        <xsl:with-param name="value" select="$summary" />
        <xsl:with-param name="type" select="$summaryType" />
        <xsl:with-param name="xmlBase" select="$summaryXmlBase" />
        <xsl:with-param name="baseUrl" select="$summaryBaseUrl" />
      </xsl:call-template>
    </xsl:if>
  </xsl:template>
<!-- atom:link -->
  <xsl:template name="_OutputAtomLink">
    <xsl:param name="href" />
    <xsl:param name="rel" />
    <xsl:param name="type" />
    <xsl:param name="title" />
    <xsl:param name="hreflang" />
    <xsl:param name="length" />
    <xsl:param name="xmlBase" />
    <xsl:variable name="_validatedHref" select="msfeednorm:ValidateUrl(normalize-space($href))" />
    <xsl:if test="string($_validatedHref)">
      <atom:link>
        <xsl:attribute name="href"><xsl:value-of select="$_validatedHref" /></xsl:attribute>
        <xsl:call-template name="_OutputTextAttribute">
          <xsl:with-param name="tagName" select="'rel'" />
          <xsl:with-param name="value" select="$rel" />
        </xsl:call-template>
        <xsl:call-template name="_OutputMimeTypeAttribute">
          <xsl:with-param name="tagName" select="'type'" />
          <xsl:with-param name="value" select="$type" />
        </xsl:call-template>
        <xsl:call-template name="_OutputTextAttribute">
          <xsl:with-param name="tagName" select="'title'" />
          <xsl:with-param name="value" select="$title" />
        </xsl:call-template>
        <xsl:call-template name="_OutputTextAttribute">
          <xsl:with-param name="tagName" select="'hreflang'" />
          <xsl:with-param name="value" select="$hreflang" />
        </xsl:call-template>
        <xsl:call-template name="_OutputPositiveNumberAttribute">
          <xsl:with-param name="tagName" select="'length'" />
          <xsl:with-param name="value" select="$length" />
        </xsl:call-template>
        <xsl:call-template name="_OutputXmlBase">
          <xsl:with-param name="value" select="$xmlBase" />
        </xsl:call-template>
      </atom:link>
    </xsl:if>
  </xsl:template>
<!-- atom:author -->
  <xsl:template name="_OutputAtomAuthor">
    <xsl:param name="name" />
    <xsl:param name="email" />
    <xsl:param name="uri" />
    <xsl:call-template name="_OutputAtomAuthorOrContributor">
      <xsl:with-param name="tagName" select="'atom:author'" />
      <xsl:with-param name="name" select="$name" />
      <xsl:with-param name="email" select="$email" />
      <xsl:with-param name="uri" select="$uri" />
    </xsl:call-template>
  </xsl:template>
<!-- atom:contributor -->
  <xsl:template name="_OutputAtomContributor">
    <xsl:param name="name" />
    <xsl:param name="email" />
    <xsl:param name="uri" />
    <xsl:call-template name="_OutputAtomAuthorOrContributor">
      <xsl:with-param name="tagName" select="'atom:contributor'" />
      <xsl:with-param name="name" select="$name" />
      <xsl:with-param name="email" select="$email" />
      <xsl:with-param name="uri" select="$uri" />
    </xsl:call-template>
  </xsl:template>
<!-- atom:published -->
  <xsl:template name="_OutputAtomPublished">
    <xsl:param name="value" />
    <xsl:call-template name="_OutputDateElement">
      <xsl:with-param name="tagName" select="'atom:published'" />
      <xsl:with-param name="nameSpace" select="$_NSatom1" />
      <xsl:with-param name="value" select="$value" />
      <xsl:with-param name="outFormat" select="'iso8601'" />
    </xsl:call-template>
  </xsl:template>
<!-- atom:updated -->
  <xsl:template name="_OutputAtomUpdated">
    <xsl:param name="value" />
    <xsl:call-template name="_OutputDateElement">
      <xsl:with-param name="tagName" select="'atom:updated'" />
      <xsl:with-param name="nameSpace" select="$_NSatom1" />
      <xsl:with-param name="value" select="$value" />
      <xsl:with-param name="outFormat" select="'iso8601'" />
    </xsl:call-template>
  </xsl:template>
<!-- slash:comments -->
  <xsl:template name="_OutputSlashComments">
    <xsl:param name="value" />
    <xsl:call-template name="_OutputPositiveNumberElement">
      <xsl:with-param name="tagName" select="'slash:comments'" />
      <xsl:with-param name="nameSpace" select="$_NSslash" />
      <xsl:with-param name="value" select="$value" />
    </xsl:call-template>
  </xsl:template>
<!-- wfw:commentRss -->
  <xsl:template name="_OutputWfwCommentRSS">
    <xsl:param name="value" />
    <xsl:call-template name="_OutputUrlElement">
      <xsl:with-param name="tagName" select="'wfw:commentRss'" />
      <xsl:with-param name="nameSpace" select="$_NSwfw" />
      <xsl:with-param name="value" select="$value" />
    </xsl:call-template>
  </xsl:template>
<!-- cf:treatAs -->
  <xsl:template name="_OutputCfTreatAs">
    <xsl:param name="value" />
    <xsl:call-template name="_OutputTextElement">
      <xsl:with-param name="tagName" select="'cf:treatAs'" />
      <xsl:with-param name="nameSpace" select="$_NScf" />
      <xsl:with-param name="value" select="$value" />
    </xsl:call-template>
  </xsl:template>
<!-- cf:listinfo -->
  <xsl:template name="_OutputCfListinfo">
    <xsl:param name="value" />
    <cf:listinfo>
      <xsl:for-each select="$value/cf:sort">
        <xsl:variable name="_ValidatedSortElem" select="normalize-space(@element)" />
        <xsl:variable name="_ValidatedSortLabel" select="normalize-space(@label)" />
        <xsl:if test="string($_ValidatedSortElem) or string($_ValidatedSortLabel)">
          <cf:sort>
            <xsl:if test="string($_ValidatedSortElem)">
              <xsl:attribute name="element"><xsl:value-of select="$_ValidatedSortElem"/></xsl:attribute>
            </xsl:if>
            <xsl:if test="string($_ValidatedSortLabel)">
              <xsl:attribute name="label"><xsl:value-of select="$_ValidatedSortLabel"/></xsl:attribute>
            </xsl:if>
            <xsl:call-template name="_OutputTextAttribute">
              <xsl:with-param name="tagName" select="'ns'" />
              <xsl:with-param name="value" select="@ns" />
            </xsl:call-template>
            <xsl:call-template name="_OutputTextAttribute">
              <xsl:with-param name="tagName" select="'data-type'" />
              <xsl:with-param name="value" select="@data-type" />
            </xsl:call-template>
            <xsl:call-template name="_OutputBoolAttribute">
              <xsl:with-param name="tagName" select="'default'" />
              <xsl:with-param name="value" select="@default" />
            </xsl:call-template>
          </cf:sort>
        </xsl:if>
      </xsl:for-each>
      <xsl:for-each select="$value/cf:group">
        <xsl:variable name="_ValidatedGroupElem" select="normalize-space(@element)" />
        <xsl:variable name="_ValidatedGroupLabel" select="normalize-space(@label)" />
        <xsl:if test="string($_ValidatedGroupElem) or string($_ValidatedGroupLabel)">
          <cf:group>
            <xsl:if test="string($_ValidatedGroupElem)">
              <xsl:attribute name="element"><xsl:value-of select="$_ValidatedGroupElem"/></xsl:attribute>
            </xsl:if>
            <xsl:if test="string($_ValidatedGroupLabel)">
              <xsl:attribute name="label"><xsl:value-of select="$_ValidatedGroupLabel"/></xsl:attribute>
            </xsl:if>
            <xsl:call-template name="_OutputTextAttribute">
              <xsl:with-param name="tagName" select="'ns'" />
              <xsl:with-param name="value" select="@ns" />
            </xsl:call-template>
          </cf:group>
        </xsl:if>
      </xsl:for-each>
    </cf:listinfo>
  </xsl:template>
<!-- mon:expiration -->
  <xsl:template name="_OutputMonExpiration">
    <xsl:param name="value" />
    <xsl:call-template name="_OutputDateElement">
      <xsl:with-param name="tagName" select="'mon:expiration'" />
      <xsl:with-param name="nameSpace" select="$_NSmon" />
      <xsl:with-param name="value" select="$value" />
      <xsl:with-param name="outFormat" select="'iso8601'" />
    </xsl:call-template>
  </xsl:template>
<!-- output the extension nodes -->
  <xsl:template name="_OutputExtension">
    <xsl:param name="value" />
    <xsl:param name="references" />
    <xsl:if test="namespace-uri($value) != $_NScfi">
      <xsl:variable name="nodeRefName">'<xsl:value-of select="namespace-uri($value)"/>':<xsl:value-of select="local-name($value)"/>;</xsl:variable>
      <xsl:choose>
        <xsl:when test="string($references) and contains($references, $nodeRefName)">
          <xsl:call-template name="_OutputTextElement">
            <xsl:with-param name="value" select="$value" />
            <xsl:with-param name="tagName" select="name($value)" />
            <xsl:with-param name="nameSpace" select="namespace-uri($value)" />
          </xsl:call-template>
        </xsl:when>
        <xsl:otherwise>
          <xsl:copy-of select="$value" />
        </xsl:otherwise>
      </xsl:choose>
    </xsl:if>
  </xsl:template>
</xsl:stylesheet>
<?xml version="1.0" ?>
<xsl:stylesheet version="1.0" 
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform" 
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:dcterms="http://purl.org/dc/terms/"
  xmlns:cf="http://www.microsoft.com/schemas/rss/core/2005"
  xmlns:msfeednorm="urn:microsoft:feed-normalization"
  exclude-result-prefixes="dcterms msfeednorm"
<!-- Shared templates -->
  <xsl:import href="res://msfeeds.dll/SharedNormalizer.xsl" />
<!-- Output XML UTF-8 -->
  <xsl:output method="xml" encoding="utf-8" />
<!-- Figure out the type for RSS 2.0 text fields -->
  <xsl:template name="_GetRSS2TypeValue">
    <xsl:param name="type" />
    <xsl:param name="default" />
    <xsl:choose>
      <xsl:when test="normalize-space($type) = 'html'">html</xsl:when>
      <xsl:when test="normalize-space($type) = 'text'">text</xsl:when>
      <xsl:when test="not(string($type)) or normalize-space($type) = ''"><xsl:value-of select="$default" /></xsl:when>
      <xsl:otherwise>invalid</xsl:otherwise>
      <!-- Note that unknown value for a type will yield empty output -->
    </xsl:choose>
  </xsl:template>
<!-- Entry point -->
  <xsl:template match="/rss">
    <rss>
      <!-- Copy all namespaces -->
      <xsl:for-each select="namespace::*"><xsl:copy /></xsl:for-each>
      <!-- Ensure version is 2.0 -->
      <xsl:attribute name="version">2.0</xsl:attribute>
      <!-- Process channel -->
      <channel>
        <xsl:apply-templates select="channel" />
      </channel>
    </rss>
  </xsl:template>
<!-- Channel processing -->
  <xsl:template match="channel">
    <!-- Copy all namespaces -->
    <xsl:for-each select="namespace::*">
      <xsl:copy />
    </xsl:for-each>
    <xsl:call-template name="_OutputXmlBase"><xsl:with-param name="value" select="@xml:base" /></xsl:call-template>
    <xsl:call-template name="_OutputXmlLang"><xsl:with-param name="value" select="@xml:lang" /></xsl:call-template>
    <xsl:if test="not(language)">
      <xsl:call-template name="_OutputLanguage"><xsl:with-param name="value" select="@xml:lang" /></xsl:call-template>
    </xsl:if>
    <!-- Figure out the base URL value; xml:base overrides the download URL -->
    <xsl:variable name="baseChannelUrl">
      <xsl:call-template name="_GetFeedBaseUrl">
        <xsl:with-param name="downloadUrl" select="$downloadUrl" />
        <xsl:with-param name="rootNode" select="." />
      </xsl:call-template>
    </xsl:variable>
    <!-- Build a list of referenced nodes from cf:sort and cf:group -->
    <xsl:variable name="cfReferences">
      <xsl:call-template name="_BuildCfReferenceList"><xsl:with-param name="value" select="." /></xsl:call-template>
    </xsl:variable>
    <!-- Process channel elements -->
    <xsl:apply-templates select="*" mode="channel">
      <xsl:with-param name="baseChannelUrl" select="$baseChannelUrl" />
    </xsl:apply-templates>
    <!-- Process items -->
    <xsl:apply-templates select="item">
      <xsl:with-param name="baseChannelUrl" select="$baseChannelUrl" />
      <xsl:with-param name="references" select="$cfReferences" />
    </xsl:apply-templates>
  </xsl:template>
  <xsl:template match="*" mode="channel">
    <xsl:param name="baseChannelUrl" />
    <xsl:variable name="isFirst">
      <xsl:call-template name="_IsFirstChildOfItsKind"><xsl:with-param name="value" select="." /></xsl:call-template>
    </xsl:variable>
    <xsl:choose>
      <xsl:when test="namespace-uri(.) = '' and local-name(.) = 'title' and $isFirst = 'true'">
        <xsl:variable name="type">
          <xsl:call-template name="_GetRSS2TypeValue">
            <xsl:with-param name="type" select="@cf:type" />
            <xsl:with-param name="default" select="'text'" />
          </xsl:call-template>
        </xsl:variable>
        <xsl:call-template name="_OutputTitle">
          <xsl:with-param name="value" select="." />
          <xsl:with-param name="type" select="$type" />
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = '' and local-name(.) = 'link' and $isFirst = 'true'">
        <xsl:variable name="linkUrl">
          <xsl:call-template name="_CompleteUrl">
            <xsl:with-param name="baseUrl" select="$baseChannelUrl" />
            <xsl:with-param name="Url" select="." />
          </xsl:call-template>
        </xsl:variable>
        <xsl:call-template name="_OutputLink"><xsl:with-param name="value" select="$linkUrl" /></xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = '' and local-name(.) = 'description' and $isFirst = 'true'">
        <xsl:variable name="type">
          <xsl:call-template name="_GetRSS2TypeValue">
            <xsl:with-param name="type" select="@cf:type" />
            <xsl:with-param name="default" select="'text'" />
          </xsl:call-template>
        </xsl:variable>
        <xsl:call-template name="_OutputTextDescription">
          <xsl:with-param name="value" select="." />
          <xsl:with-param name="type" select="$type" />
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = '' and local-name(.) = 'pubDate' and $isFirst = 'true'">
        <xsl:call-template name="_OutputPubDate"><xsl:with-param name="value" select="." /></xsl:call-template>
        <xsl:if test="not(../lastBuildDate)">
          <xsl:call-template name="_OutputLastBuildDate"><xsl:with-param name="value" select="." /></xsl:call-template>
          <xsl:if test="not(../atom:updated)">
            <xsl:call-template name="_OutputAtomUpdated"><xsl:with-param name="value" select="." /></xsl:call-template>
          </xsl:if>
        </xsl:if>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSatom1 and local-name(.) = 'published'">
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSatom1 and local-name(.) = 'updated'">
        <xsl:if test="$isFirst = 'true'">
          <xsl:call-template name="_OutputAtomUpdated"><xsl:with-param name="value" select="." /></xsl:call-template>
          <xsl:if test="not(../pubDate) and not(../lastBuildDate)">
            <xsl:call-template name="_OutputLastBuildDate"><xsl:with-param name="value" select="." /></xsl:call-template>
          </xsl:if>
        </xsl:if>  
      </xsl:when>
      <xsl:when test="namespace-uri(.) = '' and local-name(.) = 'language' and $isFirst = 'true'">
        <xsl:call-template name="_OutputLanguage"><xsl:with-param name="value" select="." /></xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = '' and local-name(.) = 'copyright' and $isFirst = 'true'">
        <xsl:variable name="type">
          <xsl:call-template name="_GetRSS2TypeValue">
            <xsl:with-param name="type" select="@cf:type" />
            <xsl:with-param name="default" select="'text'" />
          </xsl:call-template>
        </xsl:variable>
        <xsl:call-template name="_OutputCopyright">
          <xsl:with-param name="value" select="." />
          <xsl:with-param name="type" select="$type" />
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = '' and local-name(.) = 'lastBuildDate' and $isFirst = 'true'">
        <xsl:call-template name="_OutputLastBuildDate"><xsl:with-param name="value" select="." /></xsl:call-template>
        <xsl:if test="not(../atom:updated)">
          <xsl:call-template name="_OutputAtomUpdated"><xsl:with-param name="value" select="." /></xsl:call-template>
        </xsl:if>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = '' and local-name(.) = 'managingEditor' and $isFirst = 'true'">
        <xsl:variable name="convertToAtom">
          <xsl:choose>
            <xsl:when test="../atom:author">false</xsl:when>
            <xsl:otherwise>true</xsl:otherwise>
          </xsl:choose>
        </xsl:variable>
        <xsl:call-template name="_OutputManagingEditor">
          <xsl:with-param name="value" select="." />
          <xsl:with-param name="convertToAtom" select="$convertToAtom" />
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = '' and local-name(.) = 'webMaster' and $isFirst = 'true'">
        <xsl:call-template name="_OutputWebMaster"><xsl:with-param name="value" select="." /></xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = '' and local-name(.) = 'category'">
        <xsl:call-template name="_OutputCategory">
          <xsl:with-param name="value" select="." />
          <xsl:with-param name="domain" select="@domain" />
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = '' and local-name(.) = 'generator' and $isFirst = 'true'">
        <xsl:call-template name="_OutputGenerator">
          <xsl:with-param name="value" select="." />
          <xsl:with-param name="uri" select="@cf:uri" />
          <xsl:with-param name="version" select="@cf:version" />
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = '' and local-name(.) = 'docs' and $isFirst = 'true'">
        <xsl:call-template name="_OutputDocs"><xsl:with-param name="value" select="." /></xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = '' and local-name(.) = 'cloud' and $isFirst = 'true'">
        <xsl:call-template name="_OutputCloud"><xsl:with-param name="value" select="." /></xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = '' and local-name(.) = 'ttl' and $isFirst = 'true'">
        <xsl:call-template name="_OutputTtl"><xsl:with-param name="value" select="." /></xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = '' and local-name(.) = 'image' and $isFirst = 'true'">
        <xsl:variable name="imageUrl">
          <xsl:call-template name="_CompleteUrl">
            <xsl:with-param name="baseUrl" select="$baseChannelUrl" />
            <xsl:with-param name="Url" select="url" />
          </xsl:call-template>
        </xsl:variable>
        <xsl:variable name="imageLink">
          <xsl:call-template name="_CompleteUrl">
            <xsl:with-param name="baseUrl" select="$baseChannelUrl" />
            <xsl:with-param name="Url" select="link" />
          </xsl:call-template>
        </xsl:variable>
        <xsl:call-template name="_OutputImage">
          <xsl:with-param name="url" select="$imageUrl" />
          <xsl:with-param name="title" select="title" />
          <xsl:with-param name="link" select="$imageLink" />
          <xsl:with-param name="width" select="width" />
          <xsl:with-param name="height" select="height" />
          <xsl:with-param name="description" select="description" />
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = '' and local-name(.) = 'rating' and $isFirst = 'true'">
        <xsl:call-template name="_OutputRating"><xsl:with-param name="value" select="." /></xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = '' and local-name(.) = 'textInput' and $isFirst = 'true'">
        <xsl:call-template name="_OutputTextInput">
          <xsl:with-param name="title" select="title" />
          <xsl:with-param name="name" select="name" />
          <xsl:with-param name="link" select="link" />
          <xsl:with-param name="description" select="description" />
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = '' and local-name(.) = 'skipHours' and $isFirst = 'true'">
        <xsl:call-template name="_OutputSkipHours"><xsl:with-param name="value" select="." /></xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = '' and local-name(.) = 'skipDays' and $isFirst = 'true'">
        <xsl:call-template name="_OutputSkipDays"><xsl:with-param name="value" select="." /></xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSatom1 and local-name(.) = 'link'">
        <xsl:call-template name="_OutputAtomLink">
          <xsl:with-param name="href" select="@href" />
          <xsl:with-param name="rel" select="@rel" />
          <xsl:with-param name="type" select="@type" />
          <xsl:with-param name="title" select="@title" />
          <xsl:with-param name="hreflang" select="@hreflang" />
          <xsl:with-param name="length" select="@length" />
          <xsl:with-param name="xmlBase" select="@xml:base" />
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSatom1 and local-name(.) = 'author'">
        <xsl:if test="$isFirst = 'true'">
          <xsl:call-template name="_OutputAtomAuthor">
            <xsl:with-param name="name" select="atom:name" />
            <xsl:with-param name="email" select="atom:email" />
            <xsl:with-param name="uri" select="atom:uri" />
          </xsl:call-template>
        </xsl:if>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSatom1 and local-name(.) = 'contributor'">
          <xsl:call-template name="_OutputAtomContributor">
            <xsl:with-param name="name" select="atom:name" />
            <xsl:with-param name="email" select="atom:email" />
            <xsl:with-param name="uri" select="atom:uri" />
          </xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NScf and local-name(.) = 'treatAs'">
        <xsl:if test="$isFirst = 'true'">
          <xsl:call-template name="_OutputCfTreatAs"><xsl:with-param name="value" select="." /></xsl:call-template>
        </xsl:if>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NScf and local-name(.) = 'listinfo'">
        <xsl:if test="$isFirst = 'true'">
          <xsl:call-template name="_OutputCfListinfo"><xsl:with-param name="value" select="." /></xsl:call-template>
        </xsl:if>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = '' and local-name(.) = 'item'">
        <!-- Do nothing here for items -->
      </xsl:when>
      <!-- Copy extension nodes -->
      <xsl:when test="namespace-uri(.) != ''">
        <xsl:call-template name="_OutputExtension"><xsl:with-param name="value" select="." /></xsl:call-template>
      </xsl:when>
    </xsl:choose>
  </xsl:template>
<!-- Item processing -->
  <xsl:template match="item">
    <xsl:param name="baseChannelUrl" />
    <xsl:param name="references" />
    <item>
      <!-- Copy all namespaces -->
      <xsl:for-each select="namespace::*">
        <xsl:copy />
      </xsl:for-each>
      <xsl:call-template name="_OutputXmlBase"><xsl:with-param name="value" select="@xml:base" /></xsl:call-template>
      <xsl:call-template name="_OutputXmlLang"><xsl:with-param name="value" select="@xml:lang" /></xsl:call-template>
      <!-- Item's base URL stacks onto channel's base URL -->
      <xsl:variable name="baseChannelItemUrl">
        <xsl:call-template name="_CombineUrls">
          <xsl:with-param name="baseUrl" select="$baseChannelUrl" />
          <xsl:with-param name="relUrl" select="@xml:base" />
        </xsl:call-template>
      </xsl:variable>
      <!-- Process item elements -->
      <xsl:apply-templates select="*" mode="item">
        <xsl:with-param name="baseItemUrl" select="$baseChannelItemUrl" />
        <xsl:with-param name="references" select="$references" />
      </xsl:apply-templates>
    </item>
  </xsl:template>
  <xsl:template match="*" mode="item">
    <xsl:param name="baseItemUrl" />
    <xsl:param name="references" />
    <xsl:variable name="isFirst">
      <xsl:call-template name="_IsFirstChildOfItsKind"><xsl:with-param name="value" select="." /></xsl:call-template>
    </xsl:variable>
    <xsl:choose>
      <xsl:when test="namespace-uri(.) = '' and local-name(.) = 'title' and $isFirst = 'true'">
        <xsl:variable name="type">
          <xsl:call-template name="_GetRSS2TypeValue">
            <xsl:with-param name="type" select="@cf:type" />
            <xsl:with-param name="default" select="'text'" />
          </xsl:call-template>
        </xsl:variable>
        <xsl:call-template name="_OutputTitle">
          <xsl:with-param name="value" select="." />
          <xsl:with-param name="type" select="$type" />
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = '' and local-name(.) = 'link' and $isFirst = 'true'">
        <xsl:variable name="linkUrl">
          <xsl:call-template name="_CompleteUrl">
            <xsl:with-param name="baseUrl" select="$baseItemUrl" />
            <xsl:with-param name="Url" select="." />
          </xsl:call-template>
        </xsl:variable>
        <xsl:call-template name="_OutputLink"><xsl:with-param name="value" select="$linkUrl" /></xsl:call-template>
      </xsl:when>
      <xsl:when test="(namespace-uri(.) = '' and local-name(.) = 'author') or (namespace-uri(.) = $_NSdc and local-name(.) = 'creator')">
        <xsl:variable name="convertToAtom">
          <xsl:choose>
            <xsl:when test="../atom:author">false</xsl:when>
            <xsl:otherwise>true</xsl:otherwise>
          </xsl:choose>
        </xsl:variable>
        <xsl:call-template name="_OutputAuthor">
          <xsl:with-param name="value" select="." />
          <xsl:with-param name="convertToAtom" select="$convertToAtom" />
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSatom1 and local-name(.) = 'contributor'">
        <xsl:call-template name="_OutputAtomContributor">
          <xsl:with-param name="name" select="atom:name" />
          <xsl:with-param name="email" select="atom:email" />
          <xsl:with-param name="uri" select="atom:uri" />
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = '' and local-name(.) = 'category'">
        <xsl:call-template name="_OutputCategory">
          <xsl:with-param name="value" select="." />
          <xsl:with-param name="domain" select="@domain" />
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = '' and local-name(.) = 'comments' and $isFirst = 'true'">
        <xsl:variable name="commentUrl">
          <xsl:call-template name="_CompleteUrl">
            <xsl:with-param name="baseUrl" select="$baseItemUrl" />
            <xsl:with-param name="Url" select="." />
          </xsl:call-template>
        </xsl:variable>
        <xsl:call-template name="_OutputComments"><xsl:with-param name="value" select="$commentUrl" /></xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = '' and local-name(.) = 'enclosure'">
        <xsl:variable name="enclosureUrl">
          <xsl:call-template name="_CompleteUrl">
            <xsl:with-param name="baseUrl" select="$baseItemUrl" />
            <xsl:with-param name="Url" select="@url" />
          </xsl:call-template>
        </xsl:variable>
        <xsl:call-template name="_OutputEnclosure">
          <xsl:with-param name="url" select="$enclosureUrl" />
          <xsl:with-param name="length" select="@length" />
          <xsl:with-param name="type" select="@type" />
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = '' and local-name(.) = 'guid' and $isFirst = 'true'">
        <xsl:choose>
          <xsl:when test="normalize-space(@isPermaLink) = 'true' or not(string(@isPermaLink))">
            <xsl:variable name="linkUrl">
              <xsl:call-template name="_CompleteUrl">
                <xsl:with-param name="baseUrl" select="$baseItemUrl" />
                <xsl:with-param name="Url" select="." />
              </xsl:call-template>
            </xsl:variable>
            <xsl:call-template name="_OutputGuid">
              <xsl:with-param name="value" select="$linkUrl" />
              <xsl:with-param name="isPermaLink" select="@isPermaLink" />
            </xsl:call-template>
            <!-- If there is no link we'll use permalink guid instead -->
            <xsl:if test="not(../link)">
              <xsl:call-template name="_OutputLink"><xsl:with-param name="value" select="$linkUrl" /></xsl:call-template>
            </xsl:if>
          </xsl:when>
          <xsl:otherwise>
            <xsl:call-template name="_OutputGuid">
              <xsl:with-param name="value" select="." />
              <xsl:with-param name="isPermaLink" select="@isPermaLink" />
            </xsl:call-template>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = '' and local-name(.) = 'pubDate' and $isFirst = 'true'">
        <xsl:call-template name="_OutputPubDate"><xsl:with-param name="value" select="." /></xsl:call-template>
        <xsl:if test="not(../atom:published)">
          <xsl:call-template name="_OutputAtomPublished"><xsl:with-param name="value" select="." /></xsl:call-template>
        </xsl:if>
        <xsl:if test="not(../atom:updated) and not(../dcterms:modified)">
          <xsl:call-template name="_OutputAtomUpdated"><xsl:with-param name="value" select="." /></xsl:call-template>
        </xsl:if>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSdc and local-name(.) = 'date'">
        <xsl:if test="$isFirst = 'true' and not(../pubDate) and not(../dcterms:modified) and not(../atom:updated)">
          <xsl:call-template name="_OutputAtomUpdated"><xsl:with-param name="value" select="." /></xsl:call-template>
        </xsl:if>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSdcterms and local-name(.) = 'modified'">
        <xsl:if test="$isFirst = 'true' and not(../atom:updated)">
          <xsl:call-template name="_OutputAtomUpdated"><xsl:with-param name="value" select="." /></xsl:call-template>
        </xsl:if>  
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSatom1 and local-name(.) = 'updated'">
        <xsl:if test="$isFirst = 'true'">
          <xsl:call-template name="_OutputAtomUpdated"><xsl:with-param name="value" select="." /></xsl:call-template>
        </xsl:if>  
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSatom1 and local-name(.) = 'published'">
        <xsl:if test="$isFirst = 'true'">
          <xsl:call-template name="_OutputAtomPublished"><xsl:with-param name="value" select="." /></xsl:call-template>
          <xsl:if test="not(../pubDate)">
            <xsl:call-template name="_OutputPubDate"><xsl:with-param name="value" select="." /></xsl:call-template>
          </xsl:if>
        </xsl:if>  
      </xsl:when>
      <xsl:when test="namespace-uri(.) = '' and local-name(.) = 'source' and $isFirst = 'true'">
        <xsl:variable name="srcUrl">
          <xsl:call-template name="_CompleteUrl">
            <xsl:with-param name="baseUrl" select="$baseItemUrl" />
            <xsl:with-param name="Url" select="@url" />
          </xsl:call-template>
        </xsl:variable>
        <xsl:call-template name="_OutputSource">
          <xsl:with-param name="value" select="." />
          <xsl:with-param name="url" select="$srcUrl" />
        </xsl:call-template>
      </xsl:when>
      <!-- content:encoded takes precedence over the description -->
      <xsl:when test="namespace-uri(.) = $_NScontent and local-name(.) = 'encoded'">
        <xsl:if test="$isFirst = 'true'">
          <xsl:variable name="summType">
            <xsl:call-template name="_GetRSS2TypeValue">
              <xsl:with-param name="type" select="../description/@cf:type" />
              <xsl:with-param name="default" select="'html'" />
            </xsl:call-template>
          </xsl:variable>
          <xsl:variable name="baseDescUrl">
            <xsl:call-template name="_CombineUrls">
              <xsl:with-param name="baseUrl" select="$baseItemUrl" />
              <xsl:with-param name="relUrl" select="@xml:base" />
            </xsl:call-template>
          </xsl:variable>
          <xsl:variable name="baseSummUrl">
            <xsl:call-template name="_CombineUrls">
              <xsl:with-param name="baseUrl" select="$baseItemUrl" />
              <xsl:with-param name="relUrl" select="../description/@xml:base" />
            </xsl:call-template>
          </xsl:variable>
          <xsl:call-template name="_OutputDescriptionAndSummary">
            <xsl:with-param name="description" select="." />
            <xsl:with-param name="descriptionType" select="'html'" />
            <xsl:with-param name="descriptionBaseUrl" select="$baseDescUrl" />
            <xsl:with-param name="summary" select="../description" />
            <xsl:with-param name="summaryType" select="$summType" />
            <xsl:with-param name="summaryXmlBase" select="../description/@xml:base" />
            <xsl:with-param name="summaryBaseUrl" select="$baseSummUrl" />
          </xsl:call-template>
        </xsl:if>
      </xsl:when>
      <!-- description will be used if there is no content:encoded -->
      <xsl:when test="namespace-uri(.) = '' and local-name(.) = 'description' and $isFirst = 'true'">
        <xsl:if test="not(../*[namespace-uri(.) = $_NScontent and local-name(.) = 'encoded'])">
          <xsl:variable name="type">
            <xsl:call-template name="_GetRSS2TypeValue">
              <xsl:with-param name="type" select="@cf:type" />
              <xsl:with-param name="default" select="'html'" />
            </xsl:call-template>
          </xsl:variable>
          <xsl:variable name="baseDescUrl">
            <xsl:call-template name="_CombineUrls">
              <xsl:with-param name="baseUrl" select="$baseItemUrl" />
              <xsl:with-param name="relUrl" select="@xml:base" />
            </xsl:call-template>
          </xsl:variable>
          <xsl:call-template name="_OutputDescription">
            <xsl:with-param name="value" select="." />
            <xsl:with-param name="type" select="$type" />
            <xsl:with-param name="baseUrl" select="$baseDescUrl" />
          </xsl:call-template>
        </xsl:if>
      </xsl:when>
      <!-- atom:summary will be preserved unless both content:encoded and description are present -->
      <xsl:when test="namespace-uri(.) = $_NSatom1 and local-name(.) = 'summary'">
        <xsl:if test="$isFirst = 'true' and not(../description and ../*[namespace-uri(.) = $_NScontent and local-name(.) = 'encoded'])">
          <xsl:variable name="baseSummUrl">
            <xsl:call-template name="_CombineUrls">
              <xsl:with-param name="baseUrl" select="$baseItemUrl" />
              <xsl:with-param name="relUrl" select="@xml:base" />
            </xsl:call-template>
          </xsl:variable>
          <xsl:call-template name="_OutputAtomSummary">
            <xsl:with-param name="value" select="." />
            <xsl:with-param name="type" select="@type" />
            <xsl:with-param name="xmlBase" select="@xml:base" />
            <xsl:with-param name="baseUrl" select="$baseSummUrl" />
          </xsl:call-template>
        </xsl:if>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSatom1 and local-name(.) = 'link'">
        <!-- Special handling for item level atom:link with rel=entry-content: complete relative URL -->
        <xsl:variable name="atomLinkUrl">
          <xsl:choose>
            <xsl:when test="@rel = 'entry-content'">
              <xsl:call-template name="_CombineUrls">
                <xsl:with-param name="baseUrl" select="$baseItemUrl" />
                <xsl:with-param name="relUrl" select="@href" />
              </xsl:call-template>
            </xsl:when>
            <xsl:otherwise>
              <xsl:value-of select="@href" />
            </xsl:otherwise>
          </xsl:choose>
        </xsl:variable>
        <xsl:call-template name="_OutputAtomLink">
          <xsl:with-param name="href" select="$atomLinkUrl" />
          <xsl:with-param name="rel" select="@rel" />
          <xsl:with-param name="type" select="@type" />
          <xsl:with-param name="title" select="@title" />
          <xsl:with-param name="hreflang" select="@hreflang" />
          <xsl:with-param name="length" select="@length" />
          <xsl:with-param name="xmlBase" select="@xml:base" />
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSatom1 and local-name(.) = 'author'">
        <xsl:call-template name="_OutputAtomAuthor">
          <xsl:with-param name="name" select="atom:name" />
          <xsl:with-param name="email" select="atom:email" />
          <xsl:with-param name="uri" select="atom:uri" />
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSslash and local-name(.) = 'comments'">
        <xsl:if test="$isFirst = 'true'">
          <xsl:call-template name="_OutputSlashComments"><xsl:with-param name="value" select="." /></xsl:call-template>
        </xsl:if>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSwfw and (local-name(.) = 'commentRss' or local-name(.) = 'commentRSS')">
        <xsl:if test="$isFirst = 'true'">
          <xsl:variable name="commentRssUrl">
            <xsl:call-template name="_CompleteUrl">
              <xsl:with-param name="baseUrl" select="$baseItemUrl" />
              <xsl:with-param name="Url" select="." />
            </xsl:call-template>
          </xsl:variable>
          <xsl:call-template name="_OutputWfwCommentRSS"><xsl:with-param name="value" select="$commentRssUrl" /></xsl:call-template>
        </xsl:if>
      </xsl:when>
      <!-- Copy extension nodes -->
      <xsl:when test="namespace-uri(.) != ''">
        <xsl:call-template name="_OutputExtension">
          <xsl:with-param name="value" select="." />
          <xsl:with-param name="references" select="$references" />
        </xsl:call-template>
      </xsl:when>
    </xsl:choose>
  </xsl:template>
</xsl:stylesheet><?xml version="1.0" ?>
<xsl:stylesheet version="1.0" 
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform" 
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:cf="http://www.microsoft.com/schemas/rss/core/2005"
  xmlns:content="http://purl.org/rss/1.0/modules/content/"
  xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
  xmlns:rss="http://purl.org/rss/1.0/"
  xmlns:dc="http://purl.org/dc/elements/1.1/"
  xmlns:dcterms="http://purl.org/dc/terms/"
  xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
  xmlns:msfeednorm="urn:microsoft:feed-normalization" 
  exclude-result-prefixes="content rdf rss dc dcterms sy msfeednorm"
<!-- Shared templates -->
  <xsl:import href="res://msfeeds.dll/SharedNormalizer.xsl" />
<!-- Output XML UTF-8 -->
  <xsl:output method="xml" encoding="utf-8" />
<!-- Entry point -->
  <xsl:template match="/rdf:RDF">
    <rss version="2.0">
      <channel>
        <!-- Build a list of referenced nodes from cf:sort and cf:group -->
        <xsl:variable name="cfReferences">
          <xsl:call-template name="_BuildCfReferenceList"><xsl:with-param name="value" select="rss:channel" /></xsl:call-template>
        </xsl:variable>
        <!-- Process feed elements -->
        <xsl:apply-templates select="rss:channel" />
        <xsl:apply-templates select="rss:image" />
        <xsl:apply-templates select="rss:textinput" />
        <xsl:apply-templates select="rss:item">
          <xsl:with-param name="references" select="$cfReferences" />
        </xsl:apply-templates>
      </channel>
    </rss>
  </xsl:template>
<!-- Channel processing -->
  <xsl:template match="rss:channel">
    <xsl:apply-templates select="*" mode="channel" />
  </xsl:template>
  <xsl:template match="*" mode="channel">
    <xsl:variable name="isFirst">
      <xsl:call-template name="_IsFirstChildOfItsKind"><xsl:with-param name="value" select="." /></xsl:call-template>
    </xsl:variable>
    <xsl:choose>
      <xsl:when test="namespace-uri(.) = $_NSrss and local-name(.) = 'title' and $isFirst = 'true'">
        <xsl:call-template name="_OutputTitle"><xsl:with-param name="value" select="." /></xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSrss and local-name(.) = 'link' and $isFirst = 'true'">
        <xsl:variable name="linkUrl">
          <xsl:call-template name="_CompleteUrl">
            <xsl:with-param name="baseUrl" select="$downloadUrl" />
            <xsl:with-param name="Url" select="." />
          </xsl:call-template>
        </xsl:variable>
        <xsl:call-template name="_OutputLink"><xsl:with-param name="value" select="$linkUrl" /></xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSrss and local-name(.) = 'description' and $isFirst = 'true'">
        <xsl:call-template name="_OutputTextDescription"><xsl:with-param name="value" select="." /></xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSdc and local-name(.) = 'creator'">
        <xsl:if test="$isFirst = 'true'">
          <xsl:call-template name="_OutputManagingEditor">
            <xsl:with-param name="value" select="." />
            <xsl:with-param name="convertToAtom" select="'true'" />
          </xsl:call-template>
        </xsl:if>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSdc and local-name(.) = 'subject'">
        <xsl:call-template name="_OutputCategory"><xsl:with-param name="value" select="." /></xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSdc and local-name(.) = 'publisher'">
        <xsl:if test="$isFirst = 'true'">
          <xsl:call-template name="_OutputWebMaster"><xsl:with-param name="value" select="." /></xsl:call-template>
        </xsl:if>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSdc and local-name(.) = 'language'">
        <xsl:if test="$isFirst = 'true'">
          <xsl:call-template name="_OutputLanguage"><xsl:with-param name="value" select="." /></xsl:call-template>
        </xsl:if>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSdc and local-name(.) = 'rights'">
        <xsl:if test="$isFirst = 'true'">
          <xsl:call-template name="_OutputCopyright"><xsl:with-param name="value" select="." /></xsl:call-template>
        </xsl:if>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSdcterms and local-name(.) = 'modified'">
        <xsl:if test="$isFirst = 'true'">
          <xsl:call-template name="_OutputLastBuildDate"><xsl:with-param name="value" select="." /></xsl:call-template>
          <xsl:if test="not(../atom:updated)">
            <xsl:call-template name="_OutputAtomUpdated"><xsl:with-param name="value" select="." /></xsl:call-template>
          </xsl:if>
        </xsl:if>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSdc and local-name(.) = 'date'">
        <xsl:if test="$isFirst = 'true'">
          <xsl:call-template name="_OutputPubDate"><xsl:with-param name="value" select="." /></xsl:call-template>
          <xsl:if test="not(../dcterms:modified)">
            <xsl:call-template name="_OutputLastBuildDate"><xsl:with-param name="value" select="." /></xsl:call-template>
            <xsl:if test="not(../atom:updated)">
              <xsl:call-template name="_OutputAtomUpdated"><xsl:with-param name="value" select="." /></xsl:call-template>
            </xsl:if>
          </xsl:if>
        </xsl:if>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSdcterms and local-name(.) = 'available'">
        <xsl:if test="$isFirst = 'true' and not(../dc:date) and not(../dcterms:modified)">
          <xsl:call-template name="_OutputLastBuildDate"><xsl:with-param name="value" select="." /></xsl:call-template>
          <xsl:if test="not(../atom:updated)">
            <xsl:call-template name="_OutputAtomUpdated"><xsl:with-param name="value" select="." /></xsl:call-template>
          </xsl:if>
        </xsl:if>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSdcterms and local-name(.) = 'issued'">
        <xsl:if test="$isFirst = 'true' and not(../dc:date) and not(../dcterms:available) and not(../dcterms:modified)">
          <xsl:call-template name="_OutputLastBuildDate"><xsl:with-param name="value" select="." /></xsl:call-template>
          <xsl:if test="not(../atom:updated)">
            <xsl:call-template name="_OutputAtomUpdated"><xsl:with-param name="value" select="." /></xsl:call-template>
          </xsl:if>
        </xsl:if>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSatom1 and local-name(.) = 'published'">
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSatom1 and local-name(.) = 'updated'">
        <xsl:if test="$isFirst = 'true'">
          <xsl:call-template name="_OutputAtomUpdated"><xsl:with-param name="value" select="." /></xsl:call-template>
          <xsl:if test="not(../dc:date) and not(../dcterms:available) and not(../dcterms:modified) and not(../dcterms:issued)">
            <xsl:call-template name="_OutputLastBuildDate"><xsl:with-param name="value" select="." /></xsl:call-template>
          </xsl:if>
        </xsl:if>
      </xsl:when>
      <!-- First pair of updateFrequency and updatePeriod gets converted to ttl; all sy:* nodes are preserved as extensions -->
      <xsl:when test="namespace-uri(.) = $_NSsy and local-name(.) = 'updatePeriod' and $isFirst = 'true'">
        <xsl:if test="../sy:updateFrequency">
          <xsl:call-template name="_ConvertUpdatesToTtl">
            <xsl:with-param name="updatePeriod" select="string(.)" />
            <xsl:with-param name="updateFrequency" select="string(../sy:updateFrequency)" />
          </xsl:call-template>
        </xsl:if>
        <xsl:call-template name="_OutputExtension"><xsl:with-param name="value" select="." /></xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NScf and local-name(.) = 'treatAs'">
        <xsl:if test="$isFirst = 'true'">
          <xsl:call-template name="_OutputCfTreatAs"><xsl:with-param name="value" select="." /></xsl:call-template>
        </xsl:if>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NScf and local-name(.) = 'listinfo'">
        <xsl:if test="$isFirst = 'true'">
          <xsl:call-template name="_OutputCfListinfo"><xsl:with-param name="value" select="." /></xsl:call-template>
        </xsl:if>
      </xsl:when>
      <!-- Copy extension nodes -->
      <xsl:when test="namespace-uri(.) != $_NSrss and namespace-uri(.) != ''">
        <xsl:call-template name="_OutputExtension"><xsl:with-param name="value" select="." /></xsl:call-template>
      </xsl:when>
    </xsl:choose>
  </xsl:template>
<!-- Image processing -->
  <xsl:template match="rss:image">
    <xsl:if test="position() = 1">
      <xsl:variable name="imageUrl">
        <xsl:call-template name="_CompleteUrl">
          <xsl:with-param name="baseUrl" select="$downloadUrl" />
          <xsl:with-param name="Url" select="rss:url" />
        </xsl:call-template>
      </xsl:variable>
      <xsl:variable name="imageLink">
        <xsl:call-template name="_CompleteUrl">
          <xsl:with-param name="baseUrl" select="$downloadUrl" />
          <xsl:with-param name="Url" select="rss:link" />
        </xsl:call-template>
      </xsl:variable>
      <xsl:call-template name="_OutputImage">
        <xsl:with-param name="url" select="$imageUrl" />
        <xsl:with-param name="title" select="rss:title" />
        <xsl:with-param name="link" select="$imageLink" />
        <xsl:with-param name="subnodesToCopy" select="*[namespace-uri(.) != $_NSrss and namespace-uri(.) != '']" />
      </xsl:call-template>
    </xsl:if>
  </xsl:template>
<!-- Text Input processing -->
  <xsl:template match="rss:textinput">
    <xsl:if test="position() = 1">
      <xsl:variable name="linkUrl">
        <xsl:call-template name="_CompleteUrl">
          <xsl:with-param name="baseUrl" select="$downloadUrl" />
          <xsl:with-param name="Url" select="rss:link" />
        </xsl:call-template>
      </xsl:variable>
      <xsl:call-template name="_OutputTextInput">
        <xsl:with-param name="title" select="rss:title" />
        <xsl:with-param name="name" select="rss:name" />
        <xsl:with-param name="link" select="$linkUrl" />
        <xsl:with-param name="description" select="rss:description" />
        <xsl:with-param name="subnodesToCopy" select="*[namespace-uri(.) != $_NSrss and namespace-uri(.) != '']" />
      </xsl:call-template>
    </xsl:if>
  </xsl:template>
<!-- Item processing -->
  <xsl:template match="rss:item">
    <xsl:param name="references" />
    <item>
      <xsl:call-template name="_OutputXmlLang"><xsl:with-param name="value" select="@xml:lang" /></xsl:call-template>
      <xsl:apply-templates select="* | @*" mode="item">
        <xsl:with-param name="references" select="$references" />
      </xsl:apply-templates>
    </item>
  </xsl:template>
  <xsl:template match="*" mode="item">
    <xsl:param name="references" />
    <xsl:variable name="isFirst">
      <xsl:call-template name="_IsFirstChildOfItsKind"><xsl:with-param name="value" select="." /></xsl:call-template>
    </xsl:variable>
    <xsl:choose>
      <xsl:when test="namespace-uri(.) = $_NSrss and local-name(.) = 'title' and $isFirst = 'true'">
        <xsl:call-template name="_OutputTitle"><xsl:with-param name="value" select="." /></xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSrss and local-name(.) = 'link' and $isFirst = 'true'">
        <xsl:variable name="linkUrl">
          <xsl:call-template name="_CompleteUrl">
            <xsl:with-param name="baseUrl" select="$downloadUrl" />
            <xsl:with-param name="Url" select="." />
          </xsl:call-template>
        </xsl:variable>
        <xsl:call-template name="_OutputLink"><xsl:with-param name="value" select="$linkUrl" /></xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSdc and local-name(.) = 'creator'">
          <xsl:call-template name="_OutputAuthor">
            <xsl:with-param name="value" select="." />
            <xsl:with-param name="convertToAtom" select="'true'" />
          </xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSdc and local-name(.) = 'subject'">
        <xsl:call-template name="_OutputCategory"><xsl:with-param name="value" select="." /></xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSdc and local-name(.) = 'date'">
        <xsl:if test="$isFirst= 'true'">
          <xsl:call-template name="_OutputPubDate"><xsl:with-param name="value" select="." /></xsl:call-template>    
          <xsl:if test="not(../atom:published)">
            <xsl:call-template name="_OutputAtomPublished"><xsl:with-param name="value" select="." /></xsl:call-template>
          </xsl:if>
          <xsl:if test="not(../atom:updated) and not(../dcterms:modified)">
            <xsl:call-template name="_OutputAtomUpdated"><xsl:with-param name="value" select="." /></xsl:call-template>
          </xsl:if>
        </xsl:if>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSatom1 and local-name(.) = 'published'">
        <xsl:if test="$isFirst= 'true'">
          <xsl:call-template name="_OutputAtomPublished"><xsl:with-param name="value" select="." /></xsl:call-template>
          <xsl:if test="not(../dc:date)">
            <xsl:call-template name="_OutputPubDate"><xsl:with-param name="value" select="." /></xsl:call-template>
          </xsl:if> 
        </xsl:if>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSatom1 and local-name(.) = 'updated'">
        <xsl:if test="$isFirst = 'true'">
          <xsl:call-template name="_OutputAtomUpdated"><xsl:with-param name="value" select="." /></xsl:call-template>
        </xsl:if>  
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSdcterms and local-name(.) = 'modified'">
        <xsl:if test="$isFirst = 'true'">
          <xsl:if test="not(../atom:updated)">
            <xsl:call-template name="_OutputAtomUpdated"><xsl:with-param name="value" select="." /></xsl:call-template>
          </xsl:if> 
        </xsl:if>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NScontent and local-name(.) = 'encoded'">
        <xsl:if test="$isFirst = 'true'">
          <xsl:call-template name="_OutputDescriptionAndSummary">
            <xsl:with-param name="description" select="." />
            <xsl:with-param name="descriptionType" select="'html'" />
            <xsl:with-param name="descriptionBaseUrl" select="$downloadUrl" />
            <xsl:with-param name="summary" select="../rss:description" />
            <xsl:with-param name="summaryType" select="'html'" />
            <xsl:with-param name="summaryBaseUrl" select="$downloadUrl" />
          </xsl:call-template>
        </xsl:if>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSrss and local-name(.) = 'description' and $isFirst = 'true'">
        <xsl:if test="not(../content:encoded)">
          <xsl:call-template name="_OutputDescription">
            <xsl:with-param name="value" select="." />
            <xsl:with-param name="type" select="'html'" />
            <xsl:with-param name="baseUrl" select="$downloadUrl" />
          </xsl:call-template>
        </xsl:if>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSslash and local-name(.) = 'comments'">
        <xsl:if test="$isFirst = 'true'">
          <xsl:call-template name="_OutputSlashComments"><xsl:with-param name="value" select="." /></xsl:call-template>
        </xsl:if>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSwfw and (local-name(.) = 'commentRss' or local-name(.) = 'commentRSS')">
        <xsl:if test="$isFirst = 'true'">
          <xsl:variable name="commentRssUrl">
            <xsl:call-template name="_CompleteUrl">
              <xsl:with-param name="baseUrl" select="$downloadUrl" />
              <xsl:with-param name="Url" select="." />
            </xsl:call-template>
          </xsl:variable>
          <xsl:call-template name="_OutputWfwCommentRSS"><xsl:with-param name="value" select="$commentRssUrl" /></xsl:call-template>
        </xsl:if>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSatom1 and local-name(.) = 'link'">
        <!-- Special handling for item level atom:link with rel=entry-content: complete relative URL -->
        <xsl:variable name="atomLinkUrl">
          <xsl:choose>
            <xsl:when test="@rel = 'entry-content'">
              <xsl:call-template name="_CombineUrls">
                <xsl:with-param name="baseUrl" select="$downloadUrl" />
                <xsl:with-param name="relUrl" select="@href" />
              </xsl:call-template>
            </xsl:when>
            <xsl:otherwise>
              <xsl:value-of select="@href" />
            </xsl:otherwise>
          </xsl:choose>
        </xsl:variable>
        <xsl:call-template name="_OutputAtomLink">
          <xsl:with-param name="href" select="$atomLinkUrl" />
          <xsl:with-param name="rel" select="@rel" />
          <xsl:with-param name="type" select="@type" />
          <xsl:with-param name="title" select="@title" />
          <xsl:with-param name="hreflang" select="@hreflang" />
          <xsl:with-param name="length" select="@length" />
          <xsl:with-param name="xmlBase" select="@xml:base" />
        </xsl:call-template>
      </xsl:when>
      <!-- Copy extension nodes -->
      <xsl:when test="namespace-uri(.) != $_NSrss and namespace-uri(.) != ''">
        <xsl:call-template name="_OutputExtension">
          <xsl:with-param name="value" select="." />
          <xsl:with-param name="references" select="$references" />
        </xsl:call-template>
      </xsl:when>
    </xsl:choose>
  </xsl:template>
  <xsl:template match="@*" mode="item">
    <!-- No need to check if first, because XML doesn't allow duplicate attributes -->
    <xsl:if test="namespace-uri(.) = $_NSrdf and local-name(.) = 'about'">
      <xsl:call-template name="_OutputGuid">
        <xsl:with-param name="value" select="." />
        <xsl:with-param name="isPermaLink" select="'false'" />
      </xsl:call-template>
    </xsl:if>
  </xsl:template>
</xsl:stylesheet>
<xsl:stylesheet version="1.0" 
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform" 
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:cf="http://www.microsoft.com/schemas/rss/core/2005"
  xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
  xmlns:atom03="http://purl.org/atom/ns#"
  xmlns:msfeednorm="urn:microsoft:feed-normalization"
  exclude-result-prefixes="sy atom03 msfeednorm"
<!-- Shared templates -->
  <xsl:import href="res://msfeeds.dll/SharedNormalizer.xsl" />
<!-- Output XML UTF-8 -->
  <xsl:output method="xml" encoding="utf-8" />
<!-- Entry point -->
  <xsl:template match="/atom03:feed">
    <rss version="2.0">
      <channel>
        <xsl:call-template name="_OutputXmlBase"><xsl:with-param name="value" select="@xml:base" /></xsl:call-template>
        <xsl:call-template name="_OutputXmlLang"><xsl:with-param name="value" select="@xml:lang" /></xsl:call-template>
        <xsl:call-template name="_OutputLanguage"><xsl:with-param name="value" select="@xml:lang" /></xsl:call-template>
        <!-- Figure out the base URL value; xml:base overrides the download URL -->
        <xsl:variable name="baseChannelUrl">
          <xsl:call-template name="_GetFeedBaseUrl">
            <xsl:with-param name="downloadUrl" select="$downloadUrl" />
            <xsl:with-param name="rootNode" select="." />
          </xsl:call-template>
        </xsl:variable>
        <!-- Try to find the main link - one that has an href pointing to html and with type alternate -->
        <xsl:variable name="mainLink" select="atom03:link[(@rel = 'alternate' or @rel = '' or not(@rel)) and (@type = 'text/html' or @type = '' or not(@type))]" />
        <!-- Output link -->
        <xsl:if test="$mainLink">
          <!-- Combine base URL with the main link -->
          <xsl:variable name="channelLinkUrl">
            <xsl:call-template name="_CompleteUrlTwoBase">
              <xsl:with-param name="baseUrl1" select="$baseChannelUrl" />
              <xsl:with-param name="baseUrl2" select="$mainLink/@xml:base" />
              <xsl:with-param name="Url" select="$mainLink/@href" />
            </xsl:call-template>
          </xsl:variable>
          <xsl:call-template name="_OutputLink"><xsl:with-param name="value" select="$channelLinkUrl" /></xsl:call-template>
        </xsl:if>
        <!-- Build a list of referenced nodes from cf:sort and cf:group -->
        <xsl:variable name="cfReferences">
          <xsl:call-template name="_BuildCfReferenceList"><xsl:with-param name="value" select="." /></xsl:call-template>
        </xsl:variable>
        <!-- Process channel elements -->
        <xsl:apply-templates select="*" mode="channel">
          <xsl:with-param name="baseChannelUrl" select="$baseChannelUrl" />
        </xsl:apply-templates>
        <!-- Process items -->
        <xsl:apply-templates select="atom03:entry">
          <xsl:with-param name="baseChannelUrl" select="$baseChannelUrl" />
          <xsl:with-param name="references" select="$cfReferences" />
        </xsl:apply-templates>
      </channel>
    </rss>
  </xsl:template>
<!-- Channel processing -->
  <xsl:template match="*" mode="channel">
    <xsl:param name="baseChannelUrl" />
    <xsl:variable name="isFirst">
      <xsl:call-template name="_IsFirstChildOfItsKind"><xsl:with-param name="value" select="." /></xsl:call-template>
    </xsl:variable>
    <xsl:choose>
      <xsl:when test="namespace-uri(.) = $_NSatom03 and local-name(.) = 'title' and $isFirst = 'true'">
        <xsl:call-template name="_OutputTitle">
          <xsl:with-param name="value" select="." />
          <xsl:with-param name="type" select="@type" />
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSatom03 and local-name(.) = 'author'">
        <!-- First one gets converted to managing Editor -->
        <xsl:if test="$isFirst = 'true'">
          <xsl:variable name="manEditor">
            <xsl:call-template name="_ConvertAtomAuthorToAuthor">
              <xsl:with-param name="name" select="atom03:name" />
              <xsl:with-param name="email" select="atom03:email" />
            </xsl:call-template>
          </xsl:variable>
          <xsl:call-template name="_OutputManagingEditor"><xsl:with-param name="value" select="$manEditor" /></xsl:call-template>
        </xsl:if>
        <!-- Map to Atom 1.0 -->
        <xsl:call-template name="_OutputAtomAuthor">
          <xsl:with-param name="name" select="atom03:name" />
          <xsl:with-param name="email" select="atom03:email" />
          <xsl:with-param name="uri" select="atom03:url" />
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSatom03 and local-name(.) = 'contributor'">
        <!-- Map to Atom 1.0 -->
        <xsl:call-template name="_OutputAtomContributor">
          <xsl:with-param name="name" select="atom03:name" />
          <xsl:with-param name="email" select="atom03:email" />
          <xsl:with-param name="uri" select="atom03:url" />
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSatom03 and local-name(.) = 'tagline' and $isFirst = 'true'">
        <xsl:call-template name="_OutputTextDescription">
          <xsl:with-param name="value" select="." />
          <xsl:with-param name="type" select="@type" />
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSatom03 and local-name(.) = 'id' and $isFirst = 'true'">
        <xsl:call-template name="_OutputGuid">
          <xsl:with-param name="value" select="." />
          <xsl:with-param name="isPermaLink" select="'false'" />
          <xsl:with-param name="channelGuid" select="'true'" />
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSatom03 and local-name(.) = 'generator' and $isFirst = 'true'">
        <xsl:call-template name="_OutputGenerator">
          <xsl:with-param name="value" select="." />
          <xsl:with-param name="uri" select="@url" />
          <xsl:with-param name="version" select="@version" />
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSatom03 and local-name(.) = 'modified' and $isFirst = 'true'">
        <xsl:call-template name="_OutputLastBuildDate"><xsl:with-param name="value" select="." /></xsl:call-template>
        <xsl:variable name="updatedExists">
          <xsl:choose>
            <xsl:when test="../atom:updated">true</xsl:when>
            <xsl:otherwise>false</xsl:otherwise>
          </xsl:choose>
        </xsl:variable>
        <xsl:if test="$updatedExists = 'false'">
          <xsl:call-template name="_OutputAtomUpdated"><xsl:with-param name="value" select="." /></xsl:call-template>
        </xsl:if>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSatom1 and local-name(.) = 'published'">
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSatom1 and local-name(.) = 'updated'">
        <xsl:if test="$isFirst = 'true'">
          <xsl:call-template name="_OutputAtomUpdated"><xsl:with-param name="value" select="." /></xsl:call-template>
          <xsl:if test="not(../atom03:modified)">
            <xsl:call-template name="_OutputLastBuildDate"><xsl:with-param name="value" select="." /></xsl:call-template>
          </xsl:if>
        </xsl:if>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSatom03 and local-name(.) = 'copyright' and $isFirst = 'true'">
        <xsl:call-template name="_OutputCopyright">
          <xsl:with-param name="value" select="." />
          <xsl:with-param name="type" select="@type" />
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSdc and local-name(.) = 'subject'">
        <xsl:call-template name="_OutputCategory"><xsl:with-param name="value" select="." /></xsl:call-template>
      </xsl:when>
      <!-- First pair of updateFrequency and updatePeriod gets converted to ttl; all sy:* nodes are preserved as extensions -->
      <xsl:when test="namespace-uri(.) = $_NSsy and local-name(.) = 'updatePeriod' and $isFirst = 'true'">
        <xsl:if test="../sy:updateFrequency">
          <xsl:call-template name="_ConvertUpdatesToTtl">
            <xsl:with-param name="updatePeriod" select="string(.)" />
            <xsl:with-param name="updateFrequency" select="string(../sy:updateFrequency)" />
          </xsl:call-template>
          <xsl:call-template name="_OutputExtension"><xsl:with-param name="value" select="." /></xsl:call-template>
        </xsl:if>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NScf and local-name(.) = 'treatAs'">
        <xsl:if test="$isFirst = 'true'">
          <xsl:call-template name="_OutputCfTreatAs"><xsl:with-param name="value" select="." /></xsl:call-template>
        </xsl:if>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NScf and local-name(.) = 'listinfo'">
        <xsl:if test="$isFirst = 'true'">
          <xsl:call-template name="_OutputCfListinfo"><xsl:with-param name="value" select="." /></xsl:call-template>
        </xsl:if>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSatom03 and local-name(.) = 'entry'">
        <!-- Do nothing here for items -->
      </xsl:when>
      <!-- Copy extension nodes -->
      <xsl:when test="namespace-uri(.) != $_NSatom03 and namespace-uri(.) != ''">
        <xsl:call-template name="_OutputExtension"><xsl:with-param name="value" select="." /></xsl:call-template>
      </xsl:when>
    </xsl:choose>
  </xsl:template>
<!-- Item processing -->
  <xsl:template match="atom03:entry">
    <xsl:param name="baseChannelUrl" />
    <xsl:param name="references" />
    <item>
      <xsl:call-template name="_OutputXmlBase"><xsl:with-param name="value" select="@xml:base" /></xsl:call-template>
      <xsl:call-template name="_OutputXmlLang"><xsl:with-param name="value" select="@xml:lang" /></xsl:call-template>
      <!-- Item's base URL stacks onto channel's base URL -->
      <xsl:variable name="baseChannelItemUrl">
        <xsl:call-template name="_CombineUrls">
          <xsl:with-param name="baseUrl" select="$baseChannelUrl" />
          <xsl:with-param name="relUrl" select="@xml:base" />
        </xsl:call-template>
      </xsl:variable>
      <!-- Try to find the main link - one that has an href pointing to html and with type alternate -->
      <xsl:variable name="mainLink" select="atom03:link[(@rel = 'alternate' or @rel = '' or not(@rel)) and (@type = 'text/html' or @type = '' or not(@type))]" />
      <!-- Output link -->
      <xsl:if test="$mainLink">
        <!-- Combine base URL with the main link -->
        <xsl:variable name="itemLinkUrl">
          <xsl:call-template name="_CompleteUrlTwoBase">
            <xsl:with-param name="baseUrl1" select="$baseChannelItemUrl" />
            <xsl:with-param name="baseUrl2" select="$mainLink/@xml:base" />
            <xsl:with-param name="Url" select="$mainLink/@href" />
          </xsl:call-template>
        </xsl:variable>
        <xsl:call-template name="_OutputLink"><xsl:with-param name="value" select="$itemLinkUrl" /></xsl:call-template>
      </xsl:if>
      <xsl:apply-templates select="*" mode="item">
        <xsl:with-param name="baseItemUrl" select="$baseChannelItemUrl" />
        <xsl:with-param name="references" select="$references" />
      </xsl:apply-templates>
    </item>
  </xsl:template>
  <xsl:template match="*" mode="item">
    <xsl:param name="baseItemUrl" />
    <xsl:param name="references" />
    <xsl:variable name="isFirst">
      <xsl:call-template name="_IsFirstChildOfItsKind"><xsl:with-param name="value" select="." /></xsl:call-template>
    </xsl:variable>
    <xsl:choose>
      <xsl:when test="namespace-uri(.) = $_NSatom03 and local-name(.) = 'title' and $isFirst = 'true'">
        <xsl:call-template name="_OutputTitle">
          <xsl:with-param name="value" select="." />
          <xsl:with-param name="type" select="@type" />
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSatom03 and local-name(.) = 'link' and @rel = 'enclosure' and (@href or @length or @type)">
        <xsl:variable name="enclosureUrl">
          <xsl:call-template name="_CompleteUrlTwoBase">
            <xsl:with-param name="baseUrl1" select="$baseItemUrl" />
            <xsl:with-param name="baseUrl2" select="@xml:base" />
            <xsl:with-param name="Url" select="@href" />
          </xsl:call-template>
        </xsl:variable>
        <xsl:call-template name="_OutputEnclosure">
          <xsl:with-param name="url" select="$enclosureUrl" />
          <xsl:with-param name="length" select="@length" />
          <xsl:with-param name="type" select="@type" />
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSatom03 and local-name(.) = 'author'">
        <xsl:variable name="author">
          <xsl:call-template name="_ConvertAtomAuthorToAuthor">
            <xsl:with-param name="name" select="atom03:name" />
            <xsl:with-param name="email" select="atom03:email" />
          </xsl:call-template>
        </xsl:variable>
        <xsl:call-template name="_OutputAuthor"><xsl:with-param name="value" select="$author" /></xsl:call-template>
        <!-- Map to Atom 1.0 -->
        <xsl:call-template name="_OutputAtomAuthor">
          <xsl:with-param name="name" select="atom03:name" />
          <xsl:with-param name="email" select="atom03:email" />
          <xsl:with-param name="uri" select="atom03:url" />
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSatom03 and local-name(.) = 'contributor'">
        <!-- Map to Atom 1.0 -->
        <xsl:call-template name="_OutputAtomContributor">
          <xsl:with-param name="name" select="atom03:name" />
          <xsl:with-param name="email" select="atom03:email" />
          <xsl:with-param name="uri" select="atom03:url" />
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSatom03 and local-name(.) = 'id' and $isFirst = 'true'">
        <xsl:call-template name="_OutputGuid">
          <xsl:with-param name="value" select="." />
          <xsl:with-param name="isPermaLink" select="'false'" />
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSatom1 and local-name(.) = 'published'">
        <xsl:if test="$isFirst = 'true'">
          <xsl:call-template name="_OutputAtomPublished"><xsl:with-param name="value" select="." /></xsl:call-template>
          <xsl:if test="not(../atom03:issued)">
            <xsl:call-template name="_OutputPubDate"><xsl:with-param name="value" select="." /></xsl:call-template>
          </xsl:if>
        </xsl:if>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSatom1 and local-name(.) = 'updated'">
        <xsl:if test="$isFirst = 'true'">
          <xsl:call-template name="_OutputAtomUpdated"><xsl:with-param name="value" select="." /></xsl:call-template>
        </xsl:if>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSatom03 and local-name(.) = 'modified' and $isFirst = 'true'">
        <xsl:if test="not(../atom:updated)">
          <xsl:call-template name="_OutputAtomUpdated"><xsl:with-param name="value" select="." /></xsl:call-template>
        </xsl:if>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSatom03 and local-name(.) = 'issued' and $isFirst = 'true'">
        <xsl:call-template name="_OutputPubDate"><xsl:with-param name="value" select="." /></xsl:call-template>
        <xsl:if test="not(../atom:updated) and not(../atom03:modified)">
          <xsl:call-template name="_OutputAtomUpdated"><xsl:with-param name="value" select="." /></xsl:call-template>
        </xsl:if>
        <xsl:if test="not(../atom:published)">
          <xsl:call-template name="_OutputAtomPublished"><xsl:with-param name="value" select="." /></xsl:call-template>
        </xsl:if>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSdc and local-name(.) = 'subject'">
        <xsl:call-template name="_OutputCategory"><xsl:with-param name="value" select="." /></xsl:call-template>
      </xsl:when>
      <!-- Handle content: printable goes into description; non-printable is preserved -->
      <xsl:when test="namespace-uri(.) = $_NSatom03 and local-name(.) = 'content' and $isFirst = 'true'">
          <xsl:if test="@type = '' or not(@type) or @type = 'text/plain' or @type = 'text/html' or @type = 'application/xhtml+xml'">
            <xsl:variable name="baseContentUrl">
              <xsl:call-template name="_CombineUrls">
                <xsl:with-param name="baseUrl" select="$baseItemUrl" />
                <xsl:with-param name="relUrl" select="@xml:base" />
              </xsl:call-template>
            </xsl:variable>
            <xsl:call-template name="_OutputDescription">
              <xsl:with-param name="value" select="." />
              <xsl:with-param name="type" select="@type" />
              <xsl:with-param name="baseUrl" select="$baseContentUrl" />
            </xsl:call-template>
          </xsl:if>
      </xsl:when>
      <!-- Handle summary: printable goes into description or atom:summary; non-printable is discarded -->
      <xsl:when test="namespace-uri(.) = $_NSatom03 and local-name(.) = 'summary' and $isFirst = 'true'">
        <xsl:if test="@type = '' or not(@type) or @type = 'text/plain' or @type = 'text/html' or @type = 'application/xhtml+xml'">
          <xsl:variable name="baseContentUrl">
            <xsl:call-template name="_CombineUrls">
              <xsl:with-param name="baseUrl" select="$baseItemUrl" />
              <xsl:with-param name="relUrl" select="@xml:base" />
            </xsl:call-template>
          </xsl:variable>
          <xsl:choose>
            <xsl:when test="not(../atom03:content[@type = '' or not(@type) or @type = 'text/plain' or @type = 'text/html' or @type = 'application/xhtml+xml'])">
              <xsl:call-template name="_OutputDescription">
                <xsl:with-param name="value" select="." />
                <xsl:with-param name="type" select="@type" />
                <xsl:with-param name="baseUrl" select="$baseContentUrl" />
              </xsl:call-template>
            </xsl:when>
            <xsl:otherwise>
              <!-- Map to Atom 1.0 -->
              <xsl:call-template name="_OutputAtomSummary">
                <xsl:with-param name="value" select="." />
                <xsl:with-param name="type" select="@type" />
                <xsl:with-param name="xmlBase" select="@xml:base" />
                <xsl:with-param name="baseUrl" select="$baseContentUrl" />
              </xsl:call-template>
            </xsl:otherwise>
          </xsl:choose>
        </xsl:if>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSslash and local-name(.) = 'comments'">
        <xsl:if test="$isFirst = 'true'">
          <xsl:call-template name="_OutputSlashComments"><xsl:with-param name="value" select="." /></xsl:call-template>
        </xsl:if>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSwfw and (local-name(.) = 'commentRss' or local-name(.) = 'commentRSS')">
        <xsl:if test="$isFirst = 'true'">
          <xsl:variable name="commentRssUrl">
            <xsl:call-template name="_CompleteUrlTwoBase">
              <xsl:with-param name="baseUrl1" select="$baseItemUrl" />
              <xsl:with-param name="baseUrl2" select="@xml:base" />
              <xsl:with-param name="Url" select="." />
            </xsl:call-template>
          </xsl:variable>
          <xsl:call-template name="_OutputWfwCommentRSS"><xsl:with-param name="value" select="$commentRssUrl" /></xsl:call-template>
        </xsl:if>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSatom1 and local-name(.) = 'link'">
        <!-- Special handling for item level atom:link with rel=entry-content: complete relative URL -->
        <xsl:variable name="atomLinkUrl">
          <xsl:choose>
            <xsl:when test="@rel = 'entry-content'">
              <xsl:call-template name="_CombineUrls">
                <xsl:with-param name="baseUrl" select="$baseItemUrl" />
                <xsl:with-param name="relUrl" select="@href" />
              </xsl:call-template>
            </xsl:when>
            <xsl:otherwise>
              <xsl:value-of select="@href" />
            </xsl:otherwise>
          </xsl:choose>
        </xsl:variable>
        <xsl:call-template name="_OutputAtomLink">
          <xsl:with-param name="href" select="$atomLinkUrl" />
          <xsl:with-param name="rel" select="@rel" />
          <xsl:with-param name="type" select="@type" />
          <xsl:with-param name="title" select="@title" />
          <xsl:with-param name="hreflang" select="@hreflang" />
          <xsl:with-param name="length" select="@length" />
          <xsl:with-param name="xmlBase" select="@xml:base" />
        </xsl:call-template>
      </xsl:when>
      <!-- Copy extension nodes -->
      <xsl:when test="namespace-uri(.) != $_NSatom03 and namespace-uri(.) != ''">
        <xsl:call-template name="_OutputExtension">
          <xsl:with-param name="value" select="." />
          <xsl:with-param name="references" select="$references" />
        </xsl:call-template>
      </xsl:when>
    </xsl:choose>
  </xsl:template>
</xsl:stylesheet>
<xsl:stylesheet version="1.0" 
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform" 
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:cf="http://www.microsoft.com/schemas/rss/core/2005"
  xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
  xmlns:msfeednorm="urn:microsoft:feed-normalization"
  exclude-result-prefixes="sy msfeednorm"
<!-- Shared templates -->
  <xsl:import href="res://msfeeds.dll/SharedNormalizer.xsl" />
<!-- Output XML UTF-8 -->
  <xsl:output method="xml" encoding="utf-8" />
<!-- Entry point -->
  <xsl:template match="/atom:feed">
    <rss version="2.0">
      <channel>
        <xsl:call-template name="_OutputXmlBase"><xsl:with-param name="value" select="@xml:base" /></xsl:call-template>
        <xsl:call-template name="_OutputXmlLang"><xsl:with-param name="value" select="@xml:lang" /></xsl:call-template>
        <xsl:call-template name="_OutputLanguage"><xsl:with-param name="value" select="@xml:lang" /></xsl:call-template>
        <!-- Figure out the base URL value; xml:base overrides the download URL -->
        <xsl:variable name="baseChannelUrl">
          <xsl:call-template name="_GetFeedBaseUrl">
            <xsl:with-param name="downloadUrl" select="$downloadUrl" />
            <xsl:with-param name="rootNode" select="." />
          </xsl:call-template>
        </xsl:variable>
        <!-- Try to find the main link - one that has an href pointing to html and with type alternate -->
        <xsl:variable name="mainLink" select="atom:link[(@rel = 'alternate' or @rel = '' or not(@rel)) and (@type = 'text/html' or @type = '' or not(@type))]" />
        <!-- Combine base URL with the main link -->
        <xsl:variable name="channelLinkUrl">
          <xsl:call-template name="_CompleteUrlTwoBase">
            <xsl:with-param name="baseUrl1" select="$baseChannelUrl" />
            <xsl:with-param name="baseUrl2" select="$mainLink/@xml:base" />
            <xsl:with-param name="Url" select="$mainLink/@href" />
          </xsl:call-template>
        </xsl:variable>
        <xsl:if test="$mainLink">
          <xsl:call-template name="_OutputLink"><xsl:with-param name="value" select="$channelLinkUrl" /></xsl:call-template>
        </xsl:if>
        <xsl:if test="atom:logo">
          <xsl:variable name="logoImageUrl">
            <xsl:call-template name="_CompleteUrlTwoBase">
              <xsl:with-param name="baseUrl1" select="$baseChannelUrl" />
              <xsl:with-param name="baseUrl2" select="atom:logo/@xml:base" />
              <xsl:with-param name="Url" select="atom:logo" />
            </xsl:call-template>
          </xsl:variable>
          <xsl:call-template name="_OutputImage">
            <xsl:with-param name="url" select="$logoImageUrl" />
            <xsl:with-param name="title" select="atom:title" />
            <xsl:with-param name="titleType" select="atom:title/@type" />
            <xsl:with-param name="link" select="$channelLinkUrl" />
          </xsl:call-template>
        </xsl:if>
        <!-- Build a list of referenced nodes from cf:sort and cf:group -->
        <xsl:variable name="cfReferences">
          <xsl:call-template name="_BuildCfReferenceList"><xsl:with-param name="value" select="." /></xsl:call-template>
        </xsl:variable>
        <xsl:apply-templates select="*" mode="channel">
          <xsl:with-param name="baseChannelUrl" select="$baseChannelUrl" />
        </xsl:apply-templates>
        <xsl:apply-templates select="atom:entry">
          <xsl:with-param name="baseChannelUrl" select="$baseChannelUrl" />
          <xsl:with-param name="references" select="$cfReferences" />
        </xsl:apply-templates>
      </channel>
    </rss>
  </xsl:template>
<!-- Channel processing -->
  <xsl:template match="*" mode="channel">
    <xsl:param name="baseChannelUrl" />
    <xsl:variable name="isFirst">
      <xsl:call-template name="_IsFirstChildOfItsKind"><xsl:with-param name="value" select="." /></xsl:call-template>
    </xsl:variable>
    <xsl:choose>
      <xsl:when test="namespace-uri(.) = $_NSatom1 and local-name(.) = 'updated'">
        <xsl:if test="$isFirst = 'true'">
          <xsl:call-template name="_OutputAtomUpdated"><xsl:with-param name="value" select="." /><xsl:with-param name="type" select="@type" /></xsl:call-template>
          <xsl:call-template name="_OutputLastBuildDate"><xsl:with-param name="value" select="." /><xsl:with-param name="type" select="@type" /></xsl:call-template>
        </xsl:if>
        
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSatom1 and local-name(.) = 'title' and $isFirst = 'true'">
        <xsl:call-template name="_OutputTitle">
          <xsl:with-param name="value" select="." />
          <xsl:with-param name="type" select="@type" />
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSatom1 and local-name(.) = 'author'">
        <!-- First one gets converted to managing Editor -->
        <xsl:if test="$isFirst = 'true'">
          <xsl:variable name="manEditor">
            <xsl:call-template name="_ConvertAtomAuthorToAuthor">
              <xsl:with-param name="name" select="atom:name" />
              <xsl:with-param name="email" select="atom:email" />
            </xsl:call-template>
          </xsl:variable>
          <xsl:call-template name="_OutputManagingEditor"><xsl:with-param name="value" select="$manEditor" /></xsl:call-template>
        </xsl:if>
        <!-- We also make a full copy of every atom:author -->
        <xsl:call-template name="_OutputAtomAuthor">
          <xsl:with-param name="name" select="atom:name" />
          <xsl:with-param name="email" select="atom:email" />
          <xsl:with-param name="uri" select="atom:uri" />
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSatom1 and local-name(.) = 'contributor'">
        <xsl:call-template name="_OutputAtomContributor">
          <xsl:with-param name="name" select="atom:name" />
          <xsl:with-param name="email" select="atom:email" />
          <xsl:with-param name="uri" select="atom:uri" />
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSatom1 and local-name(.) = 'subtitle' and $isFirst = 'true'">
        <xsl:call-template name="_OutputTextDescription">
          <xsl:with-param name="value" select="." />
          <xsl:with-param name="type" select="@type" />
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSatom1 and local-name(.) = 'id' and $isFirst = 'true'">
        <xsl:call-template name="_OutputGuid">
          <xsl:with-param name="value" select="." />
          <xsl:with-param name="isPermaLink" select="'false'" />
          <xsl:with-param name="channelGuid" select="'true'" />
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSatom1 and local-name(.) = 'generator' and $isFirst = 'true'">
        <xsl:call-template name="_OutputGenerator">
          <xsl:with-param name="value" select="." />
          <xsl:with-param name="uri" select="@uri" />
          <xsl:with-param name="version" select="@version" />
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSatom1 and local-name(.) = 'rights' and $isFirst = 'true'">
        <xsl:call-template name="_OutputCopyright">
          <xsl:with-param name="value" select="." />
          <xsl:with-param name="type" select="@type" />
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSatom1 and local-name(.) = 'link'">
        <xsl:call-template name="_OutputAtomLink">
          <xsl:with-param name="href" select="@href" />
          <xsl:with-param name="rel" select="@rel" />
          <xsl:with-param name="type" select="@type" />
          <xsl:with-param name="title" select="@title" />
          <xsl:with-param name="hreflang" select="@hreflang" />
          <xsl:with-param name="length" select="@length" />
          <xsl:with-param name="xmlBase" select="@xml:base" />
        </xsl:call-template>
      </xsl:when>
      <!-- First pair of updateFrequency and updatePeriod gets converted to ttl; all sy:* nodes are preserved as extensions -->
      <xsl:when test="namespace-uri(.) = $_NSsy and local-name(.) = 'updatePeriod' and $isFirst = 'true'">
        <xsl:if test="../sy:updateFrequency">
          <xsl:call-template name="_ConvertUpdatesToTtl">
            <xsl:with-param name="updatePeriod" select="string(.)" />
            <xsl:with-param name="updateFrequency" select="string(../sy:updateFrequency)" />
          </xsl:call-template>
        </xsl:if>
        <xsl:call-template name="_OutputExtension"><xsl:with-param name="value" select="." /></xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NScf and local-name(.) = 'treatAs'">
        <xsl:if test="$isFirst = 'true'">
          <xsl:call-template name="_OutputCfTreatAs"><xsl:with-param name="value" select="." /></xsl:call-template>
        </xsl:if>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NScf and local-name(.) = 'listinfo'">
        <xsl:if test="$isFirst = 'true'">
          <xsl:call-template name="_OutputCfListinfo"><xsl:with-param name="value" select="." /></xsl:call-template>
        </xsl:if>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSatom1 and local-name(.) = 'entry'">
        <!-- Do nothing here for items -->
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSmon and local-name(.) = 'expiration'">
        <xsl:if test="$isFirst = 'true'">
          <xsl:call-template name="_OutputMonExpiration"><xsl:with-param name="value" select="." /><xsl:with-param name="type" select="@type" /></xsl:call-template>
        </xsl:if>
      </xsl:when>
      <!-- Copy extension nodes -->
      <xsl:when test="namespace-uri(.) != $_NSatom1 and namespace-uri(.) != ''">
        <xsl:call-template name="_OutputExtension"><xsl:with-param name="value" select="." /></xsl:call-template>
      </xsl:when>
    </xsl:choose>
  </xsl:template>
<!-- Item processing -->
  <xsl:template match="atom:entry">
    <xsl:param name="baseChannelUrl" />
    <xsl:param name="references" />
    <item>
      <xsl:call-template name="_OutputXmlBase"><xsl:with-param name="value" select="@xml:base" /></xsl:call-template>
      <xsl:call-template name="_OutputXmlLang"><xsl:with-param name="value" select="@xml:lang" /></xsl:call-template>
      <!-- Item's base URL stacks onto channel's base URL -->
      <xsl:variable name="baseChannelItemUrl">
        <xsl:call-template name="_CombineUrls">
          <xsl:with-param name="baseUrl" select="$baseChannelUrl" />
          <xsl:with-param name="relUrl" select="@xml:base" />
        </xsl:call-template>
      </xsl:variable>
      <!-- Try to find the main link - one that has an href pointing to html and with type alternate -->
      <xsl:variable name="mainLink" select="atom:link[(@rel = 'alternate' or @rel = '' or not(@rel)) and (@type = 'text/html' or @type = '' or not(@type))]" />
      <!-- Output link -->
      <xsl:if test="$mainLink">
        <!-- Combine base URL with the main link -->
        <xsl:variable name="itemLinkUrl">
          <xsl:call-template name="_CompleteUrlTwoBase">
            <xsl:with-param name="baseUrl1" select="$baseChannelItemUrl" />
            <xsl:with-param name="baseUrl2" select="$mainLink/@xml:base" />
            <xsl:with-param name="Url" select="$mainLink/@href" />
          </xsl:call-template>
        </xsl:variable>
        <xsl:call-template name="_OutputLink"><xsl:with-param name="value" select="$itemLinkUrl" /></xsl:call-template>
      </xsl:if>
      <xsl:apply-templates select="*" mode="item">
        <xsl:with-param name="baseItemUrl" select="$baseChannelItemUrl" />
        <xsl:with-param name="references" select="$references" />
      </xsl:apply-templates>
    </item>
  </xsl:template>
  <xsl:template match="*" mode="item">
    <xsl:param name="baseItemUrl" />
    <xsl:param name="references" />
    <xsl:variable name="isFirst">
      <xsl:call-template name="_IsFirstChildOfItsKind"><xsl:with-param name="value" select="." /></xsl:call-template>
    </xsl:variable>
    <xsl:choose>
      <!-- Process items -->
      <xsl:when test="namespace-uri(.) = $_NSatom1 and local-name(.) = 'title' and $isFirst = 'true'">
        <xsl:call-template name="_OutputTitle">
          <xsl:with-param name="value" select="." />
          <xsl:with-param name="type" select="@type" />
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSatom1 and local-name(.) = 'link' and @rel = 'enclosure' and (@href or @length or @type)">
        <xsl:variable name="enclosureUrl">
          <xsl:call-template name="_CompleteUrlTwoBase">
            <xsl:with-param name="baseUrl1" select="$baseItemUrl" />
            <xsl:with-param name="baseUrl2" select="@xml:base" />
            <xsl:with-param name="Url" select="@href" />
          </xsl:call-template>
        </xsl:variable>
        <xsl:call-template name="_OutputEnclosure">
          <xsl:with-param name="url" select="$enclosureUrl" />
          <xsl:with-param name="length" select="@length" />
          <xsl:with-param name="type" select="@type" />
        </xsl:call-template>
        <!-- We also make a full copy of the atom:link -->
        <xsl:call-template name="_OutputAtomLink">
          <xsl:with-param name="href" select="@href" />
          <xsl:with-param name="rel" select="@rel" />
          <xsl:with-param name="type" select="@type" />
          <xsl:with-param name="title" select="@title" />
          <xsl:with-param name="hreflang" select="@hreflang" />
          <xsl:with-param name="length" select="@length" />
          <xsl:with-param name="xmlBase" select="@xml:base" />
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSatom1 and local-name(.) = 'link'">
        <!-- Special handling for item level atom:link with rel=entry-content: complete relative URL -->
        <xsl:variable name="atomLinkUrl">
          <xsl:choose>
            <xsl:when test="@rel = 'entry-content'">
              <xsl:call-template name="_CombineUrls">
                <xsl:with-param name="baseUrl" select="$baseItemUrl" />
                <xsl:with-param name="relUrl" select="@href" />
              </xsl:call-template>
            </xsl:when>
            <xsl:otherwise>
              <xsl:value-of select="@href" />
            </xsl:otherwise>
          </xsl:choose>
        </xsl:variable>
        <xsl:call-template name="_OutputAtomLink">
          <xsl:with-param name="href" select="$atomLinkUrl" />
          <xsl:with-param name="rel" select="@rel" />
          <xsl:with-param name="type" select="@type" />
          <xsl:with-param name="title" select="@title" />
          <xsl:with-param name="hreflang" select="@hreflang" />
          <xsl:with-param name="length" select="@length" />
          <xsl:with-param name="xmlBase" select="@xml:base" />
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSatom1 and local-name(.) = 'author'">
        <xsl:variable name="author">
          <xsl:call-template name="_ConvertAtomAuthorToAuthor">
            <xsl:with-param name="name" select="atom:name" />
            <xsl:with-param name="email" select="atom:email" />
          </xsl:call-template>
        </xsl:variable>
        <xsl:call-template name="_OutputAuthor"><xsl:with-param name="value" select="$author" /></xsl:call-template>
        <!-- We also make a full copy of the atom:author -->
        <xsl:call-template name="_OutputAtomAuthor">
          <xsl:with-param name="name" select="atom:name" />
          <xsl:with-param name="email" select="atom:email" />
          <xsl:with-param name="uri" select="atom:uri" />
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSatom1 and local-name(.) = 'contributor'">
        <xsl:call-template name="_OutputAtomContributor">
          <xsl:with-param name="name" select="atom:name" />
          <xsl:with-param name="email" select="atom:email" />
          <xsl:with-param name="uri" select="atom:uri" />
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSatom1 and local-name(.) = 'id' and $isFirst = 'true'">
        <xsl:call-template name="_OutputGuid">
          <xsl:with-param name="value" select="." />
          <xsl:with-param name="isPermaLink" select="'false'" />
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSatom1 and local-name(.) = 'updated' and $isFirst = 'true'">
        <xsl:call-template name="_OutputAtomUpdated"><xsl:with-param name="value" select="." /></xsl:call-template>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSatom1 and local-name(.) = 'published' and $isFirst = 'true'">
        <xsl:call-template name="_OutputAtomPublished"><xsl:with-param name="value" select="." /></xsl:call-template>
        <xsl:call-template name="_OutputPubDate"><xsl:with-param name="value" select="." /></xsl:call-template>
        <xsl:if test="not(../atom:updated)">
          <xsl:call-template name="_OutputAtomUpdated"><xsl:with-param name="value" select="." /></xsl:call-template>
        </xsl:if>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSatom1 and local-name(.) = 'category' and (@term or @scheme)">
        <xsl:call-template name="_OutputCategory">
          <xsl:with-param name="value" select="@term" />
          <xsl:with-param name="domain" select="@scheme" />
        </xsl:call-template>
      </xsl:when>
      <!-- Handle content: printable goes into description; non-printable is preserved -->
      <xsl:when test="namespace-uri(.) = $_NSatom1 and local-name(.) = 'content' and $isFirst = 'true'">
        <xsl:choose>
          <xsl:when test="(@src = '' or not(@src)) and (@type = '' or not(@type) or @type = 'text' or @type = 'html' or @type = 'xhtml')">
            <xsl:variable name="baseContentUrl">
              <xsl:call-template name="_CombineUrls">
                <xsl:with-param name="baseUrl" select="$baseItemUrl" />
                <xsl:with-param name="relUrl" select="@xml:base" />
              </xsl:call-template>
            </xsl:variable>
            <xsl:call-template name="_OutputDescription">
              <xsl:with-param name="value" select="." />
              <xsl:with-param name="type" select="@type" />
              <xsl:with-param name="baseUrl" select="$baseContentUrl" />
            </xsl:call-template>
          </xsl:when>
          <xsl:otherwise>
            <!-- NOTE: We don't understand content so we just won't touch it -->
            <xsl:call-template name="_OutputExtension">
              <xsl:with-param name="value" select="." />
            </xsl:call-template>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:when>
      <!-- Handle summary: printable goes into description or atom:summary; non-printable is discarded -->
      <xsl:when test="namespace-uri(.) = $_NSatom1 and local-name(.) = 'summary' and $isFirst = 'true'">
        <xsl:if test="(@src = '' or not(@src)) and (@type = '' or not(@type) or @type = 'text' or @type = 'html' or @type = 'xhtml')">
          <xsl:variable name="baseContentUrl">
            <xsl:call-template name="_CombineUrls">
              <xsl:with-param name="baseUrl" select="$baseItemUrl" />
              <xsl:with-param name="relUrl" select="@xml:base" />
            </xsl:call-template>
          </xsl:variable>
          <xsl:choose>
            <xsl:when test="not(../atom:content[(@src = '' or not(@src)) and (@type = '' or not(@type) or @type = 'text' or @type = 'html' or @type = 'xhtml')])">
              <xsl:call-template name="_OutputDescription">
                <xsl:with-param name="value" select="." />
                <xsl:with-param name="type" select="@type" />
                <xsl:with-param name="baseUrl" select="$baseContentUrl" />
              </xsl:call-template>
            </xsl:when>
            <xsl:otherwise>
              <xsl:call-template name="_OutputAtomSummary">
                <xsl:with-param name="value" select="." />
                <xsl:with-param name="type" select="@type" />
                <xsl:with-param name="xmlBase" select="@xml:base" />
                <xsl:with-param name="baseUrl" select="$baseContentUrl" />
              </xsl:call-template>
            </xsl:otherwise>
          </xsl:choose>
        </xsl:if>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSslash and local-name(.) = 'comments'">
        <xsl:if test="$isFirst = 'true'">
          <xsl:call-template name="_OutputSlashComments"><xsl:with-param name="value" select="." /></xsl:call-template>
        </xsl:if>
      </xsl:when>
      <xsl:when test="namespace-uri(.) = $_NSwfw and (local-name(.) = 'commentRss' or local-name(.) = 'commentRSS')">
        <xsl:if test="$isFirst = 'true'">
          <xsl:variable name="commentRssUrl">
            <xsl:call-template name="_CompleteUrlTwoBase">
              <xsl:with-param name="baseUrl1" select="$baseItemUrl" />
              <xsl:with-param name="baseUrl2" select="@xml:base" />
              <xsl:with-param name="Url" select="." />
            </xsl:call-template>
          </xsl:variable>
          <xsl:call-template name="_OutputWfwCommentRSS"><xsl:with-param name="value" select="$commentRssUrl" /></xsl:call-template>
        </xsl:if>
      </xsl:when>
      <!-- Copy extension nodes -->
      <xsl:when test="namespace-uri(.) != $_NSatom1 and namespace-uri(.) != ''">
        <xsl:call-template name="_OutputExtension">
          <xsl:with-param name="value" select="." />
          <xsl:with-param name="references" select="$references" />
        </xsl:call-template>
      </xsl:when>
    </xsl:choose>
  </xsl:template>
</xsl:stylesheet>
stdole2.tlbWWW
FeedsWWW
HIFeedsManagerWWW
|RootFolderWW
edisp
IsSubscribed
+feedUrlW
subscribedWW
WExistsFeedWW
feedPath
]existsWW
#GetFeedW
yGetFeedByUrl
ExistsFolder
folderPathWW
GetFolderWWW
DeleteFeedWW
DeleteFolderd
vFEEDS_BACKGROUNDSYNC_ACTIONWd
FBSA_DISABLEd
FBSA_ENABLEWd
OFBSA_RUNNOWW
BackgroundSyncWW
RactionWW
8IOFEEDS_BACKGROUNDSYNC_STATUSW
0I&FBSS_DISABLEDWWW
FBSS_ENABLED
BackgroundSyncStatus
+statusWW
*DefaultIntervalW
OgminutesW
AsyncSyncAll
.'NormalizeWWW
KfeedXmlInWWW
feedXmlOutWW
ItemCountLimitWW,
8{HIFeedsEnumWW,
0vCountWWW,
zItem
indexWWW,
xA_NewEnum
enumVarW
IFeedFolderW
x=SubfoldersWW
CreateFeedWW
feedName
CreateSubfolderW
folderNameWW
ExistsSubfolderW
i8GetSubfolder
xDeleteWW
B+RenameWW
>yMove
newParentPathWWW
ParentWW
IsRootWW
TotalUnreadItemCount
TotalItemCountWW
FEEDS_EVENTS_SCOPEWW
FES_ALLW
FES_SELF_ONLYWWW
FES_SELF_AND_CHILDREN_ONLYWWX
kFEEDS_EVENTS_MASKWWWX
?FEM_FOLDEREVENTSX
FEM_FEEDEVENTSWW
*GetWatcherWW
0scopeWWW
-mask
8ZfIFeedFolderEventsWWW
ErrorWWW
&6FolderAddedW
-IFolderDeletedWWW
FolderRenamedWWW
7oldPathW
FolderMovedFromW
FolderMovedToWWW
FolderItemCountChangedWW
WitemCountTypeWWW
FeedAddedWWW
oFeedDeletedW
FeedRenamedW
6FeedUrlChangedWW
FeedMovedFromWWW
FeedMovedToW
'FeedDownloadingW 
}FEEDS_DOWNLOAD_ERROR 
FDE_NONE 
FDE_DOWNLOAD_FAILEDW 
FDE_INVALID_FEED_FORMATW 
FDE_NORMALIZATION_FAILED 
FDE_PERSISTENCE_FAILEDWW 
FDE_DOWNLOAD_BLOCKED 
FDE_CANCELED 
FDE_UNSUPPORTED_AUTH 
SFDE_BACKGROUND_DOWNLOAD_DISABLED 
TFDE_NOT_EXISTWWW 
"FDE_UNSUPPORTED_MSXMLWWW 
FDE_UNSUPPORTED_DTDW 
FDE_DOWNLOAD_SIZE_LIMIT_EXCEEDED 
FDE_ACCESS_DENIEDWWW 
aFDE_AUTH_FAILEDW 
,FDE_INVALID_AUTH
v[FeedDownloadCompletedWWW
FeedItemCountChanged
IFeedWWW
FEEDS_XML_SORT_PROPERTYW
zFXSP_NONEWWW
fFXSP_PUBDATE
FXSP_DOWNLOADTIMEWWWL
FEEDS_XML_SORT_ORDERL
dFXSO_NONEWWWL
FXSO_ASCENDINGWWL
0dCFXSO_DESCENDINGW
FEEDS_XML_FILTER_FLAGSWW
FXFF_ALL
FXFF_UNREADW
QFXFF_READWWW
FEEDS_XML_INCLUDE_FLAGSW
)FXIF_NONEWWW
3FXIF_CF_EXTENSIONSWW
sortProperty
sortOrderWWW
NfilterFlagsW
includeFlags
LocalIdW
feedGuid
LastWriteTimeWWW
lastWriteWWW
Download
AsyncDownloadWWW
)`CancelAsyncDownloadWx
FEEDS_SYNC_SETTINGWWx
FSS_DEFAULTWx
0,GFSS_INTERVALx
FSS_MANUALWWx
FSS_SUGGESTEDWWW
SyncSettingW
u'Interval
LastDownloadTime
&lastDownload
/LocalEnclosurePathWW
`hItemsWWW
GetItemW
28itemIdWW
~TitleWWW
 DescriptionW
homePage
ImageWWW
WimageUrl
LastBuildDateWWW
PubDateW
blastPopulateDate
Language
!/CopyrightWWW
MaxItemCount
DownloadEnclosuresAutomaticallyW
FEEDS_DOWNLOAD_STATUSWWW
058FDS_NONE
FDS_PENDINGW
1FDS_DOWNLOADINGW
iFDS_DOWNLOADEDWW
FDS_DOWNLOAD_FAILEDW
(DownloadStatusWW
LastDownloadErrorWWW
q_MergeWWW
T:feedXmlW
DownloadUrlW
IsListWW
MarkAllItemsRead
LUnreadItemCountW
UItemCountWWW@
IFeed2WW@
GetItemByEffectiveId
itemEffectiveIdW@
XLastItemDownloadTime@
Username@
Password@
SetCredentialsWW@
ClearCredentials
IFeedEventsW
FeedMovedWWW
IFeedItemWWW
}linkUrlW
Z^itemGuid
)Comments
AuthorWW
PEnclosureWWW
IsReadWW
)itemUrlW
Modifiedl
IFeedItem2WWl
EffectiveIdW
IFeedEnclosureWW
enclosureUrl
mimeType
LengthWW
LocalPathWWW
nDownloadMimeType
RemoveFileWW
'SetFileW
downloadFilePath
enclosureFilenameWWW4
8\qFeedsManager
]FeedFolderWatcherWWW
5FeedWatcherW
Microsoft FeedsWWW'
Retrieves the root subscription folder.WWW:
Determines if the URL is in the system subscription store.
Checks if a feed exists.WW
Retrieves a feed from its path.WWW
Retrieves a feed by its URL.WW
Checks if a feed folder exists.WWW!
Retrieves a folder from its path.W
Deletes a feed.WWW
Deletes a feed folder.;
Controls the behavior of background synchronization engine.WWW%
Retrieves the background sync status.W0
Retrieves the default update interval for feeds.WW+
Sets the default update interval for feeds.WWW-
Starts the background synchronization engine.W'
Converts a feed to the normalized form.WWW9
Retrieves the maximum number of items retained for feeds.W3
Retrieves the number of objects in this collection.WWW
Returns an object by index.WWW1
Retrieves the collection of feeds in this folder.W6
Retrieves the collection of subfolders in this folder.)
Creates a new feed, and subscribes to it.W&
Creates a new subfolder in the folder.
Retrieves a feed by its name.W
Checks if a subfolder exists.W"
Retrieves a subfolder by its name.,
Deletes this folder and all of its contents.WW)
Retrieves the name of the current folder.W
Renames the folder.WWW)
Retrieves the path of the current folder.W(
Moves the feed folder to a new location.WW0
Retrieves the parent of the current feed folder.WW<
Checks to see whether the current folder is the root folder.WW8
Retrieves the total (aggregated) number of unread items.WW1
Retrieves the total (aggregated) number of items.W/
Retrieves the appropriate interface for events.WWW-
Occurs when a feed folder event error occurs.W+
Occurs when a folder or subfolder is added.WWW-
Occurs when a folder or subfolder is removed.W-
Occurs when a folder or subfolder is renamed.W<
Occurs when a folder or subfolder is moved from this folder.WW:
Occurs when a folder or subfolder is moved to this folder.?
Occurs when the aggregated item count of a feed folder changes.WWW*
Occurs when a feed is added to the folder..
Occurs when a feed is deleted from the folder.
Occurs when a feed is renamed.)
Occurs when the URL of a feed is changed.W-
Occurs when a feed is moved from this folder.W+
Occurs when a feed is moved to this folder.WWW&
Occurs when a feed starts to download.6
Occurs when a feed has finished or failed downloading.-
Occurs when the item count of a feed changed.W:
Returns the Extensible Markup Language (XML) for the feed.'
Retrieves the display name of the feed.WWW
Renames the feed.W
Retrieves the URL of the feed.
Sets the URL of the feed.W-
Retrieves the guid associated with this feed.W(
Retrieves the path for the current feed.WW!
Moves the feed to a new location.W(
Retrieves the parent folder of the feed.WW)
Retrieves the last time the feed changed.W
Deletes the feed.W
Downloads content for the feed.WWW.
Downloads content for the feed asynchronously.*
Cancels asynchronous download of the feed.*
Retrieves the update setting for the feed.%
Sets the update setting for the feed.W+
Retrieves the update interval for the feed.WWW&
Sets the update interval for the feed.I
Retrieves the date and time of the last successful download for the feed.WL
Retrieves the file system path where enclosures for the feed are downloaded.WW0
Retrieves an enumerator for items from the feed.WW.
Returns a IFeedItem object by identifier (ID)."
Retrieves the title from the feed.7
Retrieves a phrase or sentence that describes the feed.WWW*
Retrieves the home page URL from the feed.&
Retrieves the image URL from the feed.,
Retrieves the last build date from the feed.WW4
Retrieves the publication date and time of the feed.WW/
Retrieves the time to live (TTL) from the feed.WWW*
Retrieves the language code from the feed.&
Retrieves the copyright from the feed.=
Maximum number of items to keep, excess items will be deletedW_
Retrieves a VARIANT_BOOL value that determines whether enclosures are downloaded automatically.WWWZ
Sets a VARIANT_BOOL value that determines whether enclosures are downloaded automatically.2
Retrieves the current download status of the feed..
Retrieves the last download error of the feed.&
Merges feed XML into an existing feed.5
Retrieves the URL that was used to download the feed.W!
Determines if the feed is a list.WG
Sets the IFeedItem::IsRead property to VARIANT_TRUE for all feed items.WWW)
Retrieves the count of unread feed items.W*
Retrieves the count of items in this feed.2
Retrieves the item that contains the effective ID.;
Retrieves the most recent download time for all feed items.WWWA
Retrieves the username used to authenticate the feed, if present.WA
Retrieves the password used to authenticate the feed, if present.W=
Sets the username and password used to authenticate the feed.W?
Clears the username and password used to authenticate the feed.WWW&
Occurs when a feed event error occurs.
Occurs when a feed is deleted.
Occurs when a feed is moved.WWH
Returns the Extensible Markup Language (XML) fragment for the feed item.WW'
Retrieves the title from the feed item.WWW%
Retrieves the URL from the feed item.W&
Retrieves the guid from the feed item.-
Retrieves the description from the feed item.W0
Retrieves the publication date of the feed item.WW:
Retrieves the URL of the comments page from the feed item.(
Retrieves the author from the feed item.WWF
Retrieves the IFeedEnclosure object associated with the the feed item.+
Retrieves the read status of the feed item.WWW&
Sets the read status of the feed item.8
Retrieves the assigned identifier (ID) of the feed item.WW+
Retrieves the parent feed of the feed item.WWW
Deletes the feed item.6
Retrieves the URL that was used to download this item.?
Retrieves the date and time of the last download for this item.WWWC
Retrieves the date and time of the last modification for this item.WWW)
Retrieves the effective ID for this item.W%
Retrieves the URL from the enclosure.WS
Retrieves the Multipurpose Internet Mail Extensions (MIME) type from the enclosure.WWW.
Retrieves the length value from the enclosure.'
Downloads the enclosure asynchronously.WWW/
Cancels asynchronous download of the enclosure.WWW7
Retrieves the current download status of the enclosure.WWW3
Retrieves the last download error of the enclosure.WWW>
Retrieves the local system path where the enclosure is stored.0
Retrieves the parent feed item of the enclosure.WW:
Retrieves the URL that was used to download the enclosure.c
Retrieves the final Multipurpose Internet Mail Extensions (MIME) type for the downloaded enclosure.WWWK
Deletes the enclosure file or cancels any pending or in-progress downloads.WWW7
Adds the downloaded enclosure file to the RSS platform.WWW/
Exposes methods to access the System Feed List.WWW:
Exposes event handlers for System Feed List folder events.'
Exposes event handlers for feed events.WWW
Microsoft.Feeds.InteropWWW
TYPELIB
en-US
