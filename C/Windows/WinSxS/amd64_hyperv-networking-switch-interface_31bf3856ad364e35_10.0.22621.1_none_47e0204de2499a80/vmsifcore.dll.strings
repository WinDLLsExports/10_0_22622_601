!This program cannot be run in DOS mode.
rRich
.text
`.rdata
@.data
.pdata
@.rsrc
@.reloc
q0R^G'
q0R^G'
q:_0#
|$ AVH
VWAVH
p:_0#
p:_0#
p:_0#
@A^_^
q:_0#
@SVWH
SVWAVH
8A^_^[
WAVAWH
\$8H;
A_A^_
p:_0#
\$ UH
M H1E
 H3E H3E
ntelA
ineID
T$HE3
T$HE3
UAVAWH
H!|$8H
D$0E3
A_A^]
@UVWATAUAVAWH
D9l$(|
D$,D8-
t(D8-
@UVWAVAWH
D9|$(
t(D8=
A_A^_^]
@SUVWATAUAVAW
A_A^A]A\_^][
t:fA9(t4H
fA9,@u
x ATAVAWH
 A_A^A\
H WATAUAVAWH
 A_A^A]A\_
x AVH
fA9,Qu
UVWAVAWH
H!\$8H
H!\$@I
A_A^_^]
UVWAVAWH
H!\$8H
H!\$@I
H!_(H!_0H!_8H!_@M
A_A^_^]
l$ VWAVH
L$0E3
L$0fD
L$ UVWATAUAVAWH
pA_A^A]A\_^]
97tKA
A8]8t
UVWAVAWH
t,D8=?
L9{Hu
A_A^_^]
\$ VWAVH
D$0H;
u#H!X
D$@E3
UVWATAUAVAWH
ty@8=
t"@8=
fA9>u
@8=Mz
PA_A^A]A\_^]
L$ SUVWH
L$xH+
f9,Cu
8_^][
WAVAWH
}0H+}(H
@A_A^_
WAVAWH
{8D8{@uXL9?u$E3
@A_A^_
VWATAVAWH
 A_A^A\_^
@VWAVH
0A^_^
WATAUAVAWH
T$8L+
A_A^A]A\_
L$ UVWATAUAVAWH
C D8U@u
A_A^A]A\_^]
@UVWATAUAVAWH
T$dfD
D$hfE
D+D$x
D+D$xD
A_A^A]A\_^]
t$ WH
t$ WH
UVWATAUAVAWH
}HL9M@t
L97sKI
 A_A^A]A\_^]
WAVAWH
rHfD9?w
C9fD9?u,
 A_A^_
t$ WATAUAVAWH
f9<Au
f9<Au
fD94Ou
tG9)u
|$(H;
|$0H;
|$8H;
|$HH;
|$pH;
t$XE3
t4E88t/H
E8<0u
 A_A^A]A\_
x AVH
uPH9i
L$ SVWH
L$ SVWAVH
8A^_^[
WAVAWH
@A_A^_
@VWATAVAWH
0A_A^A\_^
x UAVAWH
T$0H+
L$0fD
HcD$$HcL$ H
A_A^]
WAVAWH
@A_A^_
WAVAWH
fD96u)L
 A_A^_
x AVH
WAVAWH
 A_A^_
D$(E3
h UAVAWH
L$@I+
L$PH;
T$PL;
A_A^]
\$ UVWATAUAVAWH
pA_A^A]A\_^]
UVWATAUAVAWH
D9d$D
L$PH3
`A_A^A]A\_^]
|$ UATAUAVAWH
A_A^A]A\]
UVWATAUAVAWH
L!t$(H
D9u`A
pA_A^A]A\_^]
t$ UWATAVAWH
A_A^A\_]
x AVH
t$ WATAUAVAWH
A_A^A]A\_
WATAUAVAWH
A_A^A]A\_
t;L9J
t5L9J
h VWAVH
s WAVAWH
A_A^_
UWATAVAWH
CLH!t$0
u8!{LH!{@A
A_A^A\_]
UVWAVAWH
pA_A^_^]
t9H9A
x AVH
x ATAVAWH
A_A^A\
UVWATAUAVAWH
PA_A^A]A\_^]
SUVWATAUAVAWH
L$PD;
A_A^A]A\_^][
UVWATAUAVAWH
t$hD;
 A_A^A]A\_^]
WATAUAVAWH
H9X uK
0A_A^A]A\_
UVWATAUAVAWH
PA_A^A]A\_^]
D9ALs
t1B9\
WATAUAVAWH
t_D9e
tYD9e
oHD9m
taD9m
t[D9m
A_A^A]A\_
x AVH
Unknown exception
bad array new length
string too long
Exception
ReturnNt
ReturnHr
LogNt
LogHr
FailFast
%hs(%u)\%hs!%p: 
%hs!%p: 
(caller: %p) 
%hs(%d) tid(%x) %08X %ws
Msg:[%ws] 
CallContext:[%hs] 
[%hs(%hs)]
[%hs]
kernelbase.dll
RaiseFailFastException
lntdll.dll
RtlNtStatusToDosErrorNoTeb
RtlDllShutdownInProgress
RtlDisownModuleHeapAllocation
WilFailureNotifyWatchers
RtlRegisterFeatureConfigurationChangeNotification
RtlUnregisterFeatureConfigurationChangeNotification
RtlNotifyFeatureUsage
NtQueryWnfStateData
NtUpdateWnfStateData
onecore\internal\sdk\inc\wil\opensource\wil\resource.h
WilError_03
onecore\internal\sdk\inc\wil\Staging.h
WilStaging_02
UNKNOWN
SWITCH
Successfully query vmswitch capabilities. Initializing VMSIF with those capabilities.
Failed to query vmswitch capabilities, expected for TH, non-AZURE RS1, or RS2..RS3 vmswitch. Initializing VMSIF with no vmswitch capabilities. Status=0x%x
\\.\VmSwitch
Underflow VmsIfOutstanding handle count!
Local\SM0:%lu:%lu:%hs
IOCTL_PORT_CREATE
IOCTL_PORT_DELETE
IOCTL_SWITCH_CREATE
IOCTL_SWITCH_DELETE
IOCTL_SWITCH_GET_INFO
IOCTL_SWITCH_SET_INFO
IOCTL_NIC_SET_INFO
IOCTL_NIC_GET_INFO
IOCTL_PORT_GET_VLAN
IOCTL_PORT_SET_VLAN
IOCTL_PORT_GET_INFO
IOCTL_PORT_SET_INFO
IOCTL_PORT_LOOKUP_FROM_MAC
IOCTL_PORT_FEATURE_STATUS_GET
IOCTL_PORT_PROPERTY_GET
IOCTL_PORT_PROPERTY_SET
IOCTL_PORT_PROPERTY_ADD
IOCTL_PORT_PROPERTY_DELETE
IOCTL_ENUM_NIC_COUNT
IOCTL_ENUM_NICS
IOCTL_ENUM_PORT_COUNT
IOCTL_ENUM_PORTS
IOCTL_ENUM_SWITCH_COUNT
IOCTL_ENUM_SWITCHES
IOCTL_ENUM_VMQ_GROUP_COUNT
IOCTL_ENUM_VMQ_GROUPS
IOCTL_ENUM_PROC_COUNT
IOCTL_ENUM_PROCS
IOCTL_PORT_ENUM_LEARNED_MAC_COUNT
IOCTL_PORT_ENUM_LEARNED_MAC
IOCTL_VMSWITCH_SET_GLOBAL_VARIABLE
IOCTL_VMSWITCH_GET_GLOBAL_VARIABLE
IOCTL_VMSWITCH_GET_INTERNAL_STATS
IOCTL_SWITCH_GET_STATS
IOCTL_PORT_GET_STATS
IOCTL_PORT_SET_ENCAP_INFO
IOCTL_PORT_GET_ENCAP_INFO
IOCTL_NIC_GET_STATS
IOCTL_NIC_CONNECT
IOCTL_NIC_DISCONNECT
IOCTL_SWITCH_FEATURE_STATUS_GET
IOCTL_SWITCH_PROPERTY_GET
IOCTL_SWITCH_PROPERTY_SET
IOCTL_SWITCH_PROPERTY_ADD
IOCTL_SWITCH_PROPERTY_DELETE
IOCTL_PROC_GET_STATS
IOCTL_VMSWITCH_GET_INIT_STATE
IOCTL_VMSWITCH_SERVICING_START
IOCTL_VMSWITCH_SERVICING_END
IOCTL_VMSWITCH_DISABLE_OPTIMIZATIONS
IOCTL_VMSWITCH_ENABLE_OPTIMIZATIONS
IOCTL_VMSWITCH_DEREGISTER_PROTOCOL
IOCTL_VMSWITCH_SHUTDOWN
IOCTL_VMSWITCH_GET_PORT_HANDLE_COUNT
IOCTL_VMSWITCH_CONFIGURE_PROCESSORS
IOCTL_SWITCH_PROPERTY_ENUM
IOCTL_PORT_PROPERTY_ENUM
IOCTL_SWITCH_EXTENSION_ENUM
IOCTL_PORT_GET_REQUIRED_EXTENSIONS
IOCTL_PORT_SET_REQUIRED_EXTENSIONS
IOCTL_NIC_SET_CONNECTION_INFO
IOCTL_INIT_LW_MINIPORT_NIC
IOCTL_DELETE_LW_MINIPORT_NIC
IOCTL_DISABLE_MINIPORT_NIC
IOCTL_ENABLE_MINIPORT_NIC
IOCTL_INIT_MINIPORT_NIC
IOCTL_DELETE_MINIPORT_NIC
IOCTL_NIC_MORPH_TO_VMNIC
IOCTL_NIC_SEND_STATUS
IOCTL_NIC_GET_INT_STATS
IOCTL_NIC_COLLECT_INT_STATS
IOCTL_NIC_GET_VLAN_INFO
IOCTL_NIC_GET_DROP_REASONS_STATS
IOCTL_NIC_GET_VMQ_INFO
IOCTL_VM_NIC_SUSPEND
IOCTL_VM_NIC_VMPHU_ZERO_BEGIN
IOCTL_VM_NIC_VMPHU_ZERO_COMPLETE
IOCTL_NIC_GET_ADDRESSES
IOCTL_DIO_NIC_SET_ADDDRESSES
IOCTL_DIO_NIC_SET_MAC_ADDRESS
IOCTL_NIC_GET_OPERATIONAL_STATUS
IOCTL_NIC_GET_VRSS_INDIRECTION_ENTRIES_COUNT
IOCTL_NIC_GET_VRSS_INFO
IOCTL_EXEC_MON_CONFIG_GET
IOCTL_EXEC_MON_CONFIG_SET
IOCTL_EXEC_MON_OPS_GET
IOCTL_EXEC_MON_OPS_COUNT
IOCTL_EXEC_MON_RESET
IOCTL_EXEC_MON_PENDING_GET
IOCTL_EXEC_MON_PENDING_COUNT
IOCTL_PROFILER_CLEAR_PROCESSOR_STATS
IOCTL_PROFILER_GET_PROCESSOR_STATS
IOCTL_NIC_SET_PACKET_FILTER
IOCTL_VM_NIC_ALLOCATE_VF
IOCTL_VM_NIC_FREE_VF
IOCTL_NIC_MORPH_TO_DIONIC
IOCTL_NIC_ENABLE_OPTIMIZATIONS
IOCTL_NIC_DISABLE_OPTIMIZATIONS
IOCTL_VM_NIC_PAUSE
IOCTL_VM_NIC_RESUME
IOCTL_VM_NIC_RESTORE
IOCTL_NIC_RELEARN_MAC
IOCTL_PORT_HW_TIMESTAMP_OVER_VMBUS_GET
IOCTL_PORT_HW_TIMESTAMP_OVER_VMBUS_SET
IOCTL_VSWITCH_CALLER_AUDIT_GET
IOCTL_VSWITCH_CALLER_AUDIT_COUNT
IOCTL_EXEC_MON_HISTORY_GET
IOCTL_EXEC_MON_HISTORY_COUNT
IOCTL_EXEC_MON_HISTORY_CURRENT_GET
IOCTL_EXEC_MON_HISTORY_CURRENT_COUNT
IOCTL_EXEC_MON_HISTORY_RANGE_GET
IOCTL_EXEC_MON_HISTORY_RANGE_COUNT
bad allocation
VmsCapabilityFixDirectOidCompletion
Direct OID completion
VmsCapabilityFixExtensibilityStackBypass
Can bypass extensibility stack for host vNICs (a feature)
VmsCapabilityFixAzureVrssExtendedParameters
Can address default object by management tools (e.g. vmmqctrl)
VmsCapabilityFixConfigureStaggeringInterval
Allows user to configure staggering interval for dynamic vmmq
VmsCapabilityFixProcessorIndexUsage
Addresses processor using processorNumber instead of global processor index
VmsCapabilityFixReserved
ReservedFix
VmsCapabilityFeatureReserved
ReservedFeature
VmsCapabilityFeatureExtensibilityStackBypass
Can bypass extensibility stack for host vNICs
VmsCapabilityFeatureUntrustedGuestIsolation
Can isolate untrusted VMs from cache attacks on host
VmsCapabilityFeaturePacketTracking
Can track where packets have been within vmswitch
VmsCapabilityFeatureNblOobIndicateUncachedData
Marks NBL as fully shadowed using bits in FORWARDING_EXTENSION
VmsCapabilityFeatureSuspendedLiveMigration
Can support suspended live migration for port redirection
VmsCapabilityFeatureIndependentHostSpreading
Can support independent host spreading when RSS is disabled in guest
VmsCapabilityFeatureVersionedIoctl
IOCTL buffers start with header meta data
VmsCapabilityFeatureQueryVlanInfo
Returns VLAN information
VmsCapabilityFeatureSoftwareRscOnPhysicalNic
Can perform Software RSC over physical NIC
VmsCapabilityFeatureLightweightMiniports
Supports device-less host MINIPORTs
VmsCapabilityFeatureDisableVmNicIM
Supports disabling vmbus monitored notifications to vmNIC
VmsCapabilityFeatureNrtNameResolutionId
Handles NrtNameResolutionId in NBLs
VmsCapabilityFeatureVmbusAffinityPolicy
Supports setting of VMBUS affinity policy
VmsCapabilityFeatureHostVNicProxy
Supports proxy driver for host vNICs
VmsCapabilityFeatureReloadability
Supports vmswitch reloadability
VmsCapabilityFeatureVmPhuZeroReloadability
Supports vmswitch Phu-Zero reloadability
VmsCapabilityFeaturePacketMonitor
Can perform packet monitoring
VmsCapabilityFeatureDynamicVMMQ
Can perform dynamic VMMQ steering using RSSv2
VmsCapabilityFeatureStateSeparation
Supports state separation
VmsCapabilityFeatureHardwarePacketTimestamp
Supports hardware timestamping of NBLs
VmsCapabilityFeatureQueryCapabilitiesIoctl
Supports IOCTL to query capabilities
VmsCapabilityFeatureConfigureSwitchPerfParameters
Supports configurable parameters to modify switch performance
VmsCapabilityFeatureHostNicUseL2IndirectionTable
Allows host vNic to indicate packets using L2 indirection table
VmsCapabilityFeatureConfigureGlobalsUsingIoctl
Allows user to configure global variable using the ioctl interface.
VmsCapabilityFeatureReloadSensitiveIoctls
Supports reload-sensitive IOCTLs.
VmsCapabilityFeatureNonConsecutiveRssCpus
Supports non-consecutive CPUs in RSS/VMMQ OIDs.
VmsCapabilityFeatureRscOnVPortLevel
Supports RSC Enablement/Disablement per vPort
VmsCapabilityFeatureConfigureSwitchExtensionParameters
Supports Enablement/Disablement of By passing extension stack and setting Required Extensions
VmsCapabilityFeatureHotPatchIOCTL
The vSwitch has support for hot patch IOCTL
Failed to allocate memory for input buffer with size %d
Context=0x%p, IOCTL=0x%x, LegacyInfo=%p, InputBuffer=0x%p, InputBufferSize=%d, OutputBuffer=0x%p, OutputBufferSize=%d
LibIoctlPrivAllocateLegacyInputBuffer: legacy input buffer size is specified as LIB_IOCTL_LEGACY_REQUESTED_SIZE, and user failed to call SetInputBufferSizeIfLegacy() before calling LibIoctlDeviceIoControl. error=%d
LibIoctlPrivAllocateLegacyInputBuffer: Using user-requested size for input buffer: %d
LibIoctlHelperCalculateSizeInLegacyBuffer does not return actual value for buffer size. legacy fixedSize=%d, legacy variableBufferSize=%d. error=%d
RecordType=%d, RecordVersion=%d, FixedSize=%d
ElementVariableBufferSize=%d
LibIoctlPrivAllocateLegacyInputBuffer size=%d
LibIoctlPrivAllocateVersionedInputBuffer, size=%d
LibIoctlPrivConstructInputBuffer - input bufer was already constructed
LibIoctlPrivConstructInputBuffer - input buffer constructed
Invalid legacy output buffer size specified: LIB_IOCTL_LEGACY_BUFFER_SIZE. error=%d
LibIoctlPrivSetInitialOutputBuffer with size=%d
LibIoctlPrivSendIoctl
Failed to create event for overlapped object. error=%d
LibIoctlPrivSendIoctl: First IOCTL returns output buffersize needed=%d
LibIoctlPrivSendIoctl: Failed to allocate IOCTL output buffer with size %d
IOCTL returned from kernel with error %d
LibIoctlPrivSendIoctl: Second IOCTL returns with error=%d
LibIoctlPrivSendIoctl: IOCTL returns with error=%d
Initialize library context, IsLegacy=%d
LibIoctlInitializeOperation: Called with legacy IOCTL code 0x%x error=%d
LibIoctlInitializeOperation: Unable to find legacy IOCTL code for %x to communicate with legacy driver. error=%d
LibIoctlInitializeOperation: Use legacy IOCTL (0x%x) instead of IOCTL (0x%x)
=====> Initialized IOCTL 0x%x, DriverHandle=0x%p, IsOverlappedHandle=%d
LibIoctlInitializeOperation: IOCTL library either failed, or has not been initialized.
LibIoctlInitializeOperation: OperationContext is NULL
=====> ReInitialize IOCTL 0x%x, DriverHandle=0x%p, IsOverlappedHandle=%d
LibIoctlAddArrayRecordEx: RecordType=%d, RecordVersion=%d, FixedSize=%d
LibIoctlAddArrayRecordElement: VariableBufferSize=%d
LibIoctlAddRecordEx: Invalid parameter. OperationContext=%p, RecordType=%d, Record=%p, error=%d
LibIoctlAddRecordEx: RecordType=%d, RecordVersion=%d, FixedSize=%d, VariableBufferSize=%d
LibIoctlGetRecordEx: Invalid parameter. OperationContext=%p, RecordType=%d, RecordVersion=%p, FixedSize=%p, Record=%p, error=%d
LibIoctlGetRecordEx: Found more than 1 element (%d) for the record RecordType=%d, error=%d
LibIoctlGetRecordEx: RecordType=%d. Got record with info: RecordVersion=%d, FixedSize=%d, VariableBufferSize=%d, Record=%p
LibIoctlDeviceIoControl: Invalid parameter: NULL OperationContext
LibIoctlDeviceIoControl: legacy output buffer size is specified as LIB_IOCTL_LEGACY_REQUESTED_SIZE, and user failed to call SetOutputBufferSizeIfLegacy() before calling this function. error=%d
LibIoctlDeviceIoControl: Fail to allocate initial output buffer of size %d, error=%d
LibIoctlSetOutputBufferSizeIfLegacy: OutputBufferSize=%d
<===== DeInitializing IOCTL operation
LibIoctlHelperPrivGetRecordSize: Invalid record header format. HeaderSize=%d, VariableBufferSizeArrayOffset=%d, NumElements=%d
LibIoctlHelperPrivGetRecordInfoFromLegacyBuffer: error in legacy database. RecordType=%d, record offset (%d) exceeds bufferSize (%d). error=%d
LibIoctlHelperPrivGetRecordInfoFromLegacyBuffer: invalid legacy info for RecordType=%d. FixedSize=%d, VariableBufferSize=%d, NumElements=%d, error=%d
LibIoctlHelperPrivGetRecordInfoFromLegacyBuffer: RecordType=%d not found in legacy database
LibIoctlHelperPrivGetVersionedArrayRecordInfo: Buffer contains record of size 0
LibIoctlHelperPrivGetVersionedArrayRecordInfo: RecordType=%d not found in buffer
LibIoctlHelperPrivValidateLegacyBufferInfo: Index=%d. Legacy info contains 0 element
LibIoctlHelperPrivValidateLegacyBufferInfo: overflow fixedSize=%d, variableBufferSize=%d
LibIoctlHelperInitialize: Invalid dispatch functions: DispatchTable=%p, MemAlloc=%p, MemFree=%p
LibIoctlHelperInitializeOperation: Fail to allocate memory for operation context (size=%d). error=%d
LibIoctlHelperInitializeOperation: IsLegacy specified, but DispatchTable->GetLegacyInfo is NULL. error=%d
LibIoctlGetArrayRecordInfoEx: Invalid parameter. OperationContext=%p, RecordType=%d, RecordVersion=%p, FixedSize=%p, NumElements=%p, error=%d
LibIoctlGetArrayRecordElementEx: request for element index (%d) exceeding numElements(%d) for RecordType=%d, error=%d
LibIoctlHelperAddArrayRecord: Fail to allocate memory for temp record for RecordType=%d, error=%d
LibIoctlHelperAddArrayRecordElement: Failed to find in-progress array operation. error=%d
LibIoctlHelperAddArrayRecordElement: Failed to allocate memory for array element, size=%d, RecordType=%d, error=%d
LibIoctlHelperCopyRecordToVersionedBuffer: Failed to copy data to buffer (buffer too small). BufferSize=%d
LibIoctlHelperCalculateSizeInLegacyBuffer: element (%p) does not exist in record. error=%d
LibIoctlHelperCalculateSizeInLegacyBuffer: element index (%d)exceeds num elements specified in legacy database (%d). Element not added.
LibIoctlHelperCalculateSizeInLegacyBuffer: legacy fixedSize (%d) is not same as record's size (%d)
LibIoctlHelperCalculateSizeInLegacyBuffer: legacy variableBufferSize (%d) is not same as element's size (%d)
LibIoctlHelperCalculateSizeInLegacyBuffer: invalid legacy database. fixedSize=%d, variableBufferSize=%d, error=%d
LibIoctlHelperCalculateSizeInLegacyBuffer: invalid legacy database. fixedSize=LIB_IOCTL_LEGACY_BUFFER_SIZE, variableBufferSize=%d, error=%d
LibIoctlHelperCalculateSizeInLegacyBuffer: invalid legacy database. Record with LIB_IOCTL_LEGACY_BUFFER_SIZE is not last record. error=%d
LibIoctlHelperCopyRecordToLegacyBuffer: invalid legacy database. Record with LIB_IOCTL_LEGACY_BUFFER_SIZE is not last record. error=%d
LibIoctlHelperCopyRecordToLegacyBuffer: legacy numElements (%d) is not same as record info (%d)
LibIoctlHelperCopyRecordToLegacyBuffer: invalid legacy database. fixedSize(%d) > maxElementSize(%d), error=%d
LibIoctlHelperCopyRecordToLegacyBuffer: legacy fixedSize (%d) is not same as record fixedSize (%d)
LibIoctlHelperCopyRecordToLegacyBuffer: legacy variableBufferSize (%d) is not same as element's variableBufferSize (%d)
LibIoctlHelperCopyRecordToLegacyBuffer: invalid legacy database. fixedSize exceeds buffer size. OffsetFromStart=%d, fixedSize=%d, bufferSize=%d, error=%d
LibIoctlHelperCopyRecordToLegacyBuffer: invalid legacy database. variableBufferSize exceeds buffer size. OffsetFromStart=%d, variableBufferSize=%d, bufferSize=%d, error=%d
LibIoctlValidateLegacyInfo: Invalid legacy database LegacyIoct(0x%x) = NewIoctl(0x%x)
LibIoctlValidateLegacyInfo: Invalid legacy database inputBuffer size != 0 or LIB_IOCTL_LEGACY_REQUESTED_SIZE for IOCTL 0x%x
LibIoctlValidateLegacyInfo: Invalid legacy input info for IOCTL 0x%x, FixedSize=%d, VariableBufferSize=%d, NumElements=%d
LibIoctlValidateLegacyInfo: validation for index %d failed for input info for IOCTL 0x%x
LibIoctlValidateLegacyInfo: Invalid legacy output buffersize (LIB_IOCTL_LEGACY_BUFFER_SIZE)
LibIoctlValidateLegacyInfo: Invalid legacy output info for IOCTL 0x%x, FixedSize=%d, VariableBufferSize=%d, NumElements=%d
LibIoctlValidateLegacyInfo: validation for index %d failed for output info for IOCTL 0x%x
vmsifcore.pdb
.text$di
.text$mn
.text$mn$00
.text$x
.text$yd
.rdata$brc
.idata$5
.00cfg
.CRT$XCA
.CRT$XCU
.CRT$XCZ
.CRT$XIA
.CRT$XIC
.CRT$XIZ
.CRT$XPA
.CRT$XPZ
.CRT$XTA
.CRT$XTZ
.gehcont
.gfids
.rdata
.rdata$r
.rdata$voltmd
.rdata$zzzdbg
.rtc$IAA
.rtc$IZZ
.rtc$TAA
.rtc$TZZ
.xdata
.xdata$x
.edata
.idata$2
.idata$3
.idata$4
.idata$6
.data$brc
.data$r$brc
.data$rs$brc
.data
.pdata
.rsrc$01
.rsrc$02
vmsifcore.dll
VmsIfCapsFindCapability
VmsIfCapsGetCapability
VmsIfCapsInitializeLibrary
VmsIfCapsIsFeaturePresent
VmsIfCapsIsFixPresent
VmsIfCapsQueryCapabilities
VmsIfCoreDeinitialize
VmsIfCoreInitialize
VmsIfDriverClose
VmsIfDriverOpen
VmsIfDriverOpenWithFileName
VmsIfIoEnumeratorExecuteEx
VmsIfIoEnumeratorPrepareEx
VmsIfIoExecuteEx
VmsIfIoFinalize
VmsIfIoPrepareEx
VmsIfMemFree
VmsIfRegisterHandle
_initterm
_initterm_e
api-ms-win-crt-runtime-l1-1-0.dll
__CxxFrameHandler3
_o___std_exception_copy
_o___std_exception_destroy
_o___std_type_info_destroy_list
_o___stdio_common_vsnprintf_s
_o___stdio_common_vswprintf
_o__callnewh
_o__cexit
_o__configure_narrow_argv
_o__crt_atexit
_o__errno
_o__execute_onexit_table
_o__initialize_narrow_environment
_o__initialize_onexit_table
_o__invalid_parameter_noinfo
_o__invalid_parameter_noinfo_noreturn
_o__purecall
_o__register_onexit_function
_o__seh_filter_dll
_o_free
_o_malloc
_o_terminate
__C_specific_handler
__current_exception
__current_exception_context
memset
_CxxThrowException
api-ms-win-crt-private-l1-1-0.dll
api-ms-win-crt-string-l1-1-0.dll
HeapFree
HeapAlloc
GetProcessHeap
DeviceIoControl
GetVersionExW
GetLastError
GetModuleFileNameA
CreateSemaphoreExW
SetLastError
EnterCriticalSection
ReleaseSemaphore
GetModuleHandleExW
LeaveCriticalSection
InitializeCriticalSectionEx
WaitForThreadpoolTimerCallbacks
WaitForSingleObject
CreateFileW
GetCurrentThreadId
ReleaseMutex
FormatMessageW
ReleaseSRWLockExclusive
OutputDebugStringW
CloseThreadpoolTimer
AcquireSRWLockExclusive
WaitForSingleObjectEx
OpenSemaphoreW
CloseHandle
SetThreadpoolTimer
ReleaseSRWLockShared
CreateThreadpoolTimer
GetProcAddress
CreateMutexExW
AcquireSRWLockShared
DeleteCriticalSection
GetCurrentProcessId
GetModuleHandleW
DebugBreak
IsDebuggerPresent
InitializeCriticalSection
RtlCaptureContext
RtlLookupFunctionEntry
RtlVirtualUnwind
UnhandledExceptionFilter
SetUnhandledExceptionFilter
GetCurrentProcess
TerminateProcess
IsProcessorFeaturePresent
QueryPerformanceCounter
GetSystemTimeAsFileTime
DisableThreadLibraryCalls
InitializeSListHead
api-ms-win-core-heap-l1-1-0.dll
api-ms-win-core-io-l1-1-0.dll
api-ms-win-core-sysinfo-l1-1-0.dll
api-ms-win-core-errorhandling-l1-1-0.dll
api-ms-win-core-libraryloader-l1-2-0.dll
api-ms-win-core-synch-l1-1-0.dll
api-ms-win-core-threadpool-l1-2-0.dll
api-ms-win-core-file-l1-1-0.dll
api-ms-win-core-processthreads-l1-1-0.dll
api-ms-win-core-localization-l1-2-0.dll
api-ms-win-core-debug-l1-1-0.dll
api-ms-win-core-handle-l1-1-0.dll
ntdll.dll
api-ms-win-core-processthreads-l1-1-1.dll
api-ms-win-core-profile-l1-1-0.dll
api-ms-win-core-interlocked-l1-1-0.dll
GetOverlappedResult
CreateEventA
memcmp
memcpy
memmove
.?AVbad_alloc@std@@
.?AVResultException@wil@@
.?AVexception@std@@
.?AVbad_array_new_length@std@@
.?AVlength_error@std@@
.?AVlogic_error@std@@
.?AVtype_info@@
VS_VERSION_INFO
StringFileInfo
040904B0
CompanyName
Microsoft Corporation
FileDescription
Hyper-V Virtual Switch Driver Core Interface Library
FileVersion
10.0.22621.1 (WinBuild.160101.0800)
InternalName
Hyper-V Virtual Switch Driver Core Interface Library
LegalCopyright
 Microsoft Corporation. All rights reserved.
OriginalFilename
vmsifcore.dll
ProductName
Microsoft
 Windows
 Operating System
ProductVersion
10.0.22621.1
VarFileInfo
Translation
Washington1
Redmond1
Microsoft Corporation1.0,
%Microsoft Windows Production PCA 20110
210902182341Z
220901182341Z0p1
Washington1
Redmond1
Microsoft Corporation1
Microsoft Windows0
9Ocr4
Ge]L*
E0C1)0'
 Microsoft Operations Puerto Rico1
229879+4675790
M0K0I
Chttp://www.microsoft.com/pkiops/crl/MicWinProPCA2011_2011-10-19.crl0a
U0S0Q
Ehttp://www.microsoft.com/pkiops/certs/MicWinProPCA2011_2011-10-19.crt0
jFtg)]
Washington1
Redmond1
Microsoft Corporation1200
)Microsoft Root Certificate Authority 20100
111019184142Z
261019185142Z0
Washington1
Redmond1
Microsoft Corporation1.0,
%Microsoft Windows Production PCA 20110
O0M0K
Ehttp://crl.microsoft.com/pki/crl/products/MicRooCerAut_2010-06-23.crl0Z
N0L0J
>http://www.microsoft.com/pki/certs/MicRooCerAut_2010-06-23.crt0
TlP0X
R!s4Z
Washington1
Redmond1
Microsoft Corporation1.0,
%Microsoft Windows Production PCA 2011
,G8vJmppuEFBibEjSxIc+NjTvJ5qx0D03TBsSHndkC9c=0Z
"Microsoft Window
 http://www.microsoft.com/windows0
20220506222411.313Z0
Washington1
Redmond1
Microsoft Corporation1)0'
 Microsoft Operations Puerto Rico1&0$
Thales TSS ESN:D9DE-E39A-43FE1%0#
Microsoft Time-Stamp Service
Washington1
Redmond1
Microsoft Corporation1&0$
Microsoft Time-Stamp PCA 20100
220302185129Z
230511185129Z0
Washington1
Redmond1
Microsoft Corporation1)0'
 Microsoft Operations Puerto Rico1&0$
Thales TSS ESN:D9DE-E39A-43FE1%0#
Microsoft Time-Stamp Service0
1?\d*W
z'@Mb
@gJ<|IZ
X0V0T
Nhttp://www.microsoft.com/pkiops/crl/Microsoft%20Time-Stamp%20PCA%202010(1).crl0l
`0^0\
Phttp://www.microsoft.com/pkiops/certs/Microsoft%20Time-Stamp%20PCA%202010(1).crt0
y{?*9
NS;bL
Washington1
Redmond1
Microsoft Corporation1200
)Microsoft Root Certificate Authority 20100
210930182225Z
300930183225Z0|1
Washington1
Redmond1
Microsoft Corporation1&0$
Microsoft Time-Stamp PCA 20100
q\Q17
&S|9a
!]_0t
U0S0Q
3http://www.microsoft.com/pkiops/Docs/Repository.htm0
O0M0K
Ehttp://crl.microsoft.com/pki/crl/products/MicRooCerAut_2010-06-23.crl0Z
N0L0J
>http://www.microsoft.com/pki/certs/MicRooCerAut_2010-06-23.crt0
>NGdx
fg:SM
xSu$W
as.,k{n?,
J>f;O
!TkjE
Washington1
Redmond1
Microsoft Corporation1)0'
 Microsoft Operations Puerto Rico1&0$
Thales TSS ESN:D9DE-E39A-43FE1%0#
Microsoft Time-Stamp Service
Washington1
Redmond1
Microsoft Corporation1&0$
Microsoft Time-Stamp PCA 20100
20220506190839Z
20220507190839Z0w0=
1/0-0
1(0&0
Washington1
Redmond1
Microsoft Corporation1&0$
Microsoft Time-Stamp PCA 2010
Washington1
Redmond1
Microsoft Corporation1&0$
Microsoft Time-Stamp PCA 2010
wuM#>
@[T1OG
