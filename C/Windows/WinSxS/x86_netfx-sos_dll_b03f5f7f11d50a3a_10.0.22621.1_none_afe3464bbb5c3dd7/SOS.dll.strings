!This program cannot be run in DOS mode.
Richb-m
.text
`.data
.rsrc
@.reloc
)+d )+d0)+d
g*d$q*d
rexception during reading PEB
    Unable to read FullDllName address at %p
SizeOfImage
DllBase
FullDllName
InMemoryOrderLinks
LDR_DATA_TABLE_ENTRY
    Unable to read InMemoryOrderModuleList address at %p
InMemoryOrderModuleList
PEB_LDR_DATA
    Unable to read PEB_LDR_DATA address at %p
ntdll
System
Object
UIntPtr
IntPtr
TypedReference
String
Double
Single
UInt64
Int64
UInt32
Int32
UInt16
Int16
SByte
Boolean
SOS Error: Out of memory
PDB symbol for mscorwks.dll not loaded
/f mscorwks.dll
mscorwks
Display of context static variables is not implemented yet
GENERICARRAY
SZARRAY
FNPTR
Native Real
VALUEARRAY
ARRAY
CLASS
VALUETYPE
BYREF
Unknown Module
Dynamic Module
  Module Name
SecurityDescriptor: %p
ClassLoader: %p
UNKNOWN
CLOSED
COLLECTED
CLEARED
HANDLETABLE_NOACCESS
FINALIZED
FINALIZING
EXITED
EXITING
UNLOAD_REQUESTED
ACTIVE
READYFORMANAGEDCODE
CREATING
 (Dynamic)
Assembly: %p
Unable to get array of Assemblies
Error getting AppDomain friendly name
Name: 
Stage: %s
StubHeap: %p
HighFrequencyHeap: %p
LowFrequencyHeap: %p
UNKNOWN
%p is not a MethodDesc
Invalid module token
Not JITTED yet.
<Error getting MethodDesc information>
Not JITTED yet. Use !bpmd -md %p to break on run.
JITTED Code Address: %p
MethodDesc: <not loaded yet>
MethodDesc: %p
Field name: %S
Name: %S
EEClass: <not loaded yet>
MethodTable: <not loaded yet>
EEClass: <error getting EEClass>
EEClass: %p
MethodTable: %p
Token: 0x%p
not supported
TYPED
FILTER
FINALLY
FAULT
Unknown MethodDesc (Module %p, mdToken %08x)
CodeAddr: %p
IsJitted: %s
Module: %p
mdToken: %08x
Class: %p
Method Name: %S
Failed to request Thread at %p
/f mscoree.dll
sos.dll
Unknown option: %s
Missing value for option %s
Invalid option: option specified multiple times: %s
Invalid option %s
Wrong option: %s
Incorrect argument: %s
Missing quote in %s
%I64u
%I64d
dynamic statics NYI
Unable to get AppDomain %lx
 %p:FailInit
 %p:NotInit 
    >> Domain:Value 
Unable to get array of AppDomains
Unable to get AppDomain information
  error getting thread %p, aborting this field
    >> Thread:Value
<Unloaded Type>
Field (mdToken token) of
Member (mdToken token) of
-----------------------
<String is invalid or too large to print>
Error getting string data
<Invalid Object>
Unable to display fields
instance
static
 <no information>
%8s %8s
shared
CLstatic
TLstatic
%20.20s 
%20.20S 
%p %8x %8x 
Invalid parent EEClass
Invalid parent MethodTable
%8s %8s %8s %20s %2s %8s %8s %s
Field
Offset
Value
Unable to get AppDomain %p
Failed to get appdomain list
Unable to get appdomain store
StressLog TaskSwitch Marker
BAD TIME
HH:mm:ss
`ALL`
LF_GC
LF_GCINFO
LF_STUBS
LF_JIT
LF_LOADER
LF_METADATA
LF_SYNC
LF_EEMEM
LF_GCALLOC
LF_CORDB
LF_CLASSLOADER
LF_CORPROF
LF_REMOTING
LF_DBGALLOC
LF_EH
LF_ENC
LF_ASSERT
LF_VERIFIER
LF_THREADPOOL
LF_GCROOTS
LF_INTEROP
LF_MARSHALER
LF_IJW
LF_ZAP
LF_STARTUP
LF_APPDOMAIN
LF_CODESHARING
LF_STORE
LF_SECURITY
LF_LOCKS
LF_BCL
LF_ALWAYS
(#Could not read address of string#)
 (Unknown function)
 (Unknown VTable)
 (%s)
 (BAD MethodTable)
 Low Bit(s) Set
(MethodTable: %p)
 (%S)
UNKNOWN METHODDESC
 (BAD Method)
 (MethodDesc: %p)
%-20s 
%4x %13.9f : 
----- No thread logs in the image: The stress log was probably not initialized correctly. -----
---------------------------- %d total entries ------------------------------------
----- Interrupted by user -----
------------ Last message from thread %x -----------
Task was switched from %x
Could not read address of format string
--------------------------------------------------------------------------------------
  ID  (sec from start)
THREAD  TIMESTAMP     FACILITY                              MESSAGE
    Total elapsed time %5.3f sec
    Last message time  %S
    Start time         %S
    Clock frequency  = %5.3f GHz
STRESS LOG:
    facilitiesToLog  = 0x%x
    levelToLog       = %d
    MaxLogSizePerThread = 0x%x (%d)
    MaxTotalLogSize = 0x%x (%d)
    CurrentTotalLogChunk = %d
    ThreadsWithLogs  = %d
Invalid stress log chunk: %p
ReadVirtual failed with code hr = %x.
Stress log address = 0x%p
Stress log in module 0x%p
Writing to file: %s
dword ptr ds:[
dword ptr [
offset 
EHHandler %d: %s FILTER BEGIN
EHHandler %d: %s HANDLER END
EHHandler %d: %s HANDLER BEGIN
EHHandler %d: %s CLAUSE END
 CLAUSE BEGIN
 catch(...)
EHHandler %d: %s
>>> %s:%d
Extension commands need mscorwks.dll in order to have something to do.
Failed to find runtime DLL (mscorwks.dll), 0x%08x
path is pointing to mscorwks.dll as well.
If you are debugging a minidump, you need to make sure that your executable
If that succeeds, the SOS command should work on retry.
load of mscordacwks.dll.  .cordll -ve -u -l will do a verbose reload.
You can also run the debugger command .cordll to control the debugger's
                machine.
                For example, an IA64 dump file must be debugged on an IA64
            4) you are debugging on the same architecture as the dump file.
                mscordacwks_<arch>_<arch>_<version>.dll is on your symbol path.
            3) or, if you are debugging a dump file, verify that the file 
                in the version directory
            2) the file mscordacwks.dll that matches your version of mscorwks.dll is 
Verify that 1) you have a recent build of the debugger (6.2.14 or newer)
Failed to load data access DLL, 0x%08x
%02X 
<'dEAX
<'d    argTabOffset = %x  
    epilog #%2u    at   %04X
    epilog        at   %04X
    Sync region = [%u,%u]
    GuardStack cookie  = [%s%u]
    varargs            = yes
    profiler callbacks = yes
    edit & continue    = yes
    localloc           = yes
    exception handlers = yes
    security check obj = yes
    var ptr tab count  = %2u 
    untracked count    = %2u 
    stack frame size   = %2u DWORDs
    arguments size     = %2u DWORDs
    double align       = %s  
    fully interruptible= %s  
    ebp frame          = %s  
    callee-saved regs  = 
    epilog      end    = %s  
    epilog     count   = %2u 
    epilog      size   = %2u 
    prolog      size   = %2u 
    method      size   = %04X
 argMask=%02X
 argOffs(%d) =
EBP%c
        call %d [ 
            thisptr in %s
            iptrMask = %02X
        pop %d
       push %d
        push
 (iargs=%02X)
] argMask=%02X
] ptrArgs=[
EBX%c
ESI%c
EDI%c
        call [ 
            thisptr in 
Unexpected special code %04X
        kill args %2d
  (%d)
        push ptr %2d
args (%d)
        pop %2d 
        push non-ptr (%d)
 (iptr)
 'this'
        reg %s becoming %s
%s%s pointer
byref 
  [E%s%02XH] a 
an untracked %s%s local
pinned 
byref
            [E%cP+%02XH] 
            [E%cP-%02XH] 
Wrong option: stack selection wrong
TEB information is not available so a stack size of 0xFFFF is assumed
_items
m_tokens
m_scope
m_code
m_resolver
Fields:
 (%S)
Invalid EEClass address
Size: %d(0x%x) bytes
MethodTable %p
Type Name: %S
Type MethodTable: %p
m_handle
ThinLock owner %x (%p), Recursive %x
Object
String: 
Element Type: %S
Array: Rank %d, Number of elements %d, Type %s
Error when reading RuntimeType field
m_runtimeType
System.RuntimeType+RuntimeTypeCache
System.RuntimeType
Size %d(0x%x) bytes
Free Object
Invalid object
<Note: this object has an invalid CLASS field>
System.Exception
System.Security.SecurityException
    SP       IP       Function
consistency errors.
work properly. !dumpheap and !verifyheap may incorrectly complain of heap 
displaying, finding or traversing objects as well as gc heap segments may not 
we are at the initialization or shutdown of the gc heap. Commands related to 
It is either in the "plan phase," where objects are being moved around, or
The garbage collector data structures are not in a valid state for traversal.
exception during sorting
exception during printing
Shared
Error getting System.RuntimeType.m_handle offset
Exiting...
Object header for %p should have a SyncBlock index of %d
SyncBlock %d corrupted, points to invalid object %p
Error requesting SyncBlock %d, continuing
SyncBlk table validation failed
%8p %8p %8p %9s
%8s %8s %8s Apartment
CONTEXT
THREAD
RuntimeCallableWrappers (RCW) to be cleaned:
%p 0x%08x %S
Security
Assembly
IOCompletion
Threadpool
Memory
Failed to request Context at %p
 (nested exceptions)
 <Invalid Object> (%p)
 %S (%p)
 (Threadpool Completion Port)
 (Threadpool Worker)
 (GC)
 (Finalizer)
 %p:%p
 Enabled 
 Disabled
%4x %4x %p  %8x
XXXX 
<<<< 
       ID OSID ThreadOBJ    State     GC       Context       Domain   Count APT%s Exception
                                      PreEmptive   GC Alloc           Lock
 Fiber   
Hosted Runtime: %s
DeadThread: %d
PendingThread: %d
BackgroundThread: %d
UnstartedThread: %d
ThreadCount: %d
Failed to request ThreadStore
Failed to switch to original thread
Wait 
ThreadpoolWorker 
IOCompletion 
ShutdownHelper 
ADUnloadHelper 
Finalizer 
SuspendEE 
Shutdown 
DbgHelper 
Gate 
Timer 
%5d %6x    
Failed to get thread type info not found for thread %d
Failed to get CLR Tls data for thread %d
Failed to get Tls expansion slots for thread %d
Failed to get Teb for Thread %d
Failed to switch to thread %d
Failed to get thread ID for thread #%d
       OSID     Special thread type
Failed to require total thread number
Failed to require current Thread ID
Failed to retrieve Tls Data index
Failed
Failed to start stack walk. Current thread is not managed
Error: bad threadcount (should be between 2 and 4)
Validation was successful
Verify that we can list threads: Success
Error: unable to find the finalizer thread
Error: Failed to request Thread
More threads were found than specified by DacpThreadStoreData.threadCount
Verify that we can list threads: 
Verify DumpDomain functionality: Success
Error: AppDomain name incorrect
unittest.exe
Failed to get appdomain, error %lx
Unexpected domain count
Unable to get shared domain info
Unable to get system domain info
Verify DumpDomain functionality: 
Success
Failed to complete stackwalking
GetFrameContext failed: %lx
Get frame data failed with %lx
Mainy.Level
Mainy.Top
Mainy.The
Mainy.Is
Mainy.This
Mainy.DebugBreak
Failed to start stack walk: %lx
Verify StackWalk: 
Error: caught exception in VerifyDACInternal
Setting breakpoint: %s [%S]
bp %p
Failed to set code notification
Filter: [%p] [%x]
Handler: [%p, %p] [%x, %x]
Clause: [%p, %p] [%x, %x]
(duplicate)
catch(...) 
EHHandler %d: %s 
FAILURE: Stress log not dumped
No Stress log in the image, no file written
SUCCESS: Stress log dumped
Attempting to dump Stress log to file '%s'
Unable to find stress log via DAC
MSCORWKS!StressLog::theLog
-addr
StressLog.txt
CLR not loaded
To try the command anyway, run !MinidumpMode 0
This command is not supported in a minidump without full memory
Bad MethodTable for Obj at %p
Other Handles: %d
Weak Short Handles: %d
Weak Long Handles: %d
Ref Count Handles: %d
Async Pinned Handles: %d
Pinned Handles: %d
Strong Handles: %d
0x%p 
<CLR reg> 
    LOCALS:
<no data>
<unable to retrieve data>
%S = 
        
    PARAMETERS:
    %p %p %S
   at 
Expected newline in documentation resource
Documentation for %s not found
COMMAND: %s.
Error loading documentation resource
DOCUMENTATION
contents
-------------------------------------------------------------------------------
Unsafe minidump commands are %s.
Mode must be 0 or 1
enabled
Current mode: %s - unsafe minidump commands are %s.
disabled
Failed to request MethodData, not in JIT code range
%s is not IP
OS Thread Id: 0x%x 
Thread %3d
---------------------------------------------
-short
Unable to determine bounds of gc heap
wrong option: %s
-verify
running "!DumpArray %p".
in parenthesis. You can also look at the token table yourself, by
If a token is unresolved, run "!do <addr>" on the addr given
This is dynamic IL. Exception info is not reported at this time.
Not enough memory to read IL
Error gathering dynamic info from object at %p
Failed to read memory
ilAddr = %p
error decoding IL
FindIL failed
error in import
bad import
Unable to get module
Unable to print IL for DynamicMethodDesc %p
Unable to build snapshot of the garbage collector state
Must pass a valid expression
ContextStaticsSize: %x
ContextStaticOffset: %x
ThreadStaticsSize: %x
ThreadStaticOffset: %x
NumStaticFields: %x
NumInstanceFields: %x
ComImport, 
Abstract, 
Interface, 
Class Attributes: %x  
Total Method Slots: %x
Vtable Slots: %x
Method Table: %p
Module: %p
Parent Class: %p
EEClass has an invalid MethodTable address
mdToken: %p (%S)
Class Name: 
Missing EEClass address
FCALL
PreJIT
  %p 
<error getting slot %d>
%8s %s
%10s 
MethodDesc
Entry
MethodDesc Table
--------------------------------------
Slots in VTable: %d
Number of IFaces in IFaceMap: %x
ComponentSize: 0x%x
BaseSize: 0x%x
 (%ws)
mdToken: %08x 
Unable to retrieve EEClass
Free MethodTable
%p is not a MethodTable
Missing MethodTable address
Invalid parameter %s
-nofields
Not a managed object
Example: DumpVC 907b50 67903084
Usage: DumpVC <Method Table> <Value object start addr>
file %s saved
Unable to write heap report
Error initializing heap traversal
Gathering types...
Writing %s format to file %s
CLRProfiler
Unable to open file
usage: HeapTraverse [-xml] filename
------------------------------------------------------------------------------
%8s %8s %8s Type Name              
Address
Domain
Free            %d
ComClassFactory %d
RCW             %d
CCW             %d
Total           %d
-----------------------------
 Free
  %8d
    none  
 XXX 
 orphaned 
%11d 
SyncBlock %d is invalid%s
, continuing...
Index SyncBlock MonitorHeld Recursion Owning Thread Info  SyncBlock Owner
Error requesting SyncBlk data
STA Interfaces to be released: %d
MTA Interfaces to be released: %d
TypeRef
Types referenced in this module
%8s %10s %s
TypeDef
Types defined in this module
MetaData start address: %p (%d bytes)
AssemblyReferencesMap: %p
FileReferencesMap: %p
MemberRefToDescMap: %p
FieldDefToDescMap: %p
MethodDefToDescMap: %p
TypeRefToMethodTableMap: %p
TypeDefToMethodTableMap: %p
LoaderHeap: %p
Assembly: %p
SupportsUpdateableMethods
Reflection 
PEFile 
Attributes: 
Name: %ws
Fail to fill Module %p
Usage: DumpModule [-mt] <Module Address>
Failed to get appdomain %p, error %lx
Domain %d: %p
System Domain: %p
Shared Domain: %p
Fail to fill AppDomain
Parent Domain: %p
Fail to fill Assembly
Invalid Assembly %s
Special thread information is not available in mini dumps.
-live
-special
The current thread is unmanaged
b9: %S
b8: %S
b7: %S
b6: %S
b5: %S
b4: %S
b3: %S
b2: %S
b1: %S
Watson Bucket parameters:
Can't get Watson Buckets
Not supported on mini dumps.
Failed to examine a WorkRequest
 CurrentLimit: %d
 MaxFree: %d
 Free: %d
Total: %d
Completion Port Thread:
Number of Timers: %d
Unknown Function: %p  Context: %p
AsyncTimerCallbackCompletion TimerInfo@%p
AsyncCallbackCompletion AsyncCallback@%p
QueueUserWorkItemCallback DelegateInfo@%p
Work Request in Queue: %d
 MinLimit: %d
 MaxLimit: %d
 Idle: %d
 Running: %d
 Total: %d
Worker Thread:
CPU utilization %d%%
Failed to request ThreadpoolMgr information
%p is not a valid object
AppDomains.
the Thread could have transitioned between multiple
the AppDomain of that stack with !threads. Note that
!gcroot %p, and if you find a root on a stack, check 
methods of finding the AppDomain failed. Try running
The type is declared in the shared domain and other
Error getting AppDomain %p
ID: %d
ID: (system domain)
Name: System Domain
ID: (shared domain)
Name: Shared Domain
AppDomain: %p
Error getting AppDomain information
Failed to perform EHInfo traverse
<user aborted>
Unable to get codeHeader information
No EH info available
%p is not a valid MethodDesc
Pointer table:
Method info block:
Could not read memory %p
GC info %p
preJIT generated code
Normal JIT generated code
GCinfo for EJIT not supported
unknown Jit
entry point %p
No GC info available
Cold region:
Hot region:
Failed to gather EHInfo data
Begin %p, size %x
Begin %p, size %x. Cold region begin %p, size %x
EJIT generated code
not a valid MethodDesc
Not jitted yet
Unmanaged code
-ehinfo
-gcinfo
 retail build
SOS Version: %u.%u.%u.%u
In plan phase of garbage collection
Workstation mode
Server mode with %d gc heaps
GC Heap not initialized, so GC mode is not determined yet.
 free
 retail
 Checked or debug build
%u.%u.%u.%u
Virtual Memory    %8d     %8d
Page File         %8d     %8d
Physical Memory   %8d     %8d
                  %8s     %8s
Total
Avail
Memory Availability (Numbers in MB)
%ld percent of memory is in use.
PagefileUsage:  %8d KB       PeakPagefileUsage:  %8d KB
VirtualSize:    %8d KB       PeakVirtualSize:    %8d KB
WorkingSetSize: %8d KB       PeakWorkingSetSize: %8d KB
Process Memory
NtQueryInformationProcess
ntdll.dll
Total  CPU time   : %d days %02d:%02d:%02d.%02d
User   CPU time   : %d days %02d:%02d:%02d.%02d
Kernel CPU time   : %d days %02d:%02d:%02d.%02d
Process Started at: %4d %s %2d %d:%d:%d.%02d
Process Times
GetProcessTimes
Kernel32.dll
Environment
_RTL_USER_PROCESS_PARAMETERS
ProcessParameters
Environment
---------------------------------------
-time
!ProcInfo is not supported on a dump file.
Module: %p (%S)
       you can pass * for module_name to search all modules
Usage: Token2EE module_name mdToken
          !Name2EE *!System.String
Examples: !Name2EE  mscorlib.dll System.String.ToString
       use * for module_name to search all loaded modules
  or    !Name2EE module_name!item_name
Usage: !Name2EE module_name item_name
more info.
Note: Roots found on stacks may be false positives. Run "!help gcroot" for
Invalid argument %s
-nostacks
ex:    StopOnException -create System.OutOfMemoryException 1
                       [<pseudo-register number for result>]
usage: StopOnException [-derived] [-create | -create2] <type name>
Breakpoint set
Error setting breakpoint: %s
sxe %s "!soe %s %s %s;.if(@$t%d==0) {g} .else {.echo '%s hit'}" clr
Failed to execute the following command: %s
r$t%d=1
There is no current managed exception on this thread
Error initialized register $t%d to zero
r$t%d=0
Pseudo-register number must be between 0 and 19
Live debugging session required
-create2
-create
-derived
%p is not a valid object.
identify a possible trend.                                                    
positives. If you still suspect a leak, use this function over time to        
differentiate between garbage and valid structures, so you may have false     
A leak may still exist because in a general scan of process memory SOS can't  
 even though you aborted.
All handles found
Didn't find %d handles:
scan wouldn't be able to find those.                                          
the handle in a non-standard way, perhaps with some bits flipped. The memory  
may be some noise in this output, as an unmanaged application may be storing  
by the orphaned handle. If the number doesn't grow over time, note that there 
the GC Heap to grow larger as objects are being kept alive, referenced only   
lifetime of your application, you may have a GCHandle leak. This will cause   
Some handles were not found. If the number of not-found handles grows over the
Quitting at %p due to user abort
only read %x bytes at %p
Found %p at location %p
Found %p in stress log at location %p, reference not counted
Searching %p...
Failed to read whole or part of stress log, some references may come from stress log
Reference found in stress log will be ignored
Searching memory
Found %d handles:
memory scan with Control-C or Control-Break.                                   
Strong and Pinned GCHandles are reported at this time. You can safely abort the
GCHandleLeaks will report any GCHandles that couldn't be found in memory.      
the process
managed thread. You can run !threads to get a list of managed threads in
Unable to walk the managed stack. The current thread is likely not a 
<aborted>
<interrupted>
 [Frame: %p]
 [%S: %p]
 %08x
%-8s  %-8s
!VMMap requires a full memory dump (.dump /ma) or a live process.
!VMStat requires a full memory dump (.dump /ma) or a live process.
%p is not a Module or base address
Fail to read memory
Fail to create file %s
Fail to read PE section info
File not specified
section %d - VA=%x, VASize=%x, FileAddr=%x, FileSize=%x
%u sections in file
Module does not have base address
Invalid arg
Usage: SaveModule <address> <file to save>
%p %p 
(TransitionUM)
(TransitionMU)
Out of memory
Invalid signature
Invalid parameters %s %s
DumpMethodSig <sigaddr> <moduleaddr>
DumpSig <sigaddr> <moduleaddr>
    %S
SecurityException Message: 
m_debugString
HResult: %lx
_HResult
StackTraceString: 
_stackTraceString
<Not Available>
Unable to decipher generated stack trace
StackTrace (generated):
_stackTrace
<none>
%S, use !PrintException %p to see more
InnerException: 
_innerException
<none>
Message: 
_message
Exception type: <Unknown>
Exception type: %S
Exception object: %p
Not a valid exception object
Error retrieving nested exception info %p
Nested exception -------------------------------------------------------------
There are nested exceptions on this thread. Run with -nested for details
Invalid exception object %s
-nested
 4)dp4)d
4)d 6)d
4)dJITTED %S!%S
Error processing exception notification
Expecting an exception event
Error in GetLastEventInformation
Unable to get method name for MethodDesc %p
Attempted to run: %s
Unable to set breakpoint with IDebugControl::Execute: %x
ba w4 /1 %p "bp poi(%p); g"
This DynamicMethodDesc is not yet JITTED. Placing memory breakpoint at %p
sxe -c "!bpmd -notification;g" clrn
Adding pending breakpoints...
MethodDesc = %p
Found %d methods...
Error getting MethodDescs
There are multiple modules with the same name...
See "!help bpmd" for more details.
Usage: !bpmd <module name> <managed function name>
Usage: !bpmd -md <MethodDesc pointer>
-notification
!bpmd is not supported on a dump file.
(System Domain)
(Shared Domain)
GC Handle Statistics for AppDomain %p 
GC Handle Statistics:
A minidump without full memory may not have this information
Unable to display GC handles
Error getting per-appdomain handle information
-perdomain
_remoteStackTraceString
Simple Context information:
%p %p %p
%8s %8s %8s
Context information:
Number of characters requested: %d
Error: %lx
_EFN_GetManagedExcepStack(NULL, szStr, sizeof(szStr)) returned:
_EFN_GetManagedExcepStack(%P, szStr, sizeof(szStr)) returned:
Error!
-ManagedExcepStack
interrupted by user
 null
Failed to read element at 
Failed to read bounds info from the array
Failed to read lower bounds info from the array
Integer overflow on array rank
Element Methodtable: %p
Name: %S[
-nofields has no effect unless -details is specified
Start index out of range
For multi-dimension array, length and start index are supported
GC Heap Size  %#8I32x(%I32u)
Heap Size  %#8I32x(%I32u)
Heap %d (%p)
------------------------------
Failed to get GCHeaps
Failed to get GCHeaps: integer overflow
Total Size  %#8I32x(%I32u)
Error requesting details
Number of GC Heaps: %d
Error requesting GC Heap data
=======================================
Total LoaderHeap size: 0x%I32x(%I32u)bytes
Module Lookup Table heaps:
Module %p: 
Unable to read module %p
Module Thunk heaps:
<no information>
Jit code heap:
Domain %d: %x
Shared Domain: %x
Total size: 0x%I32x(%I32u)bytes
Virtual Call Stub Heap:
StubHeap: 
HighFrequencyHeap: 
LowFrequencyHeap: 
Loader Heap:
-loader
%p %6.1fMB         %p %S
A%8s %8s %16s
Followed by
Fragmented blocks larger than 0.5 MB:
total %d objects
Heap %d
Failed to get GCHeaps:  integer overflow
Error requesting gc heap details
If you need this functionality, get a full memory dump with ".dump /ma mydump.dmp"
In a minidump without full memory, most gc heap structures will not be valid.
-verify will only produce output if there are errors in the heap
Cannot specify both -short and any of (-stat, -thinlock, -strings, -verify)
wrong argument
Cannot specify both -mt and -type
-thinlock
-type
-startatlowerbound
-strings
-stat
-verify 
----------------------------------
SyncBlocks to be cleaned up: %d
%8p %8p %8p %8p
%8s %8s %8s %8s
SyncBlock
ComClassFactory
SyncBlocks to be cleaned by the finalizer thread:
-detail
  %8x
%3d %4x %p
     ID     TEB   APT    APTId CallerTID Context
  Error!  integer overflow on numThread 0x%08x
Not an array, please use !DumpObj instead
-details
-length
-start
SOS failure
SOS failure!
You can create one with .dump /ma <filename>
sos.dll needs a full memory dump for complete functionality.
------------------------------------------------------------
%p(%S)
%p(%S)->
Root:
Scan Thread %d OSTHread %x
HANDLE(Unknwn):
HANDLE(AsyncPinned):
HANDLE(WeakLn):
HANDLE(WeakSh):
HANDLE(Strong):
HANDLE(RefCnt):
HANDLE(Pinned):
DOMAIN(%p):
Searching for the first %d handles, ignoring the rest
Error reading card bits
Error getting next card table
Error getting card table lowest address
object %p: missing card_table entry for %p
object %p: bad member %p at %p
object %p: fail to read members
object %p: bad GCDesc
object %p: bad MT
object %p: size %d too small
t %d 0 %S
<type id="%d" name="%S"/>
o 0x%p %d %d 
! 1 0x%p %d
n %d 1 %d %d
<object address="0x%p" typeid="%d" size="%d">
 0x%p
    <member address="0x%p"/>
</object>
<root kind="%S" address="0x%p"/>
</objects>
</roots>
</types>
</gcheap>
<objects>
<roots>
<types>
<gcheap>
stack
handle
Not enough memory to trace the heap
%s: %p (invalid object)
sizeof(%p) = %12I32u (%#12I32x) bytes
Error during heap traverse
Walking heap...
tracing roots...
Finalizer queue
Please note that %p is not a valid object.
Total %d objects
%p %8d %12I32u 
%8d %12I32u "%S"
%8s %8s %12s %s
Class Name
%8s %12s %s
Count
TotalSize
String Value
Statistics:
(0x%p, 0x%p)
ephemeral segment allocation context: 
generation %d starts at 0x%p
Error requesting heap segment %p
%p %p  %p 0x%p(%d)
Large object heap starts at 0x%p
 segment    begin allocated     size
Unable to read memory at %p
strike: Failed to store segment
More than %d heap segments, there must be an error
Object %p has no generation
:%x) 
%p(%x
Wasted: 0x%x(%lu)bytes.
Size: 0x%x(%lu)bytes.
Total size: 0x%x(%d)bytes
Unable to get code heap info
Error getting EEJitManager code heaps
Unknown Jit encountered, ignored
Size: 0x%x(%d)bytes.
HostCodeHeap: 
LoaderCodeHeap: 
Unable to get array of JIT Managers
Unable to get JIT info
  CacheEntryHeap: 
  DispatchHeap: 
  ResolveHeap: 
  LookupHeap: 
  Wasted: 0x%x(%lu)bytes.
  IndcellHeap: 
Ready for finalization %d objects 
(%p->%p)
generation %d has %d finalizable objects 
curr_object: %p > heap_segment_allocated (seg: %p)
----------------
curr_object : %p
object %p: does not have valid MT
Last good object: %p
curr_object: %p > end_youngest: %p
Not enough memory for complete fragmentation report
 ThinLock owner %x (%p) Recursive %x
%p %8d%s
     
<heap traverse interrupted>
<heap walk interrupted>
Traversing a gc heap failed
Failed to get GCHeaps:  integer overflow error
Failed to retrieve segments for gc heap
codelabel
endmac
illegal
readonly.
refanytype
sizeof
rethrow
initblk
cpblk
constrained.
initobj
tail.
volatile.
unaligned.
endfilter
localloc
stloc
ldloca
ldloc
starg
ldarga
ldarg
ldvirtftn
ldftn
clt.un
cgt.un
arglist
prefixref
prefix1
prefix2
prefix3
prefix4
prefix5
prefix6
prefix7
conv.u
stind.i
leave.s
leave
endfinally
sub.ovf.un
sub.ovf
mul.ovf.un
mul.ovf
add.ovf.un
add.ovf
conv.ovf.u
conv.ovf.i
conv.i
conv.u1
conv.u2
ldtoken
mkrefany
ckfinite
refanyval
conv.ovf.u8
conv.ovf.i8
conv.ovf.u4
conv.ovf.i4
conv.ovf.u2
conv.ovf.i2
conv.ovf.u1
conv.ovf.i1
unbox.any
stelem
ldelem
stelem.ref
stelem.r8
stelem.r4
stelem.i8
stelem.i4
stelem.i2
stelem.i1
stelem.i
ldelem.ref
ldelem.r8
ldelem.r4
ldelem.i
ldelem.i8
ldelem.u4
ldelem.i4
ldelem.u2
ldelem.i2
ldelem.u1
ldelem.i1
ldelema
ldlen
newarr
conv.ovf.u.un
conv.ovf.i.un
conv.ovf.u8.un
conv.ovf.u4.un
conv.ovf.u2.un
conv.ovf.u1.un
conv.ovf.i8.un
conv.ovf.i4.un
conv.ovf.i2.un
conv.ovf.i1.un
stobj
stsfld
ldsflda
ldsfld
stfld
ldflda
ldfld
throw
unbox
conv.r.un
isinst
castclass
newobj
ldstr
ldobj
cpobj
callvirt
conv.u8
conv.u4
conv.r8
conv.r4
conv.i8
conv.i4
conv.i2
conv.i1
shr.un
rem.un
div.un
stind.r8
stind.r4
stind.i8
stind.i4
stind.i2
stind.i1
stind.ref
ldind.ref
ldind.r8
ldind.r4
ldind.i
ldind.i8
ldind.u4
ldind.i4
ldind.u2
ldind.i2
ldind.u1
ldind.i1
switch
blt.un
ble.un
bgt.un
bge.un
bne.un
brtrue
brfalse
blt.un.s
ble.un.s
bgt.un.s
bge.un.s
bne.un.s
blt.s
ble.s
bgt.s
bge.s
beq.s
brtrue.s
brfalse.s
calli
unused
ldc.r8
ldc.r4
ldc.i8
ldc.i4
ldc.i4.s
ldc.i4.8
ldc.i4.7
ldc.i4.6
ldc.i4.5
ldc.i4.4
ldc.i4.3
ldc.i4.2
ldc.i4.1
ldc.i4.0
ldc.i4.m1
ldnull
stloc.s
ldloca.s
ldloc.s
starg.s
ldarga.s
ldarg.s
stloc.3
stloc.2
stloc.1
stloc.0
ldloc.3
ldloc.2
ldloc.1
ldloc.0
ldarg.3
ldarg.2
ldarg.1
ldarg.0
break
4`%x (%p)
<unknown token type (token=%08x)>
%x %S
%x "%S"
Error, unexpected opcode type
IL_%04x
VAR OR ARG %d
%*sIL_%04x: 
/* UNKNOWN TYPE (0x%X)*/
METHOD
method 
[BAD: RANK == 0!]
[ERROR! NIL TOKEN]
class 
valuetype 
typedref
string
object
native float
native int
native uint
float64
float32
uint64
int64
uint32
int32
uint16
int16
uint8
 pinned
 [ERROR: INVALID TOKEN TYPE 0x%8.8X] 
.module 
$%s$%X
 [ERROR: INVALID TOKEN 0x%8.8X] 
%S::%S
<unknown method def>
%S::%S 
<unknown type token>
<unknown type spec>
<unknown member ref>
<unknown token type %08x>
<unknown field def>
<unknown type ref>
<unknown type def>
STRING %x
%*s} // end .catch
%*s} // end .finally
%*s.catch
%*s.finally
%*s} // end .try
%*s.try
ExWrCp
ExRdWr
~~~~~~~
~~~~~~~~~
~~~~~
%-7s  %*s  %*s  %*s %*s  %*s
MINIMUM
MAXIMUM
AVERAGE
BLK COUNT
TOTAL
%-7s %*sK %*sK %*sK %*s %*sK
Summary
Large
Medium
Small
%08lx
Commit
Reserve
Image
Mapped
Private
%p-%p %p  %-13s %-13s %-8s %-8s
%-*s %-*s %-*s  %-13s %-13s %-8s %-8s
Start
Length
AllocProtect
Protect
State
[UNMANAGED]
[PROPERTY]
[LOCALSIG]
[FIELD]
[VARARG]
[FASTCALL]
[THISCALL]
[STDCALL]
[DEFAULT]
INTERNAL
CMOD_OPT
CMOD_REQD
GENERICArray
SZArray
Object
FNPTR
VALUEARRAY
TypedByRef
GENArray
MDArray
CopyCtor
Class
ValueClass
ByRef
String
Boolean
Unsupported token type
 mdToken: %08x (%ws)
Module in 
Dynamic 
Unable to get IMetaDataImport for module %p
NoName
[InvalidReference]
[hasThis] 
[explicit] 
PINNED 
<ELEMENT_TYPE_SENTINEL> 
 [explicit]
 [hasThis]
 (JitHelp: %s)
 (MD: %S)
 (Object: %S)
 (MT: %S)
<unknown type>
(%S[])
%-8s %p 
%08x (MethodDesc %#x %S)
 (stub for %S)
 [%s:%d]
+%#x 
(MethodDesc %#x 
%08x %08x 
ntdll!KiUserExceptionDispatcher
 exr@%x
cxr@%x
Code %x 
 ====> Exception 
, calling 
ChildEBP RetAddr  Caller,Callee
Current frame: 
%p %p 
ESP/REG  Object   Name
push 
call 
 (%S, mdToken: %08x)
 (gcstress)
%08x 
bad allocation
4*d'4*d'4*dcsm
F*dCorExitProcess
mscoree.dll
.mixcrt
EncodePointer
KERNEL32.DLL
DecodePointer
FlsFree
FlsSetValue
FlsGetValue
FlsAlloc
a,d(b,d 
h*dUnknown exception
 !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
e+000
GAIsProcessorFeaturePresent
KERNEL32
(null)
(null)
( 8PX
700WP
`h````
xpxxxx
UTF-8
UTF-16LE
UNICODE
('8PW
700PP
`h`hhh
xppwpp
runtime error 
TLOSS error
SING error
DOMAIN error
R6034
An application has made an attempt to load the C runtime library incorrectly.
Please contact the application's support team for more information.
R6033
- Attempt to use MSIL code from this assembly during native code initialization
This indicates a bug in your application. It is most likely the result of calling an MSIL-compiled (/clr) function from a native constructor or from DllMain.
R6032
- not enough space for locale information
R6031
- Attempt to initialize the CRT more than once.
This indicates a bug in your application.
R6030
- CRT not initialized
R6028
- unable to initialize heap
R6027
- not enough space for lowio initialization
R6026
- not enough space for stdio initialization
R6025
- pure virtual function call
R6024
- not enough space for _onexit/atexit table
R6019
- unable to open console device
R6018
- unexpected heap error
R6017
- unexpected multithread lock error
R6016
- not enough space for thread data
This application has requested the Runtime to terminate it in an unusual way.
Please contact the application's support team for more information.
R6009
- not enough space for environment
R6008
- not enough space for arguments
R6002
- floating point support not loaded
Microsoft Visual C++ Runtime Library
<program name unknown>
Runtime Error!
Program: 
InitializeCriticalSectionAndSpinCount
kernel32.dll
         (((((                  H
         h((((                  H
                                 H
 !"#$%&'()*+,-./0123456789:;<=>?@abcdefghijklmnopqrstuvwxyz[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
 !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`ABCDEFGHIJKLMNOPQRSTUVWXYZ{|}~
HH:mm:ss
dddd, MMMM dd, yyyy
MM/dd/yy
December
November
October
September
August
April
March
February
January
Saturday
Friday
Thursday
Wednesday
Tuesday
Monday
Sunday
 Complete Object Locator'
 Class Hierarchy Descriptor'
 Base Class Array'
 Base Class Descriptor at (
 Type Descriptor'
`local static thread guard'
`managed vector copy constructor iterator'
`vector vbase copy constructor iterator'
`vector copy constructor iterator'
`dynamic atexit destructor for '
`dynamic initializer for '
`eh vector vbase copy constructor iterator'
`eh vector copy constructor iterator'
`managed vector destructor iterator'
`managed vector constructor iterator'
`placement delete[] closure'
`placement delete closure'
`omni callsig'
 delete[]
 new[]
`local vftable constructor closure'
`local vftable'
`RTTI
`udt returning'
`copy constructor closure'
`eh vector vbase constructor iterator'
`eh vector destructor iterator'
`eh vector constructor iterator'
`virtual displacement map'
`vector vbase constructor iterator'
`vector destructor iterator'
`vector constructor iterator'
`scalar deleting destructor'
`default constructor closure'
`vector deleting destructor'
`vbase destructor'
`string'
`local static guard'
`typeof'
`vcall'
`vbtable'
`vftable'
operator
 delete
__unaligned
__restrict
__ptr64
__clrcall
__fastcall
__thiscall
__stdcall
__pascal
__cdecl
__based(
'dGetProcessWindowStation
GetUserObjectInformationA
GetLastActivePopup
GetActiveWindow
MessageBoxA
USER32.DLL
SunMonTueWedThuFriSat
JanFebMarAprMayJunJulAugSepOctNovDec
1#QNAN
1#INF
1#IND
1#SNAN
CONOUT$
YoJ1E
>V<4q
lfuFu
vnffy
`|+d@
SOS.pdb
t|+dl
`|+d1E
P+dhL
}#SVh
P+dhx
P+dhl
`|+d3
4:,dj
'dj\V
`|+d3
4:,dV
@a+d3
`|+d3
RQPWV
`|+d3
S QRh\
'dVPh
+dQRP
<,SWt0
`|+d3
4:,dSW
4:,dj
+dj/S
tqQPh$
+dPQR
t4QPh
QRPhx
`|+d3
4:,dS
9,dti
Q8VVVh
j4Wh<
+dVPj
tCSVWh@
SVWuA
`|+d3
+dj(j
SVWt/
9,dPSWQ
7[_^]
RPWVQ
+du+;
+dPQR
+dj+S
`|+d3
`|+d3
'd^_3
+dPQR
'd^_3
+dQRP
P+dWj
+dQRP
`|+d3
+dQRP
+dQRP
+dQRP
+dQRP
+dPVQ
A$;A u
Hb+d+
Lb+d|
Hb+d[]
`|+d3
hh!'dh
+dh`!'dR
ShL!'dP
h<!'dQ
h(!'dR
+dh`!'dP
Rh !'dP
X<suT
QRPSV
1(d#2(d
`|+d3
PhX%'d
QSh8%'d
PQhx$'dR
5h$'d
$hD$'dQ
Ph($'dR
h0#'dQ
S$;S(u
S$;S(u$;C
Ph8"'dQ
`|+d3
8:,dSV
PWh`&'d
PWh@&'d
PWh &'d
`|+d3
hP;'d
h(:'d
hl9'd
h 9'd
hH8'd
S(d,S(dBS(dZS(dpS(d
T(d!T(d4T(d>T(d
RhH?'d
Qh(?'d
Phl>'d
hL>'d
Ph,>'d
h|='d
h\='d
h<='d
<'dPQ
Rhl<'d
D$(vn
D$(QP
hL<'d
Vh0<'d
D$$+D$
,SUVW
)T$ "
|A'du
;'dPhXA'd
hPA'd
hHA'd
Ph,A'd
h|@'d
hl@'d
 Qhd@'d
 Ph\@'d
 RhT@'d
hH@'d
D@'du
h<@'d
9l$$v
)l$$u
h8@'d
Qh(@'d
 <'dRh
 Rhd@'d
 Qh\@'d
 PhT@'d
h8@'d
hx?'d
Phh?'d
+D$4^][
^(d$^(dZ_(d
f(dt_(d
`(d9`(dw`(d
_(d9`(d
f(d}d(d
L$$QR
;D$$v
hPB'd
s'h$B'd
T$ RjH
T$ Rj
B'dQRWV
+dWRP
B'dQRP
T$pWj
+dWPQ
B'dRPWQ
L$pWj
+dWRP
B'dQRP
T$tWj
+dWPQ
B'dRPWQ
WVh<C'd
T$,QRh
D$LPPh$C'd
L$HQj8
htC'dQRj
Ph\C'd
+dhLC'd
D$,PPh
T$$QRh$
L$(PQh
D$HPPh$C'd
h8D'dPQWS
T$tRj8
D$<RPh
D$\PS
L$`RPQh
Ph0E'd
T$LRj
T$LRj
E'dQP
h G'd
h0F'd
`|+d1E
hpG'd
htC'dPVPS
G'dhl
VhpH'd
RPVh8H'd
L$ RPQh
+dPQVh8I'd
I'dh-
I'dPh
I'dPh
'dhtI'dPh
'dhdI'dPh
'dhXI'dPh
'dhTI'dPh
'dhHI'dPh
`|+d3
T$4Rj8j
L$4Qh
T$@Rh
D$LPh
L$XQh
T$dRh
SUWh(K'd
D$(Ph
T$8Rj
L$8PQh|J'd
RhtJ'd
hlJ'd
hdJ'd
h\J'd
hTJ'd
RPh|J'd
hDJ'd
;l$ u
h<J'd
h$J'd
_][^3
hpN'd
hHN'd
h N'd
D$(Wj
QhXM'd
L$$QP
Rh,M'd
htL'd
h`L'd
hXL'd
h0L'd
`|+d3
SUVW3
hTR'd
T$(RP
T$,RP
Vh0R'd
L$4Qj
Vh`Q'd
h<Q'd
h0Q'd
+dRPQ
+dRPQ
T$ Rj
+dQRP
hhP'dh
hDP'd
;l$l|
hTO'd
?h(O'd
_^][3
h0++dh
`|+d1E
hhR'd
`|+d3
T$|Rj
`|+d3
L$(Qj
L$ QW
T$ RW
ITRPW
_^][3
PQhHS'd
h<S'd
h0S'd
^4RSWh
]_^[Y
h\T'd
hLT'd
T$4RP
D$<4T'd
h|S'd
h\S'd
\$(VWPQ
L$ QWh
QhlU'd
RhPU'd
Ph8U'd
Qh U'd
T$LRj
`|+d3
T$ RP
T$(Rh
f9\$4t
L$4Qh
u$9\$
T$(RP
9t$(uT
T$(RSP
|,9t$$u
T$,QRh
`|+d3
T$(RjH
T$ Rj
,V'dU
0V'dRS
D$xPW
`|+d3
WhdV'd
Rh`V'd
h4V'd
'dPhxW'd
pW'dQ
'dPhxW'd
t'hXW'd
pW'dPh4W'd
h\T'd
D$(RPh
h\T'd
D$8PQ
D$@ X'd
L$@Qh
L$@QP
D$@Ph
h\T'd
D$H X'd
D$\`X'd
T$,RP
h0X'd
Ph$X'd
T$`RP
D$4PQ
9\$,t$
h\T'd
T$LRP3
T$(RP
T$ Sj
L$\QR
;|$\v
h$B'd
D$tPh
hhX'd
h\T'd
h\T'd
+dSWR
9\$,t.
WWhhZ'd
+dRPQ
t1hPZ'd
hDZ'd
T$pRP
t1h0Z'd
+dRPQ
h Z'd
hPY'd
L$(QRW
`|+d3
h\T'd
L$PQj
hx\'d
hh\'d
RhT\'d
t%h(\'d
]tEWR
t%h(\'d
L$\QPh
D$$RPh
T$(QRh
D$DPh
L$NQh
T$`Rh
D$h$`
L$(Qhp['d
T$2RhX['d
D$@Ph@['d
L$JQh(['d
T$DRh
D$NPh
`|+d3
h\T'd
D$HPW
D$P$^'d
9l$,u
Uu#Vh
9l$Pt
D$XRPh
D$tPh
Qhx]'d
RhT]'d
Ph<]'d
$f9l$j
L$$QUj
D$$RPh
+dPQR
+dPQR
\$ Vh
h\T'd
L$,QS
D$4@^'d
u*Sh(^'d
h\T'd
hd^'d
u(hL^'d
h\T'd
L$,QR
t=hp_'d
t=hX_'d
T_'du
L$HQPh(_'d
T$LRh
h\T'd
'dh `'dh
Ph@u(d
h\T'd
|$|h8a'd
t$;\$
(a'du
'dPSh
9l$(u
9l$Xv
9l$Dt
9l$Dt
L$LPQh
T$dRh
D$pPh
D$,Ph
9l$Dt
T$<QRh
9l$Dt
Whx`'d
L$ Qhd`'d
T$,RhP`'d
D$8Ph<`'d
L$HQh(`'d
L$dPQh
h\T'd
Wh(^'d
Rh@x(d
`|+d3
h\T'd
D$0PW
+dSRP
9\$`t
9\$\t
hxc'dh
D$p t
h\c'dh
L$XPQhLc'd
RPh<c'd
D$@t"
T$LRQPhXb'd
h8b'd
'dh0b'dh`
'dh b'd
x(dSSPQ
a'dh`
'dh b'd
h\T'd
t.hPd'd
PQh<d'd
PQh(d'd
RPh(d'd
QRh<d'd
+dWRP
9t$ ~d
+dPQR
T$dPQRh
;t$ |
h\T'd
t*h|d'd
D$ RPhhd'd
9|$<t
9|$@t
`|+d3
hhe'd
Ph`e'd
QhXe'd
RhPe'd
PhHe'd
Qh@e'd
Rh8e'd
Ph0e'd
Qh(e'd
Rh e'd
_[]^3
h\T'd
h\T'd
D$0Phlg'd
h\g'd
L$@QhPg'd
T$TRh@g'd
D$`Ph4g'd
L$`Qh$g'd
T$dRh
T$0Rj
;L$|u
RPhtf'd
RQPhPf'd
T$\Rh8f'd
h f'd
D$pPh
L$|Qh
Qh$g'd
h\T'd
D$pSP
WVh|i'd
u";|$
hdi'd
hLi'd
u";|$
h4i'd
+dWVR
u2f9-
L$hQh
UShPh'd
h\T'd
u19D$$u+h
+dPQR
D$DRPh
`|+d3
ExSVWP
h\T'd
+dWVP
EP@j)d
u!PWhlj'd
M(hXj'd
hHj'd
UdWRh(j'd
`|+d3
h\T'd
+dSVQ
+dPQR
EhPQRhtk'd
ULPQRh`k'd
E$y;*d
M4PQhlj'd
9]ptlj
+dPQVh@
t'h@k'd
h0k'd
h k'd
u,hLT'd
Phpl'd
h\l'd
h4l'd
`|+d3
h\T'd
t#h\p'd
ShTp'd
hLp'dW
hDp'dW
T$@RP
T$ hP
T$$RP
T$(RP
T$$RP
T$(RP
T$(Rh8
T$XRP
L$lQR
Lf+dR
QRhdo'd
PSUVWh0o'd
D$(PWUh
VUWQPh
L$pQj
QhTn'd
m'dh`m'd
Ph@m'd
Rh m'd
`|+d3
h\T'd
T$0RSS
T$8RV
D$8j\P
`|+d3
h\T'd
D$,PSS
tKWVP
h\q'd
h8q'd
L$$QS
D$$PU
9\$$~q
D$8PV
L$8j\Q
;|$$|
h\T'd
L$,QS
t\9|$
u*Sh|r'd
9|$4u
h0r'd
h$r'd
9/tCj$
`|+d3
h\T'd
T$PRS
VhTt'd
D$(PQ
L$ Wj
D$$PQ
VPRQh
Qhts'd
hds'd
Wh s'd
h\T'd
u'PWh
h\T'd
hHz'd
Vh0z'd
Ph,z'd
T$8Rj
9,dRQP
VSh|y'd
T$HRh
T$<RSj
Wh<y'd
D$<PSj
Wh y'd
;t$$r
t$4w.
h@x'd
hPw'd
Ph,z'd
hdv'd
h`v'd
hpu'd
h u'd
`|+d3
D$PX|'d
D$dT|'d
D$xP|'d
9\$$u
9\$ tG
h\T'd
D$(Ph
T$(RP
L$(Qh
T$8RP
t$Vh0R'd
hL|'dh
<'dh@|'d
QPh8|'d
Ph0|'d
P+dSj
T$8RP
),dh$|'d
+dSPQ
Vh`Q'd
h`{'d
hL{'d
h`|'d
`|+d3
ExSVW
h\T'd
MPSRQ
Vht}'d
uVh`}'d
h@}'d
u1Wh(}'d
`|+d3
L$0Qjh
PVh8~'dh
T$(Rj
4:,dj
T$PRP
L$$Qj
h4~'d
t0QPh(~'dh
`|+d3
T$LRP
T$PRj
uEhl~'d
L$`Qjh
L$`Qj
u`hh~'d
uChH~'d
_^][3
hP++dh
`|+d1E
T$ QR
`|+d3
+dUSP
D$dPj
L$dQRPUS
D$,Ph
h\T'd
h\T'd
`|+d3
D$@PU
D$(Ph
L$LQRP
T$$RjH
T$,QR
T$lRj8
'dQRWV
'dRPWV
D$,Uj
'dRPWV
P+dWj
P+dWj
'dPQ3
P+dWj
'dPQWV
T$,QR
'dPQWV
T$4RV
+dWVP
`|+d3
L$(Qh@
8:,dVj
T$ Rh
T$ RP
`|+d3
h\T'd
T$8Rj
L$`QW
ti9\$4ui;
9\$4tE
D$ PS
D$<PQ
L$ Qh
tNSPh
9\$xt
+dSRP
SPh(j'd
9\$xt
+dPQR
h\T'd
T$8UUUj
9l$4u(UU
T$ QR
L$ SUj
'dPQWV
L$lUSQ
'dPQWV
D$|Pj
L$|QUVSW
+dSWVR
`|+d3
D$(PUV
D$(PWV
L$(QWR
PQRh|
_^][3
`|+d3
PPh$C'd
F$RPh
`|+d3
ExSVWP
h\T'd
+dPQR
E@RPh(d'd
E8RPh$
+dWRP
+dPQR
udVVh8
udVVh8
EhPPhh
EhPPh
UPRSj
+dPQR
PQVhX
EhPPh<
EhPPh
`|+d3
h\T'd
+du3j
+dQRP
tHVhD
`|+d3
h\T'd
`|+d3
h\T'd
+dh@x(dP
+dRPQ
`|+d3
h\T'd
RPQhh
hlJ'd
hdJ'd
h\J'd
hTJ'd
Qh|J'd
h|J'd
hTJ'd
h\T'd
L$8QR
D$|@^'d
Ph(^'d
+dVSP
D:,dV3
5D:,d
8:,d;
58:,d
@:,d;
5@:,d
<:,d;
5<:,d
4:,d;
54:,d
-L:,d
95L:,dv'
;5L:,dr
hl++d
=0:,d
RhH:,dP
WhD:,dh
h8:,dh
9,dhL
h@:,dh
h<:,dh
h4:,dh
9,dh|
9,dhl
u2;>r
u.;>r
dSVW3
`|+d3
'd_^[
`|+d3
u$Ph\
P+dPj
8_[^]
PWQhD
C,dS3
`|+d3
`|+d3
QRPhD
'd_^]
C,d_^]
VRQPh
PRWQS3
:,d+}
PRWQS3
T08QRhT
:,dhx
C,dRPQhH
C,d^t1
C,dPPhl
PVVh>
+dWPQ
+>WWh
C,dPPhl
C,dPPhl
C,dPPhl
C,dPPhl
C,dPPhl
9>uYj
QPWh,
PQRh 
PQRh 
`|+d3
+dSVQR
P+dVj
QSRWP
9r$u2
PSVQht
QRPhL
VQVWh
`|+d3
'd_^3
'd_^3
'd_^3
;Q(s(
+dVh\
+dVhT
SVWPh-
D,dPh
`|+d3
`|+d3
`|+d3
u_Sh$
8y+dRh
t)WPV
#t.Sh
t<j[V
`|+d3
jjjjjj
jjjjj
h D,dRP
|$h D,d
h D,d
`|+d3
'dWh-
'dWh-
'dWu,h
D,dPh-
D,dPh
H(;H$v
H$;H s
H8;H4v
H4;H0s
`|+d3
`|+d3
`|+d3
VWj@3
`|+d3
WVPRh\
`|+d3
`|+d1E
jjjjjjjj
h X,d
jjjjj
h X,d
U X,d
h X,dSW
`|+d3
h P,dRP
 P,d]
h P,dj
 P,d]
`|+d3
0z+dP
0z+dP
h H,d
h H,d
z+d_^[]
`|+d3
+dWVh
Vh8|'d
`|+d3
= `,d
h `,d
 `,dt
$`,du
`|+d3
PSVWh
PRPVh
`|+d3
`|+d3
Qh !'d
`|+d3
`|+d3
=h`,d
u59=,`,d
,`,d9=
u WPS
u&WVS
\$ UV
35`|+dW
=t|,d
t!ht|,d
D$,9h
h`|+dW
h`|+dW
=H{,d
`|+du
hp|+d
@`,du
0SSSSS
0SSSSS
0WWWWW
BBFFf;
=H{,d
)*dD)*dh)*d#
**d,**d
D+*dL+*dT+*d\+*dd+*dl+*dt+*d
SSSSS
SSSSS
e,du09u
VVVVV
WWWWW
0SSSSS
8VVVVV
AAGGf;
+dY{*d
+do{*d
+dhz*d
T`,dt
0WWWWW
@@BBf;
@@BBf;
hP,+d
SSSSS
`{,dV
`{,dV
SSSSS
WWWWW
hp,+d
WWWWW
SSSSS
Ph`|+d
_VVVVV
=H{,d
=H{,d
VVVVV
SSSSS
VVVVV
VVVVV
 CCGGf
e,dWuq
VVVVV
 GGBBf;
SSSSS
SSSSS
HH_^[
SSSSS
SSSSS
SSSSS
@PVhu
SSSSS
0SSSSS
8VVVVV
@@BBf;
@@BBf;
=L{,d
;5 k,dwIVSP
9=He,dt,V
He,dt4V
QSUVW
5h|,d
5d|,d
_^][Y
d|,du
`|+d3
5\`,d
5\`,d
0WWWWW
^SSSSS
^SSSSS
=H{,d
HJ*dtJ*d
4K*d<K*dHK*d\K*d
K*d L*d
tL*d|L*d
^SSSSS
^SSSSS
VVVVV
d`,d;
VVVVV
95d`,dt
YYuTVWh
=p|,d
hp|,d
p|,d3
`,dt~
`,d9}
5h|,d
5d|,d
QQSV3
h0-+d
F\8}+d3
YYt:V
hP-+d
F\=8}+dt
`,d{R*d
tehAT*d
|+dtHh
YYt4V
hx-+d
=L{,d
YYu-9D$
j@j ^V
5P{,d
[j@j 
P{,d 
9=P{,d|
=P{,d
5`{,d
5P{,d
`|,d|
l|,dVWu
50`,d3
50`,dU
>=Yt/j
tJVUP
SSSSS
50`,d
Y]_^[
< tK<
l|,dVWu
`,dVS
x|,d;
5|`,d3
a,dSUVW
'dSSS+
@PVSS
t#SSUP
t$$VSS
_^][YY
VVVVV
VVVVV
L{,du$h
=L{,d
k,d~1V
`|+d1E
Y__^[
5`|+d
5d|+d^_[
URPQQh
`|+d3
`|+d1E
%D{,d
D{,d3
 b,dj
= b,d
;5 k,dw"j
'dVW3
He,dj
`|+d3
`|+d3
0A@@Ju
=l|,d
t^9(uZ
tD9(u@
Y_^][
h8.+d
`|+d3
8e,dW
u8SS3
=8e,d
9]$SS
'dSSW
_VVVVV
SSSSS
`|+d3
SSSSS
^WWWWW
PPPPP
`|+d3
SSSSS
`|+d3
SSSSS
VVVVV
@{,dj
0k,du
5@{,d
0k,du
50k,d
<e,df
`|+d3
, <Xw
HHt@HHt
HHt]+
2If90t
PPPPP
VVVVV
`{,du
hX.+d
P{,dr!
WWWWW
~,WPV
hx.+d
;5@{,d
j,dS3
<at9<rt,<wt
SSSSS
tVHtG
tDHt0
SSSSS
;5@{,d
0k,du
`|+d3
HHtAHHt
HHt]+
PPPPP
SSSSS
SSSSS
HH_^[
VVVVV
VVVVV
SSSSS
@PVhg
SSSSS
$k,d3
=,k,d[_^
(k,dV
k,dW3
,k,du
WWWWW
=L{,d
=<`,d
VVVVV
f,dVj
PPPPP
<Yv8V
VVVVV
VVVVV
VVVVV
'd]_^[Y
=<`,d
h /+d
}+dV9P
j h@/+d
PPPPP
h`/+d
WWWWW
WWWWW
=L{,d
 k,dw7j
uL9=He,dt3V
SVWUj
`|+d3
;t$,v-
UQPXY]Y[
H{,d3
`|+d3
i,dSV3
9] SS
PPPPPPPP
PPPPPPPP
`|+d3
`|+d3
WWWWV
t+WWVPV
`|+d3
SSSSW
`|+d3
SSSSW
0SSSSS
`|+d3
PPPPP
_VVVVV
`|+d3
'dWWWW
tb9} u
;=@{,d}W
P{,dr
VVVVV
^SSSSS
j"^SSSSS
QSWVj
VW|Z;
P{,dsR
=<`,d
VW|[;
P{,dsS
=<`,d
P{,ds
VVVVV
P{,d 
`|+d3
VVVVV
VVVVV
h(0+d
P{,dr!
WWWWW
hH0+d
P{,dr
SSSSS
SSSSS
SSSSS
tGHt.Ht&
^SSSSS
`{,dY
tySSS
hh0+d
8VVVVV
VVVVV
VVVVV
SSSSS
SSSSS
P{,dr!
WWWWW
WWWWW
<e,dh
`|+d3
u6SSj
9E Yt
'dSSSS
t0WWWWW
`|+d3
|+dt.V
`|+d3
PPPPP
SSSSS
Tj,dt
Tj,dtqP
5Tj,d
SSSSS
Hj,d;E
Lj,d;E
5Dj,d
8`,d^
8`,d^
VVVVV
`|+d3
`|+d3
SSSSS
<+t(<-t$:
+t HHt
`|+d3
u&f!;f;
VVVVV
VVVVV
=H{,d
`|+d3
+dVVj
;5P{,dr'
SSSSS
SSSSS
VVVVV
`|+d3
H{,dtV
h`*+d
X:,d^
@`,dD
P!*da!*d
,+d4,+d
*(+dF(+d
MultiByteToWideChar
HeapFree
GetProcessHeap
WideCharToMultiByte
HeapAlloc
GetTimeFormatW
SystemTimeToTzSpecificLocalTime
FileTimeToSystemTime
GetLastError
MapViewOfFile
CreateFileMappingA
CloseHandle
GetFileSize
CreateFileA
UnmapViewOfFile
SwitchToFiber
LockResource
LoadResource
FindResourceA
DeleteFiber
CreateFiber
ConvertThreadToFiber
GlobalMemoryStatus
FileTimeToLocalFileTime
FreeLibrary
GetProcAddress
LoadLibraryA
WriteFile
GetCurrentThreadId
GetCommandLineA
GetVersionExA
HeapReAlloc
RaiseException
TerminateProcess
GetCurrentProcess
UnhandledExceptionFilter
SetUnhandledExceptionFilter
IsDebuggerPresent
GetModuleHandleA
ExitProcess
TlsGetValue
TlsAlloc
TlsSetValue
TlsFree
InterlockedIncrement
SetLastError
InterlockedDecrement
Sleep
SetHandleCount
GetStdHandle
GetFileType
GetStartupInfoA
DeleteCriticalSection
GetModuleFileNameA
FreeEnvironmentStringsA
GetEnvironmentStrings
FreeEnvironmentStringsW
GetEnvironmentStringsW
HeapDestroy
HeapCreate
VirtualFree
QueryPerformanceCounter
GetTickCount
GetCurrentProcessId
GetSystemTimeAsFileTime
RtlUnwind
GetCPInfo
GetACP
GetOEMCP
IsValidCodePage
LCMapStringA
LCMapStringW
EnterCriticalSection
LeaveCriticalSection
VirtualAlloc
HeapSize
InitializeCriticalSection
GetStringTypeA
GetStringTypeW
GetLocaleInfoA
SetStdHandle
GetConsoleCP
GetConsoleMode
FlushFileBuffers
SetFilePointer
WriteConsoleA
GetConsoleOutputCP
WriteConsoleW
SetEndOfFile
ReadFile
KERNEL32.dll
VerQueryValueA
GetFileVersionInfoA
GetFileVersionInfoSizeA
VERSION.dll
DebugCreate
dbgeng.dll
 !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFG
HIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
1.dll
_EFN_GetManagedExcepStack
_EFN_GetManagedObjectFieldInfo
_EFN_GetManagedObjectName
_EFN_StackTrace
CLRStack
COMState
ClrStack
DebugExtensionInitialize
DebugExtensionNotify
DebugExtensionUninitialize
DumpArray
DumpAssembly
DumpClass
DumpDomain
DumpHeap
DumpIL
DumpLog
DumpMD
DumpMT
DumpMethodSig
DumpModule
DumpObj
DumpRuntimeTypes
DumpSig
DumpStack
DumpStackObjects
DumpVC
Dumplog
Dumpruntimetypes
EEHeap
EEStack
EEVersion
EHInfo
Ehinfo
FinalizeQueue
FindAppDomain
Findappdomain
GCHandleLeaks
GCHandleleaks
GCHandles
GCInfo
GCRoot
Gchandleleaks
IP2MD
MinidumpMode
Minidumpmode
Name2EE
ObjSize
PrintException
Printexception
ProcInfo
RCWCleanupList
Rcwcleanuplist
SOSFlush
SaveModule
StopOnException
Stoponexception
SyncBlk
ThreadPool
Threads
Token2EE
TraverseHeap
Traverseheap
VMMap
VMStat
VerifyDAC
VerifyHeap
VerifyStackTrace
Verifyheap
WatsonBuckets
clrstack
comstate
dumparray
dumpassembly
dumpclass
dumpdomain
dumpheap
dumpil
dumplog
dumpmd
dumpmethodsig
dumpmodule
dumpmt
dumpobj
dumpruntimetypes
dumpsig
dumpstack
dumpstackobjects
dumpvc
eeheap
eestack
eeversion
ehinfo
finalizequeue
findappdomain
gchandleleaks
gchandles
gcinfo
gcroot
ip2md
minidumpmode
name2ee
objsize
printexception
procinfo
rcwcleanuplist
savemodule
sosflush
stoponexception
syncblk
threadpool
threads
token2ee
traverseheap
verifyheap
vmmap
vmstat
+d0Q+d
.?AVbad_alloc@std@@
.?AVexception@std@@
.?AVtype_info@@
                          
abcdefghijklmnopqrstuvwxyz
ABCDEFGHIJKLMNOPQRSTUVWXYZ
                          
abcdefghijklmnopqrstuvwxyz
ABCDEFGHIJKLMNOPQRSTUVWXYZ
*d@k,d
z?aUY
zc%C1
-64OS
DOCUMENTATION
VS_VERSION_INFO
StringFileInfo
040904B0
CompanyName
Microsoft Corporation
FileDescription
Microsoft NTSD extension for .NET Runtime
FileVersion
2.0.50727.9157 (WinRelRS6.050727-9100)
InternalName
SOS.dll
LegalCopyright
 Microsoft Corporation.  All rights reserved.
OriginalFilename
SOS.dll
ProductName
Microsoft
 .NET Framework
ProductVersion
2.0.50727.9157
Comments
Flavor=Retail
VarFileInfo
Translation
-------------------------------------------------------------------------------
NOTE: THIS FILE CONTAINS SOS DOCUMENTATION. THE FORMAT OF THE FILE IS:
<optional comments>
COMMAND: <cmd name, all lower case>
<descriptive text of the command>
\\ <these are two backslashes, immediately followed by a newline>
<repeat the sequence above>
The first command is "contents" which is the general help screen. The rest 
correspond to SOS command names. This file is embedded as a resource in the SOS 
binary. Be sure to list any new commands here.
-------------------------------------------------------------------------------
COMMAND: contents.
SOS is a debugger extension DLL designed to aid in the debugging of managed
programs. Functions are listed by category, then roughly in order of
importance. Shortcut names for popular functions are listed in parenthesis.
Type "!help <functionname>" for detailed info on that function. 
Object Inspection                  Examining code and stacks
-----------------------------      -----------------------------
DumpObj (do)                       Threads
DumpArray (da)                     CLRStack
DumpStackObjects (dso)             IP2MD
DumpHeap                           U
DumpVC                             DumpStack
GCRoot                             EEStack
ObjSize                            GCInfo
FinalizeQueue                      EHInfo
PrintException (pe)                COMState
TraverseHeap                       BPMD 
Examining CLR data structures      Diagnostic Utilities
-----------------------------      -----------------------------
DumpDomain                         VerifyHeap
EEHeap                             DumpLog
Name2EE                            FindAppDomain
SyncBlk                            SaveModule
DumpMT                             GCHandles
DumpClass                          GCHandleLeaks
DumpMD                             VMMap
Token2EE                           VMStat
EEVersion                          ProcInfo 
DumpModule                         StopOnException (soe)
ThreadPool                         MinidumpMode 
DumpAssembly                       
DumpMethodSig                      Other
DumpRuntimeTypes                   -----------------------------
DumpSig                            FAQ
RCWCleanupList
DumpIL
COMMAND: faq.
>> Where can I get the right version of SOS for my build?
If you are running version 1.1 or 2.0 of the CLR, SOS.DLL is installed in the 
same directory as the main CLR dll (MSCORWKS.DLL). Newer versions of the 
Windows Debugger provide a command to make it easy to load the right copy of 
SOS.DLL:
    ".loadby sos mscorwks"
That will load the SOS extension DLL from the same place that MSCORWKS.DLL is 
loaded in the process. You shouldn't attempt to use a version of SOS.DLL that 
doesn't match the version of MSCORWKS.DLL. You can find the version of 
MSCORWKS.DLL by running 
    "lm v m mscorwks"
in the debugger.
If you are using a dump file created on another machine, it is a little bit
more complex. You need to make sure the mscordacwks.dll file that came with
that install is on your symbol path, and you need to load the corresponding
version of sos.dll (typing .load <full path to sos.dll> rather than using the
.loadby shortcut). Within the Microsoft corpnet, we keep tagged versions 
of mscordacwks.dll, with names like mscordacwks_<architecture>_<version>.dll
that the Windows Debugger can load. If you have the correct symbol path to the
binaries for that version of the Runtime, the Windows Debugger will load the
correct mscordacwks.dll file.
>> I have a chicken and egg problem. I want to use SOS commands, but the CLR
   isn't loaded yet. What can I do?
In the debugger at startup you can type:
    "sxe clrn"
Let the program run, and it will stop with the notice
    "CLR notification: module 'mscorlib' loaded"
At this time you can use SOS commands. To turn off spurious notifications,
type:
    "sxd clrn"    
>> I got the following error message. Now what?
0:000> .loadby sos mscorwks
0:000> !DumpStackObjects
Failed to find runtime DLL (mscorwks.dll), 0x80004005
Extension commands need mscorwks.dll in order to have something to do.
0:000>
This means that the CLR is not loaded yet, or has been unloaded. You need to 
wait until your managed program is running in order to use these commands. If 
you have just started the program a good way to do this is to type 
    bp mscorwks!EEStartup "g @$ra"
in the debugger, and let it run. After the function EEStartup is finished, 
there will be a minimal managed environment for executing SOS commands.
>> I have a partial memory minidump, and !DumpObj doesn't work. Why?
In order to run SOS commands, many CLR data structures need to be traversed. 
When creating a minidump without full memory, special functions are called at
dump creation time to bring those structures into the minidump, and allow a 
minimum set of SOS debugging commands to work. At this time, those commands 
that can provide full or partial output are:
CLRStack
Threads
PrintException
EEVersion
For a minidump created with this minimal set of functionality in mind, you
will get an error message when running any other commands. A full memory dump
(obtained with ".dump /ma <filename>" in the Windows Debugger) is often the 
best way to debug a managed program at this level.
>> What other tools can I use to find my bug?
Turn on Managed Debugging Assistants. These enable additional runtime diagnostics, 
particularly in the area of PInvoke/Interop. Adam Nathan has written some great
information about that:
http://blogs.gotdotnet.com/anathan/categoryview.aspx/Debugging
COMMAND: stoponexception.
!StopOnException [-derived] 
                 [-create | -create2] 
                 <Exception> 
                 [<Pseudo-register number>]
!StopOnException helps when you want the Windows Debugger to stop on a 
particular managed exception, say a System.OutOfMemoryException, but continue
running if other exceptions are thrown. The command can be used in two ways:
1) When you just want to stop on one particular CLR exception
   At the debugger prompt, anytime after loading SOS, type:
   !StopOnException -create System.OutOfMemoryException 1
   The pseudo-register number (1) indicates that SOS can use register $t1 for
   maintaining the breakpoint. The -create parameter allows SOS to go ahead
   and set up the breakpoint as a first-chance exception. -create2 would set
   it up as a 2nd-chance exception. 
2) When you need more complex logic for stopping on a CLR exception
   !StopOnException can be used purely as a predicate in a larger expression.
   If you type:
   !StopOnException System.OutOfMemoryException 3
   then register $t3 will be set to 1 if the last thrown exception on the 
   current thread is a System.OutOfMemoryException. Otherwise, $t3 will be set
   to 0. Using the Windows Debugger scripting language, you could chain 
   such calls together to stop on various exception types. You'll have to 
   manually create such predicates, for example:
   sxe -c "!soe System.OutOfMemoryException 3; 
           !soe -derived System.IOException 4;
           .if(@$t3==1 || @$t4==1) { .echo 'stop' } .else {g}"
The -derived option will cause StopOnException to set the pseudo-register to
1 even if the thrown exception type doesn't exactly match the exception type
given, but merely derives from it. So, "-derived System.Exception" would catch
every exception in the System.Exception heirarchy.
The pseudo-register number is optional. If you don't pass a number, SOS will 
use pseudo-register $t1.
Note that !PrintException with no parameters will print out the last thrown
exception on the current thread (if any). You can use !soe as a shortcut for 
!StopOnException.
COMMAND: minidumpmode.
!MinidumpMode <0 or 1>
Minidumps created with ".dump /m" or ".dump" have a very small set of 
CLR-specific data, just enough to run a subset of SOS commands correctly. You 
are able to run other SOS commands, but they may fail with unexpected errors 
because required areas of memory are not mapped in or only partially mapped 
in. At this time, SOS cannot reliably detect if a dump file is of this type 
(for one thing, custom dump commands can map in additional memory, but there 
is no facility to read meta-information about this memory). You can turn this 
option on to protect against running unsafe commands against small minidumps.
By default, MinidumpMode is 0, so there is no restriction on commands that will
run against a minidump.
COMMAND: dumpobj.
!DumpObj [-nofields] <object address>
This command allows you to examine the fields of an object, as well as learn 
important properties of the object such as the EEClass, the MethodTable, and 
the size.
You might find an object pointer by running !DumpStackObjects and choosing
from the resultant list. Here is a simple object:
0:000> !DumpObj a79d40
Name: Customer
MethodTable: 009038ec
EEClass: 03ee1b84
Size: 20(0x14) bytes
 (C:\pub\unittest.exe)
Fields:
      MT    Field   Offset                 Type  VT     Attr    Value Name
009038ec  4000008        4             Customer   0 instance 00a79ce4 name
009038ec  4000009        8                 Bank   0 instance 00a79d2c bank
Note that fields of type Customer and Bank are themselves objects, and you can 
run !DumpObj on them too. You could look at the field directly in memory using
the offset given. "dd a79d40+8 l1" would allow you to look at the bank field 
directly. Be careful about using this to set memory breakpoints, since objects
can move around in the garbage collected heap.
What else can you do with an object? You might run !GCRoot, to determine what 
roots are keeping it alive. Or you can find all objects of that type with 
"!DumpHeap -type Customer".
The column VT contains the value 1 if the field is a valuetype structure, and
0 if the field contains a pointer to another object. For valuetypes, you can 
take the MethodTable pointer in the MT column, and the Value and pass them to 
the command !DumpVC.
The abbreviation !do can be used for brevity.
The arguments in detail:
-nofields:     do not print fields of the object, useful for objects like 
                  String
COMMAND: dumparray.
!DumpArray 
[-start <startIndex>]
[-length <length>]
[-details]
[-nofields]
<array object address>
This command allows you to examine elements of an array object.
The arguments in detail:
 -start <startIndex>: optional, only supported for single dimension array. 
                      Specify from which index the command shows the elements.
 -length <length>:    optional, only supported for single dimension array. 
                      Specify how many elements to show.
 -details:             optional. Ask the command to print out details
                      of the element using !DumpObj and !DumpVC format.
 -nofields:       optional, only takes effect when -detail is used. Do not 
                      print fields of the elements. Useful for array of objects 
                      like String                    
 Example output:
0:000> !dumparray -start 2 -length 5 -details 00ad28d0 
Name: Value[]
MethodTable: 03e41044
EEClass: 03e40fc0
Size: 132(0x84) bytes
Array: Rank 1, Number of elements 10, Type VALUETYPE
Element Type: Value
[2] 00ad28f0
    Name: Value
    MethodTable 03e40f4c
    EEClass: 03ef1698
    Size: 20(0x14) bytes
     (C:\bugs\225271\arraytest.exe)
    Fields:
          MT    Field   Offset                 Type       Attr    Value Name
    5b9a628c  4000001        0         System.Int32   instance        2 x
    5b9a628c  4000002        4         System.Int32   instance        4 y
    5b9a628c  4000003        8         System.Int32   instance        6 z
[3] 00ad28fc
    Name: Value
    MethodTable 03e40f4c
    EEClass: 03ef1698
    Size: 20(0x14) bytes
     (C:\bugs\225271\arraytest.exe)
    Fields:
          MT    Field   Offset                 Type       Attr    Value Name
    5b9a628c  4000001        0         System.Int32   instance        3 x
    5b9a628c  4000002        4         System.Int32   instance        6 y
    5b9a628c  4000003        8         System.Int32   instance        9 z
[4] 00ad2908
    Name: Value
    MethodTable 03e40f4c
    EEClass: 03ef1698
    Size: 20(0x14) bytes
     (C:\bugs\225271\arraytest.exe)
    Fields:
          MT    Field   Offset                 Type       Attr    Value Name
    5b9a628c  4000001        0         System.Int32   instance        4 x
    5b9a628c  4000002        4         System.Int32   instance        8 y
    5b9a628c  4000003        8         System.Int32   instance       12 z
[5] 00ad2914
    Name: Value
    MethodTable 03e40f4c
    EEClass: 03ef1698
    Size: 20(0x14) bytes
     (C:\bugs\225271\arraytest.exe)
    Fields:
          MT    Field   Offset                 Type       Attr    Value Name
    5b9a628c  4000001        0         System.Int32   instance        5 x
    5b9a628c  4000002        4         System.Int32   instance       10 y
    5b9a628c  4000003        8         System.Int32   instance       15 z
[6] 00ad2920
    Name: Value
    MethodTable 03e40f4c
    EEClass: 03ef1698
    Size: 20(0x14) bytes
     (C:\bugs\225271\arraytest.exe)
    Fields:
          MT    Field   Offset                 Type       Attr    Value Name
    5b9a628c  4000001        0         System.Int32   instance        6 x
    5b9a628c  4000002        4         System.Int32   instance       12 y
    5b9a628c  4000003        8         System.Int32   instance       18 z
COMMAND: dumpstackobjects.
!DumpStackObjects [-verify] [top stack [bottom stack]]
This command will display any managed objects it finds within the bounds of 
the current stack. Combined with the stack tracing commands like K and 
!CLRStack, it is a good aid to determining the values of locals and 
parameters.
If you use the -verify option, each non-static CLASS field of an object
candidate is validated. This helps to eliminate false positives. It is not
on by default because very often in a debugging scenario, you are 
interested in objects with invalid fields.
The abbreviation !dso can be used for brevity.
COMMAND: dumpheap.
!DumpHeap [-stat] 
          [-strings] 
          [-short]
          [-min <size>] 
          [-max <size>] 
          [-thinlock] 
          [-startAtLowerBound]
          [-mt <MethodTable address>] 
          [-type <partial type name>] 
          [start [end]]
!DumpHeap is a powerful command that traverses the garbage collected heap, 
collection statistics about objects. With it's various options, it can look for
particular types, restrict to a range, or look for ThinLocks (see !SyncBlk 
documentation). Finally, it will provide a warning if it detects excessive 
fragmentation in the GC heap. 
When called without options, the output is first a list of objects in the heap,
followed by a report listing all the types found, their size and number:
0:000> !dumpheap
 Address       MT     Size
00a71000 0015cde8       12 Free
00a7100c 0015cde8       12 Free
00a71018 0015cde8       12 Free
00a71024 5ba58328       68
00a71068 5ba58380       68
00a710ac 5ba58430       68
00a710f0 5ba5dba4       68
total 619 objects
Statistics:
      MT    Count TotalSize Class Name
5ba7607c        1        12 System.Security.Permissions.HostProtectionResource
5ba75d54        1        12 System.Security.Permissions.SecurityPermissionFlag
5ba61f18        1        12 System.Collections.CaseInsensitiveComparer
0015cde8        6     10260      Free
5ba57bf8      318     18136 System.String
"Free" objects are simply regions of space the garbage collector can use later.
If 30% or more of the heap contains "Free" objects, the process may suffer from
heap fragmentation. This is usually caused by pinning objects for a long time 
combined with a high rate of allocation. Here is example output where !DumpHeap
provides a warning about fragmentation:
<After the Statistics section>
Fragmented blocks larger than 1MB:
    Addr     Size Followed by
00a780c0    1.5MB    00bec800 System.Byte[]
00da4e38    1.2MB    00ed2c00 System.Byte[]
00f16df0    1.2MB    01044338 System.Byte[]
The arguments in detail:
-stat     Restrict the output to the statistical type summary
-strings  Restrict the output to a statistical string value summary
-short    Limits output to just the address of each object. This allows you
          to easily pipe output from the command to another debugger 
          command for automation.
-min      Ignore objects less than the size given in bytes
-max      Ignore objects larger than the size given in bytes
-thinlock Report on any ThinLocks (an efficient locking scheme, see !SyncBlk 
          documentation for more info)
-startAtLowerBound 
          Force heap walk to begin at lower bound of a supplied address range.
          (During plan phase, the heap is often not walkable because objects 
          are being moved. In this case, DumpHeap may report spurious errors, 
          in particular bad objects. It may be possible to traverse more of 
          the heap after the reported bad object. Even if you specify an 
          address range, !DumpHeap will start its walk from the beginning of 
          the heap by default. If it finds a bad object before the specified 
          range, it will stop before displaying the part of the heap in which 
          you are interested. This switch will force !DumpHeap to begin its 
          walk at the specified lower bound. You must supply the address of a 
          good object as the lower bound for this to work. Display memory at 
          the address of the bad object to manually find the next method 
          table (use !dumpmt to verify). If the GC is currently in a call to 
          memcopy, You may also be able to find the next object's address by 
          adding the size to the start address given as parameters.) 
-mt       List only those objects with the MethodTable given
-type     List only those objects whose type name is a substring match of the 
          string provided. 
start     Begin listing from this address
end       Stop listing at this address
A special note about -type: Often, you'd like to find not only Strings, but
System.Object arrays that are constrained to contain Strings. ("new 
String[100]" actually creates a System.Object array, but it can only hold
System.String object pointers). You can use -type in a special way to find
these arrays. Just pass "-type System.String[]" and those Object arrays will
be returned. More generally, "-type <Substring of interesting type>[]".
The start/end parameters can be obtained from the output of !EEHeap -gc. For 
example, if you only want to list objects in the large heap segment:
0:000> !eeheap -gc
Number of GC Heaps: 1
generation 0 starts at 0x00c32754
generation 1 starts at 0x00c32748
generation 2 starts at 0x00a71000
 segment    begin allocated     size
00a70000 00a71000  010443a8 005d33a8(6108072)
Large object heap starts at 0x01a71000
 segment    begin allocated     size
01a70000 01a71000  01a75000 0x00004000(16384)
Total Size  0x5d73a8(6124456)
------------------------------
GC Heap Size  0x5d73a8(6124456)
0:000> !dumpheap 1a71000 1a75000
 Address       MT     Size
01a71000 5ba88bd8     2064
01a71810 0019fe48     2032 Free
01a72000 5ba88bd8     4096
01a73000 0019fe48     4096 Free
01a74000 5ba88bd8     4096
total 5 objects
Statistics:
      MT    Count TotalSize Class Name
0019fe48        2      6128      Free
5ba88bd8        3     10256 System.Object[]
Total 5 objects
Finally, if gc heap corruption is present, you may see an error like this:
0:000> !dumpheap -stat
object 00a73d24: does not have valid MT
curr_object : 00a73d24
Last good object: 00a73d14
----------------
That indicates a serious problem. See the help for !VerifyHeap for more 
information on diagnosing the cause.
COMMAND: dumpvc.
!DumpVC <MethodTable address> <Address>
!DumpVC allows you to examine the fields of a value class. In C#, this is a 
struct, and lives on the stack or within an Object on the GC heap. You need
to know the MethodTable address to tell SOS how to interpret the fields, as
a value class is not a first-class object with it's own MethodTable as the
first field. For example:
0:000> !DumpObj a79d98
Name: Mainy
MethodTable: 009032d8
EEClass: 03ee1424
Size: 28(0x1c) bytes
 (C:\pub\unittest.exe)
Fields:
      MT    Field   Offset                 Type       Attr    Value Name
0090320c  4000010        4            VALUETYPE   instance 00a79d9c m_valuetype
009032d8  400000f        4                CLASS     static 00a79d54 m_sExcep
m_valuetype is a value type. The value in the MT column (0090320c) is the 
MethodTable for it, and the Value column provides the start address:
0:000> !DumpVC 0090320c 00a79d9c
Name: Funny
MethodTable 0090320c
EEClass: 03ee14b8
Size: 28(0x1c) bytes
 (C:\pub\unittest.exe)
Fields:
      MT    Field   Offset                 Type       Attr    Value Name
0090320c  4000001        0                CLASS   instance 00a743d8 signature
0090320c  4000002        8         System.Int32   instance     2345 m1
0090320c  4000003       10       System.Boolean   instance        1 b1
0090320c  4000004        c         System.Int32   instance     1234 m2
0090320c  4000005        4                CLASS   instance 00a79d98 backpointer
!DumpVC is quite a specialized function. Some managed programs make heavy use 
of value classes, while others do not.
COMMAND: gcroot.
!GCRoot [-nostacks] <Object address>
!GCRoot looks for references (or roots) to an object. These can exist in four
places:
   1. On the stack
   2. Within a GC Handle
   3. In an object ready for finalization
   4. As a member of an object found in 1, 2 or 3 above.
First, all stacks will be searched for roots, then handle tables, and finally
the freachable queue of the finalizer. Some caution about the stack roots: 
!GCRoot doesn't attempt to determine if a stack root it encountered is valid 
or is old (discarded) data. You would have to use !CLRStack and !U to 
disassemble the frame that the local or argument value belongs to in order to 
determine if it is still in use.
Because people often want to restrict the search to gc handles and freachable
objects, there is a -nostacks option.
COMMAND: objsize.
!ObjSize [<Object address>]
With no parameters, !ObjSize lists the size of all objects found on managed 
threads. It also enumerates all GCHandles in the process, and totals the size 
of any objects pointed to by those handles. In calculating object size, 
!ObjSize includes the size of all child objects in addition to the parent.
For example, !DumpObj lists a size of 20 bytes for this Customer object:
0:000> !do a79d40
Name: Customer
MethodTable: 009038ec
EEClass: 03ee1b84
Size: 20(0x14) bytes
 (C:\pub\unittest.exe)
Fields:
      MT    Field   Offset                 Type       Attr    Value Name
009038ec  4000008        4                CLASS   instance 00a79ce4 name
009038ec  4000009        8                CLASS   instance 00a79d2c bank
009038ec  400000a        c       System.Boolean   instance        1 valid
but !ObjSize lists 152 bytes:
0:000> !ObjSize a79d40
sizeof(00a79d40) =      152 (    0x98) bytes (Customer)
This is because a Customer points to a Bank, has a name, and the Bank points to
an Address string. You can use !ObjSize to identify any particularly large 
objects, such as a managed cache in a web server.
COMMAND: finalizequeue.
!FinalizeQueue [-detail]
This command lists the objects registered for finalization. Here is output from
a simple program:
0:000> !finalizequeue
SyncBlocks to be cleaned up: 0
MTA Interfaces to be released: 0
STA Interfaces to be released: 1
generation 0 has 4 finalizable objects (0015bc90->0015bca0)
generation 1 has 0 finalizable objects (0015bc90->0015bc90)
generation 2 has 0 finalizable objects (0015bc90->0015bc90)
Ready for finalization 0 objects (0015bca0->0015bca0)
Statistics:
      MT    Count TotalSize Class Name
5ba6cf78        1        24 Microsoft.Win32.SafeHandles.SafeFileHandle
5ba5db04        1        68 System.Threading.Thread
5ba73e28        2       112 System.IO.StreamWriter
Total 4 objects
The GC heap is divided into generations, and objects are listed accordingly. We
see that only generation 0 (the youngest generation) has any objects registered
for finalization. The notation "(0015bc90->0015bca0)" means that if you look at
memory in that range, you'll see the object pointers that are registered:
0:000> dd 15bc90 15bca0-4
0015bc90  00a743f4 00a79f00 00a7b3d8 00a7b47c
You could run !DumpObj on any of those pointers to learn more. In this example,
there are no objects ready for finalization, presumably because they still have
roots (You can use !GCRoot to find out). The statistics section provides a 
higher-level summary of the objects registered for finalization. Note that 
objects ready for finalization are also included in the statistics (if any).
If you pass -detail then you get extra information on any SyncBlocks that need
to be cleaned up, and on any RuntimeCallableWrappers (RCWs) that await cleanup.
Both of these data structures are cached and cleaned up by the finalizer thread
when it gets a chance to run.
COMMAND: printexception.
!PrintException [-nested] [<Exception object address>]
This will format fields of any object derived from System.Exception. One of the
more useful aspects is that it will format the _stackTrace field, which is a 
binary array. If _stackTraceString field is not filled in, that can be helpful 
for debugging. You can of course use !DumpObj on the same exception object to 
explore more fields.
If called with no parameters, PrintException will look for the last outstanding 
exception on the current thread and print it. This will be the same exception
that shows up in a run of !Threads.
!PrintException will notify you if there are any nested exceptions on the 
current managed thread. (A nested exception occurs when you throw another
exception within a catch handler already being called for another exception).
If there are nested exceptions, you can re-run !PrintException with the 
"-nested" option to get full details on the nested exception objects. The
!Threads command will also tell you which threads have nested exceptions.
The abbreviation !pe can be used for brevity.
COMMAND: traverseheap.
!TraverseHeap [-xml] <filename>
!TraverseHeap writes out a file in a format understood by the CLR Profiler. 
You can download the CLR Profiler from this link:
http://www.microsoft.com/downloads/details.aspx?FamilyId=86CE6052-D7F4-4AEB-
9B7A-94635BEEBDDA&displaylang=en
It creates a graphical display of the GC heap to help you analyze the state of
your application. If you pass the "-xml" flag, the file is instead written out
in an easy-to-understand xml format:
    <gcheap>
        <types>
            <type id="1" name="System.String">
            ...
        </types>
        <roots>
            <root kind="handle" address="0x00a73ff0"/>
            <root kind="stack" address="0x0069f0e0"/>
            ...
        </roots>
        <objects>
            <object address="0x00b73030" typeid="1" size="300"/>
            <object address="0x00b75054" typeid="5" size="20">
                <member address="0x00b75088" />
                ...
            </object>
            ...
        </objects>
    </gcheap>
You can break into your process, load SOS, take a snapshot of your heap with 
this function, then continue.
COMMAND: threads.
!Threads [-live] [-special] 
!Threads lists all the mananaged threads in the process. 
-live:     optional. Only print threads associated with a live thread.
-special:  optional. With this switch, the command will display all the special
           threads created by CLR. Those threads might not be managed threads 
           so they might not be shown in the first part of the command's 
           output. Example of special threads include: GC threads (in 
           concurrent GC and server GC), Debugger helper threads, Finalizer 
           threads, AppDomain Unload threads, and Threadpool timer threads.
Each thread has many attributes, many of which can be ignored. The important 
ones are discussed below:
There are three ID columns: 
1) The debugger shorthand ID (In fiber mode, if the thread is a fiber which is
   switched out by the host, this column will be shown as "<<<<") 
2) The CLR Thread ID
3) The OS thread ID.  
If PreEmptiveGC is enabled for a thread, then a garbage collection 
can occur while that thread is running. For example, if you break in while
a managed thread is making a PInvoke call to a Win32 function, that thread 
will be in PreEmptive GC mode. 
The Domain column indicates what AppDomain the thread is currently executing
in. You can pass this value to !DumpDomain to find out more. 
The APT column gives the COM apartment mode. 
Exception will list the last thrown exception (if any) for the thread. More
details can be obtained by passing the pointer value to !PrintException. If
you get the notation "(nested exceptions)", you can get details on those
exceptions by switching to the thread in question, and running 
"!PrintException -nested".
COMMAND: clrstack.
!CLRStack [-a] [-l] [-p]
CLRStack attempts to provide a true stack trace for managed code only. It is
handy for clean, simple traces when debugging straightforward managed 
programs. The -p parameter will show arguments to the managed function. The 
-l parameter can be used to show information on local variables in a frame.
SOS can't retrieve local names at this time, so the output for locals is in
the format <local address> = <value>. The -a (all) parameter is a short-cut
for -l and -p combined.
When you see methods with the name "[Frame:...", that indicates a transition 
between managed and unmanaged code. You could run !IP2MD on the return 
addresses in the call stack to get more information on each managed method.
On IA64 and x64 platforms, Transition Frames are not displayed at this time.
Especially on IA64, there is heavy optimization of parameters and locals. You
can request the JIT compiler to not optimize functions in the managed app by
creating a file myapp.ini (if your program is myapp.exe) in the same directory.
Put the following lines in myapp.ini and re-run:
[.NET Framework Debugging Control]
GenerateTrackingInfo=1
AllowOptimize=0
COMMAND: ip2md.
!IP2MD <Code address>
Given an address in managed JITTED code, IP2MD attempts to find the MethodDesc
associated with it. For example, this output from K:
0:000> K
ChildEBP RetAddr
00a79c78 03ef02ab image00400000!Mainy.Top()+0xb
00a79c78 03ef01a6 image00400000!Mainy.Level(Int32)+0xb
00a79c78 5d3725a1 image00400000!Mainy.Main()+0xee
0012ea04 5d512f59 mscorwks!CallDescrWorkerInternal+0x30
0012ee34 5d7946aa mscorwks!CallDescrWorker+0x109
0:000> !IP2MD 03ef01a6
MethodDesc: 00902f40
Method Name: Mainy.Main()
Class: 03ee1424
MethodTable: 009032d8
mdToken: 0600000d
Module: 001caa38
IsJitted: yes
CodeAddr: 03ef00b8
We have taken a return address into Mainy.Main, and discovered information 
about that method. You could run !U, !DumpMT, !DumpClass, !DumpMD, or 
!DumpModule on the fields listed to learn more.
COMMAND: u.
!U [-gcinfo] [-ehinfo] <MethodDesc address> | <Code address>
Presents an annotated disassembly of a managed method when given a MethodDesc
pointer for the method, or a code address within the method body. Unlike the
debugger "U" function, the entire method from start to finish is printed,
with annotations that convert metadata tokens to names.
<example output>
03ef015d b901000000       mov     ecx,0x1
03ef0162 ff156477a25b     call   dword ptr [mscorlib_dll+0x3c7764 (5ba27764)] (System.Console.InitializeStdOutError(Boolean), mdToken: 06000713)
03ef0168 a17c20a701       mov     eax,[01a7207c] (Object: SyncTextWriter)
03ef016d 89442414         mov     [esp+0x14],eax
If you pass the -gcinfo flag, you'll get inline display of the GCInfo for
the method. You can also obtain this information with the !GCInfo command.
If you pass the -ehinfo flag, you'll get inline display of exception info
for the method. (Beginning and end of try/finally/catch handlers, etc.).
You can also obtain this information with the !EHInfo command.
COMMAND: dumpstack.
!DumpStack [-EE] [top stack [bottom stack]]
[x86 documentation]
This command provides a verbose stack trace obtained by "scraping." Therefore
the output is very noisy and potentially confusing. The command is good for
viewing the complete call stack when "kb" gets confused. For best results,
make sure you have valid symbols.
-EE will only show managed functions.
You can also pass a stack range to limit the output. Use the debugger 
extension !teb to get the top and bottom stack values.
[ia64 and x64 documentation]
Rather than scraping, !DumpStack mimics the debugger's "K" command. 
Stackwalking is done very differently on these platforms, so SOS allows the
Windows Debugger to unwind the frames, and supplies managed code information
where possible. The [top stack [bottom stack]] arguments are ignored, but
-EE functions just the same.
COMMAND: eestack.
!EEStack [-short] [-EE]
This command runs !DumpStack on all threads in the process. The -EE option is 
passed directly to !DumpStack. The -short option tries to narrow down the 
output to "interesting" threads only, which is defined by
1) The thread has taken a lock.
2) The thread has been "hijacked" in order to allow a garbage collection.
3) The thread is currently in managed code.
See the documentation for !DumpStack for more info.
COMMAND: ehinfo.
!EHInfo (<MethodDesc address> | <Code address>)
!EHInfo shows the exception handling blocks in a jitted method. For each 
handler, it shows the type, including code addresses and offsets for the clause
block and the handler block. For a TYPED handler, this would be the "try" and
"catch" blocks respectively.
Sample output:
0:000> !ehinfo 33bbd3a
MethodDesc: 03310f68
Method Name: MainClass.Main()
Class: 03571358
MethodTable: 0331121c
mdToken: 0600000b
Module: 001e2fd8
IsJitted: yes
CodeAddr: 033bbca0
EHHandler 0: TYPED
Clause: [033bbd2b, 033bbd3c] [8b, 9c]
Handler: [033bbd3c, 033bbd50] [9c, b0]
EHHandler 1: FINALLY
Clause: [033bbd83, 033bbda3] [e3, 103]
Handler: [033bbda3, 033bbdc5] [103, 125]
EHHandler 2: TYPED
Clause: [033bbd7a, 033bbdc5] [da, 125]
Handler: [033bbdc5, 033bbdd6] [125, 136]
COMMAND: gcinfo.
!GCInfo (<MethodDesc address> | <Code address>)
!GCInfo is especially useful for CLR Devs who are trying to determine if there 
is a bug in the JIT Compiler. It parses the GCEncoding for a method, which is a
compressed stream of data indicating when registers or stack locations contain 
managed objects. It is important to keep track of this information, because if 
a garbage collection occurs, the collector needs to know where roots are so it 
can update them with new object pointer values.
Here is sample output where you can see the change in register state. Normally 
you would print this output out and read it alongside a disassembly of the 
method. For example, the notation "reg EDI becoming live" at offset 0x11 of the
method might correspond to a "mov edi,ecx" statement.
0:000> !gcinfo 5b68dbb8   (5b68dbb8 is the start of a JITTED method)
entry point 5b68dbb8
preJIT generated code
GC info 5b9f2f09
Method info block:
    method      size   = 0036
    prolog      size   =  19
    epilog      size   =   8
    epilog     count   =   1
    epilog      end    = yes
    saved reg.  mask   = 000B
    ebp frame          = yes
    fully interruptible=yes
    double align       = no
    security check     = no
    exception handlers = no
    local alloc        = no
    edit & continue    = no
    varargs            = no
    argument   count   =   4
    stack frame size   =   1
    untracked count    =   5
    var ptr tab count  =   0
    epilog        at   002E
36 D4 8C C7 AA |
93 F3 40 05    |
Pointer table:
14             |             [EBP+14H] an untracked  local
10             |             [EBP+10H] an untracked  local
0C             |             [EBP+0CH] an untracked  local
08             |             [EBP+08H] an untracked  local
44             |             [EBP-04H] an untracked  local
F1 79          | 0011        reg EDI becoming live
72             | 0013        reg ESI becoming live
83             | 0016        push ptr  0
8B             | 0019        push ptr  1
93             | 001C        push ptr  2
9B             | 001F        push ptr  3
56             | 0025        reg EDX becoming live
4A             | 0027        reg ECX becoming live
0E             | 002D        reg ECX becoming dead
10             | 002D        reg EDX becoming dead
E0             | 002D        pop  4 ptrs
F0 31          | 0036        reg ESI becoming dead
38             | 0036        reg EDI becoming dead
FF             |
This function is important for CLR Devs, but very difficult for anyone else to 
make sense of it. You would usually come to use it if you suspect a gc heap 
corruption bug caused by invalid GCEncoding for a particular method.
COMMAND: comstate.
!COMState
!COMState lists the com apartment model for each thread, as well as a Context 
pointer if provided.
COMMAND: bpmd.
!BPMD <module name> <method name>
!BPMD -md <MethodDesc>
!BPMD provides managed breakpoint support. If it can resolve the method name
to a loaded, jitted or ngen'd function it will create a breakpoint with "bp".
If not then either the module that contains the method hasn't been loaded yet
or the module is loaded, but the function is not jitted yet. In these cases,
!bpmd asks the Windows Debugger to receive CLR Notifications, and waits to
receive news of module loads and JITs, at which time it will try to resolve 
the function to a breakpoint.
This brings up a good question: "I want to set a breakpoint on the main
method of my application, but SOS doesn't work until the runtime is loaded.
How can I do this?"
  1) Start the debugger and type: 
       sxe -c "" clrn
  2) g
  3) You'll get the following notification from the debugger:
     "CLR notification: module 'mscorlib' loaded"
  4) Now you can load SOS and use commands. Type
       .loadby sos mscorwks
     then
       !bpmd myapp.exe MyApp.Main
  5) g
  6) You will stop at the start of MyApp.Main. If you type "bl" you will 
     see the breakpoint listed.
!BPMD works equally well with generic types. Adding a breakpoint on a generic 
type sets breakpoints on all already JIT-ted generic methods and sets a pending 
breakpoint for any instantiation that will be JIT-ted in the future.
Example for generics:
Given the following two classes:
class G3<T1, T2, T3> 
public void F(T1 p1, T2 p2, T3 p3)
{ ... }
public class G1<T> {
// static method
static public void G<W>(W w)
{ ... }
One would issue the following commands to set breapoints on G3.F() and 
G1.G():
!bpmd myapp.exe G3`3.F
!bpmd myapp.exe G1`1.G
!BPMD does not accept offsets nor parameters in the method name. If there
are overloaded methods, !bpmd will set a breakpoint for all of them.
In the case of hosted environments such as SQL, the module name may be 
complex, like 'price, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null'.
For this case, just be sure to surround the module name with single quotes,
like:
!bpmd 'price, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null' Price.M2
COMMAND: dumpdomain.
!DumpDomain [<Domain address>]
When called with no parameters, !DumpDomain will list all the AppDomains in the
process. It enumerates each Assembly loaded into those AppDomains as well. 
In addition to your application domain, and any domains it might create, there
are two special domains: the Shared Domain and the System Domain.
Any Assembly pointer in the output can be passed to !DumpAssembly. Any Module 
pointer in the output can be passed to !DumpModule. Any AppDomain pointer can 
be passed to !DumpDomain to limit output only to that AppDomain. Other 
functions provide an AppDomain pointer as well, such as !Threads where it lists
the current AppDomain for each thread.
COMMAND: eeheap.
!EEHeap [-gc] [-loader]
!EEHeap enumerates process memory consumed by internal CLR data structures. You
can limit the output by passing "-gc" or "-loader". All information will be 
displayed otherwise.
The information for the Garbage Collector lists the ranges of each Segment in 
the managed heap. This can be useful if you believe you have an object pointer.
If the pointer falls within a segment range given by "!EEHeap -gc", then you do
have an object pointer, and can attempt to run "!DumpObj" on it.
Here is output for a simple program:
0:000> !eeheap -gc
Number of GC Heaps: 1
generation 0 starts at 0x00a71018
generation 1 starts at 0x00a7100c
generation 2 starts at 0x00a71000
 segment    begin allocated     size
00a70000 00a71000  00a7e01c 0000d01c(53276)
Large object heap starts at 0x01a71000
 segment    begin allocated     size
01a70000 01a71000  01a76000 0x00005000(20480)
Total Size   0x1201c(73756)
------------------------------
GC Heap Size   0x1201c(73756)
So the total size of the GC Heap is only 72K. On a large web server, with 
multiple processors, you can expect to see a GC Heap of 400MB or more. The 
Garbage Collector attempts to collect and reclaim memory only when required to
by memory pressure for better performance. You can also see the notion of 
"generations," wherein the youngest objects live in generation 0, and 
long-lived objects eventually get "promoted" to generation 2.
The loader output lists various private heaps associated with AppDomains. It 
also lists heaps associated with the JIT compiler, and heaps associated with 
Modules. For example:
0:000> !EEHeap -loader
Loader Heap:
--------------------------------------
System Domain: 5e0662a0
LowFrequencyHeap:008f0000(00002000:00001000) Size: 0x00001000 bytes.
HighFrequencyHeap:008f2000(00008000:00001000) Size: 0x00001000 bytes.
StubHeap:008fa000(00002000:00001000) Size: 0x00001000 bytes.
Total size: 0x3000(12288)bytes
--------------------------------------
Shared Domain: 5e066970
LowFrequencyHeap:00920000(00002000:00001000) 03e30000(00010000:00003000) Size: 0x00004000 bytes.
Wasted: 0x00001000 bytes.
HighFrequencyHeap:00922000(00008000:00001000) Size: 0x00001000 bytes.
StubHeap:0092a000(00002000:00001000) Size: 0x00001000 bytes.
Total size: 0x6000(24576)bytes
--------------------------------------
Domain 1: 14f000
LowFrequencyHeap:00900000(00002000:00001000) 03ee0000(00010000:00003000) Size: 0x00004000 bytes.
Wasted: 0x00001000 bytes.
HighFrequencyHeap:00902000(00008000:00003000) Size: 0x00003000 bytes.
StubHeap:0090a000(00002000:00001000) Size: 0x00001000 bytes.
Total size: 0x8000(32768)bytes
--------------------------------------
Jit code heap:
Normal JIT:03ef0000(00010000:00002000) Size: 0x00002000 bytes.
Total size: 0x2000(8192)bytes
--------------------------------------
Module Thunk heaps:
Module 5ba22410: Size: 0x00000000 bytes.
Module 001c1320: Size: 0x00000000 bytes.
Module 001c03f0: Size: 0x00000000 bytes.
Module 001caa38: Size: 0x00000000 bytes.
Total size: 0x0(0)bytes
--------------------------------------
Module Lookup Table heaps:
Module 5ba22410:Size: 0x00000000 bytes.
Module 001c1320:Size: 0x00000000 bytes.
Module 001c03f0:Size: 0x00000000 bytes.
Module 001caa38:03ec0000(00010000:00002000) Size: 0x00002000 bytes.
Total size: 0x2000(8192)bytes
--------------------------------------
Total LoaderHeap size: 0x15000(86016)bytes
=======================================
By using !EEHeap to keep track of the growth of these private heaps, we are 
able to rule out or include them as a source of a memory leak.
COMMAND: name2ee.
!Name2EE <module name> <type or method name>
!Name2EE <module name>!<type or method name>
This function allows you to turn a class name into a MethodTable and EEClass. 
It turns a method name into a MethodDesc. Here is an example for a method:
0:000> !name2ee unittest.exe MainClass.Main
Module: 001caa38
Token: 0x0600000d
MethodDesc: 00902f40
Name: MainClass.Main()
JITTED Code Address: 03ef00b8
and for a class:
0:000> !name2ee unittest!MainClass
Module: 001caa38
Token: 0x02000005
MethodTable: 009032d8
EEClass: 03ee1424
Name: MainClass
The module you are "browsing" with Name2EE needs to be loaded in the process. 
To get a type name exactly right, first browse the module with ILDASM. You
can also pass * as the <module name> to search all loaded managed modules.
<module name> can also be the debugger's name for a module, such as
mscorlib or image00400000.
The Windows Debugger syntax of <module>!<type> is also supported. You can
use an asterisk on the left of the !, but the type on the right side needs
to be fully qualified.
If you are looking for a way to display a static field of a class (and you
don't have an instance of the class, so !dumpobj won't help you), note that
once you have the EEClass, you can run !DumpClass, which will display the
value of all static fields.
There is yet one more way to specify a module name. In the case of modules
loaded from an assembly store (such as a SQL db) rather than disk, the
module name will look like this:
price, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
For this kind of module, simply use price as the module name:
0:044> !name2ee price Price
Module: 10f028b0 (price, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null)
Token: 0x02000002
MethodTable: 11a47ae0
EEClass: 11a538c8
Name: Price
Where are we getting these module names from? Run !DumpDomain to see a list of
all loaded modules in all domains. And remember that you can browse all the
types in a module with !DumpModule -mt <module pointer>.
COMMAND: syncblk.
!SyncBlk [-all | <syncblk number>]
A SyncBlock is a holder for extra information that doesn't need to be created 
for every object. It can hold COM Interop data, HashCodes, and locking 
information for thread-safe operations.
When called without arguments, !SyncBlk will print the list of SyncBlocks 
corresponding to objects that are owned by a thread. For example, a
    lock(MyObject)
    {
        ....
    }
statement will set MyObject to be owned by the current thread. A SyncBlock will
be created for MyObject, and the thread ownership information stored there 
(this is an oversimplification, see NOTE below). If another thread tries to 
execute the same code, they won't be able to enter the block until the first 
thread exits.
This makes !SyncBlk useful for detecting managed deadlocks. Consider that the
following code is executed by Threads A & B:
    Resource r1 = new Resource();
    Resource r2 = new Resource();
    ...
    lock(r1)                             lock(r2)
    {                                    {
        lock(r2)                             lock(r1)
        {                                    {
            ...                                  ...
        }                                    }
    }                                    }
This is a deadlock situation, as Thread A could take r1, and Thread B r2, 
leaving both threads with no option but to wait forever in the second lock 
statement. !SyncBlk will detect this with the following output:
0:003> !syncblk
Index SyncBlock MonitorHeld Recursion Owning Thread Info   SyncBlock Owner
  238 001e40ec            3         1 001e4e60   e04   3   00a7a194 Resource
  239 001e4124            3         1 001e5980   ab8   4   00a7a1a4 Resource
It means that Thread e04 owns object 00a7a194, and Thread ab8 owns object 
00a7a1a4. Combine that information with the call stacks of the deadlock:
(threads 3 and 4 have similar output)  0:003> k
ChildEBP RetAddr
0404ea04 77f5c524 SharedUserData!SystemCallStub+0x4
0404ea08 77e75ee0 ntdll!NtWaitForMultipleObjects+0xc
0404eaa4 5d9de9d6 KERNEL32!WaitForMultipleObjectsEx+0x12c
0404eb38 5d9def80 mscorwks!Thread::DoAppropriateAptStateWait+0x156
0404ecc4 5d9dd8bb mscorwks!Thread::DoAppropriateWaitWorker+0x360
0404ed20 5da628dd mscorwks!Thread::DoAppropriateWait+0xbb
0404ede4 5da4e2e2 mscorwks!CLREvent::Wait+0x29d
0404ee70 5da4dd41 mscorwks!AwareLock::EnterEpilog+0x132
0404ef34 5da4efa3 mscorwks!AwareLock::Enter+0x2c1
0404f09c 5d767880 mscorwks!AwareLock::Contention+0x483
0404f1c4 03f00229 mscorwks!JITutil_MonContention+0x2c0
0404f1f4 5b6ef077 image00400000!Worker.Work()+0x79
By looking at the code corresponding to Worker.Work()+0x79 (run "!u 03f00229"),
you can see that thread 3 is attempting to acquire the Resource 00a7a1a4, which
is owned by thread 4.
NOTE:
It is not always the case that a SyncBlock will be created for every object 
that is locked by a thread. In version 2.0 of the CLR and above, a mechanism 
called a ThinLock will be used if there is not already a SyncBlock for the 
object in question. ThinLocks will not be reported by the !SyncBlk command. 
You can use "!DumpHeap -thinlock" to list objects locked in this way.
COMMAND: dumpmt.
!DumpMT [-MD] <MethodTable address>
Examine a MethodTable. Each managed object has a MethodTable pointer at the 
start. If you pass the "-MD" flag, you'll also see a list of all the methods 
defined on the object. 
COMMAND: dumpclass.
!DumpClass <EEClass address>
The EEClass is a data structure associated with an object type. !DumpClass 
will show attributes, as well as list the fields of the type. The output is 
similar to !DumpObj. Although static field values will be displayed, 
non-static values won't because you need an instance of an object for that.
You can get an EEClass to look at from !DumpMT, !DumpObj, !Name2EE, and 
!Token2EE among others.
COMMAND: dumpmd.
!DumpMD <MethodDesc address>
This command lists information about a MethodDesc. You can use !IP2MD to turn 
a code address in a managed function into a MethodDesc:
0:000> !dumpmd 902f40
Method Name: Mainy.Main()
Class: 03ee1424
MethodTable: 009032d8
mdToken: 0600000d
Module: 001caa78
IsJitted: yes
CodeAddr: 03ef00b8
If IsJitted is "yes," you can run !U on the CodeAddr pointer to see a 
disassembly of the JITTED code. You can also call !DumpClass, !DumpMT, 
!DumpModule on the Class, MethodTable and Module fields above.
COMMAND: token2ee.
!Token2EE <module name> <token>
This function allows you to turn a metadata token into a MethodTable or 
MethodDesc. Here is an example showing class tokens being resolved:
0:000> !token2ee unittest.exe 02000003
Module: 001caa38
Token: 0x02000003
MethodTable: 0090375c
EEClass: 03ee1ae0
Name: Bank
0:000> !token2ee image00400000 02000004
Module: 001caa38
Token: 0x02000004
MethodTable: 009038ec
EEClass: 03ee1b84
Name: Customer
The module you are "browsing" with Token2EE needs to be loaded in the process. 
This function doesn't see much use, especially since a tool like ILDASM can 
show the mapping between metadata tokens and types/methods in a friendlier way. 
But it could be handy sometimes.
You can pass "*" for <module name> to find what that token maps to in every
loaded managed module. <module name> can also be the debugger's name for a 
module, such as mscorlib or image00400000.
COMMAND: eeversion.
!EEVersion
This prints the Common Language Runtime version. It also tells you if the code 
is running in "Workstation" or "Server" mode, a distinction which affects the 
garbage collector. The most apparent difference in the debugger is that in 
"Server" mode there is one dedicated garbage collector thread per CPU.
A handy supplement to this function is to also run "lm v m mscorwks". That 
will provide more details about the CLR, including where mscorwks.dll is 
loaded from.
COMMAND: dumpmodule.
!DumpModule [-mt] <Module address>
You can get a Module address from !DumpDomain, !DumpAssembly and other 
functions. Here is sample output:
0:000> !dumpmodule 1caa50
Name: C:\pub\unittest.exe
Attributes: PEFile
Assembly: 001ca248
LoaderHeap: 001cab3c
TypeDefToMethodTableMap: 03ec0010
TypeRefToMethodTableMap: 03ec0024
MethodDefToDescMap: 03ec0064
FieldDefToDescMap: 03ec00a4
MemberRefToDescMap: 03ec00e8
FileReferencesMap: 03ec0128
AssemblyReferencesMap: 03ec012c
MetaData start address: 00402230 (1888 bytes)
The Maps listed map metadata tokens to CLR data structures. Without going into 
too much detail, you can examine memory at those addresses to find the 
appropriate structures. For example, the TypeDefToMethodTableMap above can be 
examined:
0:000> dd 3ec0010
03ec0010  00000000 00000000 0090320c 0090375c
03ec0020  009038ec ...
This means TypeDef token 2 maps to a MethodTable with the value 0090320c. You 
can run !DumpMT to verify that. The MethodDefToDescMap takes a MethodDef token 
and maps it to a MethodDesc, which can be passed to !DumpMD.
There is a new option "-mt", which will display the types defined in a module,
and the types referenced by the module. For example:
0:000> !dumpmodule -mt 1aa580
Name: C:\pub\unittest.exe
...<etc>...
MetaData start address: 0040220c (1696 bytes)
Types defined in this module
      MT    TypeDef Name
------------------------------------------------------------------------------
030d115c 0x02000002 Funny
030d1228 0x02000003 Mainy
Types referenced in this module
      MT    TypeRef Name
------------------------------------------------------------------------------
030b6420 0x01000001 System.ValueType
030b5cb0 0x01000002 System.Object
030fceb4 0x01000003 System.Exception
0334e374 0x0100000c System.Console
03167a50 0x0100000e System.Runtime.InteropServices.GCHandle
0336a048 0x0100000f System.GC
COMMAND: threadpool.
!ThreadPool
This command lists basic information about the ThreadPool, including the number
of work requests in the queue, number of completion port threads, and number of
timers.
COMMAND: dumpassembly.
!DumpAssembly <Assembly address>
Example output:
0:000> !dumpassembly 1ca248
Parent Domain: 0014f000
Name: C:\pub\unittest.exe
ClassLoader: 001ca060
  Module Name
001caa50 C:\pub\unittest.exe
An assembly can consist of multiple modules, and those will be listed. You can
get an Assembly address from the output of !DumpDomain.
COMMAND: dumpmethodsig.
!DumpMethodSig <sigaddr> <moduleaddr>
[Not documented yet]
COMMAND: dumpruntimetypes.
!DumpRuntimeTypes 
!DumpRuntimeTypes finds all System.RuntimeType objects in the gc heap and 
prints the type name and MethodTable they refer too. Sample output:
 Address   Domain       MT Type Name
------------------------------------------------------------------------------
  a515f4   14a740 5baf8d28 System.TypedReference
  a51608   14a740 5bb05764 System.Globalization.BaseInfoTable
  a51958   14a740 5bb05b24 System.Globalization.CultureInfo
  a51a44   14a740 5bb06298 System.Globalization.GlobalizationAssembly
  a51de0   14a740 5bb069c8 System.Globalization.TextInfo
  a56b98   14a740 5bb12d28 System.Security.Permissions.HostProtectionResource
  a56bbc   14a740 5baf7248 System.Int32
  a56bd0   14a740 5baf3fdc System.String
  a56cfc   14a740 5baf36a4 System.ValueType
COMMAND: dumpsig.
!DumpSig <sigaddr> <moduleaddr>
[Not documented yet]
COMMAND: rcwcleanuplist.
!RCWCleanupList <RCWCleanupList address>
[Not documented yet]
COMMAND: dumpil.
!DumpIL <Managed DynamicMethod object> | 
        <DynamicMethodDesc pointer> |
        <MethodDesc pointer>
!DumpIL prints the IL code associated with a managed method. We added this
function specifically to debug DynamicMethod code which was constructed on
the fly. Happily it works for non-dynamic code as well.
You can use it in three ways: 
  1) If you have a System.Reflection.Emit.DynamicMethod object, just pass
     the pointer as the first argument. 
  2) If you have a DynamicMethodDesc pointer you can use that to print the
     IL associated with the dynamic method.
  3) If you have an ordinary MethodDesc, you can see the IL for that as well,
     just pass it as the first argument.
Note that dynamic IL is constructed a bit differently. Rather than referring
to metadata tokens, the IL points to objects in a managed object array. Here
is a simple example of the output for a dynamic method:
  0:000> !dumpil b741dc
  This is dynamic IL. Exception info is not reported at this time.
  If a token is unresolved, run "!do <addr>" on the addr given
  in parenthesis. You can also look at the token table yourself, by
  running "!DumpArray 00b77388".
  IL_0000: ldstr 70000002 "Inside invoked method "
  IL_0005: call 6000003 System.Console.WriteLine(System.String)
  IL_000a: ldc.i4.1
  IL_000b: newarr 2000004 "System.Int32"
  IL_0010: stloc.0
  IL_0011: ldloc.0
  IL_0012: ret
COMMAND: verifyheap.
!VerifyHeap
!VerifyHeap is a diagnostic tool that checks the garbage collected heap for 
signs of corruption. It walks objects one by one in a pattern like this:
    o = firstobject;
    while(o != endobject)
    {
        o.ValidateAllFields();
        o = (Object *) o + o.Size();
    }
If an error is found, !VerifyHeap will report it. I'll take a perfectly good 
object and corrupt it:
0:000> !DumpObj a79d40
Name: Customer
MethodTable: 009038ec
EEClass: 03ee1b84
Size: 20(0x14) bytes
 (C:\pub\unittest.exe)
Fields:
      MT    Field   Offset                 Type       Attr    Value Name
009038ec  4000008        4                CLASS   instance 00a79ce4 name
009038ec  4000009        8                CLASS   instance 00a79d2c bank
009038ec  400000a        c       System.Boolean   instance        1 valid
0:000> ed a79d40+4 01  (change the name field to the bogus pointer value 1)
0:000> !VerifyHeap
will only produce output if there are errors in the heap:
object 00a79d40: bad member 00000001 at 00a79d44
curr_object : 00a79d40
Last good object: 00a79d2c
----------------
If this gc heap corruption exists, there is a serious bug in your own code or 
in the CLR. In user code, an error in constructing PInvoke calls can cause 
this problem, and running with Managed Debugging Assistants is advised. If that
possibility is eliminated, consider contacting Microsoft Product Support for
help.
COMMAND: dumplog.
!DumpLog [-addr <addressOfStressLog>] [<Filename>]
To aid in diagnosing hard-to-reproduce stress failures, the CLR team added an 
in-memory log capability. The idea was to avoid using locks or I/O which could 
disturb a fragile repro environment. The !DumpLog function allows you to write 
that log out to a file. If no Filename is specified, the file "Stresslog.txt" 
in the current directory is created.
The optional argument addr allows one to specify a stress log other then the 
default one.
0:000> !DumpLog
Attempting to dump Stress log to file 'StressLog.txt'
.................
SUCCESS: Stress log dumped
To turn on the stress log, set the following registry keys under
HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\.NETFramework:
(DWORD) StressLog = 1
(DWORD) LogFacility = 0xffffffbf (this is a bit mask, almost all logging is on.
                                  This is also the default value if the key 
                                  isn't specified)
(DWORD) StressLogSize = 65536    (this is the default value if the key isn't
                                  specified)
(DWORD) LogLevel = 6             (this is the default value if the key isn't
                                  specified.  The higher the number the more
                                  detailed logs are generated.  The maximum 
                                  value is decimal 10)
StressLogSize is the size in bytes of the in-memory log allocated for each 
thread in the process. In the case above, each thread gets a 64K log. You 
could increase this to get more logging, but more memory will be required for 
this log in the process. For example, 20 threads with 524288 bytes per thread 
has a memory demand of 10 Megabytes. The stress log is circular so new entries 
will replace older ones on threads which have reached their buffer limit.
The log facilities are defined as follows:
    GC           0x00000001
    GCINFO       0x00000002
    STUBS        0x00000004
    JIT          0x00000008
    LOADER       0x00000010
    METADATA     0x00000020
    SYNC         0x00000040
    EEMEM        0x00000080
    GCALLOC      0x00000100
    CORDB        0x00000200
    CLASSLOADER  0x00000400
    CORPROF      0x00000800
    REMOTING     0x00001000
    DBGALLOC     0x00002000
    EH           0x00004000
    ENC          0x00008000
    ASSERT       0x00010000
    VERIFIER     0x00020000
    THREADPOOL   0x00040000
    GCROOTS      0x00080000
    INTEROP      0x00100000
    MARSHALER    0x00200000
    IJW          0x00400000
    ZAP          0x00800000
    STARTUP      0x01000000
    APPDOMAIN    0x02000000
    CODESHARING  0x04000000
    STORE        0x08000000
    SECURITY     0x10000000
    LOCKS        0x20000000
    BCL          0x40000000
Here is some sample output:
3560   9.981137099 : `SYNC`               RareEnablePremptiveGC: entering. 
Thread state = a030
3560   9.981135033 : `GC`GCALLOC`GCROOTS` ========== ENDGC 4194 (gen = 2, 
collect_classes = 0) ==========={
3560   9.981125826 : `GC`                         Segment mem 00C61000 alloc 
= 00D071F0 used 00D09254 committed 00D17000
3560   9.981125726 : `GC`                     Generation 0 [00CED07C, 00000000
] cur = 00000000
3560   9.981125529 : `GC`                     Generation 1 [00CED070, 00000000
] cur = 00000000
3560   9.981125103 : `GC`                     Generation 2 [00C61000, 00000000
] cur = 00000000
3560   9.981124963 : `GC`                 GC Heap 00000000
3560   9.980618994 : `GC`GCROOTS`         GcScanHandles (Promotion Phase = 0)
The first column is the OS thread ID for the thread appending to the log, 
the second column is the timestamp, the third is the facility category for the 
log entry, and the fourth contains the log message. The facility field is 
expressed as `facility1`facility2`facility3`.  This facilitates the creation of 
filters for displaying only specific message categories.  To make sense of this 
log, you would probably want the Shared Source CLI to find out exactly where 
the log comes from.
COMMAND: findappdomain.
!FindAppDomain <Object address>
!FindAppDomain will attempt to resolve the AppDomain of an object. For example,
using an Object Pointer from the output of !DumpStackObjects:
0:000> !findappdomain 00a79d98
AppDomain: 0014f000
Name: unittest.exe
ID: 1
You can find out more about the AppDomain with the !DumpDomain command. Not 
every object has enough clues about it's origin to determine the AppDomain. 
Objects with Finalizers are the easiest case, as the CLR needs to be able to 
call those when an AppDomain shuts down.
COMMAND: savemodule.
!SaveModule <Base address> <Filename>
This command allows you to take a image loaded in memory and write it to a 
file. This is especially useful if you are debugging a full memory dump, and 
don't have the original DLLs or EXEs. This is most often used to save a managed
binary to a file, so you can disassemble the code and browse types with ILDASM.
The base address of an image can be found with the "LM" debugger command:
0:000> lm
start    end        module name
00400000 00408000   image00400000     (deferred)
10200000 102ac000   MSVCR80D     (deferred)
5a000000 5a0b1000   mscoree      (deferred)
5a140000 5a29e000   mscorjit     (deferred)
5b660000 5c440000   mscorlib_dll     (deferred)
5d1d0000 5e13c000   mscorwks     (deferred)
If I wanted to save a copy of mscorwks.dll, I could run:
0:000> !SaveModule 5d1d0000 c:\pub\out.tmp
4 sections in file
section 0 - VA=1000, VASize=e82da9, FileAddr=400, FileSize=e82e00
section 1 - VA=e84000, VASize=24d24, FileAddr=e83200, FileSize=ec00
section 2 - VA=ea9000, VASize=5a8, FileAddr=e91e00, FileSize=600
section 3 - VA=eaa000, VASize=c183c, FileAddr=e92400, FileSize=c1a00
The diagnostic output indicates that the operation was successful. If 
c:\pub\out.tmp already exists, it will be overwritten.
COMMAND: gchandles.
!GCHandles [-perdomain]
!GCHandles provides statistics about GCHandles in the process. Sometimes the 
source of a memory leak is a GCHandle leak. For example, code might keep a 50 
Megabyte array alive because a strong GCHandle points to it, and the handle was
discarded without freeing it.
The most common handles are "Strong Handles," which keep the object they point 
to alive until the handle is explicitly freed. "Pinned Handles" are used to 
prevent the garbage collector from moving an object during collection. These 
should be used sparingly, and for short periods of time. If you don't follow 
that precept, the gc heap can become very fragmented.
Here is sample output from a very simple program:
0:000> !gchandles
GC Handle Statistics:
Strong Handles: 13
Pinned Handles: 3
Async Pinned Handles: 0
Ref Count Handles: 0
Weak Long Handles: 0
Weak Short Handles: 1
Other Handles: 0
Statistics:
      MT    Count TotalSize Class Name
5ba75da8        1        12 System.Security.Permissions.SecurityPermission
5ba5c57c        1        20 System.SharedStatics
5ba76878        2        40 System.Security.PermissionSet
5ba6739c        1        48 System.Reflection.Module
5ba65bb8        2        48 System.Reflection.Assembly
5ba5dba4        1        68 System.Threading.ThreadAbortException
5ba58430        1        68 System.ExecutionEngineException
5ba58380        1        68 System.StackOverflowException
5ba58328        1        68 System.OutOfMemoryException
5ba58c10        1       108 System.AppDomain
5ba5db04        2       136 System.Threading.Thread
5ba88bd8        3     10256 System.Object[]
Total 17 objects
If you run with the -perdomain option, you will get the same output broken 
down by AppDomain.
COMMAND: gchandleleaks.
!GCHandleLeaks
This command is an aid in tracking down GCHandle leaks. It searches all of 
memory for any references to the Strong and Pinned GCHandles in the process, 
and reports what it found. If a handle is found, you'll see the address of the
reference. This might be a stack address or a field within an object, for 
example. If a handle is not found in memory, you'll get notification of that 
The command has diagnostic output which doesn't need to be repeated here. One 
thing to keep in mind is that anytime you search all of memory for a value, you
can get false positives because even though the value was found, it might be 
garbage in that no code knows about the address. You can also get false 
negatives because a user is free to pass that GCHandle to unmanaged code that 
might store the handle in a strange way (shifting bits, for example).
For example, a GCHandle valuetype is stored on the stack with the low bit set 
if it points to a Pinned handle. So !GCHandleLeaks ignores the low bit in it's
searches.
That said, if a serious leak is going on, you'll get a ever-growing set of 
handle addresses that couldn't be found.
COMMAND: vmmap.
!VMMap
!VMMap traverses the virtual address space and lists the type of protection 
applied to each region. Sample output:
0:000> !VMMap
Start    Stop     Length    AllocProtect  Protect       State    Type
00000000-0000ffff 00010000                NA            Free
00010000-00011fff 00002000  RdWr          RdWr          Commit   Private
00012000-0001ffff 0000e000                NA            Free
00020000-00020fff 00001000  RdWr          RdWr          Commit   Private
00021000-0002ffff 0000f000                NA            Free
00030000-00030fff 00001000  RdWr                        Reserve  Private
COMMAND: vmstat.
!VMStat
Provides a summary view of the virtual address space, ordered by each type of 
protection applied to that memory (free, reserved, committed, private, mapped, 
image). The TOTAL column is (AVERAGE * BLK COUNT). Sample output below:
0:000> !VMStat
~~~~           ~~~~~~~        ~~~~~~~        ~~~~~~~  ~~~~~~~~~          ~~~~~
TYPE           MINIMUM        MAXIMUM        AVERAGE  BLK COUNT          TOTAL
Free:
Small            4,096         65,536         48,393         27      1,306,611
Medium         139,264        528,384        337,920          4      1,351,680
Large        6,303,744    974,778,368    169,089,706         12  2,029,076,472
Summary          4,096    974,778,368     47,249,646         43  2,031,734,778
Reserve:
Small            4,096         65,536         43,957         41      1,802,237
Medium         249,856      1,019,904        521,557          6      3,129,342
Large        2,461,696     16,703,488     11,956,224          3     35,868,672
Summary          4,096     16,703,488        816,005         50     40,800,250
COMMAND: procinfo.
!ProcInfo [-env] [-time] [-mem]
!ProcInfo lists the environment variables for the process, kernel CPU time, as 
well as memory usage statistics.
; <$<(<,<
2 2$2(2,2024282<2
@1D1H1L1P1T1x1|1
X8\8`8d8h8l8p8t8x8|8
9 9$9(9,9094989<9@9D9H9L9P9T9X9\9`9d9h9l9p9t9x9|9
9,<0<d<h<x<|<
=,=0=a=j=|=
>">)>.>I>X>^>
?1?@?S?s?
0%0,010M0V0]0b0~0
1*1B1O1t1
1#262i2
2,3!8(8J8T8
9A:T:]:h:r:{:
;&;.;6;<;A;J;a;q;
<;<E<N<Y<g<z<
=a=j=w=
=Q>V>_>h>q>z>
1*1a1l1
1J2a2m2
223>3T3i3o3t3
4N4S4\4e4n4w4
5#5)565<5I5O5a5g5}5
536S6d6
7/757=7C7O7W7
8E8]8
:M;T;d;
;*<^<
>&>E?
1/1N1T1^1d1n1t1y1
21272F2R2W2]2s2
3*323[3i3w3
3"4,4G4L4^4p4~4
5<5h5o5
6&6D6k6
7$71797I7U7b7k7
8/8c8
9'999E9O9V9
:2;>;T;
<p<}<
0-0S0y0
1"1*171R1V1a1j1w1
6L7]7c7
8!8;8A8U8[8s8y8
9%9+9C9I9c9i9}9
:#:4:8:<:@:D:H:L:P:T:X:\:`:d:
:$;M;};
;G<n<t<
=0=T=
>!?F?
0"0.0D0P0
1,272<2
3Q3`3
5:6D6
667R7
7g8n8
8M9l9p9t9x9|9
:%:*:/:4:9:>:C:H:M:S:\:
< <Y<
=)=Q=Y=`=f=l=
>">I>P>V>\>
?W?]?s?~?
0L0R0]0
1"1'1-1A1G1L1R1
1:2d2
3B3N3d3}3
3]4|4
646d6
9"9e9
=j=w=}=
=N>t>
0%050?0L0h0m0
1`1y1
8"838D8U8~8
<3<:<Z<
=0=^=
=S>w>
?e?p?
0?1c1|1
2W3o3|3
5!535?5
616Z6o6
828a8
9b9t9
9-:F:\:
;^<m<v<
= =*=4=>=H=R=\=f=p=z=
5?5M5Y5t5
7%777C7Q7X7`7n7u7}7
8)8;8P8W8`8x8
<'<3<E<L<Y<i<p<w<~<
="=5=H=T=
?L?x?
1%1m1y1
2^2e2n2
203<3s3
3<4r4y4
616=6U6w6
7d7h7l7p7t7x7|7
8"8.8D8a8
9(:B:q:
;+;Z;q;
<)<=<M<v<
<2=O=i={=
>/>J>O>
?U?h?
0>0T0_0d0o0|0
213e3p3u3
3!4+454?4I4S4f4k4}4
5^5i5n5
5!626;6J6O6`6
6"7.7D7P7|7
8%8.8a8k8p8u8z8
9-92979P9W9\9b9{9
:':.:3:9:R:Y:^:d:
;$;9;@;F;];t;{;
<2<><T<
=&=U=l=s=
?#?*?y?
0$0E0f0p0
111X1j1
3$383O3f3}3
4)4H4
4K5o5
6(6:6D6N6Y6q6
737S7X7p7z7
7L8]8u8
:K:U:g:r:
?3?F?S?
2(2z2
3(3;3
5H5o5w5
788[8}8
:7:L:
<H<~<
=G>V>f>k>p>w>
0F1T1`1
1U2f2p2
3%343:3@3\3
3+4>4H4v4
4Y5j5t5
5E6_6z6
7K7b7l7
828y8
8 9Q9
:*:4:r:
:V;l;
=,=6=P=
>%>/>D>
?5?@?k?y?
0#0;0
1!121S1
2F2P2Z2k2
3K3^3h3
3$4:4E4J4T4
5/5C5W5g5w5
6 6;6K6
7<7S7]7
7%8;8W8i8
9)9;9N9a9x9
9#:4:R:y:
;(;2;H;S;X;
;!<4<><
>&>0>k>~>
?%?[?
!040>0
1@1[1
3.383G3L3Q3V3`3
3:4Q4[4
5'5X5
5$636B6\6
707F7Q7V7r7
9(9V9`9s9}9
:&:0:g:z:
;2;z;
<(<B<\<y<
=#=-=<=I=W=a=f=k=p=z=
>E>X>b>
?3?R?s?
0$080K0e0
021I1a1
2 2\2o2y2
2,363A3I3_3d3q3
3"4R4f4
5-5>5H5
656G6Y6k6}6
6R7c7m7
9U9h9r9
:,:;:E:W:
:*;E;d;s;};
;%<i<z<
=0=C=
> >&>5>F>w>
>(?9?C?
121K1c1h1}1
2=2P2Z2
3 313H3q3
434W4c4
5(5_5r5|5
5;6W6
7#757@7E7p7
;S;g;s;
<3<:<G<w<
=@=d=
>.>G>N>S>n>s>
?#?3?
1)1A1X1
454?4\4y4
5$5D5
5(6;6E6
6.7l7
7%868@8w8
>Z?n?
*060I0`0
0'1O1a1
4#4-4b4u4
435D5N5
6,666H6_6
7r7~7
778[8s8
9S9m9w9
:$:3:=:Q:X:e:o:y:
; ;X;
<"<V<q<{<
=,=1=6=
>!>&>?>L>o>
?)?1?[?e?o?
050r0
1R1u1
232=2
3)3@3
5P6e6
6$797[7
7'8|8
809_9
: :7:<:q:
;);:;w;
;7<U<&=r=
?6?;?M?
1B1L1
2d3k3
5L5_5i5(6f6s6
657F7P7
9%:y:
<2<N<[<|<
="=:=Z=g=
=N>a>h>o>
?E?X?u?
1"171A1
2(394L4
4L5V5
6&6G6s6
797J7T7
7M8a8
<8=R=]=
=?>X>t>
?*?4?r?
000:0I0_0}0
2,2X2r2^3
4 5D5
6B6d6v6
9':O:`:v:
;F;l;~;
=!=8=W=
>8>I>S>
?&?R?h?
0%060Q0v0
1B1U1
2-2M2n2x2
383S3b3
404@4O4Y4
5=5O5b5z5
5J6i6z6
8 8<8X8x8
:):6:D:
::;O;o;
=$=)=7=C=\=u=
>5>F>P>y>
>:?Y?j?t?
0V0`0e0j0o0t0
1%131=1P1]1d1l1
2 2I2`2k2v2
3#343>3u3
3 474a4q4
575d5
5<6M6W6
6V7j7~7
8M8Z8t8
9,919C9H9Z9_9q9v9
:,:I:t:
:-;F;_;l;~;
<#<(<:<?<Q<V<h<m<
=,=J=T=^=h=z=
1(191_1
2:2k2x2
5"5<5
5$6\6
6=7T7$808F8R8
8=9O9a9
:+:A:
; ;+;3;W;n;
;=<j<
=A=R=X=j=
>&>A>H>W>w>
>=?F?X?g?|?
?0H0^0
051J1R1d1p1
2C2v2
4D4]4p4
545v5
5$6t6
797a7
;$;R;p;
<*<0<e<j<
=D=w=
=*>C>
122>2T2|2
3+3I3V3`3
4>4z4
5)575
6P6W6_6x6~6
7!7&747J7X7w7
8 8%8N8
9R9]9{9
9":.:D:Q:s:
;6;>;P;Y;~;
<-<6<R<[<
=d=l=y=~=
>,>2>F>K>R>\>p>{>
?!?(?o?v?
0&0,070I0Z0`0q0w0
141:1^1d1v1
2w2}2
3+313
3&4,4_4r4x4
5G5y5
98:@:R:
;$;.;<;I;d;
;2<><T<q<
=%=+=7===I=O={=
=">(>.>8>a>h>o>y>
?%?>?_?f?m?w?
0#0<0]0d0k0u0
1&1b1n1
1#2*2a2h2
4%474b4
5+5e5l5}5
506Z6
7.7k7
8H8j8
>%>M>S>]>c>
>8?_?
010;0A0y0
0(1A1G1r1/282>2W2]2s2y2
3$3Y3
3&4/454^4d4v4|4
4,5D5K5|5
6!646p6
7M7g7
7K8w8
969=9^:
<,<J<U<[<
=$=+=6=<=S=d=q=
>.>4>E>J>\>b>m>u>
?B?H?b?g?
0!0<0@0D0H0L0P0T0X0\0`0d0h0l0
2%3,313D3X3l3
4!4+454?4I4
5"5,565A5
6k7u7
9j:q:
;.=4=
1C2Y2
2-3|3
6,6Z6
6`7i7o7u7
7+838:8c8i8o8
9!9'979<9N9T9`9e9w9}9
:%:<:B:\:
;5;;;R;W;u;
<'<D<H<L<P<T<X<\<`<d<h<l<p<t<x<|<
>">)>0>7><>B>Z>
>)?/?>?L?Z?e?o?u?
0/0W0~0
111G2
2(363G3X3i3z3
4$404
5(6`6
:+:V:c:
;J;S;
>A?X?t?
3T4`4l4
6I6]6h6G7R7W7j7
8+8E8
9T9n9
:D:r:w:
<<<]<j<
=#=+=Z=d=v=
>/>7>I>d>
>*?4?S?k?x?
1J1c1p1}1
2.2e2
3 363@3E3T3a3
555u5
5*6r6~6
7=8[8
;.;U;w;
<5<O<l<
?,?>?C?I?O?{?
.040O0
4,525:5G5[5f5
9=9c9
:f:q:
;$;(;,;0;4;8;<;@;
H0Y0o0
3)4.44484>4B4H4L4R4V4[4a4e4k4o4u4y4
5J6a6
9|;)<4<
3J4P4t4
4$5<5G5
6 6z6
:(:/:7:<:@:D:m:
;$;(;,;0;
<M<T<X<\<`<d<h<l<p<
<>>S>Y>b>i>
?8?@?L?T?h?s?x?
0#0_0d0o0t0
1$1T1m1
2!2-2B2H2\2c2}2
3+343A3b3l3
4 4D4
5d5w5}5
6%6*626;6G6L6Q6W6[6a6f6l6t6
767R7d7
8;8D8P8
8 9w9
:K:{:
;%;G;U;d;
=f>l>
>J?\?
3,383@3H3T3x3
4f5k5}5
7%7+71777=7D7K7R7Y7`7g7n7v7~7
8!8;8
8(929S9
:*:K:^:
=N=V=`=y=
=$>7>
0!030N0V0^0u0
0&171W1
3"4j4y4
5X6{6
<==s=
5f5o5
5c6u6~6
7"7.7;7_7q7
8%8O8
91:I:
>5?[?z?
2*343L3t3
545?5b5
929:9Y9i9{9
<:=R=
6!6k7
9%9>9P9V9_9r9
9):I:Y:_:f:s:z:
="=+=8=C=U=h=s=y=
>#>0>6>P>a>g>x>
3W3*555=5R5
7D7\7g7
838X8k8
9(9-92979B9r9
:":):.:
:2;<;F;Q;^;n;
>%???H?j?
0*040L0S0]0e0r0y0
404B4T4f4
545^5
<!<.<5<
=7>X>d>
171G1b1
?!?3?F?X?
9,:9:A:O:a:m:x:
v0J1[1|1
676W6
7c9g9k9o9s9w9{9
:.:?:F:U:Z:g:u:
;V;];c;
;c<m<
1F2<3D3
4r5x5
6 606
;*;?;F;L;b;};
;s<z<
041A1
2+383X3
3T4d5k586
8K8~8
9!9@9O9X9^9h9
:-:7:A:J:c:k:~:
; ;(;,;D;H;d;h;x;
<0<8<L<h<
=(=H=h=t=
>0>P>p>
?4?8?X?t?x?
0$0@0`0
0$0(0,0004080<0@0D0H0L0P0T0X0x0
L1T1\1d1l1t1|1
2$2,242<2D2P6T6X6\6`6d6h6l6p6t6x6|6
7,7<7L7\7l7|7
8,8<8L8\8l8|8
9,9<9L9\9l9|9
:,:<:L:\:l:|:
;,;<;L;\;l;|;
<,<<<L<\<l<|<
=,=<=L=\=l=|=
>,><>L>\>l>|>
?,?<?L?\?l?|?
0,0<0L0\0l0|0
1,1<1L1\1l1|1
2,2<2L2\2l2|2
3,3<3L3\3l3|3
4,4<4L4\4l4|4
5,5<5L5\5l5|5
6,6<6L6\6l6|6
7,7<7L7\7l7|7
8,8<8L8\8l8|8
9,989<9@9D9H9L9P9T9X9\9`9d9h9l9p9t9x9|9
:$:,:0:4:8:<:@:D:H:L:P:T:X:\:`:d:h:l:p:t:x:|:
;$;4;D;T;d;t;
<$<4<D<T<p<t<
5$5054585<5@5H5L5P5T5X5\5`5d5h5l5p5t5x5
7 949<9D9L9T9\9d9l9t9|9
: :$:(:,:0:4:8:<:@:D:H:L:P:T:X:\:`:d:h:l:p:t:x:|:
h)pX[%
Washington1
Redmond1
Microsoft Corporation1(0&
Microsoft Code Signing PCA 20110
201215213145Z
211202213145Z0t1
Washington1
Redmond1
Microsoft Corporation1
Microsoft Corporation0
E0C1)0'
 Microsoft Operations Puerto Rico1
230012+4630090
M0K0I
Chttp://www.microsoft.com/pkiops/crl/MicCodSigPCA2011_2011-07-08.crl0a
U0S0Q
Ehttp://www.microsoft.com/pkiops/certs/MicCodSigPCA2011_2011-07-08.crt0
DLYwh
bf&!D
Washington1
Redmond1
Microsoft Corporation1200
)Microsoft Root Certificate Authority 20110
110708205909Z
260708210909Z0~1
Washington1
Redmond1
Microsoft Corporation1(0&
Microsoft Code Signing PCA 20110
S0Q0O
Ihttp://crl.microsoft.com/pki/crl/products/MicRooCerAut2011_2011_03_22.crl0^
R0P0N
Bhttp://www.microsoft.com/pki/certs/MicRooCerAut2011_2011_03_22.crt0
3http://www.microsoft.com/pkiops/docs/primarycps.htm0@
Legal_policy_statement
e_.,>
D=xz#
*?*kXIc
QEX82q'
WqVNHE
Washington1
Redmond1
Microsoft Corporation1(0&
Microsoft Code Signing PCA 2011
Microsof
http://www.microsoft.com0
("]w#
20210504100722.781Z0
Washington1
Redmond1
Microsoft Corporation1)0'
 Microsoft Operations Puerto Rico1&0$
Thales TSS ESN:C4BD-E37F-5FFC1%0#
Microsoft Time-Stamp Service
Washington1
Redmond1
Microsoft Corporation1&0$
Microsoft Time-Stamp PCA 20100
210114190213Z
220411190213Z0
Washington1
Redmond1
Microsoft Corporation1)0'
 Microsoft Operations Puerto Rico1&0$
Thales TSS ESN:C4BD-E37F-5FFC1%0#
Microsoft Time-Stamp Service0
O0M0K
Ehttp://crl.microsoft.com/pki/crl/products/MicTimStaPCA_2010-07-01.crl0Z
N0L0J
>http://www.microsoft.com/pki/certs/MicTimStaPCA_2010-07-01.crt0
#3DS=D
Washington1
Redmond1
Microsoft Corporation1200
)Microsoft Root Certificate Authority 20100
100701213655Z
250701214655Z0|1
Washington1
Redmond1
Microsoft Corporation1&0$
Microsoft Time-Stamp PCA 20100
|hK,_
$`2X`F
O0M0K
Ehttp://crl.microsoft.com/pki/crl/products/MicRooCerAut_2010-06-23.crl0Z
N0L0J
>http://www.microsoft.com/pki/certs/MicRooCerAut_2010-06-23.crt0
1http://www.microsoft.com/PKI/docs/CPS/default.htm0@
Legal_Policy_Statement
oK0D$"<
z.9Wv
r~akow
Washington1
Redmond1
Microsoft Corporation1)0'
 Microsoft Operations Puerto Rico1&0$
Thales TSS ESN:C4BD-E37F-5FFC1%0#
Microsoft Time-Stamp Service
Washington1
Redmond1
Microsoft Corporation1&0$
Microsoft Time-Stamp PCA 20100
20210504041201Z
20210505041201Z0w0=
1/0-0
1(0&0
U7tb!
Washington1
Redmond1
Microsoft Corporation1&0$
Microsoft Time-Stamp PCA 2010
D1"xR
6t\YZA
Washington1
Redmond1
Microsoft Corporation1&0$
Microsoft Time-Stamp PCA 2010
/]DkYQ
/mOj{
