!This program cannot be run in DOS mode.
RichKoT
.text
`.data
.idata
@.rsrc
@.reloc
api-ms-win-core-synch-l1-2-0.dll
SleepConditionVariableCS
WakeAllConditionVariable
Unknown exception
bad allocation
Exception
ReturnNt
ReturnHr
LogNt
LogHr
FailFast
%hs(%u)\%hs!%p: 
%hs!%p: 
(caller: %p) 
%hs(%d) tid(%x) %08X %ws
Msg:[%ws] 
CallContext:[%hs] 
[%hs(%hs)]
[%hs]
kernelbase.dll
RaiseFailFastException
lstd::exception: %hs
onecore\internal\sdk\inc\wil\opensource\wil\resource.h
WilError_03
ntdll.dll
RtlNtStatusToDosErrorNoTeb
RtlDllShutdownInProgress
RtlDisownModuleHeapAllocation
WilFailureNotifyWatchers
length
C++/WinRT version:2.0.220110.5
winrt::hresult_error: %ls
Local\SM0:%lu:%lu:%hs
Windows.Foundation.PropertyValue
XAlphaMask
bad array new length
Invalid animatable property mapping.
string too long
Coefficients
ClampOutput
ArithComp
.x * 
.y * 
.z * 
 = saturate(
InterpolationMode
BorderMode
TransformMatrix
Sharpness
XForm
AffineTransform2D's source must be a source parameter.
Blend
Multiply
Screen
Darken
Lighten
ColorBurn
LinearBurn
DarkerColor
LighterColor
ColorDodge
LinearDodge
Overlay
SoftLight
HardLight
VividLight
LinearLight
PinLight
HardMix
Difference
Exclusion
Saturation
Color
Luminosity
Subtract
Division
Unsupported blend mode.
D2DBlend.hlsl
 = D2DBlend
.a = D2DBlendAlpha(
ExtendX
ExtendY
Border
Unsupported BorderEffect edge mode.
BorderEffect's source must be a source parameter.
ColorMatrix
AlphaMode
ColorMatrixEffect
Unsupported alpha mode.
ColorMatrix4x4
ColorOffset
D2DColorMatrix.hlsl
D2DColorMatrixPremultiplied
D2DColorMatrixStraight
Contrast
ClampInput
D2DContrast.hlsl
 = D2DContrast(
PSBody
Composite
SourceOver
DestinationOver
SourceIn
DestinationIn
SourceOut
DestinationOut
SourceAtop
DestinationAtop
SourceCopy
MaskInvert
Unsupported composite mode.
D2DComposite.hlsl
 = D2DComposite
Weight
CrossFade
lerp(
d3dcompiler_47.dll
D3DReflectLibrary
D3DCompile
Azimuth
Elevation
DiffuseAmount
HeightMapScale
LightColor
HeightMapKernelSize
HeightMapInterpolationMode
DistantDiffuse
LightVector
c_defaultSurfaceNormal
D2DLighting.hlsl
 = D2DDistantDiffuse(
SpecularExponent
SpecularAmount
DistantSpecular
 = D2DDistantSpecular(
Invalid float value
Common.hlsl
return 
 Non-finite floating-point value.
Output semantic can be changed only once.
sample
Unexpected effect input type.
Output_Normal_TangentSpace
XYZ_Light0Space
WhiteNoise_XY
Unknown input parameter.
onecoreuap\windows\dwm\effects\compiler\effectgenerator.cpp
lib_4_0_level_9_3_ps_only
PixelShader.hlsl
invalid vector subscript
vector too long
map/set too long
O8T>[
Unexpected effect property value.
onecoreuap\windows\dwm\effects\compiler\effectinstance.cpp
ExposureValue
Exposure
Multiplier
 = minfloat4(
.rgb * 
Unsupported effect type.
Invalid number of sources.
No more than three graph source parameters with white noise effect are supported.
A graph source parameter with a transform can only be used once.
A graph source parameter with a border effect can only be used once.
No more than four graph source parameters are supported.
onecoreuap\windows\dwm\effects\compiler\flattenedeffectgraph.cpp
Effect is too complex.
Invalid effect input.
Flood
RedAmplitude
RedExponent
RedOffset
RedDisable
GreenAmplitude
GreenExponent
GreenOffset
GreenDisable
BlueAmplitude
BlueExponent
BlueOffset
BlueDisable
AlphaAmplitude
AlphaExponent
AlphaOffset
AlphaDisable
GammaXfer
 = UnPremultiply(
 * pow(
 = Premultiply(
BlurAmount
EffectOptimization
GaussianBlur
Invalid blur border mode.
onecoreuap\windows\dwm\effects\compiler\graphicseffectgraphtraversal.cpp
SceneLightingEffect cannot be a source to GaussianBlurEffect.
Non-tree shaped effect graph.
Null effect input.
Malformed effect name.
Duplicate effect name.
Malformed named input name.
Unsupported effect property type.
Unexpected property type.
Property value out of bounds
Null animatable property name.
Multiply defined animatable property.
Malformed animatable property name.
Animatable property refers to an effect not in the graph.
Specified property does not exist or cannot be animated.
Specified property cannot be animated.
Multiple animatable properties animate the same value.
unordered_map/set too long
invalid hash bucket count
qwGrayscale
D2DSaturation.hlsl
 = D2DGrayscale(
Angle
HueRotation
Matrix
UnPremultiply(
Invert
 = Premultiply(minfloat4(
1 - UnPremultiply(
).rgb, 
.a));
RedSlope
GreenSlope
BlueSlope
AlphaSlope
LinearXfer
LuminanceToAlpha
D2DLuminanceToAlpha.hlsl
 = D2DLuminanceToAlpha(
Opacity
PSConstants
row_major 
 : packoffset(c
const 
// Copyright (C) Microsoft. All rights reserved.
// Generated file, do not edit.
#include "
cbuffer 
 : register(b0)
export minfloat4 
Unexpected variable scope.
minfloat
minfloat2
minfloat3
minfloat4
minfloat3x2
minfloat4x4
LightPosition
PointDiffuse
 = D2DPointDiffuse(
.xyz, 
PointSpecular
 = D2DPointSpecular(
 = D2DSaturation(
AmbientAmount
SpecularShine
ReflectanceModel
SceneLighting
c_defaultNormalHeight
 = SceneLightingParameters(
jIntensity
Sepia
D2DSepia.hlsl
D2DSepiaPremultiplied
D2DSepiaStraight
onecoreuap\windows\dwm\effects\compiler\shaderincluderesolver.cpp
FLightTarget
Focus
LimitingConeAngle
SpotDiffuse
LightTargetVector
LightCosConeAngle
 = D2DSpotDiffuse(
SpotSpecular
 = D2DSpotSpecular(
Temperature
TempTint
Gains
.r * 
.b * 
7.s:>j
8wJG>iR
9/iL>
79|~X>
M_>|~
:deque<T> too long
Frequency
Offset
WhiteNoise
Noise.hlsl
 = WhiteNoise(
RtlRegisterFeatureConfigurationChangeNotification
RtlUnregisterFeatureConfigurationChangeNotification
RtlNotifyFeatureUsage
NtQueryWnfStateData
NtUpdateWnfStateData
onecore\internal\sdk\inc\wil\Staging.h
WilStaging_02
Windows.UI.Composition.CompositionEffectSourceParameter
Color
Weight
Opacity
TintColor
TintOpacity
LuminosityColor
LuminosityOpacity
Backdrop
onecoreuap\windows\dwm\effects\compiler\global\materialbrushfactory.cpp
Crossfade
source1
source2
Crossfade.Weight
FRoGetActivationFactory
CoIncrementMTAUsage
DllGetActivationFactory
Windows.Foundation.Collections.IIterator`1<String>
Windows.Foundation.Collections.IIterable`1<String>
Microsoft.Internal.UI.Composition.Effects.OpacityEffect
Microsoft.Internal.UI.Composition.Effects.CrossFadeEffect
Microsoft.Internal.UI.Composition.Effects.ColorSourceEffect
Microsoft.Internal.UI.Composition.Effects.BlendEffect
$sVfrI^
$sVfrI^
k[G.l
RoOriginateLanguageException
combase.dll
kernel32.dll
WerRegisterMemoryBlock
Break, Go (continue), terminate Process, or terminate Thread (bgpt)? 
Function: 
*** Assertion failed: %ls%ls%ls
***   %s%ls%sSource: `%ls:%ld`
(No kernel debugger is present.) Respond with:
  g                    -- Go (continue)
  eb 0x%p 'p';g  -- terminate Process
  eb 0x%p 't';g  -- terminate Thread
 or regular debugging.
'i' is only supported with debug builds.
Unrecognized response.
onecoreuap\windows\dwm\common\shared\refcountbase.cpp
CMILRefCountImpl::AddReference
Tried to AddRef an object which has previously been freed (refcount went to 0).
?333333
wuceffects.pdb
.rdata$brc
.rdata$T$brc
.rdata$r$brc
.CRT$XCA
.CRT$XCU
.CRT$XCZ
.CRT$XIA
.CRT$XIC
.CRT$XIZ
.CRT$XLA
.CRT$XLZ
.CRT$XPA
.CRT$XPZ
.CRT$XTA
.CRT$XTZ
.gfids
.rdata
.rdata$sxdata
.rdata$voltmd
.rdata$zzzdbg
.rtc$IAA
.rtc$IZZ
.rtc$TAA
.rtc$TZZ
.text$di
.text$mn
.text$x
.text$yd
.tls$
.tls$ZZZ
.xdata$x
.edata
.data$brc
.data$r$brc
.data$rs$brc
.data
.idata$5
.00cfg
.idata$2
.idata$3
.idata$4
.idata$6
.rsrc$01
.rsrc$02
X[_^]
w,Sh B
w0hxB
SVWRQ
Z\9;s
~p_^]
PQQSVW
QQh4C
QQh4C
VWjbZ
VWjkZ
SVWQQ3
97s/j
PQSVW
93uHWV
|$hWQ
WPQQV
|$hWQ
H(+H$
Qj8VQ
I$RhxL
I$RhxL
A@+A<
A(+A$]
L$<_^[3
u.PVhdN
)_^[]
QQSVW
QQSVW
WD_^[]
|$pWQ
WPWWV
A(+A$
H(+H$
v<RQP
PQSVW
QQSVW
A4+A0j
A4+A0
A,+A(j
C +N$+C
C,+N0+C(;
PQQSVW
QQSWj
QSVWj
QSVWj
QQSVWj
sDj@Y
K@;KDt
K4;K8t%
'Ph U
5Ph U
+K0+S0
&Ph U
yHPh U
!Ph U
8Rh`Z
PQSVW
vkh\\
QjsVQ
PVj h
I$Rh$_
I$Rh$_
)_^[]
u$hpb
YY_^]
D$,PQ
;t$4tz
L$(;L$,t
;L$,u
;t$4u
T$@QQW
L$4^3
PQSVW
93uHWV
)_^[]
PQSVW
PQSVW
PQSVW
PQSVW
QQSVW
)_^[]
)_^[]
QQSVW
QQSVW
PQQSVW
u(h e
ugh8e
PQQSVW
PQQSVW
QSVWh@j
t-h\j
tFhT?
Y__^[
5ineI
5ntel
Y__^[
>@s5f
?@s-f
wuceffects.dll
CompileEffectDescription
CreateAcrylicBrush
CreateCrossfadeEffectFactory
CreateCustomBrush
CreateEffectDescription
CreateMicaBrush
CrossFadeToNewBrush
DeserializeEffectDescription
SerializeEffectDescription
.?AVbad_alloc@std@@
.?AUhresult_error@winrt@@
.?AVResultException@wil@@
.?AVlogic_error@std@@
.?AVout_of_range@std@@
.?AVinvalid_argument@std@@
.?AVexception@std@@
.?AVbad_array_new_length@std@@
.?AVOriginatedException@Composition@UI@Windows@@
.?AV<lambda_f734f85d8543779c8a08289b84a137f5>@@
.?AV<lambda_ba2c660fd9487eafba7ff191f91abea1>@@
.?AV<lambda_fb0bfdd47ef1e5b6398fc4284b2e8b5d>@@
.?AV<lambda_b306f4cd683d8ca256a465a653a09d75>@@
.?AV<lambda_5dc08213cb74b9a833340c9410586074>@@
.?AV<lambda_8f3337e07c8c4f79ad139134132c2f1b>@@
.?AV<lambda_8da701d7bd608867fe2ccf81a118328c>@@
.P6GXPBXPAX@Z
.?AV<lambda_af99df7639788a764efe3b91ec4ea663>@@
.?AV<lambda_ff74d4201639c4a26394d475f3c20713>@@
.?AV<lambda_cafa38e17f315aa8cbe58a52d698b71a>@@
.?AV<lambda_98dc175ebec9e0c41e0208a169137e3a>@@
.?AV<lambda_5caec47860cbb9ad654244740ea931d5>@@
.?AV<lambda_6604e86240abfa1bd81cdabb2d0569ea>@@
.?AUhresult_access_denied@winrt@@
.?AUhresult_wrong_thread@winrt@@
.?AUhresult_not_implemented@winrt@@
.?AUhresult_invalid_argument@winrt@@
.?AUhresult_out_of_bounds@winrt@@
.?AUhresult_no_interface@winrt@@
.?AUhresult_class_not_available@winrt@@
.?AUhresult_class_not_registered@winrt@@
.?AUhresult_changed_state@winrt@@
.?AUhresult_illegal_method_call@winrt@@
.?AUhresult_illegal_state_change@winrt@@
.?AUhresult_illegal_delegate_assignment@winrt@@
.?AUhresult_canceled@winrt@@
.?AVtype_info@@
?_Xlength_error@std@@YAXPBD@Z
?_Xbad_function_call@std@@YAXXZ
?_Xout_of_range@std@@YAXPBD@Z
msvcp_win.dll
api-ms-win-crt-runtime-l1-1-0.dll
__CxxFrameHandler3
__std_terminate
_o___std_exception_copy
_o___std_exception_destroy
_o___std_type_info_destroy_list
_o___stdio_common_vsnprintf_s
_o___stdio_common_vsprintf_s
_o___stdio_common_vswprintf
_o__cexit
_o__CIcos
_o__CIpow
_o__CIsin
_o__CIsqrt
_o__configure_narrow_argv
_o__create_locale
_o__crt_atexit
_o__errno
_o__execute_onexit_table
_o__initialize_narrow_environment
_o__initialize_onexit_table
_o__invalid_parameter_noinfo
_o__invalid_parameter_noinfo_noreturn
_o__itoa_s
_o__ltoa_s
_o__purecall
_o__register_onexit_function
_o__seh_filter_dll
_o__wcsicmp
_o__wcsicmp_l
_o_abort
_o_ceil
_o_iswspace
_o_terminate
__current_exception
__current_exception_context
_except_handler4_common
memset
api-ms-win-crt-private-l1-1-0.dll
api-ms-win-crt-string-l1-1-0.dll
GetModuleFileNameA
CreateSemaphoreExW
HeapFree
SetLastError
ReleaseSemaphore
GetModuleHandleExW
WaitForSingleObject
GetCurrentThreadId
ReleaseMutex
FormatMessageW
GetLastError
OutputDebugStringW
WaitForSingleObjectEx
OpenSemaphoreW
CloseHandle
HeapAlloc
GetProcAddress
CreateMutexExW
GetCurrentProcessId
GetProcessHeap
GetModuleHandleW
DebugBreak
IsDebuggerPresent
RoOriginateErrorW
InitializeCriticalSection
DeleteCriticalSection
LoadLibraryW
FreeLibrary
EnterCriticalSection
LeaveCriticalSection
WindowsDeleteString
WindowsDuplicateString
WindowsGetStringRawBuffer
RoOriginateError
WindowsSubstringWithSpecifiedLength
CoTaskMemFree
LoadResource
LockResource
SizeofResource
WindowsCreateString
RaiseException
WindowsCreateStringReference
RoGetActivationFactory
AcquireSRWLockExclusive
ReleaseSRWLockExclusive
AcquireSRWLockShared
ReleaseSRWLockShared
SetThreadpoolTimer
CreateThreadpoolTimer
InitializeCriticalSectionEx
WaitForThreadpoolTimerCallbacks
CloseThreadpoolTimer
CoTaskMemAlloc
QueryPerformanceCounter
RtlCaptureStackBackTrace
TerminateProcessOnMemoryExhaustion
RaiseFailFastException
TerminateProcess
GetCurrentProcess
TerminateThread
GetCurrentThread
UnhandledExceptionFilter
SetUnhandledExceptionFilter
IsProcessorFeaturePresent
InitializeCriticalSectionAndSpinCount
SetEvent
ResetEvent
CreateEventW
api-ms-win-core-libraryloader-l1-2-0.dll
api-ms-win-core-synch-l1-1-0.dll
api-ms-win-core-heap-l1-1-0.dll
api-ms-win-core-errorhandling-l1-1-0.dll
api-ms-win-core-processthreads-l1-1-0.dll
api-ms-win-core-localization-l1-2-0.dll
api-ms-win-core-debug-l1-1-0.dll
api-ms-win-core-handle-l1-1-0.dll
api-ms-win-core-winrt-error-l1-1-0.dll
api-ms-win-core-libraryloader-l1-2-1.dll
api-ms-win-core-winrt-string-l1-1-0.dll
api-ms-win-core-com-l1-1-0.dll
api-ms-win-core-winrt-l1-1-0.dll
api-ms-win-core-threadpool-l1-2-0.dll
api-ms-win-core-profile-l1-1-0.dll
api-ms-win-core-rtlsupport-l1-1-0.dll
api-ms-win-core-errorhandling-l1-1-3.dll
api-ms-win-core-errorhandling-l1-1-2.dll
api-ms-win-core-processthreads-l1-1-1.dll
FindResourceA
api-ms-win-core-kernel32-legacy-l1-1-0.dll
DbgPrintEx
NtQuerySystemInformation
DbgPrompt
ntdll.dll
_initterm
_initterm_e
GetSystemTimeAsFileTime
InitializeSListHead
api-ms-win-core-sysinfo-l1-1-0.dll
api-ms-win-core-interlocked-l1-1-0.dll
InterlockedPushEntrySList
MultiByteToWideChar
CoCreateFreeThreadedMarshaler
OLEAUT32.dll
api-ms-win-core-string-l1-1-0.dll
_CxxThrowException
memcmp
memcpy
memmove
COMMON.HLSL
D2DBLEND.HLSL
D2DBORDER.HLSL
D2DCOLORMATRIX.HLSL
D2DCOMPOSITE.HLSL
D2DCONTRAST.HLSL
D2DDISPLACEMENTMAP.HLSL
D2DLIGHTING.HLSL
D2DLUMINANCETOALPHA.HLSL
D2DSATURATION.HLSL
D2DSEPIA.HLSL
NOISE.HLSL
// Copyright (C) Microsoft. All rights reserved.
// HLSL implementation of D2D blend functions.
// See: http://msdn.microsoft.com/en-us/library/windows/desktop/hh706313.aspx
#if !defined(COMMON_HLSL)
#define COMMON_HLSL
// Macro for minimum-precision types (min10float, min16float)
#if defined(MINP_PREFIX)
#   define minp(type) MINP_PREFIX##type
#else
#   define minp(type) type
#endif
#define minfloat minp(float)
#define minfloat2 minp(float2)
#define minfloat3 minp(float3)
#define minfloat4 minp(float4)
#define minfloat2x2 minp(float2x2)
#define minfloat3x2 minp(float3x2)
#define minfloat3x3 minp(float3x3)
#define minfloat4x4 minp(float4x4)
// Alpha premultiplication and un-premultiplication
minfloat4 Premultiply(minfloat4 color)
    color.rgb *= color.a;
    return color;
minfloat4 UnPremultiply(minfloat4 color)
    // We follow D2D's way of handling alpha = 0
    color.rgb = (color.a == 0) ? float3(0, 0, 0) : (color.rgb / color.a);
    return color;
// Must match dwmcore-side CommonFragments_PSLib version
float2 GetInvTextureSizeFromSamplerDataExt(float4 samplerDataExt)
    return samplerDataExt.zw;
#endif
// Copyright (C) Microsoft. All rights reserved.
// HLSL implementation of D2D blend functions.
// See: http://msdn.microsoft.com/en-us/library/windows/desktop/hh706313.aspx
#include "Common.hlsl"
// Helper constants:
static const minfloat3 g_luminosityWeights = minfloat3(0.30, 0.59, 0.11);
// Helpers
inline minfloat D2DBlendGetLuminosity(minfloat3 color)
    return dot(g_luminosityWeights, color);
inline minfloat D2DBlendSafeDivision(minfloat f, minfloat b)
    if (f == 0)
    {
        return b == 0 ? 0 : 1;
    }
    else
    {
        return b / f;
    }
inline minfloat D2DBlendAlpha(minfloat f, minfloat b)
    // O_A = F_A * (1 - B_A) + B_A
    return f + b - f * b;
// Blend premultiplied f and b together with the color from the color function
inline minfloat3 D2DBlendBasicRgb(minfloat4 f, minfloat4 b, minfloat3 func)
    // O_PRGB = f(F_RGB, B_RGB) * F_A * B_A + F_RGB * (1 - B_A) + B_RGB * (1 - F_A) 
    return saturate(func * f.a * b.a
        + f.rgb * (1 - b.a)
        + b.rgb * (1 - f.a));
// Restricts the gamut of colorRgb with the given luminance to a 0-1 range.
inline minfloat3 RestrictGamut(minfloat3 colorRgb, minfloat luminance)
    const float Epsilon = 1e-10;
    // out-of-gamut processing
    minfloat3 colorNeutralRGB = luminance.xxx;
    minfloat3 negativeFactor = -colorRgb / (colorNeutralRGB - colorRgb);
    minfloat3 positiveFactor = (1.0 - colorRgb) / (colorNeutralRGB - colorRgb);
    // Extract the highest values for rgb's that are < 0 or > 1
    minfloat3 t3 = max( (1.0 - step(0, colorRgb)) * negativeFactor, 
                        step(1.0 + Epsilon, colorRgb) * positiveFactor);
    minfloat t = max(max(t3.x, t3.y), t3.z);
    return lerp(colorRgb, colorNeutralRGB, max(0, t));
// Converts an RGB color to an HSL color. The output vector has .xyz = HSL
inline minfloat3 RgbToHsl(minfloat3 colorRgb)
    minfloat3 colorHsl;
    minfloat flMax = max(colorRgb.r, max(colorRgb.g, colorRgb.b));
    minfloat flMin = min(colorRgb.r, min(colorRgb.g, colorRgb.b));
    // L
    colorHsl.z = dot(colorRgb, g_luminosityWeights);
    // S
    colorHsl.y = flMax - flMin;
    // H
    colorHsl.x = (colorHsl.y == 0.0) ?
        0.0 :
        (flMax == colorRgb.r) ?
        ((colorRgb.g - colorRgb.b) / colorHsl.y) :
        (flMax == colorRgb.g) ?
        (2.0 + (colorRgb.b - colorRgb.r) / colorHsl.y) :
        (4.0 + (colorRgb.r - colorRgb.g) / colorHsl.y);
    return colorHsl;
// This function applies the provided luminosity value to the dest, replacing dest's luminosity.
// We pass in destSat as an optimization, so we don't need to recalculate it:
inline minfloat3 D2DBlendApplySourceLumToDest(minfloat3 dest, minfloat destSat, minfloat sourceLum)
    minfloat destLum = D2DBlendGetLuminosity(dest);
    minfloat lumDifference = sourceLum - destLum;
    minfloat3 color = dest + lumDifference.xxx;
    minfloat factor1 = destSat - destLum;
    minfloat factor2 = 1 - sourceLum;
    return lerp(sourceLum + (((color - sourceLum.xxx) * sourceLum) / destLum),
        lerp(sourceLum + (((color - sourceLum.xxx) * factor2) / factor1),
        color,
        step(factor1, factor2)),
        step(0, lumDifference));
// This function generates a new RGB output, taking its hue, saturation, and luminosity from the three RGB inputs.
inline minfloat3 D2DBlendApplyHueSatLum(minfloat3 hueSource, minfloat3 satSource, minfloat3 lumSource, minfloat3 lumFallback)
    //
    // We need to calculate the min and max of the hueSource and satSource. To save instructions, pack
    // these two values into vectors, allowing for the comparisons for both to be done in parallel.
    //
    minfloat2 red = minfloat2(hueSource.r, satSource.r);
    minfloat2 green = minfloat2(hueSource.g, satSource.g);
    minfloat2 blue = minfloat2(hueSource.b, satSource.b);
    minfloat2 minSD = min(red, min(green, blue));
    minfloat2 maxSD = max(red, max(green, blue));
    minfloat destSat = maxSD.y - minSD.y;
    minfloat sourceMax = maxSD.x;
    minfloat sourceMin = minSD.x;
    // We need to figure out which componenet contributed to the max value. We do this by
    // calculating floor(1 - (max - source)), which will result in a unit vector with a value
    // of one for the source's max component.
    const minfloat3 vectorOneMin = minfloat3(1, 1, 1);
    minfloat3 sourceMaxVector = floor(vectorOneMin - (sourceMax.xxx - hueSource));
    // Similar calculation for min:
    minfloat3 sourceMinVector = floor(vectorOneMin - (hueSource - sourceMin.xxx));
    // If we had a tie for max or min, we want to disambiguate. It doesn't matter which value we
    // pick as the tie breaker, so we use saturate(sourceMaxVector.rgb - sourceMaxVector.gbr),
    // which guarauntees only one component has a 1:
    sourceMaxVector = saturate(sourceMaxVector - sourceMaxVector.gbr);
    sourceMinVector = saturate(sourceMinVector - sourceMinVector.gbr);
    // We can calculate the mid-value vector and value once the min and max vector are known:
    minfloat3 sourceMidVector = vectorOneMin - sourceMaxVector - sourceMinVector;
    minfloat sourceMid = dot(sourceMidVector, hueSource);
    // color is our output value:
    minfloat3 color = minfloat3(0, 0, 0);
    // This is just trying to do (sourceMax - sourceMin) > 0 && destSat > 0, but that takes too many
    // instructions, so we do the following instead:
    if ((sourceMax - sourceMin) * destSat > 0)
    {
        color += sourceMidVector * ((sourceMid - sourceMin) / (sourceMax - sourceMin));
        color += sourceMaxVector;
        color *= destSat;
        color = D2DBlendApplySourceLumToDest(color, destSat, D2DBlendGetLuminosity(lumSource));
    }
    else
    {
        color = D2DBlendGetLuminosity(lumFallback).xxx;
    }
    return color;
//-----------------------------------------------
// Blend functions, in order of reference webpage
inline minfloat3 D2DBlendDarkenRgb(minfloat4 f, minfloat4 b)
    // Does not need alpha unpremultiplication
    return min((1 - f.a) * b.rgb + f.rgb, (1 - b.a) * f.rgb + b.rgb);
inline minfloat3 D2DBlendMultiplyRgb(minfloat4 f, minfloat4 b)
    return D2DBlendBasicRgb(f, b, UnPremultiply(f).rgb * UnPremultiply(b).rgb);
inline minfloat3 D2DBlendColorBurnRgb(minfloat4 f, minfloat4 b)
    // This accomplishes the following without branching (14 instructions vs. 20):
    //
    // if (source == 1)         return 1;
    // if (source + dest <= 1)  return 0;
    // else                     return 1 - ((1 - dest) / source)
    minfloat3 uf = UnPremultiply(f).rgb;
    minfloat3 ub = UnPremultiply(b).rgb;
    minfloat3 color = uf + ub - 1;
    // note: it is ok if some colorU channels are zero because those failed quotients will not be chosen below
    minfloat3 color2 = color / uf;
    [unroll]
    for (int i = 0; i < 3; i++)
    {
        color[i] = (b[i] >= 1.0) ? 1.0 : (color[i] > 0.0) ? color2[i] : 0.0;
    }
    return D2DBlendBasicRgb(f, b, saturate(color));
inline minfloat3 D2DBlendLinearBurnRgb(minfloat4 f, minfloat4 b)
    return D2DBlendBasicRgb(f, b, saturate(UnPremultiply(f).rgb + UnPremultiply(b).rgb - 1));
inline minfloat3 D2DBlendDarkerColorRgb(minfloat4 f, minfloat4 b)
    minfloat3 uf = UnPremultiply(f).rgb;
    minfloat3 ub = UnPremultiply(b).rgb;
    minfloat3 color = D2DBlendGetLuminosity(uf) < D2DBlendGetLuminosity(ub) ? uf : ub;
    return D2DBlendBasicRgb(f, b, color);
inline minfloat3 D2DBlendLightenRgb(minfloat4 f, minfloat4 b)
    // Does not need alpha unpremultiplication
    minfloat3 color = max((1 - f.a) * b.rgb + f.rgb, (1 - b.a) * f.rgb + b.rgb);
    return D2DBlendBasicRgb(f, b, color);
inline minfloat3 D2DBlendScreenRgb(minfloat4 f, minfloat4 b)
    // Does not need alpha unpremultiplication
    return f.rgb * (1 - b.rgb) + b.rgb;
inline minfloat D2DBlendColorDodgeComponent(minfloat f, minfloat b)
    return (f < 1.0) ? (b / (1.0 - f)) : ceil(b);
inline minfloat3 D2DBlendColorDodgeRgb(minfloat4 f, minfloat4 b)
    minfloat3 uf = UnPremultiply(f).rgb;
    minfloat3 ub = UnPremultiply(b).rgb;
    minfloat3 color = minfloat3(
        D2DBlendColorDodgeComponent(uf.r, ub.r),
        D2DBlendColorDodgeComponent(uf.g, ub.g),
        D2DBlendColorDodgeComponent(uf.b, ub.b));
    return D2DBlendBasicRgb(f, b, saturate(color));
inline minfloat3 D2DBlendLinearDodgeRgb(minfloat4 f, minfloat4 b)
    return D2DBlendBasicRgb(f, b, saturate(UnPremultiply(f).rgb + UnPremultiply(b).rgb));
inline minfloat3 D2DBlendLighterColorRgb(minfloat4 f, minfloat4 b)
    minfloat3 uf = UnPremultiply(f).rgb;
    minfloat3 ub = UnPremultiply(b).rgb;
    minfloat3 color = D2DBlendGetLuminosity(uf) > D2DBlendGetLuminosity(ub) ? uf : ub;
    return D2DBlendBasicRgb(f, b, color);
inline minfloat3 D2DBlendOverlayRgb(minfloat4 f, minfloat4 b)
    // This accomplishes the following without branching:
    //
    // if (dest < 0.5)  return 2 * source * dest;
    // else             return 1 - 2 * (1 - source) * (1 - dest);
    minfloat3 uf = UnPremultiply(f).rgb;
    minfloat3 ub = UnPremultiply(b).rgb;
    minfloat3 color = lerp(2 * uf * ub, 2 * lerp(uf, 1, ub) - 1, round(ub));
    return D2DBlendBasicRgb(f, b, color);
inline minfloat3 D2DBlendSoftLightRgb(minfloat4 f, minfloat4 b)
    // This accomplishes the following without branching:
    //
    // if (source < 0.5)  return dest * (1 + (1 - dest) * (2 * source - 1))
    // if (dest <= 9/64)   return ((9 * g_vectorOneMin16 - 18 * source) * dest + 5.76 * source - 1.88 * g_vectorOneMin16) * dest;
    // else               return dest + (sqrt(dest) - dest) * (2 * source - g_vectorOneMin16);
    //
    // lerp is used to simulate if/else conditions.
    minfloat3 uf = UnPremultiply(f).rgb;
    minfloat3 ub = UnPremultiply(b).rgb;
    minfloat3 color = lerp(ub * (1 + (1 - ub) * (2 * uf - 1)),
        lerp(((9 - 18 * uf) * ub + 5.76 * uf - 1.88) * ub,
        ub + (sqrt(ub) - ub) * (2 * uf - 1),
        round(ub + (0.359375 - 0.001))), round(uf));
    return D2DBlendBasicRgb(f, b, color);
inline minfloat3 D2DBlendHardLightRgb(minfloat4 f, minfloat4 b)
    minfloat3 uf = UnPremultiply(f).rgb;
    minfloat3 ub = UnPremultiply(b).rgb;
    minfloat3 color = lerp(2 * ub * uf, 2 * lerp(ub, 1, uf) - 1, round(uf));
    return D2DBlendBasicRgb(f, b, color);
inline minfloat D2DBlendVividLightComponent(minfloat f, minfloat b)
    minfloat c = f + 0.5 * (b - 1);
    return (f < 0.5)
        ? ((f > 0) ? (c / f) : 0)
        : ((f < 1) ? (0.5 * b / (1 - f)) : 1);
inline minfloat3 D2DBlendVividLightRgb(minfloat4 f, minfloat4 b)
    minfloat3 uf = UnPremultiply(f).rgb;
    minfloat3 ub = UnPremultiply(b).rgb;
    minfloat3 color = minfloat3(
        D2DBlendVividLightComponent(uf.r, ub.r),
        D2DBlendVividLightComponent(uf.g, ub.g),
        D2DBlendVividLightComponent(uf.b, ub.b));
    return D2DBlendBasicRgb(f, b, saturate(color));
inline minfloat3 D2DBlendLinearLightRgb(minfloat4 f, minfloat4 b)
    minfloat3 color = saturate(UnPremultiply(b).rgb + 2 * UnPremultiply(f).rgb - 1);
    return D2DBlendBasicRgb(f, b, color);
inline minfloat3 D2DBlendPinLightRgb(minfloat4 f, minfloat4 b)
    minfloat3 uf = UnPremultiply(f).rgb;
    minfloat3 ub = UnPremultiply(b).rgb;
    minfloat3 color = lerp(min(ub, 2 * uf), max(ub, 2 * uf - 1), round(uf));
    return D2DBlendBasicRgb(f, b, color);
inline minfloat D2DBlendHardMixComponent(minfloat f, minfloat b)
    float sum = f + b;
    return sum < 0.999 ? 0
        : sum > 1.001 ? 1
        : b >= f ? 1
        : 0;
inline minfloat3 D2DBlendHardMixRgb(minfloat4 f, minfloat4 b)
    minfloat3 uf = UnPremultiply(f).rgb;
    minfloat3 ub = UnPremultiply(b).rgb;
    minfloat3 color = minfloat3(
        D2DBlendHardMixComponent(uf.r, ub.r),
        D2DBlendHardMixComponent(uf.g, ub.g),
        D2DBlendHardMixComponent(uf.b, ub.b));
    return D2DBlendBasicRgb(f, b, color);
inline minfloat3 D2DBlendDifferenceRgb(minfloat4 f, minfloat4 b)
    return D2DBlendBasicRgb(f, b, abs(UnPremultiply(f).rgb - UnPremultiply(b).rgb));
inline minfloat3 D2DBlendExclusionRgb(minfloat4 f, minfloat4 b)
    // Does not need alpha unpremultiplication
    return f.rgb + b.rgb - 2 * f.rgb * b.rgb;
inline minfloat3 D2DBlendHueRgb(minfloat4 f, minfloat4 b)
    minfloat3 ub = UnPremultiply(b).rgb;
    minfloat3 color = D2DBlendApplyHueSatLum(f.rgb, ub.rgb, ub.rgb, ub.rgb);
    return D2DBlendBasicRgb(f, b, color);
inline minfloat3 D2DBlendSaturationRgb(minfloat4 f, minfloat4 b)
    minfloat3 uf = UnPremultiply(f).rgb;
    minfloat3 ub = UnPremultiply(b).rgb;
    minfloat3 color = D2DBlendApplyHueSatLum(ub.rgb, uf.rgb, ub.rgb, ub.rgb);
    return D2DBlendBasicRgb(f, b, color);
inline minfloat3 D2DBlendLuminosityRgb(minfloat4 f, minfloat4 b)
    minfloat3 color;
    minfloat3 source = UnPremultiply(f).rgb;
    minfloat3 dest = UnPremultiply(b).rgb;
    minfloat destLum = D2DBlendGetLuminosity(dest);
    minfloat sourceLum = D2DBlendGetLuminosity(source);
    minfloat lumDifference = sourceLum - destLum;
    color = dest + lumDifference.xxx;
    color = RestrictGamut(color, sourceLum);
    return D2DBlendBasicRgb(f, b, color);
inline minfloat3 D2DBlendColorRgb(minfloat4 f, minfloat4 b)
    return D2DBlendLuminosityRgb(b, f);
// TODO: Dissolve
inline minfloat3 D2DBlendSubtractRgb(minfloat4 f, minfloat4 b)
    return D2DBlendBasicRgb(f, b, saturate(UnPremultiply(b).rgb - UnPremultiply(f).rgb));
inline minfloat3 D2DBlendDivisionRgb(minfloat4 f, minfloat4 b)
    minfloat3 uf = UnPremultiply(f).rgb;
    minfloat3 ub = UnPremultiply(b).rgb;
    minfloat3 color = minfloat3(
        D2DBlendSafeDivision(uf.r, ub.r),
        D2DBlendSafeDivision(uf.g, ub.g),
        D2DBlendSafeDivision(uf.b, ub.b));
    return D2DBlendBasicRgb(f, b, color);
// Copyright (C) Microsoft. All rights reserved.
float4 WrapUV4(float4 uv, float4 samplerData)
    float4 uvBounds = GetUVBoundsFromSamplerData(samplerData);
    float2 size = uvBounds.zw - uvBounds.xy;
    float2 min = uvBounds.xy;
    // If the signedMod is negative, we must fix it up to wrap it into
    // positive space.
    float4 signedMod = fmod(uv - min.xyxy, size.xyxy);
    float4 wrapped = lerp(signedMod + size.xyxy, signedMod, step(0, signedMod));
    return wrapped + min.xyxy; 
float2 WrapUV2(float2 uv, float4 samplerData)
    return WrapUV4(uv.xyxy, samplerData).xy;
export float2 BorderEffectClamp(float2 uv, float4 samplerData)
    float4 uvBounds = GetUVBoundsFromSamplerData(samplerData);
    return clamp(uv, uvBounds.xy, uvBounds.zw);
export float2 BorderEffectWrap(float2 uv, float4 samplerData)
    return WrapUV2(uv, samplerData);
export float2 BorderEffectWrapBilinear(float2 uv, float4 samplerData)
    // delay the wrapping until the sampling stage
    return uv;
export float2 BorderEffectMirror(float2 uv, float4 samplerData)
    float4 uvBounds = GetUVBoundsFromSamplerData(samplerData);
    float2 size = uvBounds.zw - uvBounds.xy;
    // We can just take the abs of the signedMod, as this mirrors around 0.
    float2 signedMod = fmod(uv - uvBounds.xy, size * 2);
    float2 wrapped = abs(signedMod);
    return uvBounds.zw - abs(wrapped - size);
// If clamping is not the same in both directions
export float2 BorderEffectCombine(float2 uvHorizontal, float2 uvVertical)
    return float2(uvHorizontal.x, uvVertical.y);
// Internal wrappers (no export)
float2 ApplyBorderCC(float2 uv, float4 samplerData)
    return BorderEffectClamp(uv, samplerData);
float2 ApplyBorderCM(float2 uv, float4 samplerData)
    return BorderEffectCombine(BorderEffectClamp(uv, samplerData), BorderEffectMirror(uv, samplerData));
float2 ApplyBorderMC(float2 uv, float4 samplerData)
    return BorderEffectCombine(BorderEffectMirror(uv, samplerData), BorderEffectClamp(uv, samplerData));
float2 ApplyBorderMM(float2 uv, float4 samplerData)
    return BorderEffectMirror(uv, samplerData);
// returns 2 u coordinates, in x and z
//     and 2 v coordinates, in z and w.
// These coordinates can be used to sample the texture. The texture samples
// should then be weighted by the output weights.
float4 CalcWrappedUV(
    float2 uv,
    float4 samplerData,
    float4 samplerDataExt,
    out float2 weights
    )
    float2 textureSize = GetTextureSizeFromSamplerDataExt(samplerDataExt);
    float2 invTextureSize = GetInvTextureSizeFromSamplerDataExt(samplerDataExt);
    float2 uvTexture = uv * textureSize;
    float2 uvClosePixel = floor(uvTexture) + 0.5;
    float2 signedWeights = uvTexture - uvClosePixel;
    float2 uvFarPixel = uvClosePixel + sign(signedWeights);
    // The weights will be always be between 0 and 0.5. If they are 0, we should
    // use the close pixel, so we put the close pixel in xy.
    weights = abs(signedWeights);
    float4 uvs = float4(uvClosePixel, uvFarPixel) * invTextureSize.xyxy;
    return WrapUV4(uvs, samplerData);
float4 SampleWrappedTexture(
    Texture2D tex,
    SamplerState textureSampler,
    float2 uvs,
    float4 samplerData,
    float4 samplerDataExt
    )
    float2 weights;
    float4 uvsWrapped = CalcWrappedUV(uvs, samplerData, samplerDataExt, /*out*/ weights);
    float4 color0 = tex.Sample(textureSampler, uvsWrapped.xy);
    float4 color1 = tex.Sample(textureSampler, uvsWrapped.zy);
    float4 color2 = tex.Sample(textureSampler, uvsWrapped.xw);
    float4 color3 = tex.Sample(textureSampler, uvsWrapped.zw);
    return lerp(
        lerp(color0, color1, weights.x),
        lerp(color2, color3, weights.x),
        weights.y
        );
float4 SampleWrappedTextureUOnly(
    Texture2D tex,
    SamplerState textureSampler,
    float2 uvs,
    float4 samplerData,
    float4 samplerDataExt
    )
    float2 weights;
    float4 uvsWrapped = CalcWrappedUV(uvs, samplerData, samplerDataExt, /*out*/ weights);
    float4 color0 = tex.Sample(textureSampler, float2(uvsWrapped.x, uvs.y));
    float4 color1 = tex.Sample(textureSampler, float2(uvsWrapped.z, uvs.y));
    return lerp(color0, color1, weights.x);
float4 SampleWrappedTextureVOnly(
    Texture2D tex,
    SamplerState textureSampler,
    float2 uvs,
    float4 samplerData,
    float4 samplerDataExt
    )
    float2 weights;
    float4 uvsWrapped = CalcWrappedUV(uvs, samplerData, samplerDataExt, /*out*/ weights);
    float4 color0 = tex.Sample(textureSampler, float2(uvs.x, uvsWrapped.y));
    float4 color1 = tex.Sample(textureSampler, float2(uvs.x, uvsWrapped.w));
    return lerp(color0, color1, weights.y);
// Copyright (C) Microsoft. All rights reserved.
#include "Common.hlsl"
minfloat4 D2DColorMatrixStraight(minfloat4 color, minfloat4x4 colorMatrix4x4, minfloat4 colorOffset)
    return mul(color, colorMatrix4x4) + colorOffset;
minfloat4 D2DColorMatrixPremultiplied(minfloat4 color, minfloat4x4 colorMatrix4x4, minfloat4 colorOffset)
    return Premultiply(D2DColorMatrixStraight(UnPremultiply(color), colorMatrix4x4, colorOffset));
// Copyright (C) Microsoft. All rights reserved.
// HLSL implementation of D2D composite effect modes.
// See: http://msdn.microsoft.com/en-us/library/windows/desktop/hh706320.aspx
#include "Common.hlsl"
inline minfloat4 D2DCompositeSourceOver(minfloat4 src, minfloat4 dest)
    return src + (1 - src.a) * dest;
inline minfloat4 D2DCompositeDestinationOver(minfloat4 src, minfloat4 dest)
    return (1 - dest.a) * src + dest;
inline minfloat4 D2DCompositeSourceIn(minfloat4 src, minfloat4 dest)
    return dest.a * src;
inline minfloat4 D2DCompositeDestinationIn(minfloat4 src, minfloat4 dest)
    return src.a * dest;
inline minfloat4 D2DCompositeSourceOut(minfloat4 src, minfloat4 dest)
    return (1 - dest.a) * src;
inline minfloat4 D2DCompositeDestinationOut(minfloat4 src, minfloat4 dest)
    return (1 - src.a) * dest;
inline minfloat4 D2DCompositeSourceAtop(minfloat4 src, minfloat4 dest)
    return dest.a * src + (1 - src.a) * dest;
inline minfloat4 D2DCompositeDestinationAtop(minfloat4 src, minfloat4 dest)
    return (1 - dest.a) * src + src.a * dest;
inline minfloat4 D2DCompositeXor(minfloat4 src, minfloat4 dest)
    return (1 - dest.a) * src + (1 - src.a) * dest;
inline minfloat4 D2DCompositePlus(minfloat4 src, minfloat4 dest)
    return src + dest;
inline minfloat4 D2DCompositeSourceCopy(minfloat4 src, minfloat4 dest)
    return src;
// D2DCompositeBoundedSourceCopy not supported because we
// don't have a notion of input bounds.
inline minfloat4 D2DCompositeMaskInvert(minfloat4 src, minfloat4 dest)
    return (1 - dest.a) * src + (1 - src.a) * dest;
// Copyright (C) Microsoft. All rights reserved.
#include "Common.hlsl"
minfloat4 D2DContrast(minfloat4 color, minfloat contrast)
    color = UnPremultiply(color);
    // (Math from D2D)
    // This builds two contiguous polynomials forming an 'S' shape
    // in the box from (0, 0) to (1, 1), and passing by (0.5, 0.5)
    // TODO: Do this up-front on the CPU (MSFT:3579391)
    float s = 1 - (3.0f / 4.0f) * contrast;
    float c2 = s - 1;
    float b2 = 4 - 3 * s;
    float a2 = 2 * c2;
    float b1 = s;
    float a1 = -a2;
    minfloat3 lowResult = color.rgb * (color.rgb * a1 + b1);
    minfloat3 highResult = color.rgb * (color.rgb * a2 + b2) + c2;
    // Use a single componentwise comparison to select per-channel results.
    color.rgb = (color.rgb < 0.5f) ? lowResult : highResult;
    return Premultiply(color);
// Copyright (C) Microsoft. All rights reserved.
#include "Common.hlsl"
float2 DisplacementMap(float2 uvToDisplace, minfloat4 displacement, float4 samplerDataExt, minfloat scale, uint selectX, uint selectY)
    float2 dispSelected = saturate(float2(displacement[selectX], displacement[selectY]));
    return uvToDisplace + (dispSelected - 0.5) * scale * GetInvTextureSizeFromSamplerDataExt(samplerDataExt);
// Copyright (C) Microsoft. All rights reserved.
#if !defined(D2DLIGHTING_HLSL)
#define D2DLIGHTING_HLSL
#include "Common.hlsl"
// The default normal is <0,0,1>.
static const float3 c_defaultSurfaceNormal = float3(0.0f, 0.0f, 1.0f);
// This is the default normal encoded in premultiplied RGBA8888 for use in SceneLighting.
static const minfloat4 c_defaultNormalHeight = minfloat4(0.5f, 0.5f, 1.0f, 1.0f);
inline float3 GetSurfaceNormal(float4 normalHeight)
    normalHeight = UnPremultiply(normalHeight);
    float3 normal = normalize(normalHeight.xyz * 2 - 1);
    // Flip the Y axis, because the standard normal map tools assuming the Y
    // in texture coordinate is pointing up, but our Y are pointing down.
    normal.y = -normal.y;
    return normal;
// Not being used until we add functionality for image lighting with normals.
inline float GetSurfaceHeight(float4 normalHeight, float heightMapScale)
    return normalHeight.w * heightMapScale;
inline void PreparePointVectors(float3 pixelXY, float3 lightPosition,
    out float3 pixelPosition, out float3 lightVector)
    pixelPosition = float3(pixelXY.xy, 0.0f);
    lightVector = normalize(lightPosition - pixelPosition);
inline void PrepareSpotVectors(float3 pixelXY,
    float3 lightPosition, float3 lightTargetVector,
    float focus, float2 cosConeAngle,
    float3 lightColor, out float3 pixelPosition,
    out float3 lightVector, out float3 spotLightColor)
    pixelPosition = float3(pixelXY.xy, 0.0f);
    lightVector = normalize(lightPosition - pixelPosition);
    spotLightColor = lightColor;
    float cosDirection = saturate(dot(-lightVector, lightTargetVector));
    // Compute attenuated light color from the position and exponent
    spotLightColor *= pow(cosDirection, focus);
    // Then cut off the light based on the spotlight cone:
    //  - if the lightVector is in the inner cone, we'll get full power (1)
    //  - if the lightVector is in the outer cone, power will fade to 0
    //  - outside of the outer cone, power will be 0
    spotLightColor *= smoothstep(cosConeAngle.y, cosConeAngle.x, cosDirection);
inline float CalculateLitPixelDiffuse(minfloat3 surfaceNormal,
    minfloat3 lightVector)
    return max(dot(surfaceNormal, lightVector), 0);
inline float3 CalculateBlinnPhongLitPixelSpecularUnpremultiplied(minfloat3 surfaceNormal,
    minfloat3 lightVector, minfloat exponent, minfloat3 eyeVector)
    float3 output;
    if (dot(surfaceNormal, lightVector) > 0)
    {
        float3 halfVector = lightVector + eyeVector;
        halfVector = normalize(halfVector);
        float nDotH = max(dot(surfaceNormal, halfVector), 0);
        output = pow(nDotH, exponent);
    }
    else
    {
        output = 0;
    }
    return output;
inline float4 CalculateLitPixelSpecular(minfloat3 surfaceNormal,
    minfloat3 lightVector, minfloat exponent, minfloat amount,
    minfloat3 lightColor, minfloat3 eyeVector)
    float4 output;
    output.rgb = CalculateBlinnPhongLitPixelSpecularUnpremultiplied(surfaceNormal,
        lightVector, exponent, eyeVector) * amount * lightColor;
    // This computes a specular component, meant to be blended atop a diffuse layer,
    // so the alpha channel is not opaque
    output.a = max(output.r, max(output.g, output.b));
    // Premultiply the RGB channels
    output.rgb *= output.a;
    return output;
inline minfloat4 D2DDistantDiffuse(float3 surfaceNormal, minfloat3 lightVector,
            minfloat diffuseAmount, minfloat3 lightColor)
    return float4(CalculateLitPixelDiffuse(surfaceNormal, lightVector)
        * diffuseAmount * lightColor, 1);
inline minfloat4 D2DDistantSpecular(float3 surfaceNormal, minfloat3 lightVector,
            minfloat specularShine, minfloat specularAmount, minfloat3 lightColor)
    // use 0,0,1 for the eye vector since this function is used for Image Lighting
    return CalculateLitPixelSpecular(surfaceNormal, lightVector,
        specularShine, specularAmount, lightColor, minfloat3(0,0,1));
inline minfloat4 D2DPointDiffuse(float3 surfaceNormal, minfloat3 pixelXY,
            minfloat3 lightPosition, minfloat diffuseAmount,
            minfloat3 lightColor)
    float3 pixelPosition;
    float3 lightVector;
    PreparePointVectors(pixelXY, lightPosition,
        pixelPosition, lightVector);
    return float4(CalculateLitPixelDiffuse(surfaceNormal, lightVector)
        * diffuseAmount * lightColor, 1);
inline minfloat4 D2DPointSpecular(float3 surfaceNormal, minfloat3 pixelXY,
            minfloat3 lightPosition, minfloat specularShine, minfloat specularAmount,
            minfloat3 lightColor)
    float3 pixelPosition;
    float3 lightVector;
    PreparePointVectors(pixelXY, lightPosition,
        pixelPosition, lightVector);
    // use 0,0,1 for the eye vector since this function is used for Image Lighting
    return CalculateLitPixelSpecular(surfaceNormal, lightVector,
        specularShine, specularAmount, lightColor, minfloat3(0,0,1));
inline minfloat4 D2DSpotDiffuse(float3 surfaceNormal, minfloat3 pixelXY,
    minfloat3 lightPosition, minfloat3 lightTargetVector,
    minfloat focus, minfloat2 cosConeAngle,
    minfloat diffuseAmount, minfloat3 lightColor)
    float3 pixelPosition;
    float3 lightVector;
    float3 spotLightColor;
    PrepareSpotVectors(pixelXY, lightPosition, lightTargetVector,
        focus, cosConeAngle, lightColor,
        pixelPosition, lightVector, spotLightColor);
    return float4(CalculateLitPixelDiffuse(surfaceNormal, lightVector)
        * diffuseAmount * spotLightColor, 1);
inline minfloat4 D2DSpotSpecular(float3 surfaceNormal, minfloat3 pixelXY,
    minfloat3 lightPosition, minfloat3 lightTargetVector,
    minfloat focus, minfloat2 cosConeAngle,
    minfloat specularShine, minfloat specularAmount,
    minfloat3 lightColor)
    float3 pixelPosition;
    float3 lightVector;
    float3 spotLightColor;
    PrepareSpotVectors(pixelXY, lightPosition, lightTargetVector,
        focus, cosConeAngle, lightColor,
        pixelPosition, lightVector, spotLightColor);
    // use 0,0,1 for the eye vector since this function is used for Image Lighting
    return CalculateLitPixelSpecular(surfaceNormal, lightVector,
        specularShine, specularAmount, spotLightColor, minfloat3(0,0,1));
inline float EncodeReflectanceModelAndTransparentNormal(int reflectanceModel, minfloat4 normalHeight)
    // Bit 0: a bool to store if this pixel is a fully transparent
    // Bit 1: Reflectance model. Blinn Phong (the default value) = 0, Physically Based Blinn Phong = 1
    return reflectanceModel * 2 + (any(normalHeight) ? 1 : 0);
float4 SceneLightingParameters(minfloat4 normalHeight,
    minfloat ambientAmount, minfloat diffuseAmount, minfloat specularShine, minfloat specularAmount,
    int reflectanceModel,
    out float4 outputNormalTangentSpace)
    outputNormalTangentSpace = float4(GetSurfaceNormal(normalHeight),
        EncodeReflectanceModelAndTransparentNormal(reflectanceModel, normalHeight));
    return float4(ambientAmount, diffuseAmount, specularShine, specularAmount);
#endif
// Copyright (C) Microsoft. All rights reserved.
#include "Common.hlsl"
minfloat4 D2DLuminanceToAlpha(minfloat4 color)
    color = UnPremultiply(color);
    // RGB to luminance factors from D2D
    float luminance = dot(color.rgb, minfloat3(0.2125f, 0.7154f, 0.0721f));
    return minfloat4(0, 0, 0, luminance);
// Copyright (C) Microsoft. All rights reserved.
// HLSL implementation of the D2D saturation effect.
#include "Common.hlsl"
static const minfloat3 grayFactor = minfloat3(0.2126, 0.7152, 0.0722);
inline minfloat4 D2DSaturation(minfloat4 color, minfloat amount)
    // Math from https://www.w3.org/TR/filter-effects/#saturateEquivalent
    // and https://www.w3.org/TR/SVG/filters.html#feColorMatrixValuesAttribute
    // In D2D, if amount is
    // 0 -> Fully desaturated
    // 1 -> Original color
    // 2 -> Maximum possible value, not necessarily fully saturated
    minfloat gray = dot(color.rgb, grayFactor);
    return minfloat4(lerp(gray.rrr, color.rgb, amount), color.a);
inline minfloat4 D2DGrayscale(minfloat4 color)
    // Math from https://www.w3.org/TR/filter-effects/#grayscaleEquivalent
    minfloat gray = dot(color.rgb, grayFactor);
    return minfloat4(gray, gray, gray, color.a);
// Copyright (C) Microsoft. All rights reserved.
#include "Common.hlsl"
// Straight-alpha version
inline minfloat4 D2DSepiaStraight(minfloat4 color, minfloat intensity)
    // Math from https://www.w3.org/TR/filter-effects/#sepiaEquivalent
    minfloat4 result;
    result.r = minfloat(
        (1 - 0.607 * intensity) * color.r
        + (0.769 * intensity) * color.g
        + (0.189 * intensity) * color.b);
    result.g = minfloat(
        (0.349 * intensity) * color.r
        + (1 - 0.314 * intensity) * color.g
        + (0.168 * intensity) * color.b);
    result.b = minfloat(
        (0.272 * intensity) * color.r
        + (0.534 * intensity) * color.g
        + (1 - 0.869 * intensity) * color.b);
    result.a = color.a;
    return result;
// Premultiplied-alpha version
inline minfloat4 D2DSepiaPremultiplied(minfloat4 color, minfloat intensity)
    return Premultiply(D2DSepiaStraight(UnPremultiply(color), intensity));
// Copyright (C) Microsoft. All rights reserved.
float Hash(float2 p)
    // Magic numbers for hashing the coordinates
    // This line of code is from https://www.shadertoy.com/view/4dS3Wd. It uses a very high frequency sin
    // to produce a periodic change between pixels. And then take the fractal part as a random number.
    // The theroy is from a paper On generating random numbers, with help of y= [(a+x)sin(bx)] mod 1",
    // W.J.J. Rey, 22nd European Meeting of Statisticians and the 7th Vilnius Conference on
    // Probability Theory and Mathematical Statistics, August 1998.
    return frac(1e4f * sin(17.0f * p.x + p.y * 0.1f) * (0.1f + abs(sin(p.y * 13.0f + p.x))));
float4 WhiteNoise(minfloat2 inputCoord, minfloat2 freq, minfloat2 offset)
    // Use this magic number to adjust the frequency of the white noise. When moving slowly, the artifact
    // is reduced much.
    const float COORD_SCALING = 0.81f;
    float2 coord = inputCoord * COORD_SCALING * freq + offset;
    float2 pixel00Coord = floor(coord - 0.5f) + 0.5f;
    float2 pixel11Coord = pixel00Coord + 1;
    float2 pixel10Coord = float2(pixel11Coord.x, pixel00Coord.y);
    float2 pixel01Coord = float2(pixel00Coord.x, pixel11Coord.y);
    float2 factor = coord - pixel00Coord;
    float sample00 = Hash(pixel00Coord);
    float sample10 = Hash(pixel10Coord);
    float sample01 = Hash(pixel01Coord);
    float sample11 = Hash(pixel11Coord);
    float result = lerp(lerp(sample00, sample10, factor.x), lerp(sample01, sample11, factor.x), factor.y);
    return float4(result.xxx, 1);
VS_VERSION_INFO
StringFileInfo
040904B0
CompanyName
Microsoft Corporation
FileDescription
Microsoft Composition Effects
FileVersion
10.0.22621.436 (WinBuild.160101.0800)
InternalName
wuceffects
LegalCopyright
 Microsoft Corporation. All rights reserved.
OriginalFilename
wuceffects
ProductName
Microsoft
 Windows
 Operating System
ProductVersion
10.0.22621.436
VarFileInfo
Translation
<0@0H0P0
1 1$1(1,1014181<1@1D1H1L1P1T1X1\1`1d1h1l1p1t1x1|1
202D2`2d2h2l2p2t2x2|2
3 3$3(3,3034383<3@3D3H3L3P3T3X3\3`3d3h3l3p3t3x3|3
3(4,4044484<4@4D4H4L4P4T4X4\4`4d4h4l4p4t4x4|4
5 5$5(5,5054585<5@5D5H5L5P5T5X5\5`5d5h5p5
6064686<6@6D6H6L6P6T6X6\6`6d6h6l6p6t6x6|6
707H7x7|7
8 8$8(8,8084888<8@8D8H8L8P8T8X8\8`8d8h8l8p8t8x8|8
9 9$9(9,9094989<9@9D9H9L9P9T9X9\9`9d9h9l9p9t9x9|9
: :$:(:,:0:4:8:<:@:D:H:L:P:T:X:\:`:d:h:l:p:t:x:|:
; ;$;(;,;0;4;8;<;@;D;H;L;P;T;X;\;`;d;h;l;p;t;x;|;
< <$<(<,<0<4<8<<<@<D<H<L<P<T<X<\<`<d<h<l<p<t<x<|<
=$=@=D=H=L=P=T=X=\=`=d=h=l=p=t=x=|=
>@>D>H>L>P>T>X>\>`>d>h>l>p>t>x>|>
?(?X?\?`?d?h?l?p?t?x?|?
0 0$0(0,000D0H0\0`0t0x0
1,101`1d1h1l1p1t1x1|1
2 2$2(2,20282P2h2|2
2(3,3034383<3@3D3H3L3P3T3X3\3`3d3h3l3p3t3x3|3
4$4(4<4@4T4X4p4
5 5(5<5@5T5p5t5x5|5
6 6$6(6,6064686<6@6D6H6L6P6T6X6\6`6d6h6l6p6t6x6|6
7 7$7(7,7074787<7@7D7H7L7P7T7X7\7`7d7h7l7p7t7x7|7
8 8$8(8,8084888<8@8D8H8L8P8T8X8\8`8d8h8l8p8t8x8|8
9 9$9(9,9094989<9@9D9H9L9P9T9X9\9`9d9h9l9p9t9x9|9
: :$:(:,:0:4:8:<:@:D:H:L:P:T:X:\:`:d:h:l:p:t:x:|:
; ;$;(;,;0;4;8;<;@;D;H;L;P;T;X;\;`;d;h;l;p;t;x;|;
< <$<(<,<0<4<8<<<@<D<H<L<P<T<X<\<`<d<h<l<p<t<x<|<
= =$=(=,=0=4=8=<=@=D=H=L=P=T=X=\=`=d=h=l=p=t=x=|=
> >$>(>,>0>`>x>
? ?$?(?,?0?8?<?p?
000H0`0x0
0 1P1h1
2(2@2X2p2
303<3H3T3`3d3h3l3
8"8&8,80868:8@8D8J8N8T8X8^8b8h8l8
9&909:9D9N9X9b9l9v9
:2:6:<:@:F:J:o:
<2=8=U=
=6>H>
?&?N?
040L0d0
1*131
122;2K2T2d2m2
434%636I6
:+;A;a;t;|;
=!=9=|=
>9>a>k>
0%0<0O0^0q0
101:1P1{1
2/3H3T3
4*4J4v4
4>5t5
6P6h6r6
7(7X7r7~7
9)9B9L97:B:
<8<X<
=%=.=4=9=X=f=x=
>%>5>x>
>"?8?J?{?
051E1m142b3h3
3"464J4^4v4|4
5:5G5
7?7N7j7~7
5#5'5+5/535
6 6$6(6,6064686<6@6D6`6
7%7+7
;<<_<
=1=T=
>!>1>W>
3V3y3
424T4
5*525;5D5j5v5
666s6}6
717A7M7c7
8A8J8\8}8
909D9
:Z:q:
;>;c;
<#<I<]<
>G>c>|>
?%?p?t?x?|?
0&0s0
0C1a1q1}1
2%2h2
2)3<3H3T3]3d3
474S4
6,6Q6
7#7g7p7
9C9|9
:/;S;
1V1y1
1Q2@3
7E7m7
8-9]9
2%313;3Q3
4=4G4^4
425=5I5`5
=$=C=
5.636
93:T:
;#;@;};
^0h0r0|0
1>2G2P2Y2
5*7:7i7
8Q8c8
8*9<9\9r9
9S;`;
?,?=?O?l?
172g2z2
4+4N4q4
4!5;5j5
:;;];
<6=M=r=U>
0-2c2{2
6;6h6z7
8A8k8
;^>p>
?3?z?
0[2;3c3f4z4
6#6*6
7<9v9
 8Y8j8
929;9b9
:C:a:q:}:
;,<P<
<)=G=
>!>1>K>c>
272@2Z2
3#4<4}4
4%5]5z5
7$7N7]7
818f8
9+9L9f9
9-:T:
:R;];d;
=O=Z=
0!0-0@0S0g0{0
1_1w1
232\2v2
3-3v3
3)4X4v4
5(555M5z5
6<6{6
6/7A7
9c:q:
:I;R;t;
>]>c>S?a?
3:3]3
484@4Z4u4
5Q5g5z5
516Z6
7=7`7
:E;i;
<)<b<
=:=]=
3/3Z3
3.4;4e4
5U5]5e5m5
5 6'6.656<6C6U6
8!9@9L9X9o9
93:Q:a:m:
<1<A<M<c<
>#?F?
0#1]1~1
1'242<2H2Z2g2r2}2
2)3h3
4'4=4S4l4
7P7W7
9=9I9U9l99:
;#<A<Q<]<v<
<$=-=
>1?J?a?z?
0C0K0
1C1I1^1o1
2R3Z3d3p3x3
4(404O4d4
5 6)6P6u6
8&9:9q9
-131S3q3
5 5C5l5|5
9%91999J9
<e=)>
3.3v5
6)6/686A6K6T6^6g6q6z6
6H7Q7|7
8=8Q8r8
9C9y9
<8<W<
=>=X=e=
=.>V>f>
070o0
1;1L1S1]1g1t1
2 2'2F2|2
4#5x5
6l7u7
7k8x8
9k9;:H:
;0;W;
=8>|>
0"1P1
6=6Z6
8H8Z899V9s9^:
<F<q<
=&>c>
161i1
3I3V3
4'464R4i4o4
6 6&6,62686>6D6J6Q6[6a6l6r6x6~6
9C9^9m9
9&:]:f:K;'<S<
<==m=
=>>T>
>2?;?q?
1%1@1R1`1x1
2:2L2Z2r2
343F3T3l3
4.4@4N4f4
5f5o5
6Y6b6
7L7U7
8(9:9
9f;y;
< <N<a<r<
=g=p=
>(?:?
1H1Z1
2;3h3z3
444E4u4
4+5E5V5
556r7
8D9s9
=1=I=O=
>(?7?O?\?c?j?q?x?
0\0f0m0t0{0
1'1.151<1x1
2+2C2P2W2^2e2l2
2I3Q3[3b3i3p3
4&4-444p4
4+5U5
<3?B?d?
0(0v0
0T1x1
445=576u6
:6;[;~;
 0(0B0J0d0l0
10181R1Z1t1|1
2%2/232
333%4
646E6a6t6
9@9U9`9
:*:9:P:_:v:
;4;C;Z;i;y;
;B<N<o<
=2=?=X=p=u=
=j>s>y>
>C?k?
0 0C0Z0r0
0'1.1@1G1L1S1]1
4 414v4
5)575=5C5I5O5U5\5c5j5q5x5
9&959L9R9X9^9d9j9p9
99:N:~:
;7;=;B;H;S;Y;d;k;p;y;
<#<<<C<k<s<
=%=C=
>">>>H>Q>
?G?Q?Z?c?x?
0!0?0
1+151T1b1r1~1
2&222>2R2^2j2v2
5Z5b5
5Q6c6
7b7|7
8I8R8_8e8q8
9'999
<G=b=
>#>Q>
> ?C?f?
080[0~0
575Z5
5,6f6
6?7o7
90:j:
;<;_;
=N=~=
0N1~1
596{6
6!7Q7
8D8t8
9>:n:
=<=_=
>1>T>
?!?d?
0D0X0`0h0p0x0
1,181@1
2$2,242<2D2L2T2\2l2x2
3,383X3`3h3t3
4(40484D4d4l4x4
5(505d5l5t5|5
60686T6d6p6x6
7$747@7`7l7
808<8\8d8l8x8
9<9H9P9
: :@:H:d:t:
;4;<;H;h;t;|;
<$<,<`<p<|<
=(=0=8=@=L=l=t=|=
> >(>0><>\>d>p>x>
? ?@?L?l?t?|?
0(0L0T0\0d0l0t0|0
101<1\1d1l1t1|1
282D2d2l2t2|2
3$303P3X3d3
4(444T4`4
5$5,545<5H5h5p5x5
6 6,6L6X6`6
607D7T7d7p7
8 8@8L8l8t8
9<9D9P9p9x9
:8:D:d:l:t:|:
;L;T;t;|;
< <(<L<\<d<l<t<|<
=$=,=4=<=D=L=T=\=d=l=t=|=
>$>D>P>X>
?<?L?X?`?
0D0T0`0h0
1$1,141<1D1`1|1
2$2(202D2L2`2h2p2x2
3,343<3D3X3`3h3p3
4 444<4D4L4`4h4p4x4
5 5(5<5D5L5T5h5p5x5
6$6(60646<6@6H6L6T6X6`6d6l6p6x6|6
0 0$0(0,0004080<0@0D0H0L0P0T0X0\0`0d0h0l0p0t0x0|0
1(1L1h1
2<2t2
3T3l3
5@5p5
5,6X6
