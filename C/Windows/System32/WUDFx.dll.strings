!This program cannot be run in DOS mode.
JRich|
.text
`PAGEWdfV>
`.rdata
@.data
.pdata
@.rsrc
@.reloc
D$(E3
C tfH
;Gdt^
EpH9B
O tFH
A tcH
@SVWH
l$pE3
CpH9B
t/H9Y
;Cdt0
C tFH
UVWATAUAVAWH
t~H9x
;Cdt%
A_A^A]A\_^]
C tFH
WATAUAVAWH
t|H9x
;Cdt#
Rtc6x
A_A^A]A\_
c t@H
@SVWH
d$xE3
s tHH
WAVAWH
B8|;1r6H
@A_A^_
|$ AVH
L9shE
uHL9sH
D9s@v
WATAUAVAWH
q u{D
A_A^A]A\_
VWATAUAVH
A^A]A\_^
@SUVAVAWH
pA_A^^][
pA_A^^][
{ thH
SUVWATAUAVAWH
d$ E3
~HfA9
r)fA9
A_A^A]A\_^][
M tMH
H9khD
H9kHudH
VWAVH
SUVWAUAVAWH
t$ E3
pA_A^A]_^][
pA_A^A]_^][
O tOI
WATAUAVAWH
d$ E3
A_A^A]A\_
VWATAVAWH
l$p@8
@A_A^A\_^
USVWATAUAVAWH
d$ E3
Eg;A,
{HfA9
D$(E3
D$(E3
H9|$`tvH9
A_A^A]A\_^[]
V tRI
WAVAWH
B8|;1r
0A_A^_
qpWTN
UVWATAUAVAWH
A_A^A]A\_^]
l$ VWATAVAWH
A_A^A\_^
WATAUAVAWH
D$HE3
`A_A^A]A\_
@SUVWH
h_^][
@SUWAUH
phV6)'1
hA]_][H
hA]_][H
|$ ATAVAWH
A_A^A\
VWAVH
|$ UAVAWH
;CdtN
A_A^]
{ AVH
UVWATAUAVAWH
A_A^A]A\_^]
;Gdt0
;Gdt8
UATAUAVAWH
Tph6|
A_A^A]A\]
xeL9-n<
WAVAWH
@A_A^_
x ATAVAWH
 A_A^A\
9;t\H
UWATAVAWH
A_A^A\_]
t2H9Y
t$ WATAUAVAWH
A_A^A]A\_H
ATAVAWH
0A_A^A\
VWATAUAVH
A^A]A\_^
p WATAUAVAWH
A_A^A]A\_
t$ WH
phV6)'1
qzPZP
UVWATAUAVAWH
L98uqL
`A_A^A]A\_^]
qzPZP
WAVAWH
A_A^_
p WAVAWH
;EdtDD
 A_A^_
~Y@8~Xv
UATAUAVAWH
A_A^A]A\]
x ATAVAWH
A_A^A\
D!|$8D!|$0D!|$(H
CX8CYu!
@USVWATAVAWH
A_A^A\_^[]
WAVAWH
L9|$hL
L9|$`
pSSP>>
T$hE3
|$ E3
;CdtJ
A_A^_
VWAVH
UVWATAUAVAWH
A_A^A]A\_^]
@UVWATAUAVAWH
A_A^A]A\_^]
H9l$`
UVWATAUAVAWH
pA_A^A]A\_^]
@SUVWATAVAWH
A_A^A\_^][
UWATAVAWH
A_A^A\_]
x AWH
USVWATAUAVAWH
pSSP>>
A_A^A]A\_^[]
AUAVAWH
A_A^A]
;Cdt7
p WAVAWH
!|$8!|$0!|$(H
A_A^_
H!xPH
|$ UH
@SVWAUH
xA]_^[
;CdtVH
xA]_^[
WAVAWH
@A_A^_
;G4t,
$0< u)3
h AVH
WATAUAVAWH
phV6)'1
A_A^A]A\_
x AWH
;G4to
WAVAWH
A_A^_
WATAUAVAWH
A_A^A]A\_
H9\$pu
s WATAVH
A^A\_
D$(fD
t$ UWAVH
t$ UWAVH
x ATAVAWH
A_A^A\
WATAUAVAWH
A_A^A]A\_H
t$ UWAVH
@SUVH
L$`H3
d$ AVH
C8|#1
H99t&H
D$$D;
D$$D;
x ATAVAWH
A_A^A\
WATAUAVAWH
$A:L$
A_A^A]A\_H
x ATAVAWH
A_A^A\H
t$ WATAVH
A^A\_
UWATAVAWH
A_A^A\_]
UWATAVAWH
A_A^A\_]
;G<tL
VWATAVAWH
A_A^A\_^
L$0H3
L$0H3
x ATAVAWH
A;Fdu
A_A^A\
p AWH
WAVAWH
0A_A^_
fD9?t
pS_>D
p!ZX!
UWATAVAWH
A_A^A\_]
p WAVAWH
A_A^_
t$ WAVAWH
A_A^_
UVWATAUAVAWH
`A_A^A]A\_^]
H9\$p
H9\$pu
x ATAUAVH
A^A]A\
WATAVH
A^A\_
\$ UVWATAUAVAWH
@A_A^A]A\_^]
WAVAWH
B8|;1rLH
A_A^_
p WATAUAVAWH
A_A^A]A\_
L$ E3
FxODH
VhH9z
FhH9x
q9T0e
D$HE3
@8t$Pt
VWATAVAWH
A_A^A\_^
H9\$p
VWATH
{ AVH
s WATAVH
A^A\_
{ AVH
!|$8!|$0!|$(M
D$@!|$8!|$0!|$(L
H9|$p
9{(t8H
@8{9t
VWAVH
;CdtEL
|$ AVH
phV6)'1
;C<t_
UWATAVAWH
A_A^A\_]
H9\$p
H9\$p
H9\$p
D$(fD
H9\$p
piR^E
H9\$p
p9T0e
Rtc6x
x ATAVAWH
B8|#1rCH
A_A^A\
@SUWAVAWH
D$(E3
A_A^_][
Rtc6x
Rtc6x
@SVWH
WATAUAVAWH
D$HE3
A_A^A]A\_
\$ UVWATAUH
`A]A\_^]
;CdtxD
u|L9kh
;GdtsD
O tIH
WATAUAVAWH
t|M9'L
tCM9'L
t[M9'L
t|M9'L
t[M9'L
t_L9'L
A_A^A]A\_
WAVAWH
A_A^_
|$ ATAVAWH
A_A^A\
xoH9\$pth
UVWAVAWH
D$(E3
d$ E3
;Cdt?
`A_A^_^]
xoH9\$pth
|$ UATAUAVAWH
A_A^A]A\]
USVWATAUAVAWH
H!;E3
A_A^A]A\_^[]
WATAUAVAWH
A_A^A]A\_
fD9(t
D$ E3
fD9(t
D8n-t
@8n/A
yCL9m
USVWATAUAVAWH
|$8E3
hA_A^A]A\_^[]
L9mHu
|$ UATAUAVAWH
r0fD9o
A_A^A]A\]
;Cdtl
pYQPR
;Gdt/
@SVAWH
t$hD9
0A_^[
|$ UAVAWH
D$(E3
D$(E3
0A_A^]
UWATAVAWH
A_A^A\_]
|$ UATAUAVAWH
A_A^A]A\]
|$ UATAUAVAWH
A_A^A]A\]
|$ UATAUAVAWH
A_A^A]A\]
\$p~B3
VWAVH
Rtc6x
H9shu
C uwf
{"@8s`t
USVWATAUAVAWH
pSSP>>
A_A^A]A\_^[]
\$ H;
pcRPp
UVWATAUH
`A]A\_^]
@SVWH
`_^[H
t$ WH
;Cdtm
N tGH
|$ AVH
L9shu
{"D8s`t
l$pH9q
H90uOH
|$ AVH
L9sXH
L9shL
D9s@v
Rtc6x
C uLf
WAUAVH
p;_x/
A^A]_
t$pH9y
H98uRH
VWAVH
WATAUAVAWH
Rtc6x
A_A^A]A\_
@SUVWAVH
A^_^][
UATAVH
A^A\]
UWATAVAWH
!t$8!t$0!t$(H
ppWTN
A_A^A\_]
|$ UATAUAVAWH
pc]v#>,
A_A^A]A\]
|$ UATAUAVAWH
A_A^A]A\]
pSSP>>
l$ E3
;Cdt<
phV6)'1
VWATAVAWH
A_A^A\_^
|$ AVH
t$ WH
Rtc6x
t$ WH
t$ WH
;Gdt:
|$ AVH
t$pH9y
H98uRH
;GdtH
pc[^l
VWAWH
VWATAVAWH
fD9 t
A_A^A\_^
|$ AVH
;GdtT
|$ AVH
WATAUAVAWH
phV6)'1
A_A^A]A\_
VWAVH
D$HE3
;Gdt7
phV6)'1
qc]v#>,
R$fA;Z*s
fA9Z*
s WAVAWH
A_A^_
UWATAVAWH
Tph6|
|$ E3
|$0E3
A_A^A\_]
l$ VWAVH
l$XA#
 A^_^
UAUAWH
D$ E3
D$ E3
D$ E3
D$ E3
D9m uBA
@A_A]]
USVWATAUAVAWH
HA_A^A]A\_^[]
;CdtP
p WAVAWH
;CdtP
A_A^_
VWAVH
;CdtK
Rtc6x
Rtc6x
VWAVH
H9l$0u
AUAVAWH
A_A^A]
VWAVH
;G,tX
K fA#
 A^_^
` AVH
AUAVAWH
A_A^A]
Rtc6x
{X@8{(t
r(H;Y
VWATAUAWH
A_A]A\_^
UVWATAUAVAWH
pA_A^A]A\_^]
D$HE3
D$HE3
D$HE3
w5H9J
x ATAUAVH
;FdtbD
0A^A]A\
VWAUAVAWH
0A_A^A]_^
|$ UATAUAVAWH
A_A^A]A\]
p AWH
{ ATAVAWH
yWH9+A
pS_>D
A_A^A\
H9n@A
VWATH
WAVAWH
A_A^_
{ AUAVAWH
A_A^A]
x AVH
UAVAWH
A_A^]
|$ AVH
x AVH
x AVH
pcPZt
t$ WH
L$0H3
VhH9z
FhH9x
WAVAWH
 A_A^_
UVWAUAVH
A^A]_^]
WATAUAVAWH
A_A^A]A\_
x UATAUAVAWH
t(@8u
A_A^A]A\]
WAVAWH
O f;A"tO
@A_A^_
H9_`uGH9_huAL
UWAVH
@A^_]
t$ WH
x ATAVAWH
@A_A^A\
` AVH
{ ATH
x AVH
Rtc6x
Rtc6x
Rtc6x
pS_>D
{ ATH
x ATAVAWH
P<3&A
A_A^A\
\$ UVWAVAWH
pkXr2?
L$@H3
PA_A^_^]
qsVvW
L$0H3
WAVAWH
pJT\F
0A_A^_
x UATAUAVAWH
I9V H
r6fD9w
A_A^A]A\]
x AVH
L$0H3
s WAVAWH
A_A^_
qJT\F
;Gdt9
;Cdt!
L$0H3
L$0H3
qsVvW
L$0H3
L$0H3
x AVH
L$(E3
x ATAVAWH
B8|#1rUH
A_A^A\
L$hE3
D$(E3
L$0H3
VWAVH
x ATAVAWH
H!|$ 
@A_A^A\
{ AWH
tiH9{
L$ E3
pzPZP
D$ H;
D$ H9B
x AVH
9Hu^3
9i@~.3
xE;k@}@H
t/H9y
L$xH3
x AVH
H9(u7H
p`]<)
t>H9{
p [>9
q0R^G'
ATAVAWH
p0R^G'
 A_A^A\
q:_0#
VWAVH
\$ E3
D$HE3
D$HE3
LcA<E3
HcQ<H
\$ UH
 H3E H3E
ATAVAWH
 A_A^A\
{ AVH
x UATAUAVAWH
pS_>D
r5fD9o
A_A^A]A\]
UVWATAUAVAWH
r5fD9o
A_A^A]A\_^]
` UAVAWH
wwfA9q
A_A^]
@USVWATAVH
A^A\_^[]
pS_>D
L$0H3
pS_>D
L$0H3
WAUAVH
A^A]_
WAVAWH
0A_A^_
psP2q
L$PH3
Rtc6x
UVWATAUAVAWH
 A_A^A]A\_^]
UVWATAUAVAWH
 A_A^A]A\_^]
t$ WAVAWH
A_A^_
WAVAWH
L;{(t
A_A^_
{ ATAUAVH
H9o(A
A^A]A\
WAVAWH
A_A^_
t7LcC
UVWATAUAVAWH
f94Bu
 A_A^A]A\_^]
t$ WH
@USVWATAUAVAWH
u`f9]`tEI
D$ E3
\$0E3
A_A^A]A\_^[]
x AVH
D97|N9
8w1t*
WAVAWH
 A_A^_
WAVAWH
fD;1t{fD;9u
fD;8ucH
fD;9u
7fD;6tX
 A_A^_
t$ UWATAVAWH
f9<Bu
fD9"u
fD9 u.H
fB9<@u
A_A^A\_]
\$ UVWATAUAVAW
f;D$@u^D
A_A^A]A\_^]
UWAVH
D$PfD
@USVWATAUAVAWH
t$XE3
D$@E3
T$pE3
fD94Gu
?{uQH
D$pE3
A_A^A]A\_^[]
WAVAWH
 A_A^_
fD94Au
fD94Xu
L$ SVWH
UVWATAUAVAWH
L9mwu
r5fD9o
A_A^A]A\_^]
UWAUAVAWH
A_A^A]_]
WATAVH
A^A\_
x AVH
UVWATAUAVAWH
`A_A^A]A\_^]
q;_x/
|$ UH
u(!;L
WAVAWH
A_A^_
UWAVH
x ATAUAWH
A_A]A\
x AWH
@USVWAUAVAWH
A_A^A]_^[]
h UAVAWH
> sVH
A_A^]
UAUAVH
A^A]]
WATAUAVAWH
A_A^A]A\_
t$ WAUAVH
A^A]_
|$ UATAUAVAWH
A_A^A]A\]
VWATAUAVH
A^A]A\_^
k VWAWH
Srp'0
t$ WATAUAVAWH
;@tyH
s0L9&t
{8L9'
{8D9c
s0L9&u
{8L9'
{8L9&trI
A_A^A]A\_
UATAUAVAWH
t@D9uPA
A_A^A]A\]
VWATAVAWH
A_A^A\_^
UVWATAUAVAWH
H9]@u
A_A^A]A\_^]
x AWH
p WAUAVH
A^A]_
k VWAWH
UVWATAUAVAWH
`A_A^A]A\_^]
q`]<)
L$0H3
L$0H3
L$0H3
L$0H3
L$0H3
L$0H3
UVWATAWH
`A_A\_^]
x AWH
x AWH
x AWH
UWATH
|$ AWH
qS_>D
VWAVH
x AVH
q [>9
WATAUAVAWH
A_A^A]A\_
UVWATAWH
`A_A\_^]
UVWATAWH
`A_A\_^]
!\$ D
!\$8H
!\$0A
!\$(H
x AWH
VWATH
p3S8j
q2^^0
|$ ATH
WAVAWH
A_A^_
UWAVH
UVWATAWH
`A_A\_^]
` UAUAVH
A^A]]
x AWH
x ATAVAWH
A_A^A\
UVWATAWH
`A_A\_^]
UVWATAUAVAWH
EHA;F,u
EHA;F,u
A_A^A]A\_^]
s WATAUAVAWH
fD9'A
A_A^A]A\_
{ ATAVAWH
A_A^A\
VWATAUAVH
A^A]A\_^
{ AUAVAWH
A_A^A]
WATAVH
A^A\_
UAUAVH
wdD8s
A^A]]
|$ E3
qpWR>>
|$ AWH
WATAVH
A^A\_
UVWATAUAVAWH
L9ePL
L9eHL
]HM9e
`A_A^A]A\_^]
` AWH
WATAVH
A^A\_
t$ UWAUAVAWH
A_A^A]_]
WATAWH
A_A\_
{ ATAVAWH
A_A^A\
WATAUAVAWH
A_A^A]A\_
WAVAWH
A_A^_
VWAUAVAWH
\$(E3
A_A^A]_^
@USVWATAVAWH
A_A^A\_^[]
@USVWATAUAVAWH
A_A^A]A\_^[]
x AWH
l$ VWAWH
ATAVAWH
A_A^A\
\$ UVWATAVH
A^A\_^]
l$ VWAWH
ATAVAWH
A_A^A\
\$ UVWATAVH
A^A\_^]
{ AVH
VWAVH
VWAVH
q`\TN
@t?I;
phV6)'1
q3_Xh
WATAVH
A^A\_
UAVAWH
A_A^]
x AVH
ATAVAWH
L!t$hL
0A_A^A\
UVWATAUAVAWH
A_A^A]A\_^]
L$ SVWAVH
8A^_^[
UVWATAUAVAWH
pA_A^A]A\_^]
x ATAVAWH
A_A^A\
UVWATAUAVAWH
|$PE3
|$HE3
A_A^A]A\_^]
!](!] H
H!\$XH
E H!\$PE3
H!\$HE3
H!\$@3
E(H!\$0H!\$(H
t$ UWAVH
M0H!|$ E3
!|$8!|$0!|$(H
@USVWAVH
A^_^[]
q3_Xh
|$ UATAUAVAWH
A_A^A]A\]
` UAVAWH
A_A^]
UATAVH
A^A\]
\$ E3
L$XH3
UATAVH
A^A\]
|$ UATAUAVAWH
A_A^A]A\]
ppWTN
UVWAVAWH
H9ugu
H9uou
A_A^_^]
VWATH
qPYxE
WAVAWH
{pD9{
A_A^_
t$ WAVAWH
VxL9z
FxL9x
ppWTN
V(L9z
F(L9x
A_A^_
` UAVAWH
pc]v#>,
A_A^]
WAVAWH
A_A^_
VWATAVAWH
A_A^A\_^
VWATH
H98uEH
UWATAVAWH
A_A^A\_]
K f;A"
x AVH
WATAVH
A^A\_H
t$ WAVAWH
wdH9kHt]H
@A_A^_
WAVAWH
sdH9oHt^H
D$`L;
D$`L;
ppYzS
A_A^_
qpYzS
WAVAWH
wdH9kHt^H
D$`H;
ppYzS
D$`H;
A_A^_
wdH9kHt]H
D$ H;
WATAUAVAWH
H97u@H
A_A^A]A\_
WATAVH
M96uAH
A^A\_H
VWAUAVAWH
E9~ A
pS_>D
A_A^A]_^
WATAVH
u2H9GHta
A^A\_
x AVH
;SXs@H
x AVH
CPH94
q"Q\m
k VWAVH
pS_>D
UWATAVAWH
A_A^A\_]
pS_>D
x AVH
H9oHtKH;
x AVH
L9wHtOH;
L9wHt
qpYzS
H9oHt?H;
H9oHtNH;
H9oHL
p"Q\m
t$ WAVAWH
A_A^_
\$ UVWATAUAVAWH
L9u@A
A_A^A]A\_^]
WATAUAVAWH
D$(E3
pS_>D
A_A^A]A\_
x AVH
9~(uBH
p`]<)
{ AUAVAWH
A_A^A]
L$ SVWAVH
8A^_^[
T$(E3
p WAVAWH
A_A^_
WAVAWH
B8|;1r6H
@A_A^_
x ATAVAWH
B8|#1rYH
A_A^A\
{ AVH
x ATAVAWH
B8|#1rYH
A_A^A\
x ATAVAWH
t fD9}
A_A^A\
WAVAWH
A_A^_
x ATAVAWH
A_A^A\
d$XL9
Rtc6x
Rtc6x
x AVH
x AVH
{ AVH
D$(fD
` UAUAVH
D$(fD
A^A]]
x AWH
t/H9Y
x ATAVAWH
@A_A^A\
UVWAVAWH
@A_A^_^]
tW@85>
Rtc6x
q#X0J
WAVAWH
A_A^_
UVWATAUAVAWH
f98wa@
w @8}0u
`A_A^A]A\_^]
h VWAWH
L$pH3
UWATAVAWH
A_A^A\_]
x ATAVAWH
B8|#1rCH
A_A^A\
x AVH
D$(fD
WAVAWH
A_A^_
x ATAVAWH
B8|#1rgH
A_A^A\
WAUAVH
@A^A]_
s WATAVH
A^A\_
t$ WAVAWH
A_A^_
T$8E3
x AVH
x AVH
|$ UAVAWH
A;F,u
A_A^]
x ATAVAWH
A_A^A\H
VWAVH
L$`E3
Rtc6x
@A^_^
D$(fD
` AUH
|$(fD
_Ts&L
L9@ t
t$ UWAVH
9t$HH
ED$49t$8
9t$LH
s UWAVH
f9<Cu
f9<Cu
x UATAUAVAWH
A_A^A]A\]
x AWH
D$8@8
x ATAVAWH
A_A^A\H
x ATAVAWH
@A_A^A\
@8wPt
WAVAWH
A_A^_H
x ATAVAWH
@A_A^A\
WAUAVH
A^A]_
WATAUAVAWH
F H9C t
 A_A^A]A\_
t$ WH
f!A H
ATAUAWH
|$(fD
A_A]A\
Rtc6x
{ AUAVAWH
A_A^A]
D$(fD
Rtc6x
D$`E3
WAVAWH
D8=[Q
fD93u
fD93u
A_A^_
\$ VWAVH
L$xf9i
E(=csm
E8=csm
EH=csm
EX=csm
Eh=csm
Ex=csm
drivers\wdf\umdf\DriverHost\Framework\V1\inc\UfxObject.h
Driver created request can't be completed by the same layer as the one that created it
UfxObject::PerformEarlyDispose
UMDF dispose should never be deferred
CWdfIoRequest::Initialize
RetrievalMode is invalid
Driver Created requests should not defer buffer retrieval
FxToObjectItf::FxAddToDisposeList
drivers\wdf\umdf\driverhost\framework\v1\fxtosharedinterface\fxobject\fxobjectinterface.cpp
This function should never be invoked for UMDF
drivers\wdf\umdf\driverhost\framework\v1\wudf\wdfmemorybuffer.cpp
CWdfMemoryBuffer::CreateAndInitalize
UfxParentObject should not be NULL
CWdfMemoryBuffer::GetDataBuffer
drivers\wdf\umdf\driverhost\framework\v1\wudf\wdfmemorybuffer.h
It is illegal to invoke this DDI while thread is impersonated
CWudfObjectEx::~CWudfObjectEx
drivers\wdf\umdf\driverhost\framework\v1\wudf\wudfobjectex.cpp
TODO: Write something interesting here
ppIWDFIoRequest should not be NULL
CWdfDevice::DeviceControl
pDevCntrlIrp should not be NULL
File object is NULL, but NULL file object support is not enabled
pRequest should not be NULL
CWdfDevice::DispatchRequest
CWdfDevice::CreateRequest
drivers\wdf\umdf\driverhost\framework\v1\wudf\wdfioqueue.cpp
CWdfIoQueue::DispatchRequestToDriver
Request already completed
CWdfIoRequest::CompleteWithInformation
Invalid code path- Create, close and cleanup should not be handled in this path
CWdfIoQueue::RequestCompleteEvent
xCWdfIoQueue::~CWdfIoQueue
CWdfIoQueue::ProcessReadyNotify
pReadCallback should be NULL
Could't enqueue work item
CWdfIoQueue::DispatchEvents
Invalid config for manual queues
CWdfIoQueue::ProcessCancelledRequests
CWUDF::Initialize
drivers\wdf\umdf\driverhost\framework\v1\wudf\wudf.cpp
CWudfDriverGlobals::ConfigureForObjectTracking
drivers\wdf\umdf\driverhost\framework\v1\wudf\wdfglobals.cpp
m_ObjectTracker should be NULL
CWdfIoQueue::Initialize
pQueueReadyCallback should be NULL
SOFTWARE\Microsoft\Windows NT\CurrentVersion\WUDF\Services
CWudfDriverTable::Insert
drivers\wdf\umdf\DriverHost\Framework\V1\inc\WudfGlobals.h
Invalid state
CWudfDriverGlobals::Release
CWdfMemoryBuffer
IWDFMemory
CWdfIoRequest
IWDFIoRequest3
IWDFIoRequestCompletionParams
IWDFUsbRequestCompletionParams
Continuous Readers should have the same parent
Context should contain a Continuous Reader
CWdfRequestQueue::RemoveNextRequestFromQueue
CWdfUsbPipeContinuousReader::FormatRepeater
Request should not be NULL
Urb should not be NULL
FxFormatUsbRequest
drivers\wdf\umdf\driverhost\framework\v1\wudf\wdfusbtargetdevice.cpp
CWdfIoRequest::SetFileObjectForNextLocation
pIoTarget should not be NULL
CWdfIoRequest::Send
Timeout specified without setting Timeout flag
+{tea1CWdfIoRequest::SynchronousSend
Request has not been formatted, cannot send
Request is already pending on an I/O Target
CWdfIoTarget::IncrementIoCount
CWdfIoTarget::SubmitLocked
CWdfIoRequest::AsyncSend
If WDF_REQUEST_SEND_OPTION_SEND_AND_FORGET is set no other flags should be set (except impersonation flags)
Request created by this layer can't be sent using SEND_AND_FORGET flag
CWdfUsbTargetDevice::FormatRequestForControlTransfer
pSetupPacket should not be NULL
pIWDFIoRequest should not be NULL
CWdfIoTarget::FormatIoctlRequest
drivers\wdf\umdf\driverhost\framework\v1\wudf\WdfFile.h
CWdfFile::GetObjectFromInterface
Invalid buffer type
FxRequestBuffer::GetBuffer
drivers\wdf\umdf\driverhost\framework\v1\wudf\FxRequestBuffer.h
Can not reuse Create request
Can't reuse a sent request
CWdfIoTarget::Remove
CWdfCmResourceList::ValidateRegisterSystemAddressRange
TargetAddress should not be NULL
Integer overflow occurredwhen computing register address range
CWdfDevice::ReadFromHardware
Incorrect Type parameter
Count should be > 0
Driver attempted to read from invalid register address or address range
drivers\wdf\umdf\driverhost\framework\v1\wudf\wdfresources.cpp
Hardware access not allowed. Set the INF directive UmdfDirectHardwareAccess to AllowDirectHardwareAccess in driver's INF file to enable direct hardware access
Integer overflow occurred when computing length of read access
Buffer should not be NULL
Incorrect Size parameter
CWdfIoQueue::GetState
Request was not changed on the way down
Request was not formatted as a read request on the way down
Not a USB request
CWdfIoRequest::GetUsbRequestContext
CWdfIoRequest::GetPipeReadParameters
CWdfIoRequest::Reuse
m_pHostIrp should not be NULL
Can't set completion callback on a sent request
CWdfIoRequest::SetCompletionCallback
CWdfIoTarget::FormatRequestForIoctl
CWdfIoRequest::ForwardToIoQueue
CWdfIoQueue::IsState
CWdfIoQueue::ForwardRequest
WDF_IO_QUEUE states not allowed
drivers\wdf\umdf\driverhost\framework\v1\wudf\WdfIoQueue.h
CWdfIoRequest::MarkCancelable
Cancel Trap
CWdfIoQueue::RequestCancelable
CWdfUsbTargetDevice::FormatControlRequest
CWdfIoRequest::UnmarkCancelable
drivers\wdf\umdf\driverhost\framework\v1\fxtosharedinterface\fxdevice\fxdevicetomxinterface.cpp
FxDeviceToMx::GetHandle
~KZ*::!/
?5KLO#
~pDeviceInterfaceList should not be NULL
CWdfIoQueue::StopSynchronously
pDeviceInterfaceListLock should not be NULL
CWdfDevice::CreateDeviceInterface
m_pPkgPnp should not be NULL
FxIrp::GetParameterAllocatedResourcesTranslated
CWdfDevice::AssignDeviceInterfaceState
pDeviceInterfaceGuid should not be NULL
CWdfUsbPipeContinuousReader::OnCompletion
pQueue should not be NULL
CWdfDevice::RemoveQueueReferences
Can't delete default queue
m_pIWudfDevice should be NULL
CWdfDevice::FdoInitialize
ufxInterrupt->m_OnInterruptWorkItem should not be NULL
FxInterrupt::WorkItemHandler
pIWDFObject should not be NULL
FxIrp::GetParameterDeviceCapabilities
zHm_WorkitemEnqueued == TRUE
pIWDFInterrupt should not be NULL
pFxContext should not be NULL
pCloseIrp should not be NULL
pFileObj should not be NULL
CWdfDevice::ProcessCloseFile
CWdfDevice::CloseFile
CWdfDevice::CleanupFile
CWdfDevice::DispatchCleanupClose
pWdfFileObject should not be NULL
FxTransactionedListUm::GetNextEntry
List is not locked for enumeration
drivers\wdf\umdf\driverhost\framework\v1\wudf\fxtransactionedlistum.cpp
CWdfDevice::FlushAllTargetsByFileObject
fileObj should not be NULL
CWdfDevice::FlushAllQueuesByFileObject
FxIrp::SetCompletionRoutine
UMDF completion routine can't be invoked selectively on Success/Error/Cancel
FxIrp::GetMinorFunction
drivers\wdf\umdf\driverhost\framework\v1\fxtosharedinterface\fxirp\fxirpum.cpp
FxIrp::GetMajorFunction
FxIrp::GetParameterPowerType
FxIrp::GetParameterPowerStateSystemState
FxIrp::GetParameterPowerStateDeviceState
FxIrp::GetParameterPowerState
CWdfDevice::FindDeviceInterface
FxIrp::GetParameterPowerShutdownType
FxDeviceToMx::DeleteObject
CWdfIoTarget::SubmitSync
Infinite wait should never fail
CWdfIoQueue::QueueStop
FxIrp::GetParameterAllocatedResources
CWdfUsbPipeContinuousReader::_HandleReadFailureWorkItemThunk
No failed read work-item should be running
CWdfDriver::CreatePreallocatedWdfMemory
drivers\wdf\umdf\DriverHost\Framework\V1\inc\UfxObject.h
UfxObject::Release
Dereference of destroyed object
{?e:HC
vCWdfIoRequest::InsertTailRequestQueue
drivers\wdf\umdf\driverhost\framework\v1\wudf\wdfiorequest.cpp
Context should not be NULL
CWdfRequestQueue::InsertInQueue
drivers\wdf\umdf\driverhost\framework\v1\wudf\wdfrequestqueue.cpp
Ff\'dq.`@
DB+zp
+<O=r"wIL
CWdfIoRequest::GetObjectFromInterface
Invalid request type passed to FormatIoRequest
CWdfIoTarget::FormatIoRequest
CWdfIoTarget::_FormatIoRequest
Invalid request type passed to _FormatIoRequest
drivers\wdf\umdf\driverhost\framework\v1\wudf\WdfIoTarget.h
CWdfIoTarget::FormatRequestForRead
CWdfRemoteTarget::FormatRequestForWrite
CWdfDevice::Initialize
pDevInit should not be NULL
pDeviceQueryInterface should not be NULL
pWdfDriver should not be NULL
ppIWdfDevice should not be NULL
pDeviceInit should not be NULL
pCallbackInterface should not be NULL
pDrvGlobals should not be NULL
pCreateIrp should not be NULL
CWdfDevice::CreateFileW
jCWdfRequestQueue::Initialize
ufxParentObject should not be NULL
DirectHardwareAccess
RegisterAccessMode
CWdfDevice::CreateAndInitialize
CWdfDevice::SetupCallbacks
fCWdfIoTarget
WUDFx!UfxObject
IWDFIoTarget2
IWDFIoTargetStateManagement
IRequestCallbackRequestCompletion
CWdfCmResourceList
IWDFCmResourceList
CWdfDevice
IWDFDevice3
IFxMessageDispatch
IWDFUsbTargetFactory
IWDFFileHandleTargetFactory
IWDFPropertyStoreFactory
IWDFUnifiedPropertyStoreFactory
IWDFHidInterfaceFactory
CWdfIoQueue
IWDFIoQueue
CWdfFile
IWDFFile
CWdfDriverCreatedFile
WUDFx!CWdfFile
IWDFDriverCreatedFile
CWdfUsbTargetPipe
WUDFx!CWdfIoTarget
IWDFUsbTargetPipe
IWDFUsbTargetPipe2
drivers\wdf\umdf\driverhost\framework\v1\wudf\wdfusbpipe.cpp
CWdfUsbTargetPipe::QueryInterface
CWudfObjectEx::OnDispose
Unexpected failure in QueryInterface
drivers\wdf\umdf\driverhost\framework\v1\wudf\WdfRemoteTarget.h
CWdfRemoteTarget::FormatRequestForIoctl
pFile should be NULL
CWdfIoTarget::_RequestCompletionRoutine
CWdfIoTarget::RequestCompletionRoutine
CWdfIoRequest::CompleteSubmitted
CWdfIoRequest::DeleteWdfObject
drivers\wdf\umdf\driverhost\framework\v1\wudf\WdfIoRequest.h
ppWdfMemory should not be NULL
CWdfDriver::CreateWdfMemoryWorker
drivers\wdf\umdf\driverhost\framework\v1\wudf\wdfdriver.cpp
Invalid parameters: All input params are NULL
CWdfIoRequest::GetDeviceIoControlParameters
Invalid operation. Request type is not DeviceIoControl
CWdfUsbTargetPipe::SetPipePolicy
CWdfUsbTargetPipe::RetrievePipeInfo
pWdfDevice || pWdfRequest should not be NULL
ProcessUrbSynchronously
CWdfUsbTargetPipe::FormatRequestForWrite
Write invoked on a pipe that is not an OUT EndPoint
Read invoked on a pipe that is not an IN EndPoint
CWdfUsbTargetPipe::FormatRequestForRead
DeviceOffset should be NULL
pValueLength && Value should not be NULL
CWdfUsbTargetPipe::RetrievePipePolicy
drivers\wdf\umdf\driverhost\framework\v1\wudf\wdfiotarget.cpp
CWdfIoTarget::OnCompletion
CWdfIoRequest::RetrieveInputMemory
ERROR: Attempting to clobber old memory buffer with a new one
CWdfIoRequest::PopulateMemoryObjects
Output memory object should not be NULL if the UMIRP has an output buffer.
Input memory object should not be NULL if the UMIRP has an input buffer.
CWdfDevice::GetDriver
drivers\wdf\umdf\driverhost\framework\v1\wudf\wdfdevice.cpp
ppWdfDriver should not be NULL
CWdfIoRequest::GetInputMemory
Driver must not call GetInputMemory if it has set RetrievalMode to DeferRetrieval.  Use RetrieveInputMemory or RetrieveInputBuffer instead.
Invalid operation. Request type is not Write, DeviceIoControl or SetInformation
Invalid operation. Request type is not Read, DeviceIoControl or QueryInformation
CWdfIoRequest::GetOutputMemory
Driver must not call GetOutputMemory if it has set RetrievalMode to DeferRetrieval.  Use RetrieveOutputMemory or RetrieveOutputBuffer instead.
WdfCallbackLock::Lock
Thread is recursively acquiring the lock. This is disallowed 
WdfCallbackLock::Unlock
drivers\wdf\umdf\DriverHost\Framework\V1\inc\WDFLockObject.h
The thread that acquired the lock is not the same one this releasing it
ppCompletionParams should not be NULL
CWdfIoRequest::GetCompletionParams
drivers\wdf\umdf\driverhost\framework\v1\wudf\fxrequestcontext.cpp
FxRequestContext::_StoreAndReferenceMemoryWorker
ppMemory should not be NULL
CWdfUsbTargetPipe::FormatTransfer
Attempt to change buffer on a non-preallocated memory object
CWdfMemoryBuffer::SetBuffer
CWdfIoRequest::SetCompletionEvent
CWdfRequest already completed
CWdfRequestQueue::RemoveRequestFromQueueByContext
ppFileObject should not be NULL
CWdfIoRequest::GetFileObject
CWdfIoTarget::RemoveCompletedRequestLocked
QYCWdfMemoryBuffer::SetBufferInternal
CWdfUtilRegPropVariantConv::RegistryValueToPropVariant
Unexpected failure
CWdfDevice::RetrieveDeviceInstanceId
CWdfIoRequest::RetrieveOutputMemory
Memory should not be NULL
Invalid parameters: ImpersonationLevel is not a valid level
CWdfIoRequest::Impersonate
Invalid parameters: pCallback cannot be NULL
CWdfIoQueue::RetrieveNextRequest
FxRequestContext::~FxRequestContext
CWdfIoTarget::DecrementIoCount
CWdfFile::GetDevice
ppWdfDevice should not be NULL
drivers\wdf\umdf\driverhost\framework\v1\wudf\wdffile.cpp
CWdfIoRequest::Complete
Data returned is more than MAX_ULONG
FxUsbPipeTransferContext::CopyParameters
CWdfUsbTargetPipe::IsInEndPoint
drivers\wdf\umdf\driverhost\framework\v1\wudf\WdfUsbPipe.h
CWdfIoRequest::GetCompletionStatus
CWdfUsbTargetPipe::IsOutEndPoint
Setting information on a completed request
CWdfIoRequest::SetInformation
FxInterrupt::ThreadpoolWaitCallback
drivers\wdf\umdf\driverhost\framework\v1\wudf\interruptobjectum.cpp
%02d.%03d
HostProcessSharingEnabled
MethodNeitherAction
FileObjectPolicy
KernelModeClientPolicy
DeviceGroupId
CWdfDevice::StopProcessingForPower
CWdfDevice::ResumeProcessingForPower
Power operation is already in progress
CWdfIoQueue::ResumeProcessingForPower
drivers\wdf\umdf\driverhost\framework\v1\minkernel_shared_v11\irphandlers\pnp\fxpkgpnp.cpp
CWdfIoTarget::CancelSentRequestsForFile
Request was not formatted as a write request on the way down
CWdfIoRequest::GetPipeWriteParameters
Request was not changed on the way down. Obtain parameters from IWDFIoRequest
Request was not formatted as an Ioctl request on the way down
CWdfIoRequest::GetIoctlParameters
CWdfIoRequest::GetDeviceControlTransferParameters
The RemoteInterfaceList should be empty by the time we get here.
CWdfRemoteInterfaceList::~CWdfRemoteInterfaceList
CWdfDevice::_RetrieveUnifiedDevicePropertyStoreWorker
RootSpecifier should not be NULL
PropertyStore should not be NULL
CWdfDevice::RetrieveUnifiedDevicePropertyStore
CWdfUsbPipeContinuousReader::Release
Refcount should be greater than or equal to 0
CWdfIoQueue::ProcessPowerEvents
CWdfUtilRegPropVariantConv::NumberToByteArray
drivers\wdf\umdf\driverhost\framework\v1\wudf\wdfutilregpropvariantconv.cpp
CWdfIoQueue::Dispose
pDevice should not be NULL
drivers\wdf\umdf\driverhost\framework\v1\wudf\wdfremoteinterfacelist.cpp
m_TransportInterfaceNotificationCallback should be NULL
pDriverGlobals should not be NULL
m_TransportInterfaceNotificationCallback should not be NULL
pDeviceCallbacks should not be NULL
CWdfRemoteInterfaceList::Initialize
CWdfIoTarget::WaitForDisposeEvent
ppUsbInterface should not be NULL
CWdfUsbTargetDevice::RetrieveUsbInterface
IoControlPreference should not be NULL
CWdfDevice::GetDeviceStackIoTypePreference
ReadWritePreference should not be NULL
drivers\wdf\umdf\driverhost\framework\v1\wudf\WdfUsbInterface.h
CWdfUsbInterface::GetWinUsbHandle
PropertyKey should not be NULL
CWdfUnifiedPropertyStore::SetPropertyData
PropertyData should not be NULL
drivers\wdf\umdf\driverhost\framework\v1\wudf\wdfunifiedpropertystore.cpp
Parameters\Wdf
LogPages
CWdfDevice::DispatchPnP
pUMIrp should not be NULL
CWdfIoRequest::GetInformation
CWdfFile::RetrieveFileName
CWdfIoRequest::GetCompletedRequestType
CWdfUsbTargetPipe::GetInformation
pInfo should not be NULL
RtlGetVersion
ntdll.dll
RtlVerifyVersionInfo
SOFTWARE\Microsoft\Windows NT\CurrentVersion\WUDF
=L9o<
N6FxUsbDeviceControlContext::CopyParameters
CWdfDevice::GetSystemPowerAction
ppFile should not be NULL
CWdfDevice::CreateWdfFile
waiting for all inflight requests to be acknowledged on IWDFIoQueue
CWudfDriverGlobals::WaitForSignal
CWdfIoQueue::SetState
Invalid queue state has been specified
CWdfDeviceInterface::AssignState
drivers\wdf\umdf\driverhost\framework\v1\wudf\wdfdeviceinterface.cpp
Cannot assign state to unregsitered interface.
CWdfIoRequest::AssignContext
CWdfIoRequest::CancelSentRequest
pCtx should not be NULL
CWdfDevice::_CreateRequestCompletionRoutine
pIrp should not be NULL
CWdfDevice::_ProcessCreateRequestCompletion
We only set completion handlers for Create
pIoIrp should not be NULL
Sent I/O count should be 0 after calling Dispose
CWdfIoTarget::~CWdfIoTarget
CWdfTransportSettings::Initialize
drivers\wdf\umdf\driverhost\framework\v1\wudf\wdftransportsettings.cpp
CWdfDevice::PostEvent
CWdfIoRequest::GetCompletedUsbRequestType
CWdfIoQueue_WorkItemThunk
pWdfQueueObj should not be NULL
advapi32.dll
api-ms-win-eventing-provider-l1-1-0.dll
FxTransactionedList::Add() failed
CWdfDevice::AddIoTarget
7GCWdfIoQueue::ProcessPurgeComplete
CWdfIoRequest::GetRequestorProcessId
drivers\wdf\umdf\driverhost\framework\v1\wudf\WdfUsbTargetDevice.h
CWdfUsbTargetDevice::GetTargetFile
drivers\wdf\umdf\driverhost\framework\v1\wudf\wdfdeviceinit.h
CWdfDeviceInit::SetPowerPolicyOwnership
WudfPowerPolicySettings
pdwProcessId should not be NULL
CWdfFile::GetInitiatorProcessId
CWdfDeviceInit::SetLockingConstraint
CWdfUsbTargetPipe::GetType
FCWdfIoTarget::Start
CWdfUsbTargetDevice::FormatRequestForIoctl
Cannot format a request targeted to USB device for Ioctl, use FormatControlTransfer instead
FxIrp::GetParameterPowerSystemPowerStateContext
CWdfDevice::FowardToLowerDriverAndDeleteRequest
CWdfRequestQueue::~CWdfRequestQueue
FxToObjectItf::FxAddToDriverDisposeList
CWdfRegPropertyStore
WUDFx!CWdfRegPropertyStore
IWDFNamedPropertyStore2
Invalid parameter passed to C runtime function.
f\'dq.`@
#Qs[*
ForceRemove
NoRemove
Delete
PPTP00?u
PPTP00
PPTP00<u
PPTP00
PPTP00:u
PPTP00
PPTP00#
PPTP00V{C
Ref count went from 0 to 1
UfxObject::AddRef
This object doesn't support callback locks
CWudfObjectEx::LockingNotSupported
drivers\wdf\umdf\driverhost\framework\v1\wudf\WudfObjectEx.h
CWdfHidInterface
IWDFHidInterface
CWdfHidInterface::CreateAndInitialize
drivers\wdf\umdf\driverhost\framework\v1\wudf\ufxhidinterface.cpp
IsPresent is not a valid BOOL
CWdfHidInterface::NotifyPresence
CWdfWorkItem
IWDFWorkItem
pIParent should not be NULL
CWdfWorkItem::CreateAndInitialize
drivers\wdf\umdf\driverhost\framework\v1\wudf\ufxworkitem.cpp
WorkItem destroyed without calling WdfDeleteObject. Possible reference count problem?
CWdfWorkItem::~CWdfWorkItem
CWdfWorkItem::Enqueue
Driver is attempting to queue a workitem that has been deleted. 
CWdfWorkItem::Flush
m_Enqueued == TRUE
CWdfWorkItem::WorkItemRoutine
m_RunningDown == FALSE
CWdfWorkItem::Dispose
eppThreadpool should not be NULL
CWdfInterruptThreadpool::CreateAndInit
drivers\wdf\umdf\driverhost\framework\v1\wudf\ufxinterruptthreadpool.cpp
m_Pool should not be NULL
CWdfInterruptThreadpool::UpdateThreadPoolThreadLimits
Waitblock should not be NULL
CWdfInterruptWaitblock::_CreateAndInit
uBCWdfInterrupt
IWDFInterrupt
CWdfInterrupt::CreateAndInitialize
drivers\wdf\umdf\driverhost\framework\v1\wudf\ufxinterrupt.cpp
CWdfInterrupt::Enable
CWdfInterrupt::Disable
CWdfInterrupt::GetDevice
CWdfInterrupt::GetInfo
Info should not be NULL
WDF_INTERRUPT_INFO size invalid
CWdfInterrupt::SetPolicy
Policy is out of range
Priority is out of range
CWdfInterrupt::SetExtendedPolicy
PolicyAndGroup should not be NULL
WDF_INTERRUPT_EXTENDED_POLICY Size invalid
TargetProcessorSet's reserved fields are not zero
CWdfInterrupt::AcquireInterruptLock
CWdfInterrupt::ReleaseInterruptLock
CWdfInterrupt::TryToAcquireInterruptLock
CWdfInterrupt::QueueWorkItemForIsr
Driver called QueueWorkItemForIsr DDI without providing OnInterruptWorkItem callback
Disconnect message to reflector returned failure. 
FxInterrupt::DisconnectInternal
FxInterrupt::SetPolicyInternal
FxInterrupt::ResetInternal
FxInterrupt::RevokeResourcesInternal
FlushQueuedDpcs message to reflector returned failure
FxInterrupt::FlushQueuedDpcs
Failed to assign interrupt resource to interrupt objectbecause interrupt resource is for level-triggered interruptwhich is not supported on this platform. See the docs for info onsupported platforms.
FxInterrupt::AssignResourcesInternal
Failed to assign interrupt resource to interrupt object because resource descriptor indicates it is not a level-triggered interrupt but allows sharing of interrupt. UMDF supports sharing of interrupts only for level-triggered interrupts.
AcknowledgeInterrupt message to reflector returned failure. Check UMDF log for failure reason. 
CWdfCmResourceList::GetCount
CWdfCmResourceList::GetDescriptor
CWdfCmResourceList::ValidateRegisterPhysicalAddressRange
Attempt to do multiple mapping of same resource, or multiple mapping in same resource range
entry->m_EndSystemVa should be NULL
entry->m_StartUsermodeVa should be NULL
Mapped length not zero
entry->m_EndSystemVa should not be NULL
CWdfCmResourceList::ValidateAndClearMapping
entry->m_StartUsermodeVa should not be NULL
CWdfCmResourceList::ValidateRegisterSystemBaseAddress
Invalid physical address or number of bytes provided
CWdfCmResourceList::MapIoSpaceWorker
Driver did not unmap its register resources
CWdfCmResourceList::ValidateResourceUnmap
Integer overflow occurredwhen computing port address range
CWdfCmResourceList::ValidatePortAddressRange
API-MS-Win-Core-LocalRegistry-L1-1-0.dll
RegDeleteKeyExW
RegDeleteKeyW
CLSID
AppID
Component Categories
FileType
Interface
Hardware
SECURITY
SYSTEM
Software
TypeLib
HKEY_CLASSES_ROOT
HKEY_CURRENT_USER
HKEY_LOCAL_MACHINE
HKEY_USERS
HKEY_PERFORMANCE_DATA
HKEY_DYN_DATA
HKEY_CURRENT_CONFIG
Module
Module_Raw
REGISTRY
CWudfDriverTable::Remove
Can't delete object
Leaking WDF objects, use !wudfext.wudfdumpobjects %p to find the leaks
CWudfDriverGlobals::~CWudfDriverGlobals
Thread 0x%p is %s 0x%p
BCWdfUserObject::AcquireLock is not implemented
CWdfUserObject::AcquireLock
drivers\wdf\umdf\driverhost\framework\v1\wudf\wdfuserobject.h
CWdfUserObject::ReleaseLock is not implemented
CWdfUserObject::ReleaseLock
CWdfUserObject::CreateAndInitialize
CWdfUserObject
IWDFObject
CWdfDriver
IWDFDriver
pDevStack should not be NULL
CWdfDriver::OnAddDevice
KernelDeviceName should not be NULL
hPdoKey is not a valid handle
pwszServiceName should not be NULL
pwszDeviceInstanceId should not be NULL
m_DevInit should be NULL
CWdfDriver::CreateDevice
ppDevice should not be NULL
m_DevInit->m_pCreatedDevice should be NULL
CWdfDriver::CreateWdfObject
ppObject should not be NULL
pBuff should not be NULL
CWdfDriver::CreateWdfMemory
CWdfDriver::IsVersionAvailable
pMinimumVersion should not be NULL
CWdfDriver::RetrieveVersionString
pdwVersionLength should not be NULL
User Mode Driver Framework version 1.11.0
gCWdfDeviceInit::SetFilter
Invalid value supplied for locking model.
CWdfDeviceInit::AutoForwardCreateCleanupClose
State is not a valid WDF_TRI_STATE
fTrue is not a valid BOOL
CWdfDeviceInit::SetPnpCapability
Value is not a valid WDF_TRI_STATE
Invalid pnp capability.
CWdfDeviceInit::GetPnpCapability
CWdfDeviceInit::GetPnpCapabilityInternal
CWdfDeviceInit::RetrieveDevicePropertyStore
drivers\wdf\umdf\driverhost\framework\v1\wudf\wdfdeviceinit.cpp
ppPropStore should not be NULL
this->m_pwszConfigRegistryPath should not be NULL
CWdfDeviceInit::RetrieveDeviceInstanceId
CWdfDeviceInit::SetIoTypePreference
Invalid RetrievalMode
Invalid ReadWritePreference - UMDF driver cannot request METHOD_NEITHER I/O type
Invalid IoControlPreference - UMDF driver cannot request METHOD_NEITHER I/O type
Invalid ReadWritePreference
Invalid IoControlPreference
RetrievalMode must be DeferRetrieval when choosing any ReadWritePreference other than WdfDeviceIoBuffered
RetrievalMode must be DeferRetrieval when choosing any IoControlPreference other than WdfDeviceIoBuffered
CWdfDeviceInit::RetrieveUnifiedDevicePropertyStore
+ikY<
CWdfDevice::RegisterRemoteInterfaceNotification
drivers\wdf\umdf\driverhost\framework\v1\wudf\WdfDevice.h
IncludeExistingInterfaces is not a valid BOOL
Your Device callback object must support IPnpCallbackRemoteInterfaceNotification
CWdfDevice::AssignReferenceString
CWdfDevice::AssignCompositeInstanceID
CWdfDevice::AddCompositeHardwareID
CWdfDevice::AddCompositeCompatibleID
CWdfDevice::CommitTransportSettings
Unexpected
CWdfDevice::ReadRegister
CWdfDevice::ReadRegisterBuffer
CWdfDevice::WriteRegister
CWdfDevice::WriteRegisterBuffer
CWdfIoTarget::AssignContext
CWdfIoTarget::RetrieveContext
CWdfIoTarget::GetTargetFile
CWdfIoTarget::FormatRequestForWrite
CWdfIoTarget::GetState
CWdfIoTarget::Stop
CWdfIoTarget::FormatRequestForFlush
CWdfIoTarget::FormatRequestForSetInformation
CWdfIoTarget::FormatRequestForQueryInformation
CWdfWin32Target::GetTargetFile
drivers\wdf\umdf\driverhost\framework\v1\wudf\WdfWin32Target.h
m_pTargetFile should not be NULL
CWdfWin32Target::FormatRequestForRead
CWdfWin32Target::FormatRequestForWrite
CWdfWin32Target::FormatRequestForIoctl
CWdfWin32Target::FormatRequestForFlush
CWdfWin32Target::FormatRequestForSetInformation
CWdfWin32Target::FormatRequestForQueryInformation
CWdfDevice::~CWdfDevice
Internal consistency error: Queue is not in the m_Associated list
CWdfDevice::GetDefaultIoTarget
ppWdfIoTarget should not be NULL
pFxMessageDispatch should not be NULL
CWdfDevice::CreateFxFileForHostFile
pWudfFile should not be NULL
hFile is not a valid handle
CWdfDevice::CreateWdfFileForOpenHandle
CWdfDevice::GetDefaultIoQueue
ppWdfIoQueue should not be NULL
CWdfDevice::CreateIoQueue
bDefaultQueue is not a valid BOOL
bPowerManaged is not a valid BOOL
bAllowZeroLengthRequests is not a valid BOOL
ppIoQueue should not be NULL
Enable is not a valid BOOL
CWdfDevice::RetrieveDeviceName
pdwDeviceNameLength should not be NULL
hr != E_NOT_SUFFICIENT_BUFFER
pdwDevInstLength should not be NULL
CWdfDevice::RetrieveDevicePropertyStore
this->m_pwszDeviceKeyPath should not be NULL
pbData should not be NULL
m_IPnpCallback should be NULL
m_IPnpCallbackHardware should be NULL
m_IPnpCallbackHardware2 should be NULL
m_IPnpCallbackSelfManagedIo should be NULL
m_IPnpCallbackHardwareInterrupt should be NULL
m_IPowerPolicyCallbackWakeFromS0 should be NULL
m_IPowerPolicyCallbackWakeFromSx should be NULL
CWdfDevice::DeleteDeviceFromFailedCreate
m_IDeviceUnknown should be NULL
m_CleanupCallback should be NULL
m_CloseCallback should be NULL
m_pAttachedIWudfDevice should be NULL
m_pIWudfDevice should not be NULL
pReadIrp should not be NULL
CWdfDevice::ReadFile
pWriteIrp should not be NULL
CWdfDevice::WriteFile
pFlushIrp should not be NULL
CWdfDevice::FlushBuffers
CWdfDevice::QueryInformationFile
CWdfDevice::SetInformationFile
CWdfDevice::RemoteInterfaceArrival
pSymbolicLink should not be NULL
WUDF_INTERFACE_CONTEXT_INVALID != RemoteInterfaceID
CWdfDevice::RemoteInterfaceRemoval
pQueueObj should not be NULL
CWdfDevice::ConfigureForwarding
Invalid parameters
CWdfDevice::ConfigureRequestDispatching
Forward is not a valid BOOL
CWdfDevice::SetPnpState
Invalid State passed in as an argument
Invalid pnp state.
CWdfDevice::GetPnpState
CWdfDevice::CommitPnpState
Invalid host irp
CWdfDevice::AcquireLock
AcquireLock: Invalid operation. The device is not configured to have callback lock
CWdfDevice::ReleaseLock
ReleaseLock: Invalid operation. The device is not configured to have callback lock
Invalid request type
CWdfDevice::CreateUsbTargetDevice
UmdfDispatcher should be set to WinUsb
CWdfDevice::CreateFileHandleTarget
ppTarget should not be NULL
hTarget is not a valid handle
UmdfDispatcher should be set to FileHandle
CWdfDevice::CreateRemoteTarget
ppRemoteTarget should not be NULL
CWdfDevice::CreateRemoteInterface
ppRemoteInterface should not be NULL
pRemoteInterfaceInit should not be NULL
Invalid pRemoteInterfaceInit parameter, this object should be created by the framework.
CWdfDevice::CreateSymbolicLinkW
Invalid input parameter
CWdfDevice::CreateSymbolicLinkWithReferenceString
Invalid input paramater
CWdfDevice::RegisterRemoteInterfaceNotificationInternal
CWdfDevice::AssignS0IdleSettings
Enabled is not a valid WDF_TRI_STATE
IWDFDevice::AssignS0IdleSettings can be called by the power policy owner only
CWdfDevice::AssignS0IdleSettingsEx
IdleSettings->Enabled is not a valid WDF_TRI_STATE
A parameter (DxState, IdleCaps, Enabled, or UserControlOfIdleSettings) is out range
CWdfDevice::AssignSxWakeSettings
IWDFDevice::AssignSxWakeSettings can be called by the power policy owner only
A parameter (DxState, Enabled, or UserControlOfWakeSettings) is out range
CWdfDevice::StopIdle
WaitForD0 is not a valid BOOL
IWDFDevice::StopIdle can be called by the power policy owner only
CWdfDevice::ResumeIdle
IWDFDevice::ResumeIdle can be called by the power policy owner only
LengthCb is not initialized to the size of WDF_PROPERTY_STORE_ROOT
Root class must be WdfPropertyStoreRootClassHardwareKey or WdfPropertyStoreRootClassHardwareKey for unified property store.
ServiceName must be NULL while using WdfPropertyStoreRootClassHardwareKey with unified property store.
CWdfDevice::MapIoSpace
PhysicalAddress.QuadPart should not be NULL
NumberOfBytes should be > 0
CacheType incorrect
PseudoBaseAddress should not be NULL
CWdfDevice::UnmapIoSpace
Driver attempted to unmap incorrect register address, or provided incorrect size
CWdfDevice::GetHardwareRegisterMappedAddress
Incorrect register access mode. Register mapping to user-mode is not enabled. Set the INF directive UmdfRegisterAccessMode to RegisterAccessUsingUserModeMapping in driver's INF file to enable Register mapping to user-mode
Driver provided incorrect base address
Buffer should be NULL
Count should be 0
Driver attempted to read from invalid port address or address range
CWdfDevice::WriteToHardware
Integer overflow occurred when computing length of write access
Driver attempted to write to invalid register address or address range
Driver attempted to write to invalid port address or address range
CWdfDevice::CreateInterrupt
Configuration should not be NULL
ppInterrupt should not be NULL
Size member of Configuration incorrect
Configuration->ShareVector is not a valid WDF_TRI_STATE
Configuration->AutomaticSerialization is not a valid BOOL
Configuration->OnInterruptIsr should not be NULL
IWDFInterrupt can only be created during: (1) OnDeviceAdd when the IWDFDevice %p is initially created, or (2) OnPrepareHardware
Non-NULL InterruptRaw or InterruptTranslated in WUDF_INTERRUPT_CONFIG structure not allowed in OnDeviceAdd callback
NULL InterruptRaw or InterruptTranslated in WUDF_INTERRUPT_CONFIG structure not allowed in OnPrepareHarwdare callback.
Driver cannot specify ShareVector different from WdfUseDefault in OnPrepareHardware callback.
Validation of resources failed. See Trace log for details
Driver opted for AutomaticSerialization but the locking constraint is not set correctly to WdfDeviceLevel. 
Invalid paramater: pConfig parameter is NULL
CWdfDevice::CreateWorkItem
Invalid paramater: ppWorkItem parameter is NULL
Size member of pConfig incorrect
Invalid paramater: OnWorkItemFunc parameter is NULL
Driver set AutomaticSerialization to TRUE in workitem  config structure but it has explicitly set Locking Constraint to None. 
Invalid paramater: ppHidInterface parameter is NULL
CWdfDevice::CreateHidInterface
Hid interface must be created in OnDeviceAdd.
pszString should not be NULL
CStringID::CreateAndInitialize
drivers\wdf\umdf\driverhost\framework\v1\wudf\WdfTransportSettings.h
ppStringID should not be NULL
Transport Settings are already committed. 
CWdfTransportSettings::AssignReferenceString
pcwszTransportReferenceString should not be NULL
ReferenceString has already been assigned.
ReferenceString is too long
ReferenceString must be at least 1 character.
CWdfTransportSettings::AssignCompositeInstanceID
pcwszInstanceID should not be NULL
InstanceID has already been assigned.
InstanceID too long. HardwareID + InstanceID must be less than MAX_DEVICE_ID_LEN.
InstanceID string must be at least 1 character.
CWdfTransportSettings::AddCompositeHardwareID
CWdfTransportSettings::AddCompositeCompatibleID
pszNewID should not be NULL
CWdfTransportSettings::AddID
Added ID string must be at least one character.
(cchNewID + cchInstanceID) must be less than (MAX_DEVICE_ID_LEN - 1).
NewID must be less than MAX_DEVICE_ID_LEN.
The list of CompatibleIDs cannot be longer than REGSTR_VAL_MAX_HCID_LEN.
CWdfTransportSettings::CommitTransportSettings
Transport Settings are not valid, please call AssignCompositeInstanceID(...) first.
Transport Settings are not valid, please call AddCompositeHardwareID(...) first.
cchString >= REGSTR_VAL_MAX_HCID_LEN
CWdfTransportSettings::TransportQueryHardwareCompatibleID
The HCID should never get so long that we don't have enough room in the buffer.
Transport Settings should be committed.
CWdfTransportSettings::TransportQueryID
cbDataBufferSize > m_cchCompositeInstanceID * sizeof(WCHAR)
cbDataBufferSize > m_cchCompositeHardwareIDs * sizeof(WCHAR)
cbDataBufferSize > m_cchCompositeCompatibleIDs * sizeof(WCHAR)
Valid ID Characters can only be between 0x20 and 0x7F (inclusive), but not 0x2C(',')
CWdfTransportSettings::VerifyCharactersForID
ReferenceString cannot contain any path separator characters ('\' or '/')
CWdfTransportSettings::VerifyCharactersForReferenceString
CWdfIoQueue::ConfigureRequestDispatching
CWdfIoQueue::GetDevice
CWdfIoQueue::Start
CWdfIoQueue::ProcessStopComplete
CWdfIoQueue::Stop
CWdfIoQueue::Drain
CWdfIoQueue::DrainSynchronously
CWdfIoQueue::Purge
CWdfIoQueue::PurgeSynchronously
CWdfIoQueue::RetrieveNextRequestByFileObject
m_IQueueUnknown should be NULL
pCreateCallback should be NULL
pWriteCallback should be NULL
pDevIoControlCallback should be NULL
pDefaultIoCallback should be NULL
pIoStop should be NULL
pIoResume should be NULL
pIoCanceledOnQueue should be NULL
Locking model problem should have been caught earlier
Request is not owned by the driver and hence it cannot have a callback event.
Request being completed is on a cancellation list for a queue.
CWdfIoQueue::QueueRequest
CWdfIoQueue::ProcessCancelledRequestsOnQueue
CWdfIoQueue::QueueRequestFromForward
Request is not owned by the driver and hence it cannot be forwarded.
Request is cancelable and hence it cannot be forwarded. Call IWDFRequest::UnmarkCancelable before forwarding to another queue.
Invalid operation: Requeue is allowed only for a manual queue.
CWdfIoQueue::RequeueRequest
Not an error: Testing cancel
CWdfIoQueue::CancelForDriver
CWdfIoQueue::HostIrpCancelForDriver
CWdfIoQueue::AcquireLock
pLock should not be NULL
CWdfIoQueue::ReleaseLock
Don't yet support tagged requests
TODO: Write something meaningful
CWdfIoQueue::FlushByFileObject
The queue state change notify method should not have been NULL.
CWdfIoQueue::DeleteWdfObject
Queue is being deleted while it is in a state to accept requests
Queue is being deleted while it has queued and driver-pending requests
CWdfIoQueue::QueuePurge
CWdfIoQueue::GetRequest
Driver called IWDFIoQueue::RetrieveNextRequest on a sequential queue with no outstanding requests. Driver must call IWDFIoQueue::RetrieveNextRequest before completing the current request
waiting for all threads to stop dispatching requests so that queue can be powered off, IWDFIoQueue
Power managed queue must be in powered  off state during FxIoStopProcessingForPowerPurgeNonManaged
CWdfIoQueue::StopProcessingForPower
Non-power managed queue must be in powered on state in during FxIoStopProcessingForPowerPurgeNonManaged
Non-Power managed queue must be in  powered on state during FxIoStopProcessingForPowerPurgeManaged
Unknown power action in CWdfIoQueue::StopProcessingForPower
pIWdfQueue should not be NULL
pIWdfReq should not be NULL
Invalid power state
Request is not power stop acknowledged.
CWdfIoQueue::ProcessAcknowledgedRequests
without
Queue doesn't handle this type of request
CWdfIoQueue::IsIoEventHandlerRegistered
Non Io Irp passed to CopyParameters
FxIoContext::CopyParameters
m_pWdfDevice should not be NULL
CWdfIoTarget::Dispose
DeleteTimerQueueEx failed unexpectedly
CWdfIoTarget::SubmitPendedRequest
CWdfIoTarget::GotoStartState
CWdfIoTarget::DrainPendedRequestsLocked
CWdfIoTarget::GotoCloseState
CWdfIoTarget::_RequestCancelled
CWdfIoTarget::HandleFailedResubmit
Request is being formatted with a non-NULL framework file that has a NULL host file object. This can happen if the request is formatted with a driver-created file that has already been closed.
CWdfIoTarget::_FormatIoctlRequest
Invalid request type passed to FormatGetSetInformationRequest
CWdfIoTarget::FormatGetSetInformationRequest
Invalid request type passed to _FormatGetSetInformationRequest
CWdfIoTarget::_FormatGetSetInformationRequest
Invalid parameter in callback
CWudfOneShotTimer::TimerCallback
drivers\wdf\umdf\driverhost\framework\v1\wudf\WudfOneShotTimer.h
DeleteTimerQueueTimer failed with an error other than ERROR_IO_PENDING
CWudfOneShotTimer::~CWudfOneShotTimer
ppTimer should not be NULL
CWudfOneShotTimer::CreateAndInitialize
ChangeTimerQueueTimer failed
CWudfOneShotTimer::Set
Timer canceled but is not set
CWudfOneShotTimer::Cancel
DeleteTimerQueueTimer failed
CWdfIoRequest::RetrieveContext
CWdfIoRequest::FormatUsingCurrentType
CWdfIoRequest::IsFrom32BitProcess
CWdfIoRequest::GetRequestorMode
Requestor mode is neither KernelMode nor UserMode
CWdfIoRequest::IsFromUserModeDriver
CWdfIoRequest::GetWriteParameters
Request was not formatted as a Write request on the way down
CWdfIoRequest::GetReadParameters
Request was not formatted as a Read request on the way down
CWdfIoRequest::SetUserModeDriverInitiatedIo
CWdfIoRequest::GetUserModeDriverInitiatedIo
CWdfIoRequest::RetrieveActivityId
ActivityId should not be NULL
CWdfIoRequest::SetActivityId
Completing a cancelable request. This can result in a race condition that causes double completion. Call IWDFIoRequest::UnMarkCancelable before IWDFIoRequest::Complete
This type of request should have information parameter set to zero
CWdfIoRequest::GetCreateParameters
Invalid operation. Request type is not Create
CWdfIoRequest::GetCreateParametersEx
Invalid operation. Request type is not Read
Invalid operation. Request type is not Write
Bad driver parameter
Request doesn't belong to any queue
WDF_REQUEST_SEND_OPTION impersonation flags may only be set on Create requests.
Driver must set WDF_REQUEST_SEND_OPTION_IMPERSONATION_IGNORE_FAILURE with WDF_REQUEST_SEND_OPTION_IMPERSONATE_CLIENT.
CWdfRequest is already in queue
CWdfIoRequest::InsertHeadRequestQueue
CWdfIoRequest::_TimerCallback
pTimer should not be NULL
CWdfIoRequest::CreateTimer
pReqCtx should not be NULL
CWdfIoRequest::_CancelRoutine
pReqObj should not be NULL
The canceled irp is not same as irp associated with thie request object
Pulled request from the CSQ without it having been cancelled
CWdfIoRequest::RemoveFromRequestQueue
CWdfIoRequest::GetIoQueue
CWdfIoRequest::RetrieveInputBuffer
CWdfIoRequest::RetrieveOutputBuffer
CWdfIoRequest::GetEffectiveIoType
CWdfIoRequest::IsCanceled
CWdfIoRequest::GetStatus
CWdfIoRequest::StopAcknowledge
Requeue is not a valid BOOL
CWdfIoRequest::Requeue
Invalid operation: IWDFIoRequest doesn't belong to queue.
CWdfIoRequest::GetQueryInformationParameters
Invalid operation. Request type is not QueryInformation
CWdfIoRequest::GetSetInformationParameters
Invalid operation. Request type is not SetInformation
Request is not owned by the driver.
CWdfIoRequest::VerifierVerifyRequestIsDriverOwned
Request should be unmarked cancelable by calling IWDFRequest::UnmarkCancelable.
CWdfIoRequest::VerifierVerifyRequestIsNotCancelable
StopAcknowledge can only be called from the IQueueCallbackIoStop callback.
CWdfIoRequest::VerifierVerifyRequestIsInIQueueCallbackIoStopContext
LCWdfFile::RetrieveCountedFileName
CWdfFile::GetRelatedFileObject
ppRelatedFileObj should not be NULL
|EventSetInformation
APPID
FCWdfRequestQueue::CancelRoutineInternal
p->m_CancelCallback should not be NULL
CWdfRequestQueue::IsRequestInQueue
5CWdfMemoryBuffer::CopyToBuffer
CWdfMemoryBuffer::CopyFromBuffer
CWdfMemoryBuffer::CopyFromMemory
Source should not be NULL
Invalid parameter: zero buffer size
cbDataLength not sizeof(DWORD)
cbDataLength not sizeof(QWORD)
CWdfUtilRegPropVariantConv::PropVariantToRegistryValue
unexpected registry value type
If previous block succeeds, pwszCurrentElement must not be NULL
CWdfUtilRegPropVariantConv::MultiSzToWstrArray
CWdfUtilRegPropVariantConv::WstrToByteArray
CWdfUtilRegPropVariantConv::WstrArrayToByteArray
pwsz should not be NULL
CWdfUtilRegPropVariantConv::IsExpandSz
psz should not be NULL
lyCWdfRegPropertyStore::GetNameCount
drivers\wdf\umdf\driverhost\framework\v1\wudf\wdfregpropertystore.cpp
CWdfRegPropertyStore::GetNameAt
CWdfRegPropertyStore::GetNamedValue
CWdfRegPropertyStore::SetNamedValue
CWdfRegPropertyStore::DeleteNamedValue
Registry key handle was invalid or already closed
CWdfRegPropertyStore::Reset
CWdfRegPropertyStore::CreateDevicePropertyStore
aL@]VDriverCreatedFile was released without a preceding Close operation
CWdfDriverCreatedFile::~CWdfDriverCreatedFile
drivers\wdf\umdf\driverhost\framework\v1\wudf\WdfDriverCreatedFile.h
CWdfDriverCreatedFile::AssignContext
CWdfDriverCreatedFile::RetrieveContext
CWdfDriverCreatedFile::DeleteWdfObject
CWdfDriverCreatedFile::AcquireLock
CWdfDriverCreatedFile::ReleaseLock
CWdfDriverCreatedFile::RetrieveFileName
CWdfDriverCreatedFile::GetDevice
CWdfDriverCreatedFile::RetrieveCountedFileName
CWdfDriverCreatedFile::GetRelatedFileObject
CWdfDriverCreatedFile::Close
drivers\wdf\umdf\driverhost\framework\v1\wudf\wdfdrivercreatedfile.cpp
*e>aCWdfUsbTargetDevice::FormatRequestForRead
Cannot format a request targeted to USB device for read, call this method on appropriate pipe instead
CWdfUsbTargetDevice::FormatRequestForWrite
Cannot format a request targeted to USB device for write, call this method on appropriate pipe instead
CWdfUsbTargetDevice::GetNumInterfaces
CWdfUsbTargetDevice::GetWinUsbHandle
CWdfUsbTargetDevice
IWDFUsbTargetDevice
Buffer && BufferLength should not be NULL
CWdfUsbTargetDevice::RetrieveDeviceInformation
CWdfUsbTargetDevice::RetrievePowerPolicy
CWdfUsbTargetDevice::RetrieveDescriptor
CWdfUsbTargetDevice::SetPowerPolicy
8>fuA
CWdfUsbInterface::GetInterfaceDescriptor
UsbAltInterfaceDescriptor should not be NULL
CWdfUsbInterface::GetNumEndPoints
CWdfUsbInterface::GetInterfaceNumber
CWdfUsbInterface::GetConfiguredSettingIndex
IWDFUsbInterface
CWdfUsbInterface
drivers\wdf\umdf\driverhost\framework\v1\wudf\wdfusbinterface.cpp
CWdfUsbInterface::Initialize
CWdfUsbInterface::Dispose
Preallocated request needed for release is NULL
CWdfUsbInterface::RetrieveAssociatedInterfaceHandle
pInterfaceHandle should not be NULL
USB Interface handle is invalid
CWdfUsbInterface::ReleaseAssociatedInterfaceHandle
Unexpected failure in releasing associated interface
Unexpected failure in request send
CWdfUsbInterface::SelectSetting
CWdfUsbInterface::RetrieveInterfaceDescriptor
ppUsbPipe should not be NULL
CWdfUsbInterface::RetrieveUsbPipeObject
Cannot format a request targeted to USB pipe for Ioctl, use FormatControlTransfer on USB target device instead
CWdfUsbTargetPipe::FormatRequestForIoctl
NumReaders should be > 0
CWdfUsbPipeContinuousReader::operator new
CWdfUsbPipeContinuousReader::~CWdfUsbPipeContinuousReader
Refcount on Continuous reader should be  0
CWdfUsbPipeContinuousReader::Config
Failed read work-item should not be set for re-running
CWdfUsbPipeContinuousReader::QueueWorkItemLocked
CWdfUsbPipeContinuousReader::ResubmitRepeater
Canceled request should have a canceled HRESULT
Context should be NULL when done
Read Failed Handler should be in progress
CWdfUsbTargetPipe::Reset
CWdfUsbTargetPipe::Abort
CWdfUsbTargetPipe::Flush
There should be no Sent Io
List should be empty
CWdfUsbTargetPipe::GotoStartState
CWdfUsbTargetPipe::ConfigureContinuousReader
pRequest->m_DrainSingleEntry.Next should be NULL
TransferLength can't be  0
pOnCompletion should not be NULL
CWdfWin32Target
CWdfRemoteInterfaceInit::GetInterfaceGuid
drivers\wdf\umdf\driverhost\framework\v1\wudf\WdfRemoteInterfaceInit.h
pwszSymbolicLink should not be NULL
drivers\wdf\umdf\driverhost\framework\v1\wudf\wdfremoteinterfaceinit.cpp
CWdfRemoteInterfaceInit::CreateAndInitialize
CWdfRemoteInterfaceInit::RetrieveSymbolicLink
ppRemoteInterfaceInit should not be NULL
pdwStringLength should not be NULL
RemoteInterface should only be destroyed after all RemoteTarget objects have unregistered
drivers\wdf\umdf\driverhost\framework\v1\wudf\WdfRemoteInterface.h
CWdfRemoteInterface::~CWdfRemoteInterface
CWdfRemoteInterface::Initialize
m_spRemovalCallback.p should be NULL
CWdfRemoteInterface::AssignContext
m_spCustomEventCallback.p should be NULL
CWdfRemoteInterface::DeleteWdfObject
CWdfRemoteInterface::RetrieveContext
IWDFRemoteInterface
CWdfRemoteInterface
CWdfRemoteInterface::CreateAndInitialize
IWudfTargetCallbackDeviceChange
This RemoteInterface has been Removed/Destroyed. To reopen the device, save a copy of the SymbolicLinkName and call IWDFRemoteTarget::OpenByFileName(...).
drivers\wdf\umdf\driverhost\framework\v1\wudf\wdfremoteinterface.cpp
IsListEmpty(&m_TargetQueryRemovedList)
CWdfRemoteInterface::GetSymbolicLink
RemoteTarget notified of RemoveCanceled, yet is still registered as QueryRemoved.
CWdfRemoteInterface::OnQueryRemove
pTarget should not be NULL
CWdfRemoteInterface::OnRemoveCanceled
pRegistrationID should not be NULL
CWdfRemoteInterface::RegisterTargetDeviceNotification
Could not find CWdfRemoteTarget in m_TargetList. Perhaps CloseForQueryRemove() was called twice?
CWdfRemoteInterface::OnClosedForQueryRemove
Could not find CWdfRemoteTarget in either list
CWdfRemoteInterface::UnregisterTargetDeviceNotification
m_RemoteInterfaceNotificationCallback should be NULL
CWdfRemoteInterfaceList::CreateRemoteInterface
CWdfRemoteInterfaceList::DispatchArrival
pRemoteInterface should be NULL
pRemoteInterfaceInit object has already been used in a previous call to CreateRemoteInterface(), or is being used outside the callback in which it was delivered.
CWdfRemoteTarget::AssignContext
CWdfRemoteTarget::RetrieveContext
CWdfRemoteTarget::Dispose
IWDFRemoteTarget::WdfDeleteObject() cannot be called from within a IWDFRemoteTarget callback.
IWDFRemoteTarget never has a IWDFFile, do not call this method.
IWDFRemoteTarget::Close() must be called before IWDFRemoteTarget::WdfDeleteObject().
CWdfRemoteTarget::FormatRequestForRead
CWdfRemoteTarget::GetTargetFile
CWdfRemoteTarget::FormatRequestForFlush
CWdfRemoteTarget::FormatRequestForQueryInformation
CWdfRemoteTarget::FormatRequestForSetInformation
CWdfRemoteTarget::Start
CWdfRemoteTarget::GetState
CWdfRemoteTarget
CWdfRemoteTarget::Stop
CWdfRemoteTarget::CreateAndInitialize
IWDFRemoteTarget
INVALID_HANDLE_VALUE == m_pRemoteDispatcher->GetHandle()
drivers\wdf\umdf\driverhost\framework\v1\wudf\wdfremotetarget.cpp
m_pRemoteInterface should be NULL
CWdfRemoteTarget::OpenTargetHandle
m_DriverCallbackThreadID == 0
FAILED(hr)
m_DriverCallbackThreadID == GetCurrentThreadId()
CWdfRemoteTarget::SetCallbackInProgress
Driver must successfully call IWDFRemoteTarget::Close() or CloseForQueryRemove() before returning TRUE from OnRemoteTargetQueryRemove().
CWdfRemoteTarget::SetCallbackComplete
Driver must successfully call IWDFRemoteTarget::Close() before returning from OnRemoteTargetRemoveComplete().
CWdfRemoteTarget::OnQueryRemove
pRemoteInterface argument must have been created from IWDFDevice::CreateRemoteInterface() method
CWdfRemoteTarget::OnRemoveComplete
pWdfRemoteInterface should not be NULL
CWdfRemoteTarget::OpenRemoteInterface
pwszBaseFilePath should not be NULL
Cannot call IWDFRemoteTarget::OpenRemoteInterface() when it is already open. Call Close() first.
%s\%s
pwszRelativeFileName is too long
CWdfRemoteTarget::OpenFileByName
pcwszFullPath should not be NULL
pcwszFullPath is too long or is an empty string
Cannot call IWDFRemoteTarget::OpenFileByName() when it is already open. Call Close() first.
CWdfRemoteTarget::CloseForQueryRemove
CWdfRemoteTarget::Close
CWdfRemoteTarget::Reopen
IWDFRemoteTarget::Reopen() method requires the state to be WdfIoTargetClosedForQueryRemove
m_pwszFullPath should not be NULL
FxTransactionedListUm::~FxTransactionedListUm
Destroying locked transacted list
Entry has an add transaction pending but is already on the list
Expected a pending transaction
Expected only add transactions
FxTransactionedListUm::ProcessTransactionList
List is emtpy
FxTransactionedListUm::RemoveLocked
CWudfObjectEx::RetrieveObjectContext
ppvContext should not be NULL
WudfToWdfTriState
Unknown enum value
WdfToWudfTriState
drivers\wdf\umdf\driverhost\framework\v1\wudf\wudfenumtranslation.cpp
WUDFx!CWdfUnifiedPropertyStore
CWdfUnifiedPropertyStore
IWDFUnifiedPropertyStore
CWdfUnifiedPropertyStore::GetPropertyData
PropertyDataRequiredSize should not be NULL
PropertyType should not be NULL
%s:%u(%S)
CreateThreadpoolTimer
kernel32.dll
WaitForThreadpoolTimerCallbacks
SetThreadpoolTimer
SubmitThreadpoolWork
CreateThreadpoolWork
CloseThreadpoolWork
CloseThreadpoolTimer
\Callback\PowerState
GetActiveProcessorGroupCount
kernel32.dll
drivers\wdf\umdf\driverhost\framework\v1\minkernel_shared_v11\irphandlers\pnp\interruptobject.cpp
False
drivers\wdf\umdf\driverhost\framework\v1\minkernel_shared_v11\irphandlers\pnp\fxpkgfdo.cpp
*njkH
IdleInWorkingState
WdfDefaultIdleInWorkingState
WakeFromSleepState
WdfDefaultWakeFromSleepState
<no typename given>
drivers\wdf\umdf\driverhost\framework\v1\minkernel_shared_v11\object\handleapi.cpp
VerSetConditionMask
TrackHandles
VerifierAllocateFailCount
VerboseOn
VerifyDownLevel
VerifierOn
TrackDriverForMiniDumpLog
ForceLogsInMiniDump
DsfOn
RequestParentOptimizationOn
RtlQueryRegistryValuesEx
RemoveLockOptionFlags
VerifyOn
ntdll.dll
DbgBreakOnDeviceStateError
DbgBreakOnError
WDFOBJECT
drivers\wdf\umdf\driverhost\framework\v1\minkernel_shared_v11\object\fxobjectstatemachine.cpp
FxObject
FxCmResList
FxUserObject
FxPkgFdo
WDFCMRESLIST
drivers\wdf\umdf\DriverHost\Framework\V1\minkernel_shared_v11\inc\private\common\FxCollection.hpp
RJPbg
B#eeP
Driver Version: %d.%d Kmdf Lib. Version: %d.%d
KmdfLibrary
FxDeviceToMx::FxPkgIo_ResetStateForRestart
FxDeviceToMx::FxPkgIo_ResetStateForRestart not implemented for UMDF
FxDeviceToMx::GetParentDevicePnpPkg not implemented for UMDF
FxDeviceToMx::GetParentDevicePnpPkg
FxDeviceToMx::GetParentDevice not implemented for UMDF
FxDeviceToMx::GetParentDevice
FxDeviceToMx::GetPdoPkg(AWDFDevicePtr) not implemented for UMDF
FxDeviceToMx::GetPdoPkg
FxDeviceToMx::GetDriverGlobals
FxDeviceToMx::GetDriverGlobals not implemented for UMDF
FxDeviceToMx::GetFxDevice
FxDeviceToMx::GetFxDevice not implemented for UMDF
FxDeviceToMx::GetAttachedDeviceReference not implemented for UMDF
FxDeviceToMx::GetAttachedDeviceReference
FxIoTargetToMx::GetFxObject not implemented for UMDF
FxIoTargetToMx::GetFxObject
FxIrp::SendIrpSynchronously
INFNITE wait failed
Not implemented
To be implemented
FxIrp::GetParameterQueryInterfaceInterface
FxIrp::GetParameterQDRType
FxIrp::GetParameterQueryInterfaceVersion
FxIrp::GetParameterQueryInterfaceType
FxIrp::GetParameterQueryInterfaceInterfaceSpecificData
FxIrp::GetParameterQueryInterfaceSize
FxIrp::GetParameterUsageNotificationInPath
FxIrp::GetParameterUsageNotificationType
FxIrp::SetParameterAllocatedResources
FxIrp::SetParameterAllocatedResourcesTranslated
FxIrp::AllocateIrp
FxIrp::GetIrpFromListEntry
Mx::MxBugCheckEx
WDF Violation: Please check tracelog for description of error.
WDF detected an invalid operation: Please check tracelog for description of error.
drivers\wdf\umdf\driverhost\framework\v1\fxtosharedinterface\fxverifier\ufxverifier.cpp
WDF detected an invalid device state: Please check tracelog for description of error.
FxVerifierDbgBreakPoint
Not implemented for UMDF. Framework should not be invoking this code.
FxVerifierBreakOnDeviceStateError
UfxVerifierTrapNotImpl
FxPox::_PoxRegisterDevice is not implemented
drivers\wdf\umdf\driverhost\framework\v1\fxtosharedinterface\fxpox\fxpoxum.cpp
FxPox::_PoxRegisterDevice
FxPox::_PoxUnregisterDevice
FxPox::_PoxUnregisterDevice is not implemented
FxPox::_PoxActivateComponent
FxPox::_PoxActivateComponent is not implemented
FxPox::_PoxIdleComponent
FxPox::_PoxIdleComponent is not implemented
FxPox::_PoxReportDevicePoweredOn
FxPox::_PoxReportDevicePoweredOn is not implemented
FxPox::_PoxSetDeviceIdleTimeout
FxPox::_PoxSetDeviceIdleTimeout is not implemented
T9FG!
UmdfV1DriverInfo
DriverImageName
UmdfVersion
DriverVersion
DriverConfigInfo
IsFilter
IsPowerPolicyOwner
IsS0IdleWakeFromS0Enabled
IsS0IdleUsbSSEnabled
IsS0IdleSystemManaged
IsSxWakeEnabled
IsUsingLevelTriggeredLineInterrupt
IsUsingEdgeTriggeredLineInterrupt
IsUsingMsiXOrSingleMsi22Interrupt
IsUsingMsi22MultiMessageInterrupt
IsUsingMultipleInterrupt
IsDirectHardwareAccessAllowed
IsUsingUserModemappingAccessMode
IsKernelModeClientAllowed
IsNullFileObjectAllowed
IsPoolingDisabled
IsMethodNeitherActionCopy
IsUsingDirectIoForReadWrite
IsUsingDirectIoForIoctl
IsUsingDriverWppRecorder
SetupClass
BusEnumerator
HardwareId
PoolGroupId
Manufacturer
Microsoft.Wdf.UMDF.FxV1
RSDSJ~
WUDFx.pdb
.text
.text$di
.text$lp00SPGO
.text$mn
.text$mn$00
.text$x
.text$yd
PAGEWdfV
.rdata$brc
.idata$5
.00cfg
.CRT$XCA
.CRT$XCL
.CRT$XCU
.CRT$XCZ
.CRT$XIA
.CRT$XIAA
.CRT$XIZ
.gehcont
.gfids
.giats
.rdata
.rdata$voltmd
.rdata$zETW0
.rdata$zETW1
.rdata$zETW2
.rdata$zETW9
.rdata$zzzdbg
.xdata
ATL$__a
ATL$__m
ATL$__z
.edata
.idata$2
.idata$3
.idata$4
.idata$6
.data$brc
.data
.pdata
.rsrc$01
.rsrc$02
WUDFx.DLL
DllCanUnloadNow
DllGetClassObject
Microsoft_WDF_UMDF_Version
_vsnwprintf_s
__C_specific_handler
memcpy_s
_purecall
malloc
wcsncpy_s
_vsnprintf_s
_wcsicmp
realloc
wcschr
strchr
_callnewh
_XcptFilter
_amsg_exit
_initterm
msvcrt.dll
_errno
_lock
_unlock
__dllonexit
_onexit
RtlInitUnicodeString
DbgPrint
RtlCaptureContext
RtlLookupFunctionEntry
RtlVirtualUnwind
ntdll.dll
EnterCriticalSection
LeaveCriticalSection
TryEnterCriticalSection
HeapFree
GetCurrentThreadId
CloseThreadpoolWait
CreateEventW
GetLastError
WaitForThreadpoolWaitCallbacks
SetEvent
CreateThreadpoolWait
CloseHandle
SetThreadpoolWait
HeapAlloc
GetProcessHeap
DebugBreak
CloseThreadpool
CreateThreadpool
SetThreadpoolThreadMinimum
SetThreadpoolThreadMaximum
GetSystemInfo
ResetEvent
InitializeCriticalSectionAndSpinCount
DeleteCriticalSection
SizeofResource
GetModuleFileNameW
InitializeCriticalSection
MultiByteToWideChar
RaiseException
FindResourceExW
LoadResource
GetProcAddress
GetModuleHandleW
FreeLibrary
lstrcmpiW
LoadLibraryExW
WaitForSingleObject
GetCurrentThread
GetCurrentProcess
DuplicateHandle
WaitForSingleObjectEx
CreateTimerQueue
DeleteTimerQueueEx
CreateTimerQueueTimer
ChangeTimerQueueTimer
DeleteTimerQueueTimer
SetLastError
GetModuleHandleExW
DisableThreadLibraryCalls
ExpandEnvironmentStringsW
Sleep
CreateFileW
UnhandledExceptionFilter
SetUnhandledExceptionFilter
TerminateProcess
QueryPerformanceCounter
GetCurrentProcessId
GetSystemTimeAsFileTime
GetTickCount
OutputDebugStringA
KERNEL32.dll
EventWriteTransfer
TraceMessage
RegDeleteValueW
RegOpenKeyExW
RegSetValueExW
RegEnumKeyExW
RegCreateKeyExW
RegQueryInfoKeyW
RegCloseKey
RegQueryValueExW
EventUnregister
UnregisterTraceGuids
RegisterTraceGuidsW
GetTraceEnableLevel
GetTraceEnableFlags
GetTraceLoggerHandle
EventRegister
RegEnumValueW
ADVAPI32.dll
OLEAUT32.dll
CharNextW
UnregisterClassA
USER32.dll
CoTaskMemAlloc
CoTaskMemFree
CoTaskMemRealloc
CoCreateInstance
api-ms-win-core-com-l1-1-0.dll
RtlCompareMemory
RtlInitAnsiString
RtlAnsiStringToUnicodeString
RtlCompareUnicodeString
RtlQueryRegistryValues
SetWaitableTimer
RegisterWaitForSingleObject
CancelWaitableTimer
LoadLibraryA
GetVersionExA
CreateWaitableTimerA
UnregisterWaitEx
SleepEx
GetModuleHandleA
TraceMessageVa
memcpy
memmove
memset
UMDF_VERSION
VS_VERSION_INFO
StringFileInfo
040904B0
CompanyName
Microsoft Corporation
FileDescription
WDF:UMDF Framework Library
FileVersion
10.0.22621.1 (WinBuild.160101.0800)
InternalName
Wudfx
LegalCopyright
 Microsoft Corporation. All rights reserved.
OriginalFilename
Wudfx.dll
ProductName
Microsoft
 Windows
 Operating System
ProductVersion
10.0.22621.1
VarFileInfo
Translation
