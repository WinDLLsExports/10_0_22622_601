!This program cannot be run in DOS mode.
Rich)
.text
h.rdata
H.data
.pdata
H.idata
HNONPAGE
`PAGEPcVfT+
`fothk
`.edata
@INIT
bGFIDS
B.rsrc
B.reloc
\$ E3
x ATAUAVH
fD9qHu
A^A]A\
x ATAUAVH
fD9qHu
A^A]A\
x AVH
D$(fD
L+A0A
WATAUAVAWH
fD9/t
A_A^A]A\_
t$ WH
L$ E3
x AVH
f9iHu
VWAUAVAWH
fD9yHu
A_A^A]_^
WATAUAVAWH
fD9YHu
A_A^A]A\_
fD9YHu
PcSrH
WAUAWH
D$(fD
A_A]_
AsrtH
AsrtH
x AVH
PcUsH
L9A0t
-fffffff
fffffff
fffffff
fffffff
.fffffff
fffffff
fffffff
fffff
AQAPRQPH
(D$ H
0XYZAXAY
ffffff
fffff
fffff
D$8fD
L9-R|
fD9qHu
L9-r{
fD9qHu
fD9+t
fD9/t
D$8fD
D$8fD
D$8fD
D$8fD
fD9YHu
UVWATAUAVAWH
C8;0u*E
D;kpu
D;ctu
 A_A^A]A\_^]
UVWATAUAVAWH
D$8fD
l$0IcA0= 
pA_A^A]A\_^]
x ATAVAWH
fD9aHu
D$8fD
A_A^A\
t$ WATAUAVAWH
A_A^A]A\_
x ATAVAWH
fD9aHu
A_A^A\
WATAUAVAWH
f9YHu
A_A^A]A\_
t$ WAVAWH
+|$Pu
 A_A^_
f9QHu
WAVAWH
A_A^_
WAVAWH
A_A^_
SUVWATAUAVAWH
D$(D+
xN9{hu*E3
L9%FQ
D$8fD
f9YHu
f9YHu
A_A^A]A\_^][
x AVH
f9QHu
WAVAWH
H9_`u0E2
'H9_`u!
tVHcC0L
A_A^_
D$8fD
x ATAUAVH
tWL;g0L
D$8fD
A^A]A\
x AVH
t$ WH
D$8fD
WAVAWH
f9YHu
D$8fD
A_A^_
f9qHu
{ AVH
D$(fD
UAVAWI
D$(fD
A_A^]
WAUAVH
A^A]_
L$XH3
x AUAVAWH
0A_A^A]
WAVAWH
 A_A^_
T$ E3
x AVH
R$fA;Z*
L$ E3
L$@H3
L$PH3
x AUAVAWH
fD93t
fD93t
D$(fD
A_A^A]
WAVAWH
fD93t
fD93t
D$(fD
A_A^_
WATAUAVAWH
t1L9r
 A_A^A]A\_
WAVAWH
 A_A^_
D$8fD
WATAUAVAWH
fD9iHu
|$XA+
fD9iHu
A_A^A]A\_
fD9iHu
|$XA+
\$8fD
fD9iHu
l$XA+
\$8fD
l$PA+
\$8fD
fD9iHu
l$XA+
\$8fD
f9yHu
D$8fD
D$pE3
VWATAUAWH
l$8fD
A_A]A\_^
WATAVH
fD9aHu
d$ E3
A^A\_
WATAUAVAWH
fD9+t
fD9/t
fD9+t
fD9/t
D$(fD
A_A^A]A\_
WATAUAVAWH
fD93t
fD93t
D$(fD
A_A^A]A\_
WATAUH
D$(fD
A]A\_
WATAUAVAWH
fD9#t
fD9't
fD9#t
fD9't
D$(fD
A_A^A]A\_
x AUAVAWH
fD9yHu
fD9yHu
A_A^A]
x ATAUAVH
A^A]A\
AUAVAWH
A_A^A]
x ATAUAVH
A^A]A\
ATAUAWH
A_A]A\
WATAUAVAWH
fD9aHu
fD9aHu
D$8fD
fD9aHu
D$8fD
A_A^A]A\_
f9yHu
f9yHu
f9yHu
x AVH
fD9qHu
x AVH
fD9qHu
f9qHu
\$(fD
D$(fD
x AVH
tAH9w
t-H9Y
x AVH
WAVAWH
A_A^_
x AVH
L$XE3
L$pH3
D$pE3
L$XE3
UWAVH
E0f!H
 A^_]
WATAUAVAWH
 A_A^A]A\_
t$ WATAUAVAWH
 A_A^A]A\_
UWAUAVAWH
`A_A^A]_]
VWAVH
D$PfD
D$Pf!H
 A^_^
WATAUAVAWH
 A_A^A]A\_
VWATAVAWH
D$`fD
 A_A^A\_^
H9G t^
p WAVAWH
0A_A^_
T$ E3
L$pH3
T$ E3
L$pH3
L+A0L
@USVWH
M0+S8H
E(+C8
C<9E8s
9Chu&
H_^[]
L9IHt
APL9IHt
O8H9Q
t)H+P
UWATAVAWH
L9e0u
 A_A^A\_]
UWAVH
E 9MH
 A^_]
L$ SUVWATAUAVAWH
XA_A^A]A\_^][
UVWATAUAVAWH
`A_A^A]A\_^]
t$ WATAUAVAWH
CXfD+
A_A^A]A\_
MXFpH
MXFbH
x AVH
9_ t.H
MXF H
x AVH
UWAWH
t$ WAVAWH
0A_A^_
D8E'tQ
D8E)t
D8E(t
VWAVH
t[9D$pD
WATAUAVAWH
A_A^A]A\_
x AVH
@USVWATAUAVAWH
d$0E3
hA_A^A]A\_^[]
WAVAWH
A_A^_
HcC0L
x AVH
{ AVH
T$ H;
{ AVH
H;D$0H
GD$0H
T$ H;
f9yHu
D$8fD
f9iHu
?9iXu-H
|$@fD
D$8fD
D$8fD
ATAVAWH
D$@fD
L9=9r
A_A^A\
f9qHu
D$8fD
D$8fD
WATAUAVAWH
f9qHu
A_A^A]A\_
x AVH
fD9qHu
UVWAVAWH
fD9yHu
D$8fD
|$ E3
}8L9>
A_A^_^]
x AVH
f9YHu
D$8fD
\$ E3
x AVH
D$8fD
D$8fD
f9qHu
D$8fD
VWAUAVAWH
t$8fD
D$@fD
A_A^A]_^
D$8fD
D$8fD
D$8fD
HcC0L
x AVH
H99uAH
x AVH
VWATAVAWH
D$PH;
 A_A^A\_^
VWATAVAWH
D$PH;
 A_A^A\_^
f9yHu
D$8fD
WATAUAVAWH
PcNtL
A_A^A]A\_
PcNt9Q
L$8fD
PcNttmL
D$8fD
D$8fD
D$8fD
D$8fD
f9qHu
D$8fD
x AVH
fD9qHu
D$(fD
VWATAVAWH
c\D8c8u5H
 A_A^A\_^
L$ SVWAVH
8A^_^[
f9Aju
x AVH
uYf9kjtS
S`H9*u
HcCpA
Ap9Alu
|$ UAVAWH
Bp9Bl
C Ic@lA;@pt=B
Ap9Al
 A_A^]
WAVAWH
@t fA
 A_A^_
ty!L$<H
f9AZu
u:fA9XZt3A
A!@`I
8A4tB
WAVAWH
 A_A^_
tv!L$<H
D8Ayt
VWATAUAWH
fD9iHu
O`fA;
H9ohtt
A_A]A\_^
QptmH
D$8fD
\$ UVWH
WAUAVH
fD9qHu
A^A]_
x AVH
YptrH
D$8fD
t$ WH
H9A0u
D9A@u
H9QHE
H9A0u
B@D9A@u
H9QHE
B@H9A@
{ AVH
D$(fD
s AWH
D$(fD
WAUAWH
D$(fD
A_A]_
L$8E3
x UATAUAVAWH
!|$@H
A_A^A]A\]
t8H9q
AsrtH
AsrtH
CPortTopology::Init
CPortWaveRT::Init
QpMiniportAudioSignalProcessing->Release()
ntStatus = Miniport->GetDescription(&m_pPcFilterDescriptor)
ntStatus = Miniport->GetDeviceDescription (&m_DeviceDescription)
ntStatus = Miniport->Init( UnknownAdapter, ResourceList, PPORTWAVERT(this) )
ntStatus = Miniport->Init( UnknownAdapter, ResourceList, PPORTTOPOLOGY(this))
cPinPropertyGetHWLatency
that->Stream->GetHWLatency (hwLatency)
PinPropertyNotificationEvent
ntStatus = that->StreamNotification->RegisterNotificationEvent( pNewEntry->pNotificationEvent )
CPortPinWaveRT::Init
Miniport->Release()
CPortFilterWaveRT::~CPortFilterWaveRT
DMiniport->AddRef()
CPortFilterWaveRT::Init
CPortFilterTopology::Init
CPortFilterTopology::~CPortFilterTopology
ntStatus = Port->Miniport->NewStream ( &Stream, PPORTWAVERTSTREAM(this), Id, Descriptor->DataFlow == KSPIN_DATAFLOW_OUT, DataFormat )
UYZPinPropertyGetAudioBuffer
ntStatus = that->StreamNotification->AllocateBufferWithNotification( that->rt.NotificationCount, propertyNotification->RequestedBufferSize, &that->rt.AudioBuffer.Mdl, &bufferSize, &byteOffset, &cacheType )
sPinPropertyGetPositionRegister
ntStatus = that->Stream->GetPositionRegister (mapping)
status = Stream->SetState(state)
CPortPinWaveRT::DistributeDeviceState
* 4H`
CPortPinWaveRT::~CPortPinWaveRT
mmres.dll
PowerSettings
ImmediateIdle
IdlePowerState
PerformanceIdleTime
ConservationIdleTime
]$C9"D
SingleComponentMultiFxStates
UsePositionLock
DispatchSettings
K::If
ResourceSet
Interrupt
RtlQueryRegistryValuesEx
\Registry\Machine\System\CurrentControlSet\Services\AudioSrv
InterruptAffinity
CoreAudioBufferDuration
ImagePath
XdvTimedFactor
IoCreateDeviceSecure
IoValidateDeviceIoControlAccess
PsGetVersion
EtwUnregister
WmiTraceMessage
WmiQueryTraceInformation
EtwRegisterClassicProvider
CPortPinWaveRT::Close
Stream->Release()
StreamNotification->Release()
StreamNotification->UnregisterNotificationEvent( pCurrentEntry->pNotificationEvent )
StreamNotification->FreeBufferWithNotification( rt.AudioBuffer.Mdl, rt.AudioBufferSize )
CPortWaveRT::DataRangeIntersection
ntStatus = Miniport->DataRangeIntersection( PinId, DataRange, MatchingDataRange, OutputBufferLength, ResultantFormat, ResultantFormatLength )
PortclsMof
>2b(h#op
\Device\VerifierExt
Leaking resources allocated by IPortWaveRTStream::AllocatePagesForMdl/AllocateContiguousPagesForMdl.
The MDL isn't unmapped before free.
{146F1A80-4791-11D0-A5D6-28DB04C10000}
{146F1A80-4791-11D0-A5D6-28DB04C10000}
{642F5D00-4791-11D0-A5D6-28DB04C10000}
{53172480-4791-11D0-A5D6-28DB04C10000}
EF-7F
D:P(A;;GA;;;SY)(A;;GA;;;BA)(A;;GRGWGX;;;LS)(A;;GRGWGX;;;IU)
)|wBK
PcInitializeAdapterDriver : Invalid Parameter.
DllUnload
DllInitialize
PcInitializeAdapterDriver
[Function:returned]
Caller
Callee
[Function:calling]
Caller
Callee
[Function:calling]
Caller
Callee
[Function:calling]
Caller
Callee
[RefCount:calling]
Caller
Callee
[Function:returned]
Caller
Callee
[Function:returned]
Caller
Callee
[RefCount:returned]
Caller
Callee
RefCount
[Function:returned]
Caller
Callee
[Function:returned]
Caller
Callee
[Function:calling]
Caller
Callee
[Function:calling]
Caller
Callee
[Port::Init]
[Pin::Close]
[Pin::DistributeDeviceState]
OldState
state
status
[Pin::Init]
[Pin::DistributeDeviceState]
OldState
NewState
IgnoreErrors
Failed to query interface from miniport
ntStatus
Failed to call miniport - Init
ntStatus
[Filter::Init]
Failed CreatePortPinWaveRT from miniport
ntStatus
[Filter::Close]
AssertWithArgs
assertVersion
timestamp
imageSize
imageName
count
totalHits
originatingBinary
bucketArgument1
bucketArgument2
message
Assert
assertVersion
timestamp
imageSize
imageName
count
totalHits
message
AssertWER
assertVersion
timestamp
imageSize
imageName
count
totalHits
Status
vo"Z6jwS
Microsoft.Windows.Audio.PortClass
TelemetryAssert
TelemetryAssertDiagTrack_KM
TelemetryAssertDiagTrack
zPMeSsk
9/%Wj
 MISMATCH
>v5]r
IRP_MN_START_DEVICE
IRP_MN_QUERY_REMOVE_DEVICE
IRP_MN_REMOVE_DEVICE
IRP_MN_CANCEL_REMOVE_DEVICE
IRP_MN_STOP_DEVICE
IRP_MN_QUERY_STOP_DEVICE
IRP_MN_CANCEL_STOP_DEVICE
IRP_MN_QUERY_DEVICE_RELATIONS
IRP_MN_QUERY_INTERFACE
IRP_MN_QUERY_CAPABILITIES
IRP_MN_QUERY_RESOURCES
IRP_MN_QUERY_RESOURCE_REQUIREMENTS
IRP_MN_QUERY_DEVICE_TEXT
IRP_MN_FILTER_RESOURCE_REQUIREMENTS
IRP_MN_UNKNOWN_0x0e
IRP_MN_READ_CONFIG
IRP_MN_WRITE_CONFIG
IRP_MN_EJECT
IRP_MN_SET_LOCK
IRP_MN_QUERY_ID
IRP_MN_QUERY_PNP_DEVICE_STATE
IRP_MN_QUERY_BUS_INFORMATION
IRP_MN_PAGING_NOTIFICATION
IRP_MN_SURPRISE_REMOVAL
`XQUY
FAILED!
Timeout on state transition from KSSTATE_STOP to KSSTATE_ACQUIRE by AVStrMiniPinSetDeviceState.
Timeout on state transition from KSSTATE_PAUSE to KSSTATE_RUN by AVStrMiniPinSetDeviceState.
Timeout on state transition by AVStrMiniPinSetDeviceState.
The miniport driver should not call PoRequestPowerIrp with IRP_MN_SET_POWER.
This device is not registered by PcRegisterAdapterPowerManagement.
PcUnregisterAdapterPowerManagement should only be called at IRQL == PASSIVE_LEVEL.
PcRequestNewPowerState should only be called at IRQL == PASSIVE_LEVEL.
PcRegisterSubdevice should only be called at IRQL == PASSIVE_LEVEL.
PcRegisterPhysicalConnectionToExternal should only be called at IRQL == PASSIVE_LEVEL.
PcRegisterPhysicalConnectionFromExternal should only be called at IRQL == PASSIVE_LEVEL.
PcRegisterPhysicalConnection should only be called at IRQL == PASSIVE_LEVEL.
This device is already registered by PcRegisterAdapterPowerManagement.
PcRegisterAdapterPowerManagement should only be called at IRQL == PASSIVE_LEVEL.
PcNewServiceGroup should only be called at IRQL == PASSIVE_LEVEL.
PcNewResourceSublist should only be called at IRQL == PASSIVE_LEVEL.
PcNewResourceList should only be called at IRQL == PASSIVE_LEVEL.
PcNewRegistryKey should only be called at IRQL == PASSIVE_LEVEL.
PcNewPort should only be called at IRQL == PASSIVE_LEVEL.
PcNewMiniport should only be called at IRQL == PASSIVE_LEVEL.
PcNewInterruptSync should only be called at IRQL == PASSIVE_LEVEL.
PcNewDmaChannel should only be called at IRQL == PASSIVE_LEVEL.
PcInitializeAdapterDriver should only be called at IRQL == PASSIVE_LEVEL.
PcGetDeviceProperty should only be called at IRQL == PASSIVE_LEVEL.
PcGetContentRights should only be called at IRQL == PASSIVE_LEVEL.
PcForwardIrpSynchronous should only be called at IRQL == PASSIVE_LEVEL.
PcForwardContentToInterface should only be called at IRQL == PASSIVE_LEVEL.
PcForwardContentToFileObject should only be called at IRQL == PASSIVE_LEVEL.
PcForwardContentToDeviceObject should only be called at IRQL == PASSIVE_LEVEL.
PcDispatchIrp should only be called at IRQL == PASSIVE_LEVEL.
PcDestroyContent should only be called at IRQL == PASSIVE_LEVEL.
PcCreateContentMixed should only be called at IRQL == PASSIVE_LEVEL.
PcCompletePendingPropertyRequest shouldn't be called with an NtStatus value of STATUS_PENDING.
PcCompletePendingPropertyRequest should only be called at IRQL <= DISPATCH_LEVEL.
PcCompleteIrp should only be called at IRQL <= DISPATCH_LEVEL.
PcAddContentHandlers should only be called at IRQL == PASSIVE_LEVEL.
DeviceExtensionSize should be either 0 or no less than PORT_CLASS_DEVICE_EXTENSION_SIZE.
PcAddAdapterDevice should only be called at IRQL == PASSIVE_LEVEL.
m_Miniport->Service()
CPortDMus::RequestService
ulRefCount = m_Miniport->Release()
CPortDMus::~CPortDMus
ntStatus = m_Miniport->Init( UnknownAdapter, ResourceList, PPORTDMUS(this), &pServiceGroup)
CPortDMus::Init
ntStatus = m_Miniport->GetDescription(&m_pPcFilterDescriptor)
m_MPPinCountI->Release()
m_Miniport->Release()
CPortDMus::ReleaseChildren
ntStatus = m_Miniport->DataRangeIntersection( PinId, DataRange, MatchingDataRange, OutputBufferLength, ResultantFormat, ResultantFormatLength)
CPortDMus::DataRangeIntersection
pPowerNotify->PowerChangeNotify(PowerState)
CPortDMus::PowerChangeNotify
pPowerNotify->Release()
m_MPPinCountI->PinCount(PinId,FilterNecessary,FilterCurrent,FilterPossible,GlobalCurrent,GlobalPossible)
CPortDMus::PinCount
{146F1A80-4791-11D0-A5D6-28DB04C10000}
CPortFilterDMus::~CPortFilterDMus
m_Miniport->AddRef()
CPortFilterDMus::Init
CPortPinDMus::~CPortPinDMus
CPortPinDMus::Init
ntStatus = m_Port->m_MiniportMidi->NewStream( &m_MiniportMidiStream, NULL, NonPagedPoolNx, m_Id, m_StreamType == DMUS_STREAM_MIDI_CAPTURE ? TRUE : FALSE, m_DataFormat, &(m_ServiceGroup) )
ntStatus = m_Port->m_Miniport->NewStream( &m_MiniportMXF, NULL, NonPagedPoolNx, m_Id, m_StreamType, m_DataFormat, &(m_ServiceGroup), (PAllocatorMXF)m_AllocatorMXF, (PMASTERCLOCK)this->m_Port, &SchedulePreFetch )
ulRefCount = m_MiniportMXF->Release()
m_MiniportMidiStream->Release()
ntStatus = m_MiniportMXF->ConnectOutput(m_CaptureSinkMXF)
CPortPinDMus::ConnectMXFGraph
(void) m_MiniportMXF->DisconnectOutput(m_CaptureSinkMXF)
CPortPinDMus::DeleteMXFGraph
(void) m_MiniportMXF->SetState(NewState)
CPortPinDMus::SetMXFGraphState
m_MiniportMXF->Release()
CPortPinDMus::Close
m_MiniportMXF->SetState(KSSTATE_PAUSE)
CPortPinDMus::PowerNotify
m_MiniportMXF->SetState(KSSTATE_ACQUIRE)
m_MiniportMXF->SetState(m_DeviceState)
(void) m_MiniportMXF->PutMessage(NULL)
CPortPinDMus::ServeCapture
ntStatus = m_MiniportStream->SetState(State)
CFeederOutMXF::SetState
ntStatus = m_MiniportStream->Write(aDMKEvt->uData.abData + byteOffset,bytesRemaining,&bytesWritten)
CFeederOutMXF::ConsumeEvents
ntStatus = m_MiniportStream->Write(aDMKEvt->uData.pbData + byteOffset,bytesRemaining,&bytesWritten)
CFeederInMXF::SetState
ntStatus2 = m_MiniportStream->Read(aMidiData,sizeof(PBYTE),&bytesRead)
CFeederInMXF::PutMessage
CPortTopology::~CPortTopology
m_MPPinNameI->Release()
CPortTopology::ReleaseChildren
CPortTopology::DataRangeIntersection
pPowerNotify->PowerChangeNotify( PowerState )
CPortTopology::PowerChangeNotify
pMiniportPnpNotify->PnpStop()
CPortTopology::PnpStop
PUNKNOWN(pMiniportPnpNotify)->Release()
CPortTopology::PinCount
ntStatus = m_MPPinNameI->GetPinName(_pIrp,_pKsPPin,_pvData)
CPortTopology::GetPinName
IPort::NewRegistryKey should only be called at IRQL == PASSIVE_LEVEL.
IPort::Init should only be called at IRQL == PASSIVE_LEVEL.
IPort::GetDeviceProperty should only be called at IRQL == PASSIVE_LEVEL.
CPortPinTopology::~CPortPinTopology
CPortPinTopology::Init
CPortWaveCyclic::~CPortWaveCyclic
ntStatus = Miniport->Init( UnknownAdapter, ResourceList, PPORTWAVECYCLIC(this) )
CPortWaveCyclic::Init
pIMiniportAudioSignalProcessing->Release()
CPortWaveCyclic::ReleaseChildren
CPortWaveCyclic::DataRangeIntersection
CPortWaveCyclic::PowerChangeNotify
CPortWaveCyclic::PinCount
{146F1A80-4791-11D0-A5D6-28DB04C10000}
CPortPinWaveCyclic::~CPortPinWaveCyclic
CPortPinWaveCyclic::Init
ntStatus = m_Port->Miniport->NewStream( &m_Stream, NULL, NonPagedPoolNx, m_Id, m_DataFlow == KSPIN_DATAFLOW_OUT, m_DataFormat, &m_DmaChannel, &m_ServiceGroup )
m_Stream->SetNotificationFreq( WAVECYC_NOTIFICATION_FREQUENCY, &m_FrameSize )
m_Stream->Release()
CPortPinWaveCyclic::Close
ntStatus = m_Stream->SetState(NewState)
CPortPinWaveCyclic::SetDeviceState
m_Stream->Silence(m_DmaChannel->SystemAddress(),m_DmaChannel->BufferSize())
ntStatus = m_Stream->SetFormat(inDataFormat)
CPortPinWaveCyclic::SynchronizedSetFormat
ntStatus = m_Stream->GetPosition(&ulDmaPosition)
CPortPinWaveCyclic::GetPosition
m_Stream->SetState(KSSTATE_PAUSE)
CPortPinWaveCyclic::PowerNotify
m_Stream->SetState(KSSTATE_ACQUIRE)
m_Stream->SetState(m_DeviceState)
m_Stream->SetState(KSSTATE_STOP)
CPortPinWaveCyclic::RequestService
m_Stream->Silence( m_DmaChannel->SystemAddress(), m_ulDmaCopy + ulBytesToSilence - ulDmaBufferSize )
m_Stream->Silence( PVOID(PUCHAR(m_DmaChannel->SystemAddress()) + m_ulDmaCopy), ulBytesToSilence)
CPortFilterWaveCyclic::~CPortFilterWaveCyclic
CPortFilterWaveCyclic::Init
{642F5D00-4791-11D0-A5D6-28DB04C10000}
{53172480-4791-11D0-A5D6-28DB04C10000}
Status = Miniport->NormalizePhysicalPosition( &StreamTime )
CPortClockWaveCyclic::GetCurrentTime
Status = Miniport->NormalizePhysicalPosition( &PhysicalTime )
CPortClockWaveCyclic::GetCurrentPhysicalTime
Resolution->Granularity = Miniport->NormalizePhysicalPosition( &OneByte )
CPortClockWaveCyclic::GetResolution
CPortWavePci::~CPortWavePci
ntStatus = Miniport->Init( UnknownAdapter, ResourceList, PPORTWAVEPCI(this), &ServiceGroup )
CPortWavePci::Init
CPortWavePci::ReleaseChildren
CPortWavePci::DataRangeIntersection
CPortWavePci::PinCount
Miniport->Service()
CPortWavePci::RequestService
{146F1A80-4791-11D0-A5D6-28DB04C10000}
CPortFilterWavePci::~CPortFilterWavePci
CPortFilterWavePci::Init
CPortPinWavePci::~CPortPinWavePci
CPortPinWavePci::Init
ntStatus = Port->Miniport->NewStream ( &Stream, NULL, NonPagedPoolNx, PPORTWAVEPCISTREAM(this), Id, Descriptor->DataFlow == KSPIN_DATAFLOW_OUT, DataFormat, &DmaChannel, &ServiceGroup )
CPortPinWavePci::Close
m_IrpStream->Release()
Stream->MappingAvailable()
CPortPinWavePci::IrpSubmitted
Stream->RevokeMappings(FirstTag, LastTag, MappingsCancelled)
CPortPinWavePci::MappingsCancelled
ntStatus = Stream->SetState(KSSTATE_PAUSE)
CPortPinWavePci::PowerNotify
ntStatus = Stream->SetState(KSSTATE_ACQUIRE)
Stream->GetPosition( &ullCurrentPosition )
ntStatus = Stream->SetState(m_DeviceState)
PAUSE
ACQUIRE
UNKNOWN
Stream->GetPosition(&m_ullStreamSleepPosition)
ntStatus = Stream->SetState(KSSTATE_STOP)
ntStatus = Stream->SetState(NewState)
CPortPinWavePci::SetDeviceState
ntStatus = that->Stream->SetFormat(FilteredDataFormat)
PinPropertyDataFormat
Status = WavePciPin->Stream->GetAllocatorFraming( AllocatorFraming )
CPortPinWavePci::PinPropertyAllocatorFraming
ntStatus= Stream->GetPosition(&pIrpStreamPosition->ullStreamPosition)
CPortPinWavePci::GetPosition
ntStatus2 = that->Stream->SetState(KSSTATE_PAUSE)
PinPropertyPosition
that->Stream->MappingAvailable()
ntStatus2 = that->Stream->SetState(KSSTATE_RUN)
Stream->Service()
CPortPinWavePci::RequestService
8NiStatus = Miniport->GetPosition( PULONGLONG( &StreamTime ) )
CPortClockWavePci::GetCurrentTime
Status = Miniport->GetPosition( PULONGLONG( &PhysicalTime ))
CPortClockWavePci::GetCurrentPhysicalTime
CPortClockWavePci::GetResolution
CPortWaveRT::~CPortWaveRT
m_pIAudioEngine->Release()
CPortWaveRT::ReleaseChildren
CPortWaveRT::PowerChangeNotify
CPortWaveRT::PnpStop
CPortWaveRT::PinCount
The unmapped BaseAddress doesn't match the MDL.
IPortWaveRTStream::UnmapAllocatedPages should only be called at IRQL == PASSIVE_LEVEL.
IPortWaveRTStream::MapAllocatedPages cannot accept a NULL MDL.
IPortWaveRTStream::MapAllocatedPages: the CacheType can only be MmNonCached, MmCached or MmWriteCombined.
IPortWaveRTStream::MapAllocatedPages should only be called at IRQL == PASSIVE_LEVEL.
The MDL has been mapped already.
IPortWaveRTStream::GetPhysicalPagesCount should only be called at IRQL == PASSIVE_LEVEL.
IPortWaveRTStream::GetPhysicalPageAddress should only be called at IRQL == PASSIVE_LEVEL.
IPortWaveRTStream::FreePagesFromMdl should only be called at IRQL == PASSIVE_LEVEL.
IPortWaveRTStream::AllocatePagesForMdl has invalid parameter on TotalBytes.
IPortWaveRTStream::AllocatePagesForMdl should only be called at IRQL == PASSIVE_LEVEL.
IPortWaveRTStream::AllocateContiguousPagesForMdl has invalid parameter on TotalBytes.
IPortWaveRTStream::AllocateContiguousPagesForMdl should only be called at IRQL == PASSIVE_LEVEL.
Stream->FreeAudioBuffer (rt.AudioBuffer.Mdl, rt.AudioBufferSize)
StreamInput->Release()
StreamOutput->Release()
Stream->GetPosition(pKsAudioPosition)
CPortPinWaveRT::GetKsAudioPosition
ntStatus = that->StreamInput->GetReadPacket(&value->PacketNumber, &value->Flags, &value->PerformanceCounterValue, &value->MoreData)
PinPropertyHandler_GetReadPacket
ntStatus = that->StreamOutput->SetWritePacket(value->PacketNumber, value->Flags, value->EosPacketLength)
PinPropertyHandler_SetWritePacket
ntStatus = that->StreamOutput->GetOutputStreamPresentationPosition(value)
PinPropertyHandler_GetOutputStreamPresentationPosition
ntStatus = that->StreamOutput->GetPacketCount(packetCount)
PinPropertyHandler_GetPacketCount
ntStatus = _streamNotification->AllocateBufferWithNotification( _notificationCount, nextRequestedBufferSize, _pMDL, &returnBufferSize, _pOffsetFromFirstPag, _pCacheType )
RetryAllocateBufferWithNotification
_streamNotification->FreeBufferWithNotification( *_pMDL, nextRequestedBufferSize)
ntStatus = _streamNotification->AllocateBufferWithNotification( _notificationCount, finalRequestBufferSize, _pMDL, &returnBufferSize, _pOffsetFromFirstPag, _pCacheType )
ntStatus = that->Stream->AllocateAudioBuffer (property->RequestedBufferSize, &that->rt.AudioBuffer.Mdl, &bufferSize, &byteOffset, &cacheType)
that->Stream->FreeAudioBuffer (that->rt.AudioBuffer.Mdl, bufferSize)
that->Stream->FreeAudioBuffer(that->rt.AudioBuffer.Mdl, bufferSize)
that->Stream->FreeAudioBuffer( that->rt.AudioBuffer.Mdl, bufferSize )
that->StreamNotification->FreeBufferWithNotification( that->rt.AudioBuffer.Mdl, bufferSize )
ntStatus = that->Stream->GetClockRegister (mapping)
PinPropertyGetClockRegister
ntStatus = that->StreamNotification->UnregisterNotificationEvent( pRemovedEvent->pNotificationEvent )
[%03X]
DMusic MPU-401 In 
DMusic MPU-401 Out 
Thread
Unknown
SeConvertStringSecurityDescriptorToSecurityDescriptor
Properties
Class
NoDisplayClass
NoUseClass
Security
DeviceType
DeviceCharacteristics
Exclusive
\Registry\Machine\System\CurrentControlSet\Control\Class
{%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}
<unknown>
TELASSERT
RSDS<
portcls.pdb
.text$lp01portcls.sys!20_pri7
.text$lp06portcls.sys!50_coldboot
.text$mn
.text$mn$00
.text$mn$21
.text$np
.text$zy
.text$zz
.rdata$brc
.rdata$00$brc
.rdata$06$brc
.rdata$zz$brc
.gehcont
.giats
.rdata
.rdata$00
.rdata$01
.rdata$06
.rdata$PAGE$lp01portcls.sys!20_pri7
.rdata$zETW0
.rdata$zETW1
.rdata$zETW2
.rdata$zETW9
.rdata$zz
.rdata$zzzdbg
.xdata
.data$06$brc
.data$dk00$brc
.data$dk01$brc
.data$dk06$brc
.data$pr00$brc
.data$pr06$brc
.data$zz$brc
.data
.data$00
.data$dk06
.data$pr00
.data$zz
.bss$06
.bss$dk00
.bss$dk06
.bss$pr00
.bss$pr01
.bss$pr06
.bss$zz
.pdata
.idata$5
.00cfg
.idata$2
.idata$3
.idata$4
.idata$6
NONPAGE
PAGE$lp01portcls.sys!20_pri7
PAGE$lp06portcls.sys!50_coldboot
PAGE$np
PAGE$zy
PAGE$zz
PAGEPcVf$zz
fogrp
.edata
.gfids
.rsrc$01
.rsrc$02
PortCls
KeInsertQueueDpc
IoAllocateWorkItem
KeGetCurrentIrql
KeInitializeDpc
KeRemoveQueueDpc
ExAllocatePool2
IoFreeWorkItem
ExFreePoolWithTag
IoQueueWorkItem
IoGetDmaAdapter
KeInitializeMutex
KeLowerIrql
IoFreeMdl
IoGetDeviceProperty
ExAllocatePoolWithTag
KfRaiseIrql
__C_specific_handler
KeAcquireSpinLockRaiseToDpc
KeReleaseSpinLock
IofCompleteRequest
ProbeForRead
IoGetCurrentProcess
KeSetEvent
KeAcquireSpinLockAtDpcLevel
KeClearEvent
KeReleaseSpinLockFromDpcLevel
KeInitializeEvent
MmMapLockedPagesSpecifyCache
KeWaitForSingleObject
KeWaitForMultipleObjects
ObfDereferenceObject
ObfReferenceObject
RtlInitUnicodeString
IoWMIRegistrationControl
IoWMIWriteEvent
IoAcquireRemoveLockEx
RtlCompareUnicodeString
IoRegisterDeviceInterface
IoReleaseRemoveLockEx
MmIsDriverVerifying
IoReleaseRemoveLockAndWaitEx
IoInitializeTimer
IoSetDeviceInterfaceState
IoDetachDevice
EtwSetInformation
PoRegisterPowerSettingCallback
PoCallDriver
RtlFreeUnicodeString
IoStartTimer
IoDeleteDevice
IoStopTimer
IoInitializeRemoveLockEx
PoSetPowerState
KeReleaseMutex
RtlQueryRegistryValues
IoAttachDeviceToDeviceStack
EtwWriteTransfer
PoUnregisterPowerSettingCallback
PoCreatePowerRequest
PoDeletePowerRequest
EtwUnregister
MmGetSystemRoutineAddress
EtwRegister
IofCallDriver
IoBuildSynchronousFsdRequest
PoClearPowerRequest
PoSetPowerRequest
PoRequestPowerIrp
IoOpenDeviceRegistryKey
ZwQueryValueKey
ZwClose
PoStartNextPowerIrp
ZwOpenKey
PoFxActivateComponent
PoFxCompleteDirectedPowerDown
PoFxRegisterDevice
PoFxUnregisterDevice
PoFxReportDevicePoweredOn
PoFxIdleComponent
PoFxStartDevicePowerManagement
PoFxSetDeviceIdleTimeout
PoFxCompleteIdleState
PoFxPowerControl
PoFxCompleteDevicePowerNotRequired
PoFxCompleteIdleCondition
ZwQueryKey
ZwEnumerateValueKey
IoOpenDeviceInterfaceRegistryKey
ZwCreateKey
ZwDeleteKey
ZwEnumerateKey
ZwSetValueKey
KeSetTimer
KeInitializeTimer
KeCancelTimer
IoConnectInterrupt
KeSynchronizeExecution
IoDisconnectInterrupt
KeQueryGroupAffinity
KeQueryActiveProcessorCountEx
ntoskrnl.exe
WmiCompleteRequest
WmiSystemControl
WMILIB.SYS
DrmGetContentRights
DrmDestroyContent
DrmCreateContentMixed
DrmForwardContentToDeviceObject
DrmForwardContentToInterface
DrmAddContentHandlers
DrmForwardContentToFileObject
drmk.sys
MmUnlockPagableImageSection
MmLockPagableDataSection
MmAddVerifierThunks
IoBuildDeviceIoControlRequest
IoGetDeviceObjectPointer
ExReleaseSpinLockShared
ExAcquireSpinLockShared
MmAddVerifierSpecialThunks
MmIsVerifierEnabled
ExSetTimerResolution
_purecall
IoFileObjectType
ObReferenceObjectByHandle
KeGetRecommendedSharedDataAlignment
ExGetPreviousMode
KeSetTimerEx
IoReportTargetDeviceChangeAsynchronous
MmAreMdlPagesCached
MmAllocatePagesForMdlEx
IoBuildPartialMdl
MmBuildMdlForNonPagedPool
IoAllocateMdl
MmAllocatePagesForMdl
KeStackAttachProcess
MmFreePagesFromMdl
MmUnmapLockedPages
ExEventObjectType
KeUnstackDetachProcess
_vsnwprintf
KeInitializeSpinLock
ExAcquireFastMutexUnsafe
KeEnterCriticalRegion
SeReleaseSubjectContext
KeSetSelectedCpuSetsThread
IoSteerInterrupt
ExReleaseFastMutexUnsafe
KeLeaveCriticalRegion
SeAccessCheckWithHint
SeCaptureSubjectContext
ObOpenObjectByPointer
IoCreateDevice
IoDeviceObjectType
ZwSetSecurityObject
RtlSetDaclSecurityDescriptor
IoIsWdmVersionAvailable
RtlLengthSid
RtlAddAccessAllowedAce
RtlAbsoluteToSelfRelativeSD
wcschr
_wcsnicmp
RtlCreateSecurityDescriptor
SeExports
RtlLengthSecurityDescriptor
_snwprintf
SeCaptureSecurityDescriptor
RtlGetSaclSecurityDescriptor
RtlGetOwnerSecurityDescriptor
RtlGetGroupSecurityDescriptor
RtlGetDaclSecurityDescriptor
KsEnableEvent
KsDisableEvent
KsGenerateEvent
KsAddIrpToCancelableQueue
KsCancelIo
KsProbeStreamIrp
KsRemoveIrpFromCancelableQueue
KsRemoveSpecificIrpFromCancelableQueue
KsReleaseIrpOnCancelableQueue
KsCancelRoutine
KsDereferenceSoftwareBusObject
KsAddObjectCreateItemToDeviceHeader
KsReferenceSoftwareBusObject
KsDispatchIrp
KsAllocateObjectHeader
KsFreeObjectHeader
KsAllocateDeviceHeader
KsSetDevicePnpAndBaseObject
KsFreeDeviceHeader
KsSetMajorFunctionHandler
KsValidateConnectRequest
KsPinPropertyHandler
KsPropertyHandler
KsPinDataIntersection
KsDispatchInvalidDeviceRequest
KsFreeEventList
KsDefaultDeviceIoCompletion
KsTopologyPropertyHandler
KsAcquireResetValue
KsSynchronousIoControlDevice
KsValidateClockCreateRequest
KsCreateDefaultAllocator
ks.sys
WppAutoLogTrace
WppAutoLogStart
imp_WppRecorderReplay
WppAutoLogStop
WppRecorder.sys
RtlFreeAnsiString
RtlQueryRegistryValuesEx
DbgkWerCaptureLiveKernelDump
RtlUnicodeStringToAnsiString
RtlInitAnsiString
KeQueryTimeIncrement
KeQueryPerformanceCounter
KeStallExecutionProcessor
HAL.dll
t$ WATAUAVAWH
L9%%O
f9qHu
A_A^A]A\_
f9qHu
fD9iHu
t$ WH
WATAUAVAWH
KsoOH
D$XE3
A_A^A]A\_
T$@E3
|$ E3
@SUVWAWH
d$8E3
d$ E3
PA__^][
|$ ATAVAWH
d$8E3
d$ E3
A_A^A\
UWAVH
E0D!U8H
@A^_]
UWAVH
@8u0u?L
PA^_]
@8u0u'L
t$(E3
)D$ H
WATAUAVAWH
;D$Xs5A
PcPrH
PcPrH
PcPrH
PcPrH
 A_A^A]A\_
WATAUAVAWH
;D$Xs&A
PcEtH
PcEtH
PcEtH
PcEtH
 A_A^A]A\_
|$ ATAVAWH
PcPrA
 A_A^A\
|$ ATAVAWH
0A_A^A\
UVWATAUAVAWH
H9X(t8H
0A_A^A]A\_^]
p H9x
p8H9x0
t$ AWH
PcErH
A;@$sSA
L$hH3
x AVH
x AVH
f9YHu
fA9rHu
WAVAWH
fD9xHu
A_A^_
\$ UVWATAUAVAWH
H9=K*
f9qHu
A_A^A]A\_^]
UWAUAVAWH
A_A^A]_]
UVWATAUAVAWH
H+K`H
A_A^A]A\_^]
x AVH
PcCrH
WATAUAVAWH
PcCrH
A_A^A]A\_
PcIcH
x ATAVAWH
?Rr<M
@A_A^A\
SVWATAUAVAWH
f9yHE
A9} A
D$ E3
I+L$Xu
I+L$`
A_A^A]A\_^[
WATAUAVAWH
fA9zHE
|$ E3
|$ E3
A_A^A]A\_
fA9ZHu
WAVAWH
fD9xHu
|$ E3
A_A^_
\$ UVWATAUAVAWH
A_A^A]A\_^]
f9iHu
WATAUAVAWH
d$XE3
A_A^A]A\_
UVWATAUAVAWH
A_A^A]A\_^]
L$ UVWATAUAVAWH
H9Z@t/
v(9^$
A$9B$u
A(H9B(u
A 9B t
D$`9^
A$9B$u
A(H9B(u
A 9B t
NPI9^
T$`;n
 A_A^A]A\_^]
SUVWATAUAVAWH
PcStH
PcSiH
8A_A^A]A\_^][
UVWATAUAVAWH
PcEtH
PcSbA
PcEiH
 A_A^A]A\_^]
f9qHu
H9s@t:L
UVWATAUAVAWH
t$8E3
@A_A^A]A\_^]
WATAUAVAWH
@PA9AL
@LA9AP
@HA9AD
@DA9AH
A_A^A]A\_
{ ATAUAVH
@A^A]A\
UVWATAUAVAWH
fD94Bu
A_A^A]A\_^]
USVWATAVAWH
H!t$ I
0A_A^A\_^[]
D$PE3
t$ WH
PcRMH
x UATAUAVAWH
PcCiH
PcSlI
PcRLH
PcRPH
A_A^A]A\]
\$ UVWATAUAVAWH
fD9yHu
PcKdA
A_A^A]A\_^]
UVWATAUAVAWH
f9YHu
PcKdH
A_A^A]A\_^]
x AVH
fD9qHu
UVWATAUAVAWH
fD9aHu
fD9aHu
pA_A^A]A\_^]
t+D8@
t$ UWATAVAWH
fD9aHu
PcKdH
A_A^A\_]
@UVWAVAWH
PA_A^_^]
{ AVH
PcCrH
f9qHu
UWATAVAWH
A_A^A\_]
L$PE3
D$@E3
D$0E3
f9yHu
WATAUAVAWH
fE9jHu
D$ E3
A_A^A]A\_
UATAUAVAWH
fD9yHu
A_A^A]A\]
AUAVAWH
f9qHu
A_A^A]
f9yHu
WAVAWH
L$pH3
A_A^_
PcRvH
PcDWH
PcUsH
SVWATAUAVAWH
PcPrA
d$`E8n@t
PcPrI
 A_A^A]A\_^[
t$ WAVAWH
;B$sO
 A_A^_
f9YHu
UVWATAUAVAWH
d$ E3
PcRtH
u;D9cht(H
d$ E3
A_A^A]A\_^]
PcCrA
PcCrA
x AVH
L$PH3
WATAUAVAWH
A_A^A]A\_
WAVAWH
u*!Q4!Q0H!Q H!Q(3
 A_A^_
L$0H3
\$8fD
\$8fD
fD9iHu
fD9iHu
T$@E3
T$@E3
M9/t<L
/M9.t<L
D$8fD
PcRtH
D$(E3
D$(E3
D$(E3
D$(E3
D$(E3
H+K`H
l$8fD
D$8fD
l$8fD
PcDfA
)D$@A
)L$PA
)D$`A
)L$pD
A9} A
E9E v5E
\$ E3
|$ E3
PcRtH
|$ E3
D$8fD
D$8fD
\$xI9
L9-jo
D$8fD
L9-Sn
D$8fD
PcRtH
t$@fD
I+L$Xu
I+L$`
D$8fD
fE94Gu
PcLNf
T$8fD
D8a)s
D8a)s
D$8fD
D$8fD
D$8fD
D$8fD
L$PE3
D$8fD
D$8fD
H95ET
H955S
H954R
L9=MN
D$8fD
D$PE3
L95CM
D$8fD
D$0E3
D$0E3
L9-aF
T$8fD
T$8fD
UVWATAUAVAWH
H9_hu
A_A^A]A\_^]
l$ VWAVH
0A^_^
x AVH
f9qHu
f9YHu
D$8fD
x AVH
L9s8t
PcMqH
fD9qHu
D$8fD
E9Y0t
D$8fD
uD@8{=u
f9iHu
D$8fD
u0@8k=u
WATAUAVAWH
D9x$u
D9x u
PcIsH
D9z$u
D9z u'D8?u"H
D8q)s
L9-H2
fD9yHu
D$8fD
fD9yHu
D$8fD
A_A^A]A\_
WATAUAVAWH
fD9aHu
D$8fD
A_A^A]A\_
WATAUAVAWH
fD9aHu
D$8fD
A_A^A]A\_
x AVH
x ATAVAWH
A_A^A\
x ATAVAWH
A_A^A\
x ATAVAWH
A_A^A\
t$ WH
D$PE3
VWATAVAWH
fD9aHu
A_A^A\_^
x ATAVAWH
f9qHu
A_A^A\
f9qHu
D$8fD
VWAUAVAWH
fD9yHu
}HD9}T
A_A^A]_^
tJH9q@t(H
PcRMH
x AVH
t|H9s
t[H9s
L$ SUVWATAUAWH
H9D$xt$M
C(H9D$pt/H
D;c8t,H
0A_A]A\_^][
D$PE3
L$pH3
UVWATAUAVAWH
]XH9C0u^
tVH92t
@8u@t
PA_A^A]A\_^]
t$ WATAUAVAWH
A_A^A]A\_
u&A9Z
t4D9A
x AVH
tW;*sSH
x AVH
x AVH
D$8fD
|$ UATAUAVAWH
D8Q)s
fD9aHu
D$PD+
D$8fD
D8Q)s
fD9aHu
D8Q)r
f9qHu
D$PD+
D$8fD
D8Q)s
fD9aHu
t$8fD
fD9aHu
A_A^A]A\]
x AVH
fD9qHu
D$8fD
}HD9uTv-H
0;uTr
x AVH
KH!|$(L
p AWH
f9yHu
D$8fD
WAVAWH
A_A^_
UVWATAUAVAWH
A8Z)s
f9AHu
l$8fD
A_A^A]A\_^]
f9yHu
D$8fD
|$ E3
WATAUAVAWH
fD9iHu
E8J)s
D8I)s
E8J)s
E8J)s
D8I)s
D8I)s
D8I)s
D8I)s
E8J)s
A_A^A]A\_
;D$Pr
L$XH9Y@u=H
x AVH
;A0sVH
x AVH
x ATAVAWH
PcRlI
H!w(I
 A_A^A\
VWAVH
@A^_^
WAVAWH
@A_A^_
t$ WH
p AWH
D|$hI
VWAVH
@A^_^
x AVH
t$ WATAUAVAWH
L9/t4L
A_A^A]A\_
x AVH
|$ UATAUAVAWH
A_A^A]A\]
x AVH
t$ WH
H9kpt<H9kxt6L
H9kpt6L
kpH9kxt6L
WAVAWH
 A_A^_
|$ UH
UVWATAUAVAWH
tgH!D$pI
0A_A^A]A\_^]
t$ WATAUAVAWH
8RrqI
L9u8t
D$HE3
L9spt>L
spM97t<L
A_A^A]A\_
L$@H!\$@
x AVH
wx;CDt
|$ ATAVAWH
L!|$ H
$D9w|t
D9w|u9L!
D!|$X
0A_A^A\
H9A u
H9Q t
L$0H+K@H
D$0H+C8H
H9A8u
H9Q8t
H+K0H
H+S(H
A H9A(u
H9Q(t
AXt=L
x AVH
D$8fD
D$8fD
f9yHu
D$8fD
|$ UATAUAVAWH
A_A^A]A\]
x AVH
t$ WAVAWH
A_A^_
x AVH
t$ UWATAVAWH
A_A^A\_]
x AVH
UWAVH
PA^_]
UVWATAUAVAWH
tIL!|$pI
0A_A^A]A\_^]
t$ WATAUAVAWH
L9bhu
L9c8t
\$8E3
D$PHc
A_A^A]A\_
d$ E3
t$ WH
H!\$@
x AVH
t$ UWAWH
H!|$ A
H!}(H9>
H!|$(D
x AVH
\$ E3
x AVH
Q(H9Zht
|$ UATAUAVAWH
A_A^A]A\]
x AVH
f9iHu
x AVH
t$ WATAUAVAWH
fD9iHu
L9.t4L
A_A^A]A\_
WAVAWH
f9iHu
D$8fD
A_A^_
UVWATAUAVAWH
fD9IHu
A_A^A]A\_^]
|$ E3
|$ E3
f9iHu
D$8fD
f9qHu
H9s t:L
f9qHu
x ATAUAVH
f9iHu
L9%(9
A^A]A\
UVWATAUAVAWH
H9=J8
f9qHu
H9=96
`A_A^A]A\_^]
f9qHu
H9sxt:L
x AVH
f9YHu
t$ WH
f9iHu
l$ E3
x AVH
D$8fD
L$ L#
|$ UATAUAVAWH
f9YHu
IcF0L
f9YHu
D$8fD
A_A^A]A\]
UVWATAUAVAWH
fD9IHu
D$8fD
`A_A^A]A\_^]
f9qHu
t$ WATAUAVAWH
L95E%
fD9yHu
M9}8t
\$(L#
|$ E3
L959 
D$`Hc
A_A^A]A\_
fA9jHu
fA9rHu
t$ WATAUAVAWH
fD9`Hu
d$ E3
A_A^A]A\_
WAVAWH
fD9xHu
|$ E3
A_A^_
t$ WATAUAVAWH
fA9ZHu
A_A^A]A\_
t$ WATAUAVAWH
f9iHu
l$ E3
A8j)r
D$8fD
A8j)r
A8j)s
A8j)r
A8j)s
A8j)s
A8j)s
A8j)r
A8j)s
D$8fD
A8j)s
A8Z)s
A_A^A]A\_
x AVH
f9iHu
D$8fD
l$ E3
f9qHu
f9YHu
D$8fD
x AVH
fD9qHu
D$8fD
f9iHu
D$8fD
L$`E3
H9l$`tnH
VWAVH
fD9qHu
D$8fD
f9yHu
D$8fD
x ATAVAWH
f9YHu
\$8fD
\$8fD
A_A^A\
x ATAVAWH
f9YHu
T$8fD
A_A^A\
f9iHu
D$8fD
f9iHu
D$8fD
D$8fD
f9qHu
D$8fD
D$8fD
t$ WATAUAVAWH
fD9`Hu
I+H`H
I+H`H
A_A^A]A\_
WATAUAVAWH
fA9zHE
|$ E3
|$ E3
H9~xu
A_A^A]A\_
f9iHu
x AUAVAWH
fE9rHu
A_A^A]
ATAVAWH
f9qHu
A_A^A\
f9yHu
|$ E3
f9qHu
D$8fD
t$ E3
UVWATAUAVAWH
@A_A^A]A\_^]
D$8fD
L$HA;
D;L$Hr
L$HA;
|$ UAVAWH
0A_A^]
x AVH
L$HA;
|$ UAVAWH
ta9{$r\
0A_A^]
@USWH
A@H9AHu
H9QHt
x ATAVAWH
0A_A^A\
ATAVAWH
fD9yju
fD9yhu
fD9cjs
D9d$xt
D9|$x
D9d$xH
D9d$xu
0A_A^A\
x AVH
t$ WAVAWH
D$(f90t
L$HH3
A_A^_
G !plH
G !pp3
WATAUAVAWH
0A_A^A]A\_
x ATAVAWH
f9yZu
f9yXu
 A_A^A\
x AVH
A D8@xu
D8A4t
f9iHu
D$8fD
f9YHu
D$8fD
x AVH
fD9qHu
D$8fD
s D9u
t%H9X
x ATAUAVH
fD9qHu
A^A]A\
AUAVAWH
f9qHu
A_A^A]
WATAWH
f9iHu
A_A\_
x ATAUAWH
f9iHu
A_A]A\
USVATAUAVAWH
H9]xt
H9Mxt#H
pA_A^A]A\^[]
f9,Qu
SeTsI
WATAUAVAWH
 A_A^A]A\_
UVWAVAWH
9:u|B
 A_A^_^]
@USVWATAUAVAWH
fD9$Cu
SeAlA
;tffA;
XA_A^A]A\_^[]
WATAUAVAWH
 A_A^A]A\_
WAVAWH
 A_A^_
n0fD;
UWAVH
E8!E(
SeSdH
pA^_]
UVWATAUAVAWH
A_A^A]A\_^]
UVWATAUAVAWH
D8MHt
PA_A^A]A\_^]
UWAVH
E(H9]
0A^_]
L$ UH
L$HH3
H WAVAWH
PpRbH
0A_A^_
x AVH
L$8fD
L$0E3
D$(E3
PpUcH
+Cx;C|
VWAVH
 A^_^
x AVH
VWAVH
@A^_^
x AVH
t$ WH
H;Jxt(H
 !"#$%&'
portcls.sys
DllInitialize
DllUnload
PcAddAdapterDevice
PcAddContentHandlers
PcAddStreamResource
PcAssignPowerFrameworkSettings
PcCompleteIrp
PcCompletePendingPropertyRequest
PcCreateContentMixed
PcDestroyContent
PcDispatchIrp
PcForwardContentToDeviceObject
PcForwardContentToFileObject
PcForwardContentToInterface
PcForwardIrpSynchronous
PcGetContentRights
PcGetDeviceProperty
PcGetPhysicalDeviceObject
PcGetTimeInterval
PcInitializeAdapterDriver
PcNewDmaChannel
PcNewInterruptSync
PcNewMiniport
PcNewPort
PcNewRegistryKey
PcNewResourceList
PcNewResourceSublist
PcNewServiceGroup
PcRegisterAdapterPnpManagement
PcRegisterAdapterPowerManagement
PcRegisterIoTimeout
PcRegisterPhysicalConnection
PcRegisterPhysicalConnectionFromExternal
PcRegisterPhysicalConnectionToExternal
PcRegisterSubdevice
PcRemoveStreamResource
PcRequestNewPowerState
PcUnregisterAdapterPnpManagement
PcUnregisterAdapterPowerManagement
PcUnregisterIoTimeout
WEVT_TEMPLATE
MOFDATA
PORTCLSMOF
VS_VERSION_INFO
StringFileInfo
040904B0
CompanyName
Microsoft Corporation
FileDescription
Port Class (Class Driver for Port/Miniport Devices)
FileVersion
10.0.22621.1 (WinBuild.160101.0800)
InternalName
portcls.sys
LegalCopyright
 Microsoft Corporation. All rights reserved.
OriginalFilename
portcls.sys
ProductName
Microsoft
 Windows
 Operating System
ProductVersion
10.0.22621.1
VarFileInfo
Translation
Response Time
Start
Information
Enter Driver Start
Exit Driver Start
Enter Driver Stop
Exit Driver Stop
CRIM0
Portcls/Analytic
Portcls/Operational
Portcls/Performance
EventData
NTStatus
NTStatus
PRVA$
Portcls
OPCOp
win:Start
win:Stop
LEVL@
win:Informational
TASKD
Portcls_Device_Initialization
Portcls_Device_Read
Portcls_Device_Write
Portcls_Device_Stop
KEYWD
win:ResponseTime
8fzIz^
@hvl~
`90`G
zpL1^0
MOFDATA
WEVT_TEMPLATE
MOFDATA
en-US
S?SrS
U/V^V
Y4Z*[
+QVQwQ
Y3[e\#^
V?XvZ
X7XnX
^!_^_x_
P3QbQ
UaV\W
[$\<\a\!]Z]
SQTxT
TLUgU
U\VyV
V"W8W{W
]i]c^
XQ`R(W
QdRvR
R%ScT
Z%[_[
[U\l\
\%]K]
[UpV[WHXeY
PGQJR
WDWkX+Y^Y
QSS}S
SETxT(Y
Y-[r[
]T]z]
];^f^
W%X;X
XXYyY
^-_n_
XDXoX
QAQQQ
T'XsX
PJQZQ]R
R<SLS
TCT\TqTmUEX[XlY}Y
[)\@\
Q=QCRwS
^2^J^
P"PaQ
W%XKXmX}XxY
P*PIPrP
R,R<R
]g^=_i_
1PJPaP
Q Q@Q
Q$RVRxR
WAWaW
W,XyY@\x\
P0QjQ
R9RXR
UhW&Y
YWZyZ
]G]q]\^
S'SLS\SoU
U)V[VFWxW
X)YTY
\K\n\~\
T<UdUtU
PoQ"R
TQUwU
U5VrVVX|X
^Q_c_
Q'RQR
U#V}X
X,YTYdY1[
^ ^4^
XhY-Z4[j[
]'_O___
T~U\VNWwX
Y1ZcZg[
]K]_]
Q RFR
UHVmVbW
R1RJRbRvR
R1S_T
^*_w_
Q)QKQdQ
RGS^SvS
Q?QoQ
Q,RmR~R
V'WeW
X@XoX
WMXkX
Z"ZpZ
[q\ ]
_L_n_
Q,QcQ
S>SpS
W8WrW
